<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> LCT学习笔记 | hk_cnyali's Blog</title><meta name="description" content="LCT学习笔记 - hk_cnyali"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.jpg"><link rel="stylesheet" href="https:////cdn.staticfile.org/KaTeX/0.7.1/katex.min.css"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css"><link rel="search" type="application/opensearchdescription+xml" href="/atom.xml" title="hk_cnyali's Blog"><link rel="stylesheet" href="/css/style.css"><link rel="search" type="application/opensearchdescription+xml" href="http://hk-cnyali.com/atom.xml" title="hk_cnyali's Blog"></head><body><div class="wrapper" id="wrap"><header class="header"><h1 class="title">hk_cnyali's Blog</h1><section><ul class="nav nav-list"><li class="nav-list-item"><a class="nav-list-link" href="/" target="_self">Home</a></li><li class="nav-list-item"><a class="nav-list-link" href="/archives/" target="_self">Archives</a></li><li class="nav-list-item"><a class="nav-list-link" href="/About-Me/" target="_self">About</a></li><li class="nav-list-item"><a class="nav-list-link" href="/Tags/" target="_self">Tags</a></li><li class="nav-list-item"><a class="nav-list-link" href="/Debug/" target="_self">Debug</a></li><li class="nav-list-item"><a class="nav-list-link" href="/Friendly-Links/" target="_self">Friendly-Links</a></li><li class="nav-list-item"><a href="javascript:;" class="popup-trigger"> Search </a></li><div class="site-search">
<div class="popup search-popup local-search-popup" id="search-popup">
<div class="local-search-header clearfix">
<span class="search-icon">
<i class="fa fa-search"></i>
</span>
<span class="popup-btn-close">
<i class="fa fa-times-circle"></i>
</span>
<div class="local-search-input-wrapper">
<input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
</div>
</div>
<div id="local-search-result"></div>
</div>
</div></ul></section></header><main class="container"><aside id="sidebar" class="sidebar"> 
<div class="sidebar-inner">  
<ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active">文章目录</li></ul><div class="post-toc">
<div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#基础知识"><span class="nav-number">1.</span> <span class="nav-text">基础知识</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#引入"><span class="nav-number">1.1.</span> <span class="nav-text">引入</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#实链剖分"><span class="nav-number">1.1.1.</span> <span class="nav-text">实链剖分</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#性质"><span class="nav-number">1.1.2.</span> <span class="nav-text">性质</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基本操作"><span class="nav-number">1.2.</span> <span class="nav-text">基本操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#access-x-access-x-access-x"><span class="nav-number">1.2.1.</span> <span class="nav-text">access(x)access(x)access(x)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#make-root-x-make-root-x-make-root-x"><span class="nav-number">1.2.2.</span> <span class="nav-text">make_root(x)make\_root(x)make_root(x)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#find-root-x-find-root-x-find-root-x"><span class="nav-number">1.2.3.</span> <span class="nav-text">find_root(x)find\_root(x)find_root(x)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#split-x-y-split-x-y-split-x-y"><span class="nav-number">1.2.4.</span> <span class="nav-text">split(x,y)split(x,y)split(x,y)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#link-x-y-link-x-y-link-x-y"><span class="nav-number">1.2.5.</span> <span class="nav-text">link(x,y)link(x, y)link(x,y)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#cut-x-y-cut-x-y-cut-x-y"><span class="nav-number">1.2.6.</span> <span class="nav-text">cut(x,y)cut(x, y)cut(x,y)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#注意点"><span class="nav-number">1.3.</span> <span class="nav-text">注意点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#应用"><span class="nav-number">2.</span> <span class="nav-text">应用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#模拟"><span class="nav-number">2.1.</span> <span class="nav-text">模拟</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#维护联通性"><span class="nav-number">2.2.</span> <span class="nav-text">维护联通性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#维护链上信息"><span class="nav-number">2.3.</span> <span class="nav-text">维护链上信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#维护生成树"><span class="nav-number">2.4.</span> <span class="nav-text">维护生成树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#维护边双"><span class="nav-number">2.5.</span> <span class="nav-text">维护边双</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#维护子树信息（只能维护，无法修改）"><span class="nav-number">2.6.</span> <span class="nav-text">维护子树信息（只能维护，无法修改）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#模板-Luogu-P3690"><span class="nav-number">3.</span> <span class="nav-text">模板(Luogu P3690)</span></a></li></ol></div>
</div></div>
</aside><div class="post"><article class="post-block"><h1 class="post-title">LCT学习笔记</h1><div class="post-info">Posted at 18-12-27 16:24, Updated at 19-10-16 21:59</div><div class="post-content"><p>动态维护树上一些问题的数据结构，前置技能需要<code>Splay</code></p>
<p><del>这个东西好像全世界都会了，就我没写过</del></p>
<p>本文大多数内容都是整理<del>抄</del>自网上各种博客和hyj的课件</p>
<a id="more"></a>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p><code>Link-Cut-Tree</code>，简称<code>LCT</code></p>
<p>学完树链剖分后，我们发现很多树上操作问题都可以用树剖解决。可是如果树的形态不断改变，即需要支持加边、删边操作，就需要用到<code>LCT</code>了</p>
<h4 id="实链剖分"><a href="#实链剖分" class="headerlink" title="实链剖分"></a>实链剖分</h4><p>类似于轻重链剖分，对于每个点将其与某个儿子的边划为实边，其余的划为虚边</p>
<p>实链剖分中<strong>虚实儿子会不断改变</strong>，因此我们用<code>Splay</code>来维护，每条实链对应一个<code>Splay</code></p>
<p>所以其实<code>LCT</code>的本质就是利用树剖的思想，把整棵树拆成一条条实链，通过<code>Splay</code>维护实链，从而动态维护树上信息</p>
<h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><ul>
<li>每一个<code>Splay</code>维护的是一条从上到下按在原树中深度严格递增的路径， 其内部是以深度为关键字排序</li>
<li>每个节点包含且仅包含于一个<code>Splay</code>中</li>
<li>每个节点与它实边相连的点在同一个<code>Splay</code>中，实边包含在<code>Splay</code>当中；虚边总是由一棵<code>Splay</code>中的根连向另一棵<code>Splay</code>中最深的节点。连向的节点记录父亲，连出的节点不记录儿子（认父不认子）</li>
</ul>
<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><h4 id="access-x-access-x-access-x"><a href="#access-x-access-x-access-x" class="headerlink" title="access(x)access(x)access(x)"></a><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>c</mi><mi>c</mi><mi>e</mi><mi>s</mi><mi>s</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">access(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">a</span><span class="mord mathit">c</span><span class="mord mathit">c</span><span class="mord mathit">e</span><span class="mord mathit">s</span><span class="mord mathit">s</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mclose">)</span></span></span></span></h4><ul>
<li><p>作用：把<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span></span></span></span>到原树根节点的路径上<strong>打通</strong>，经过的边全部变成实边，使得原树根与<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span></span></span></span>在同一<code>Splay</code>中，且<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span></span></span></span>是这条路径的一个端点，以维护当前点到原树根的链上的信息</p>
<blockquote>
<p>19.3.29UPD</p>
<p>注意：一定是<strong>打通</strong>，实际上<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span></span></span></span>并没有旋到根的位置</p>
</blockquote>
</li>
<li><p>实现：重复以下步骤直至<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span></span></span></span>与原树的根联通：</p>
<ol>
<li>把<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span></span></span></span>点<code>splay</code>到当前<code>Splay</code>的根</li>
<li>改变虚实儿子：把<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span></span></span></span>到父亲的实边变成虚边，把父亲连向自己的边变成实边</li>
<li><code>push_up</code></li>
<li>跳到父亲</li>
</ol>
</li>
</ul>
<blockquote>
<p>access = splay + change_child + push_up</p>
</blockquote>
<h4 id="make-root-x-make-root-x-make-root-x"><a href="#make-root-x-make-root-x-make-root-x" class="headerlink" title="make_root(x)make\_root(x)make_root(x)"></a><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>a</mi><mi>k</mi><mi>e</mi><mi mathvariant="normal">_</mi><mi>r</mi><mi>o</mi><mi>o</mi><mi>t</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">make\_root(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1.06em;vertical-align:-0.31em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mord mathit">e</span><span class="mord mathrm" style="margin-right:0.02778em;">_</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">o</span><span class="mord mathit">o</span><span class="mord mathit">t</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mclose">)</span></span></span></span></h4><ul>
<li><p>作用：把<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span></span></span></span>变成原树的根</p>
</li>
<li><p>实现：</p>
<ol>
<li><p>先<code>access(x)</code>，由于<code>LCT</code>的性质，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span></span></span></span>此时在当前<code>Splay</code>中深度最大，只有左儿子</p>
</li>
<li><p>翻转<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span></span></span></span>所在的整棵<code>Splay</code>，相当于翻转了<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span></span></span></span>到原树根的路径，使得当前点只有右儿子，变成深度最小，即为根</p>
<p>具体实现时，先<code>splay(x)</code>，然后只需直接打翻转标记</p>
</li>
</ol>
<blockquote>
<p>19.5.29UPD</p>
<p>为什么要<code>splay()</code>？</p>
<p>实际上<code>access(x)</code>时，<code>x</code>是没有旋到根的，只是把路径打通。。。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>make_root = access + splay + reverse</p>
</blockquote>
<h4 id="find-root-x-find-root-x-find-root-x"><a href="#find-root-x-find-root-x-find-root-x" class="headerlink" title="find_root(x)find\_root(x)find_root(x)"></a><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mi>i</mi><mi>n</mi><mi>d</mi><mi mathvariant="normal">_</mi><mi>r</mi><mi>o</mi><mi>o</mi><mi>t</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">find\_root(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1.06em;vertical-align:-0.31em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mord mathit">i</span><span class="mord mathit">n</span><span class="mord mathit">d</span><span class="mord mathrm" style="margin-right:0.02778em;">_</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">o</span><span class="mord mathit">o</span><span class="mord mathit">t</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mclose">)</span></span></span></span></h4><ul>
<li>作用：找一个点所在原树的根</li>
<li>实现：<code>access(x)</code>并<code>splay(x)</code>后，当前<code>Splay</code>最左边的点即为原树的根，最后再<code>splay</code>一下保证复杂度</li>
<li>注意：<ol>
<li><code>find_root</code>的常数比较大，如果只有加边没有删边操作的话，可以用<code>DSU</code>代替此操作</li>
<li><strong>在往左走的时候一定要记得<code>push_down</code>，且一开始就要<code>push_down</code>一下</strong></li>
</ol>
</li>
</ul>
<blockquote>
<p>find_root = access + splay + go_left_child + splay</p>
</blockquote>
<h4 id="split-x-y-split-x-y-split-x-y"><a href="#split-x-y-split-x-y-split-x-y" class="headerlink" title="split(x,y)split(x,y)split(x,y)"></a><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>p</mi><mi>l</mi><mi>i</mi><mi>t</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">split(x,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">p</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">i</span><span class="mord mathit">t</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span></h4><ul>
<li><p>作用：将两个点之间的路径放到一个<code>Splay</code>中，获取这条链上的信息</p>
</li>
<li><p>实现：<code>make_root(x)</code>使得<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span></span></span></span>成为原树的根，再<code>access(y)</code>，最后<code>splay(y)</code></p>
<p>最后<code>splay(y)</code>是用来更新信息的，同时保证<code>Splay</code>的复杂度</p>
</li>
</ul>
<blockquote>
<p>split(x, y) = make_root(x) + access(y) + splay(y)</p>
</blockquote>
<h4 id="link-x-y-link-x-y-link-x-y"><a href="#link-x-y-link-x-y-link-x-y" class="headerlink" title="link(x,y)link(x, y)link(x,y)"></a><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>i</mi><mi>n</mi><mi>k</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">link(x, y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">i</span><span class="mord mathit">n</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span></h4><ul>
<li>作用：连<svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.326ex" height="2.343ex" style="vertical-align: -0.671ex;" viewbox="0 -719.6 2292.9 1008.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg">
<defs>
<path stroke-width="1" id="E1-MJMATHI-78" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"/>
<path stroke-width="1" id="E1-MJMAIN-2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/>
<path stroke-width="1" id="E1-MJMATHI-79" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)">
 <use xlink:href="#E1-MJMATHI-78" x="0" y="0"/>
 <use xlink:href="#E1-MJMAIN-2212" x="794" y="0"/>
 <use xlink:href="#E1-MJMATHI-79" x="1795" y="0"/>
</g>
</svg>的边（这里默认把<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03588em;">y</span></span></span></span>连到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span></span></span></span>上）</li>
<li>实现：<code>make_root(x)</code>后，先判断<code>find_root(y)</code>是否等于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span></span></span></span>，如果是则说明已经相连，否则从<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span></span></span></span> 向<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03588em;">y</span></span></span></span>连一条轻边。</li>
</ul>
<blockquote>
<p>link(x, y) = make_root(x) + (fa[x] = y)</p>
</blockquote>
<h4 id="cut-x-y-cut-x-y-cut-x-y"><a href="#cut-x-y-cut-x-y-cut-x-y" class="headerlink" title="cut(x,y)cut(x, y)cut(x,y)"></a><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>u</mi><mi>t</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">cut(x, y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">u</span><span class="mord mathit">t</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span></h4><ul>
<li><p>作用：断开<svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.326ex" height="2.343ex" style="vertical-align: -0.671ex;" viewbox="0 -719.6 2292.9 1008.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg">
<defs>
<path stroke-width="1" id="E1-MJMATHI-78" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"/>
<path stroke-width="1" id="E1-MJMAIN-2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/>
<path stroke-width="1" id="E1-MJMATHI-79" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)">
 <use xlink:href="#E1-MJMATHI-78" x="0" y="0"/>
 <use xlink:href="#E1-MJMAIN-2212" x="794" y="0"/>
 <use xlink:href="#E1-MJMATHI-79" x="1795" y="0"/>
</g>
</svg>的边（这里默认把<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03588em;">y</span></span></span></span>与父亲<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span></span></span></span>的边断掉）</p>
</li>
<li><p>实现：判断<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03588em;">y</span></span></span></span>之间是否真的存在一条边；若存在，直接切断</p>
<p>这里实现上有点复杂，解释一下这个代码吧</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">make_root(x);</span><br><span class="line"><span class="keyword">if</span> (find_root(y) == x &amp;&amp; Tree[y].fa == x &amp;&amp; !ls(y))</span><br><span class="line">&#123;</span><br><span class="line">    Tree[y].fa = rs(x) = <span class="number">0</span>;</span><br><span class="line">    push_up(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03588em;">y</span></span></span></span>在同一个联通块中，那么纵使在<code>find_root(y)</code>的开始把<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03588em;">y</span></span></span></span><code>splay</code>到根，最后又把<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span></span></span></span>旋回到根了。所以在执行完<code>find_root(y)==x</code>这条语句后当前<code>Splay</code>的根仍然是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span></span></span></span></p>
</li>
</ul>
<blockquote>
<p>cut(x, y) = make_root(x) + (f[y] = right_child[x] = 0)</p>
</blockquote>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ol>
<li><p><code>LCT</code>中的<code>Splay</code>和普通<code>Splay</code>的区别：</p>
<ul>
<li>在<code>rotate</code>时要判断<code>if(!is_root(f))</code>，因为有可能<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span></span></span></span>已经为当前<code>Splay</code>的根，如果不判断的话就会把它向父亲的虚边变实，而这并不是我们所期望的</li>
<li>在<code>splay</code>中循环条件由<code>while(Tree[x].fa != y)</code>变成了<code>while(!is_root(x)</code></li>
<li><code>splay</code>中需要先从根<code>push_down</code>到当前点，再<code>rotate</code></li>
</ul>
</li>
<li><p><code>push_down</code>一般写法与线段树的有点区别：当前点如果有翻转标记的话，它的左右儿子是还没有被翻转的，在标记下传的同时进行翻转。因此在<code>find_root</code>往左儿子走之前就要<code>push_down</code>一下。其实也就是<strong>每访问一个点之前就要<code>push_down</code>！</strong></p>
</li>
<li><p>UPD 19.3.31</p>
<p><code>LCT</code>中<code>make_root</code>是一个重要的操作，除了<code>access</code>之外的所有操作都建立在<code>make_root</code>之上</p>
</li>
</ol>
<hr>
<p>至此，<code>LCT</code>的基本操作就学习<del>口胡</del>完啦</p>
<p><del>我是不会告诉你我到现在还没有开始码的</del></p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h3><p>用来模拟题目中类似的过程，往往在里面再套上一个数据结构来维护一些信息</p>
<h3 id="维护联通性"><a href="#维护联通性" class="headerlink" title="维护联通性"></a>维护联通性</h3><p>直接按照题目<code>link</code>与<code>cut</code></p>
<p>查询两点连通性：<code>find_root</code>，如果没有<code>cut</code>的话可以直接用<code>DSU</code></p>
<h3 id="维护链上信息"><a href="#维护链上信息" class="headerlink" title="维护链上信息"></a>维护链上信息</h3><p>要修改原树中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">u</span></span></span></span>到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03588em;">v</span></span></span></span>的路径上的信息</p>
<p>直接<code>split(u,v)</code>，然后在<code>Splay</code>中操作，利用<code>push_down</code>的lazy标记完成所有点的改变</p>
<h3 id="维护生成树"><a href="#维护生成树" class="headerlink" title="维护生成树"></a>维护生成树</h3><p>维护一个图的最小或最大生成树</p>
<p>因为<code>LCT</code>无法维护边权，所以考虑化边为点。原图中一条边的连接，在新图中变为两条边，即：</p>
<p>原点——新点——原点</p>
<p>原点不带权，新点带权，其权值为原来的边权</p>
<p><code>LCT</code>维护一下链上最大值和次大值，每次直接连边，或是<code>split</code>更新答案</p>
<h3 id="维护边双"><a href="#维护边双" class="headerlink" title="维护边双"></a>维护边双</h3><p>加边的时候，如果这两个点已经联通，那么这条边加入后就一定会形成一个环，因此这个环里的所有点就处在同一个边双里</p>
<p>用类似缩点的方法，遇到环，则新建一个点代表这个边双，把这个环里的所有点的父亲指向新点</p>
<p>凡要用到一个点就<code>x = fa[x]</code>，相当于踏入这个环就踏进这个新点</p>
<p>这个操作用<code>DSU</code>实现就好</p>
<h3 id="维护子树信息（只能维护，无法修改）"><a href="#维护子树信息（只能维护，无法修改）" class="headerlink" title="维护子树信息（只能维护，无法修改）"></a>维护子树信息（只能维护，无法修改）</h3><p>我们发现，在<code>LCT</code>中都是维护的链上信息，那么如何维护原树子树信息呢？</p>
<p>不难发现，<code>原树子树信息 = 虚子树 + 实子树 + 自身信息</code></p>
<p>于是相当于需要多维护一个虚子树信息</p>
<p>对于每个父亲与自己不在同一<code>Splay</code>中的点，把自己的信息加入到自己存的父亲的虚儿子信息库</p>
<p>如果维护信息是可减的，一个数组存，更新是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span></p>
<p>如果维护信息不可减（如min，max），就需要堆或者其它数据结构维护,复杂度多一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>log</mi></mrow><annotation encoding="application/x-tex">\log</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span></span></span></span></p>
<p>相对于原来的<code>LCT</code>，发生改变的操作有<code>push_up</code>，<code>access</code>，<code>link</code></p>
<p>变化的原因：</p>
<ul>
<li><code>push_up</code>：要多维护虚子树的信息</li>
<li><code>access</code>：在改变<strong>虚边</strong>实边时，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span></span></span></span>的虚子树信息会变化，所以要修改</li>
<li><code>link</code>：在把<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span></span></span></span>向<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03588em;">y</span></span></span></span>连<strong>虚边</strong>的时候，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03588em;">y</span></span></span></span>的虚子树信息会变化，同时因为每个点的子树信息要算上虚子树信息，所以所有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03588em;">y</span></span></span></span>祖先的子树信息都会变化，需要暴力把所有祖先修改，很麻烦。但是我们可以先直接<code>make_root(y)</code>，这样<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03588em;">y</span></span></span></span>就没有祖先了 </li>
</ul>
<p>可以发现，需要修改的地方都是<strong>虚边</strong>改变了的地方，根本原因是<code>push_up</code>时只维护了总子树信息，并没有维护虚儿子信息。所以需要手动修改</p>
<hr>
<p>至此，<code>LCT</code>的基本功能又学习<del>口胡</del>完啦</p>
<p><del>我是不会告诉你我到现在还是没有开始码的</del></p>
<h2 id="模板-Luogu-P3690"><a href="#模板-Luogu-P3690" class="headerlink" title="模板(Luogu P3690)"></a>模板(<a href="https://www.luogu.org/problemnew/show/P3690" target="_blank" rel="noopener">Luogu P3690</a>)</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y1 Y1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y2 Y2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Chkmax</span> <span class="params">(T &amp;a, T b)</span> </span>&#123; <span class="keyword">return</span> a &lt; b ? a = b, <span class="number">1</span> : <span class="number">0</span>; &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Chkmin</span> <span class="params">(T &amp;a, T b)</span> </span>&#123; <span class="keyword">return</span> a &gt; b ? a = b, <span class="number">1</span> : <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">proc_status</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">ifstream <span class="title">t</span> <span class="params">(<span class="string">"/proc/self/status"</span>)</span></span>;</span><br><span class="line">	<span class="built_in">cerr</span> &lt;&lt; <span class="built_in">string</span> (istreambuf_iterator &lt;<span class="keyword">char</span>&gt; (t), istreambuf_iterator &lt;<span class="keyword">char</span>&gt; ()) &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">T <span class="title">read</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	T sum = <span class="number">0</span>, fl = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar();</span><br><span class="line">	<span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(ch); ch = getchar()) <span class="keyword">if</span> (ch == <span class="string">'-'</span>) fl = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span> (; <span class="built_in">isdigit</span>(ch); ch = getchar()) sum = (sum &lt;&lt; <span class="number">3</span>) + (sum &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>;</span><br><span class="line">	<span class="keyword">return</span> sum * fl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">3e5</span> + <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> LCT</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls (Tree[x].ch[0])</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs (Tree[x].ch[1])</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tree</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		<span class="keyword">int</span> ch[<span class="number">2</span>], fa, rev, sum, val;</span><br><span class="line">	&#125;Tree[Maxn];</span><br><span class="line">	<span class="keyword">int</span> Stack[Maxn], top;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">is_root</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> (Tree[Tree[x].fa].ch[<span class="number">0</span>] != x) &amp;&amp; (Tree[Tree[x].fa].ch[<span class="number">1</span>] != x); &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">judge_dir</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x == Tree[Tree[x].fa].ch[<span class="number">1</span>]; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_up</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; Tree[x].sum = Tree[ls].sum ^ Tree[rs].sum ^ Tree[x].val; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_down</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">if</span> (Tree[x].rev) swap(ls, rs), Tree[ls].rev ^= <span class="number">1</span>, Tree[rs].rev ^= <span class="number">1</span>, Tree[x].rev = <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">connect</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f, <span class="keyword">int</span> dir)</span> </span>&#123; Tree[x].fa = f, Tree[f].ch[dir] = x; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span> <span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line"><span class="comment">/**/</span>	<span class="keyword">int</span> f = Tree[x].fa, anc = Tree[f].fa, dirx = judge_dir(x), dirf = judge_dir(f);</span><br><span class="line">		Tree[x].fa = anc; <span class="keyword">if</span> (!is_root(f)) Tree[anc].ch[dirf] = x;</span><br><span class="line">		connect (Tree[x].ch[dirx ^ <span class="number">1</span>], f, dirx);</span><br><span class="line">		connect (f, x, dirx ^ <span class="number">1</span>);</span><br><span class="line">		push_up(f), push_up (x);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">splay</span> <span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		Stack[++top] = x; <span class="keyword">for</span> (<span class="keyword">int</span> y = x; !is_root(y); y = Tree[y].fa) Stack[++top] = Tree[y].fa;</span><br><span class="line">		<span class="keyword">while</span> (top) push_down (Stack[top--]);</span><br><span class="line">		<span class="keyword">for</span> (; !is_root(x); rotate(x)) <span class="keyword">if</span> (!is_root(Tree[x].fa)) rotate (judge_dir(x) == judge_dir(Tree[x].fa) ? Tree[x].fa : x);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**/</span><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">access</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; x; y = x, x = Tree[x].fa) splay (x), rs = y, push_up (x); &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">make_root</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; access (x), splay (x), Tree[x].rev ^= <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">find_root</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; access (x), splay (x); push_down (x); <span class="keyword">while</span> (ls) x = ls, push_down (x); splay (x); <span class="keyword">return</span> x; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">split</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; make_root (x), access (y), splay (y); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**/</span><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">link</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; make_root (x); <span class="keyword">if</span> (find_root (y) == x) <span class="keyword">return</span> ; Tree[x].fa = y; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">cut</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; make_root (x); <span class="keyword">if</span> (find_root (y) == x &amp;&amp; Tree[y].fa == x &amp;&amp; !Tree[y].ch[<span class="number">0</span>]) Tree[y].fa = rs = <span class="number">0</span>, push_up (x); &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; split (x, y); <span class="keyword">return</span> Tree[y].sum; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">modify</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; access (x), splay(x); Tree[x].val = y; push_up(x); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Solve</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (M--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> op = read&lt;<span class="keyword">int</span>&gt;(), x = read&lt;<span class="keyword">int</span>&gt;(), y = read&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">		<span class="keyword">if</span> (!op) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, LCT :: query (x, y));</span><br><span class="line">		<span class="keyword">if</span> (op == <span class="number">1</span>) LCT :: link (x, y);</span><br><span class="line">		<span class="keyword">if</span> (op == <span class="number">2</span>) LCT :: cut (x, y);</span><br><span class="line">		<span class="keyword">if</span> (op == <span class="number">3</span>)  LCT :: modify (x, y);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Input</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	N = read&lt;<span class="keyword">int</span>&gt;(), M = read&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) LCT :: Tree[i].val = read&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">	freopen(<span class="string">"A.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">"A.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	Input();</span><br><span class="line">	Solve();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><div class="article-meta"><div class="tags"><i class="icon icon-tag"></i><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/LCT/">LCT</a><span class="tag-list-count">11</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Splay/">Splay</a><span class="tag-list-count">13</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构/">数据结构</a><span class="tag-list-count">110</span></li></ul></div></div></article></div></main><footer><div class="paginator"><a class="prev" href="/2018/12/30/「HNOI2010」弹飞绵羊-LCT/"><span>「HNOI2010」弹飞绵羊 - LCT</span></a><a class="next" href="/2018/12/27/「PKUWC2018」随机算法-状压dp/"><span>「PKUWC2018」随机算法 - 状压dp</span></a></div><div class="v" id="comments"> </div><script src="//cdn.jun6.net/av-min.js"></script>
<script src="//cdn.jun6.net/Valine.min.js"></script>
<script type="text/javascript"> new Valine({ el: '#comments' , verify: "true", notify: "true", appId: "2wXHHL7KBB6DpOQTCnkO5zIA-gzGzoHsz", appKey: "dJgClhnm2rklwPRlXrTRdXsz", placeholder: "快来评论吧~~~（有人@你时会有邮件提醒，建议填写真实邮箱噢）", avatar:"mm", pageSize:"6" || 10 }); </script><link rel="stylesheet" href="/css/partial/valine.css"><script src="//libs.baidu.com/jquery/2.1.4/jquery.min.js"></script><script>$(document).ready(function(){
    $("#comments").on('click', 'span.vat',function(){
        $(this).parent('div.vmeta').next("div.vcontent").after($("div.vwrap"));
        $('textarea#veditor').focus();
    })
})</script><div class="copyright"><p>© 2017 - 2020 靡不有初，鲜克有终</p><p>Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>, theme by <a href="https://github.com/hk-cnyali" target="_blank">hk_cnyali</a>.</p></div><script type="text/javascript" src="https://libs.baidu.com/jquery/1.9.1/jquery.min.js"></script><script>// Popup Window;
var isfetched = false;
var isXml = true;
// Search DB path;
var search_path = "search.json";
if (search_path.length === 0) {
  search_path = "search.xml";
} else if (/json$/i.test(search_path)) {
  isXml = false;
}
var path = "/" + search_path;
// monitor main search box;
// console.log(path);

var onPopupClose = function (e) {
  // console.log("onPopupClose");
  $('.popup').hide();
  $('#local-search-input').val('');
  $('.search-result-list').remove();
  $('#no-result').remove();
  $(".local-search-pop-overlay").remove();
  $('body').css('overflow', '');
}

function proceedsearch() {
  // console.log("proceed_search");
  $("body")
    .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
    .css('overflow', 'hidden');
  $('.search-popup-overlay').click(onPopupClose);
  $('.popup').toggle();
  var $localSearchInput = $('#local-search-input');
  $localSearchInput.attr("autocapitalize", "none");
  $localSearchInput.attr("autocorrect", "off");
  $localSearchInput.focus();
}

// search function;
var searchFunc = function(path, search_id, content_id) {
  // console.log("searchFunc");
  'use strict';

  // start loading animation
  $("body")
    .append('<div class="search-popup-overlay local-search-pop-overlay">' +
      '<div id="search-loading-icon">' +
      '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
      '</div>' +
      '</div>')
    .css('overflow', 'hidden');
  $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');
  // console.log("start_loading_animation");

  // console.log(path);
  // console.log(isXml);
  // console.log(document.getElementById(search_id));

  $.ajax({
    url: path,
    dataType: isXml ? "xml" : "json",
    async: true,
    error: function(res) {
      // console.log("error!");
    }, 
    success: function(res) {
      // console.log("success!");
      // get the contents from search data
      isfetched = true;
      $('.popup').detach().appendTo('.header');
      var datas = isXml ? $("entry", res).map(function() {
        return {
          title: $("title", this).text(),
          content: $("content",this).text(),
          url: $("url" , this).text()
        };
      }).get() : res;
      var input = document.getElementById(search_id);
      // console.log("input = " + input);
      var resultContent = document.getElementById(content_id);
      // console.log("resultContent = " + resultContent);
      var inputEventFunction = function() {
        var searchText = input.value.trim().toLowerCase();
        var keywords = searchText.split(/[\s\-]+/);
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        var resultItems = [];
        if (searchText.length > 0) {
          // perform local searching
          datas.forEach(function(data) {
            var isMatch = false;
            var hitCount = 0;
            var searchTextCount = 0;
            var title = data.title.trim();
            var titleInLowerCase = title.toLowerCase();
            var content = data.content.trim().replace(/<[^>]+>/g,"");
            var contentInLowerCase = content.toLowerCase();
            var articleUrl = decodeURIComponent(data.url);
            var indexOfTitle = [];
            var indexOfContent = [];
            // only match articles with not empty titles
            if(title != '') {
              keywords.forEach(function(keyword) {
                function getIndexByWord(word, text, caseSensitive) {
                  var wordLen = word.length;
                  if (wordLen === 0) {
                    return [];
                  }
                  var startPosition = 0, position = [], index = [];
                  if (!caseSensitive) {
                    text = text.toLowerCase();
                    word = word.toLowerCase();
                  }
                  while ((position = text.indexOf(word, startPosition)) > -1) {
                    index.push({position: position, word: word});
                    startPosition = position + wordLen;
                  }
                  return index;
                }

                indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
              });
              if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                isMatch = true;
                hitCount = indexOfTitle.length + indexOfContent.length;
              }
            }

            // show search results

            if (isMatch) {
              // sort index by position of keyword

              [indexOfTitle, indexOfContent].forEach(function (index) {
                index.sort(function (itemLeft, itemRight) {
                  if (itemRight.position !== itemLeft.position) {
                    return itemRight.position - itemLeft.position;
                  } else {
                    return itemLeft.word.length - itemRight.word.length;
                  }
                });
              });

              // merge hits into slices

              function mergeIntoSlice(text, start, end, index) {
                var item = index[index.length - 1];
                var position = item.position;
                var word = item.word;
                var hits = [];
                var searchTextCountInSlice = 0;
                while (position + word.length <= end && index.length != 0) {
                  if (word === searchText) {
                    searchTextCountInSlice++;
                  }
                  hits.push({position: position, length: word.length});
                  var wordEnd = position + word.length;

                  // move to next position of hit

                  index.pop();
                  while (index.length != 0) {
                    item = index[index.length - 1];
                    position = item.position;
                    word = item.word;
                    if (wordEnd > position) {
                      index.pop();
                    } else {
                      break;
                    }
                  }
                }
                searchTextCount += searchTextCountInSlice;
                return {
                  hits: hits,
                  start: start,
                  end: end,
                  searchTextCount: searchTextCountInSlice
                };
              }

              var slicesOfTitle = [];
              if (indexOfTitle.length != 0) {
                slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
              }

              var slicesOfContent = [];
              while (indexOfContent.length != 0) {
                var item = indexOfContent[indexOfContent.length - 1];
                var position = item.position;
                var word = item.word;
                // cut out 100 characters
                var start = position - 20;
                var end = position + 80;
                if(start < 0){
                  start = 0;
                }
                if (end < position + word.length) {
                  end = position + word.length;
                }
                if(end > content.length){
                  end = content.length;
                }
                slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
              }

              // sort slices in content by search text's count and hits' count

              slicesOfContent.sort(function (sliceLeft, sliceRight) {
                if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                  return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                  return sliceRight.hits.length - sliceLeft.hits.length;
                } else {
                  return sliceLeft.start - sliceRight.start;
                }
              });

              // select top N slices in content

              var upperBound = parseInt("1");
              if (upperBound >= 0) {
                slicesOfContent = slicesOfContent.slice(0, upperBound);
              }
              // console.log(upperBound);

              // highlight title and content

              function highlightKeyword(text, slice) {
                var result = '';
                var prevEnd = slice.start;
                slice.hits.forEach(function (hit) {
                  result += text.substring(prevEnd, hit.position);
                  var end = hit.position + hit.length;
                  result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                  prevEnd = end;
                });
                result += text.substring(prevEnd, slice.end);
                return result;
              }

              var resultItem = '';

              if (slicesOfTitle.length != 0) {
                resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
              } else {
                resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
              }

              slicesOfContent.forEach(function (slice) {
                resultItem += "<a>" +
                  "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                  "...</p>" + "</a>";
              });

              resultItem += "</li>";
              resultItems.push({
                item: resultItem,
                searchTextCount: searchTextCount,
                hitCount: hitCount,
                id: resultItems.length
              });
            }
          })
        };
        if (keywords.length === 1 && keywords[0] === "") {
          resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
        } else if (resultItems.length === 0) {
          resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
        } else {
          resultItems.sort(function (resultLeft, resultRight) {
            if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
              return resultRight.searchTextCount - resultLeft.searchTextCount;
            } else if (resultLeft.hitCount !== resultRight.hitCount) {
              return resultRight.hitCount - resultLeft.hitCount;
            } else {
              return resultRight.id - resultLeft.id;
            }
          });
          var searchResultList = '<ul class=\"search-result-list\">';
          resultItems.forEach(function (result) {
            searchResultList += result.item;
          })
          searchResultList += "</ul>";
          resultContent.innerHTML = searchResultList;
        }
      }

      if ('auto' === "auto") {
        input.addEventListener('input', inputEventFunction);
      } else {
        $('.search-icon').click(inputEventFunction);
        input.addEventListener('keypress', function (event) {
          if (event.keyCode === 13) {
            inputEventFunction();
          }
        });
      }

      // remove loading animation
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');

      proceedsearch();
    }
  });
}

// handle and trigger popup window;
$('.popup-trigger').click(function(e) {
  e.stopPropagation();
  if (isfetched === false) {
    searchFunc(path, 'local-search-input', 'local-search-result');
  } else {
    proceedsearch();
  };
});

$('.popup-btn-close').click(onPopupClose);
$('.popup').click(function(e){
  // console.log("popup.click");
  e.stopPropagation();
});
$(document).on('keyup', function (event) {
  // console.log("keyup");
  var shouldDismissSearchPopup = event.which === 27 && $('.search-popup').is(':visible');
  if (shouldDismissSearchPopup) {
    onPopupClose();
  }
});</script></footer></div><script>var wrap = document.getElementById('wrap');
window.onload = function () {
  wrap.className += ' done';
}
</script></body></html>