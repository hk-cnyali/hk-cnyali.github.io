[{"title":"「2-20模拟赛」C. 排序","url":"/2020/02/25/%E3%80%8C2-20%E6%A8%A1%E6%8B%9F%E8%B5%9B%E3%80%8DC-%E6%8E%92%E5%BA%8F/","content":"","categories":["Problem"],"tags":["hide"]},{"title":"「2-24模拟赛」C. 文体两开花 (flower) - 树形DP + 背包 + 贪心","url":"/2020/02/25/%E3%80%8C2-24%E6%A8%A1%E6%8B%9F%E8%B5%9B%E3%80%8DC-%E6%96%87%E4%BD%93%E4%B8%A4%E5%BC%80%E8%8A%B1-flower-%E6%A0%91%E5%BD%A2DP-%E8%83%8C%E5%8C%85-%E8%B4%AA%E5%BF%83/","content":"","categories":["Problem"],"tags":["动态规划","贪心","背包","树形DP","hide"]},{"title":"「2-23模拟赛」B. 小b爱实数","url":"/2020/02/25/%E3%80%8C2-23%E6%A8%A1%E6%8B%9F%E8%B5%9B%E3%80%8DB-%E5%B0%8Fb%E7%88%B1%E5%AE%9E%E6%95%B0/","content":"","categories":["Problem"],"tags":["hide"]},{"title":"「2-19模拟赛」A. 配对 - 构造 + 换根DP","url":"/2020/02/25/%E3%80%8C2-19%E6%A8%A1%E6%8B%9F%E8%B5%9B%E3%80%8DA-%E9%85%8D%E5%AF%B9-%E6%9E%84%E9%80%A0-%E6%8D%A2%E6%A0%B9DP/","content":"","categories":["Problem"],"tags":["构造","换根DP","hide"]},{"title":"「2-20模拟赛」A. 选举 - 构造","url":"/2020/02/25/%E3%80%8C2-20%E6%A8%A1%E6%8B%9F%E8%B5%9B%E3%80%8DA-%E9%80%89%E4%B8%BE-%E6%9E%84%E9%80%A0/","content":"","categories":["Problem"],"tags":["构造","hide"]},{"title":"「2-22模拟赛」B. 回文后缀 - 动态规划 + 递推","url":"/2020/02/25/%E3%80%8C2-22%E6%A8%A1%E6%8B%9F%E8%B5%9B%E3%80%8DB-%E5%9B%9E%E6%96%87%E5%90%8E%E7%BC%80-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E9%80%92%E6%8E%A8/","content":"","categories":["Problem"],"tags":["动态规划","计数","递推","hide"]},{"title":"「2-22模拟赛」C. 无向图 - 组合数学 + NTT + 斯特林数","url":"/2020/02/25/%E3%80%8C2-22%E6%A8%A1%E6%8B%9F%E8%B5%9B%E3%80%8DC-%E6%97%A0%E5%90%91%E5%9B%BE-%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6-NTT-%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/","content":"","categories":["Problem"],"tags":["斯特林数","NTT","组合数学","hide","多项式"]},{"title":"「2-23模拟赛」A. 小b爱旅行 - 线性基 + 暴力重构","url":"/2020/02/25/%E3%80%8C2-23%E6%A8%A1%E6%8B%9F%E8%B5%9B%E3%80%8DA-%E5%B0%8Fb%E7%88%B1%E6%97%85%E8%A1%8C-%E7%BA%BF%E6%80%A7%E5%9F%BA-%E6%9A%B4%E5%8A%9B%E9%87%8D%E6%9E%84/","content":"","categories":["Problem"],"tags":["线性基","hide","暴力重构"]},{"title":"「2-5模拟赛」A. rng - 概率和期望 + 线段树","url":"/2020/02/12/%E3%80%8C2-5%E6%A8%A1%E6%8B%9F%E8%B5%9B%E3%80%8DA-rng-%E6%A6%82%E7%8E%87%E5%92%8C%E6%9C%9F%E6%9C%9B-%E7%BA%BF%E6%AE%B5%E6%A0%91/","content":"","categories":["Problem"],"tags":["线段树","数据结构","概率和期望","hide"]},{"title":"「2-5模拟赛」C. pm - 单调栈 + 树状数组","url":"/2020/02/10/%E3%80%8C2-5%E6%A8%A1%E6%8B%9F%E8%B5%9B%E3%80%8DC-pm-%E5%8D%95%E8%B0%83%E6%A0%88-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/","content":"","categories":["Problem"],"tags":["单调栈","树状数组","hide"]},{"title":"「2-2模拟赛」A. 人生 - 计数 + DP优化","url":"/2020/02/10/%E3%80%8C2-2%E6%A8%A1%E6%8B%9F%E8%B5%9B%E3%80%8DA-%E4%BA%BA%E7%94%9F-%E8%AE%A1%E6%95%B0-DP%E4%BC%98%E5%8C%96/","content":"","categories":["Problem"],"tags":["动态规划","计数","DP优化","hide"]},{"title":"「2-4模拟赛」C. 亚特兰大 - 莫比乌斯反演 + 可撤销并查集","url":"/2020/02/10/%E3%80%8C2-4%E6%A8%A1%E6%8B%9F%E8%B5%9B%E3%80%8DC-%E4%BA%9A%E7%89%B9%E5%85%B0%E5%A4%A7-%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94-%E5%8F%AF%E6%92%A4%E9%94%80%E5%B9%B6%E6%9F%A5%E9%9B%86/","content":"","categories":["Problem"],"tags":["并查集","莫比乌斯反演","hide","可撤销并查集"]},{"title":"「2-1模拟赛」A. 楼房搭建 - 反悔型贪心","url":"/2020/02/10/%E3%80%8C2-1%E6%A8%A1%E6%8B%9F%E8%B5%9B%E3%80%8DA-%E6%A5%BC%E6%88%BF%E6%90%AD%E5%BB%BA-%E5%8F%8D%E6%82%94%E5%9E%8B%E8%B4%AA%E5%BF%83/","content":"","categories":["Problem"],"tags":["贪心","hide","反悔型贪心"]},{"title":"「2-2模拟赛」B. 赢家 - 状压DP + 补集转化","url":"/2020/02/09/%E3%80%8C2-2%E6%A8%A1%E6%8B%9F%E8%B5%9B%E3%80%8DB-%E8%B5%A2%E5%AE%B6-%E7%8A%B6%E5%8E%8BDP-%E8%A1%A5%E9%9B%86%E8%BD%AC%E5%8C%96/","content":"","categories":["Problem"],"tags":["容斥","动态规划","状态压缩","hide","补集转化"]},{"title":"「2-9模拟赛」B. 整除分块 - 毒瘤 + 找规律 + 推式子","url":"/2020/02/09/%E3%80%8C2-9%E6%A8%A1%E6%8B%9F%E8%B5%9B%E3%80%8DB-%E6%95%B4%E9%99%A4%E5%88%86%E5%9D%97-%E6%AF%92%E7%98%A4-%E6%89%BE%E8%A7%84%E5%BE%8B-%E6%8E%A8%E5%BC%8F%E5%AD%90/","content":"","categories":["Problem"],"tags":["数学","毒瘤","hide","找规律","推式子"]},{"title":"「2-6模拟赛」C. 不同的缩写 - 二分图匹配 + Hall定理","url":"/2020/02/06/%E3%80%8C2-6%E6%A8%A1%E6%8B%9F%E8%B5%9B%E3%80%8DC-%E4%B8%8D%E5%90%8C%E7%9A%84%E7%BC%A9%E5%86%99-%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D-Hall%E5%AE%9A%E7%90%86/","content":"","categories":["Problem"],"tags":["二分图匹配","二分图","hide","Hall定理"]},{"title":"「Codeforces」Educational Codeforces Round 81","url":"/2020/02/05/%E3%80%8CCodeforces%E3%80%8DEducational-Codeforces-Round-81/","content":"\n[link](https://codeforces.com/contest/1295)\n\n## [D - Same GCDs](https://codeforces.com/contest/1295/problem/D)\n\n### Description\n\n给出$a, m$，求有多少个$x \\in[0, m)$满足$\\gcd(a, m) = \\gcd(a + x, m)$\n\n$a < m \\le 10^{10}$\n\n### Solution\n\n> 以下$(a, b)$均表示$\\gcd(a, b)$\n\n考场降智...\n \n题意可以转化为求有多少个$x'\\in[a, a + m)$，满足$(a, m) = (x', m)$\n\n又因为$(a, b) = (a - b, b)$，所以当$x'\\in[m, a + m)$时，$(x', m) = (x' - m, m)$\n\n所以转化为求有多少 $x'\\in[0, m)$，满足$(a, m) = (x', m)$\n\n答案即为$\\varphi(\\frac{m}{(a, m)})$\n\n<details>\n<summary>Code</summary>\n\n```cpp\n#include <iostream>\n#include <ctime>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <climits>\n#include <queue>\n#include <set>\n#include <cmath>\n#include <map>\n#include <bitset>\n#include <fstream>\n#include <tr1/unordered_map>\n#include <assert.h>\n\n#define x first\n#define y second\n#define y0 Y0\n#define y1 Y1\n#define mp make_pair\n#define pb push_back\n#define DEBUG(x) cout << #x << \" = \" << x << endl;\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int MAXN = 1e5;\n\nLL a, M;\n\ninline LL get_phi (LL n)\n{\n\tLL ans = n;\n\tfor (LL i = 2; i * i <= n; ++i) if (!(n % i))\n\t{\n\t\twhile (!(n % i)) n /= i;\n\t\tans = ans / i * (i - 1);\n\t}\n\tif (n > 1) ans = ans / n * (n - 1);\n\treturn ans;\n}\n\ninline void Solve ()\n{\n\tprintf(\"%lld\\n\", get_phi (M / __gcd (a, M)));\n}\n\ninline void Input ()\n{\n\ta = read<LL>(), M = read<LL>();\n}\n\nint main ()\n{\n\n#ifdef hk_cnyali\n\tfreopen(\"D.in\", \"r\", stdin);\n\tfreopen(\"D.out\", \"w\", stdout);\n#endif\n\n\tint Te = read<int>();\n\n\twhile (Te--)\n\t{\n\t\tInput ();\n\t\tSolve ();\n\t}\n\n\treturn 0;\n}\n```\n</details>\n\n## [E. Permutation Separation](https://codeforces.com/contest/1295/problem/E)\n\n### Description\n\n![20-2-5-1](/images/20-2-5-1.png)\n\n### Solution\n\n枚举最后答案中左半边集合元素的最大值$x$, 维护一个数组$s_i$表示当前如果从$i$处切开所花费的代价。\n\n考虑左半边集合元素的最大值从$x - 1$变化到$x$时，$s_i$会怎样变化\n\n显然是在$[1, x - 1]$加上$a_i$，在$[x, n)$减去$a_i$\n\n线段树维护最小值，区间加即可\n\n<details>\n<summary>Code</summary>\n\n```cpp\n#include <iostream>\n#include <ctime>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <climits>\n#include <queue>\n#include <set>\n#include <cmath>\n#include <map>\n#include <bitset>\n#include <fstream>\n#include <tr1/unordered_map>\n#include <assert.h>\n\n#define x first\n#define y second\n#define y0 Y0\n#define y1 Y1\n#define mp make_pair\n#define pb push_back\n#define DEBUG(x) cout << #x << \" = \" << x << endl;\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int MAXN = 2e5;\n\nint N, P[MAXN + 5], A[MAXN + 5];\n\nnamespace SEG\n{\n#define mid ((l + r) >> 1)\n#define ls o << 1\n#define rs o << 1 | 1\n#define lson ls, l, mid\n#define rson rs, mid + 1, r\n\tconst int MAXN = ::MAXN * 4;\n\n\tstruct info\n\t{\n\t\tLL val, tag;\n\t} node[MAXN + 5];\n\n\tinline void push_up (int o) { node[o].val = min (node[ls].val, node[rs].val); }\n\n\tinline void push_down (int o)\n\t{\n\t\tif (!node[o].tag) return ;\n\t\tLL &tag = node[o].tag;\n\t\tnode[ls].val += tag, node[ls].tag += tag;\n\t\tnode[rs].val += tag, node[rs].tag += tag;\n\t\ttag = 0;\n\t}\n\n\tinline void update (int o, int l, int r, int x, int y, LL val)\n\t{\n\t\tif (x > y) return ;\n\t\tif (x <= l && r <= y)\n\t\t{\n\t\t\tnode[o].val += val, node[o].tag += val;\n\t\t\treturn ;\n\t\t}\n\t\tpush_down (o);\n\t\tif (x <= mid) update (lson, x, y, val);\n\t\tif (y > mid) update (rson, x, y, val);\n\t\tpush_up (o);\n\t}\n\n\tinline LL query () { return node[1].val; }\n#undef mid\n}\n\nint Pos[MAXN + 5];\n\ninline void Solve ()\n{\n\tLL sum = 0;\n\tfor (int i = 1; i <= N; ++i) \n\t{\n\t\tsum += A[i];\n\t\tSEG :: update (1, 1, N - 1, i, i, sum);\n\t}\n\n\tLL ans = LLONG_MAX;\n\tfor (int i = 1; i <= N; ++i)\n\t{\n\t\tint p = Pos[i];\n\t\tif (p == 1 || p == N) Chkmin(ans, (LL) A[p]);\n\t\tSEG :: update (1, 1, N - 1, 1, p - 1, A[p]);\n\t\tSEG :: update (1, 1, N - 1, p, N - 1, -A[p]);\n\t\tChkmin (ans, SEG :: query ());\n\t}\n\n\tcout << ans << endl;\n}\n\ninline void Input ()\n{\n\tN = read<int>();\n\tfor (int i = 1; i <= N; ++i) Pos[P[i] = read<int>()] = i;\n\tfor (int i = 1; i <= N; ++i) A[i] = read<int>();\n}\n\nint main ()\n{\n\n#ifdef hk_cnyali\n\tfreopen(\"E.in\", \"r\", stdin);\n\tfreopen(\"E.out\", \"w\", stdout);\n#endif\n\n\tInput ();\n\tSolve ();\n\n\treturn 0;\n}\n```\n</details>\n\n## [F. Good Contest](https://codeforces.com/contest/1295/problem/F)\n\n### Description\n\n给你$n$个数，第$i$个数的取值为$_i$到$r_i$中等概率随机的**整数**\n\n求产生的序列单调不上升的概率\n\n$n\\le 50, l_i, r_i\\le 998244351$\n\n### Solution\n\n因为是整数，所以可以先求方案再除总方案数\n\n暴力dp是设$f[i][j]$表示到第$i$个数，其取值为$j$的方案。因为权值范围很大，考虑优化。\n\n发现题目所给的区间把值域劈成了若干个值域连续段，因为权值必须不增，考虑设$f[i][j]$表示从大到小考虑到第$i$个段，已经填完了$j$个数的方案数，枚举下一段填多少个数转移。\n\n转移时要保证填上去的数从大到小依次排列，即固定了顺序，且值可以相同。于是变成了**球相同，盒不同，允许空盒**的[放球问题](https://hk-cnyali.com/2019/08/22/「Algorithm」放球问题)，插板法算下方案即可\n\n转移方程:\n\n$$\nf[i][j] * \\binom{len + k - 1}{k} \\rightarrow f[i + 1][j + k]\n$$\n\n其中$len$表示第$i$段的值域长度\n\n组合数$O(k)$暴力计算，总复杂度$O(n^4)$\n\n<details>\n<summary>Code</summary>\n\n```cpp\n\n#include <iostream>\n#include <ctime>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <climits>\n#include <queue>\n#include <set>\n#include <cmath>\n#include <map>\n#include <bitset>\n#include <fstream>\n#include <tr1/unordered_map>\n#include <assert.h>\n\n#define x first\n#define y second\n#define y0 Y0\n#define y1 Y1\n#define mp make_pair\n#define pb push_back\n#define DEBUG(x) cout << #x << \" = \" << x << endl;\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int MAXN = 100;\nconst int MAXM = MAXN * 2;\nconst int MOD = 998244353;\n\nnamespace MATH\n{\n\tint fac[MAXN + 5], ifac[MAXN + 5], inv[MAXN + 5];\n\n\tinline void ADD (int &a, int b) { if ((a += b) >= MOD) a -= MOD; }\n\n\tinline int Pow (int a, int b)\n\t{\n\t\tint ans = 1;\n\t\tfor (int i = b; i; i >>= 1, a = (LL) a * a % MOD) if (i & 1) ans = (LL) ans * a % MOD;\n\t\treturn ans;\n\t}\n\n\tinline void init (int n = MAXN + 1)\n\t{\n\t\tfac[0] = 1; for (int i = 1; i <= n; ++i) fac[i] = (LL) fac[i - 1] * i % MOD;\n\t\tifac[n] = Pow (fac[n], MOD - 2); for (int i = n - 1; i >= 0; --i) ifac[i] = (LL) ifac[i + 1] * (i + 1) % MOD;\n\t\tfor (int i = 0; i < n; ++i) inv[i + 1] = (LL) fac[i] * ifac[i + 1] % MOD;\n\t}\n\n\tinline int C (int n, int m)\n\t{\n\t\tif (n < m || n < 0 || m < 0) return 0;\n\t\tif (m == 0) return 1;\n\t\tif (m == 1) return n;\n\t\treturn (LL) C (n, m - 1) * (n - m + 1) % MOD * inv[m] % MOD;\n\t}\n}\n\nusing namespace MATH;\n\nint N;\nint L[MAXN + 5], R[MAXN + 5]; \nint Hash[MAXM + 5], M;\n\ninline void Init ()\n{\n\tsort (Hash + 1, Hash + M + 1);\n\tM = unique (Hash + 1, Hash + M + 1) - Hash - 1;\n\tfor (int i = 1; i <= N; ++i)\n\t{\n\t\tL[i] = lower_bound (Hash + 1, Hash + M + 1, L[i]) - Hash;\n\t\tR[i] = lower_bound (Hash + 1, Hash + M + 1, R[i]) - Hash;\n\t}\n}\n\nint f[MAXM + 5][MAXN + 5];\n\ninline int check (int x, int k)\n{\n\tif (x == 0) return 1;\n\tif (Hash[L[x]] <= Hash[k - 1] + 1 && Hash[k] <= Hash[R[x]]) return 1;\n\treturn 0;\n}\n\nint sum = 1;\n\ninline void Solve ()\n{\n\tInit ();\n\tf[M + 1][0] = 1;\n\n\tfor (int i = M + 1; i >= 2; --i) for (int j = 0; j <= N; ++j) if (f[i][j])\n\t{\n\t\tint len = Hash[i - 1] - Hash[i - 2];\n\t\tADD (f[i - 1][j], f[i][j]);\n\t\tfor (int k = 1; j + k <= N && check (j + k, i - 1); ++k)\n\t\t\tADD (f[i - 1][j + k], (LL) f[i][j] * C (len + k - 1, k) % MOD);\n\t}\n\n\tcout << (LL) f[1][N] * Pow (sum, MOD - 2) % MOD << endl;\n}\n\ninline void Input ()\n{\n\tN = read<int>();\n\tfor (int i = 1; i <= N; ++i)\n\t{\n\t\tL[i] = read<int>(), R[i] = read<int>();\n\t\tHash[++M] = L[i], Hash[++M] = L[i] - 1, Hash[++M] = R[i];\n\t\tsum = (LL) sum * (R[i] - L[i] + 1) % MOD;\n\t}\n}\n\nint main ()\n{\n\n#ifdef hk_cnyali\n\tfreopen(\"F.in\", \"r\", stdin);\n\tfreopen(\"F.out\", \"w\", stdout);\n#endif\n\n\tMATH :: init ();\n\tInput ();\n\tSolve ();\n\n\treturn 0;\n}\n```\n</details>\n","categories":["Problem"],"tags":["Codeforces","数论","欧拉函数","动态规划","线段树","数据结构","组合数学"]},{"title":"「USACO20DJAN」Platinum Solution","url":"/2020/02/04/%E3%80%8CUSACO20DJAN%E3%80%8DPlatinum-Solution/","content":"\n<!--more-->\n\n[LOJ](https://loj.ac/problems/search?keyword=USACO+2020)\n\n## [Cave Paitings](https://loj.ac/problem/3246)\n\n### Solution\n\n用并查集维护连通性，并记录一下当前这个联通块的方案数。依次枚举每一行，先把一行的联通块缩起来，再把上一行的信息并上来即可\n\n<details>\n<summary>Code</summary>\n\n```cpp\n\n#include <iostream>\n#include <ctime>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <climits>\n#include <queue>\n#include <set>\n#include <cmath>\n#include <map>\n#include <bitset>\n#include <fstream>\n#include <tr1/unordered_map>\n#include <assert.h>\n\n#define x first\n#define y second\n#define y0 Y0\n#define y1 Y1\n#define mp make_pair\n#define pb push_back\n#define DEBUG(x) cout << #x << \" = \" << x << endl;\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int MAXN = 1000;\nconst int MOD = 1e9 + 7;\n\ninline void ADD (int &a, int b) { if ((a += b) >= MOD) a -= MOD; }\n\nint N, M;\nchar A[MAXN + 5][MAXN + 5];\n\nnamespace DSU\n{\n\tconst int maxn = MAXN * MAXN;\n\n\tint fa[maxn + 5], ans[maxn + 5];\n\n\tinline void init (int n) { for (int i = 1; i <= n; ++i) fa[i] = i, ans[i] = 1; }\n\n\tinline int get_fa (int x) { return fa[x] == x ? x : fa[x] = get_fa (fa[x]); }\n\n\tinline int get_ans (int x) { return ans[get_fa (x)]; }\n\n\tinline void link (int x, int y) // link y to x\n\t{\n\t\tx = get_fa (x), y = get_fa (y);\n\t\tif (x == y) return ;\n\t\tfa[y] = x;\n\t\tans[x] = (LL) ans[x] * ans[y] % MOD;\n\t}\n\n\tinline void add (int x) { ADD (ans[get_fa(x)], 1); }\n}\n\nint Id[MAXN + 5][MAXN + 5];\n\ninline void Solve ()\n{\n\tfor (int i = 1, tot = 0; i <= N; ++i) for (int j = 1; j <= M; ++j) Id[i][j] = ++tot;\n\tDSU :: init (N * M);\n\n\tfor (int i = 1; i <= N; ++i)\n\t{\n\t\tfor (int j = 1; j <= M; ++j) if (A[i][j] == '.' && A[i][j - 1] == '.')\n\t\t\t DSU :: link (Id[i][j], Id[i][j - 1]);\n\n\t\tfor (int j = 1; j <= M; ++j) if (A[i][j] == '.' && A[i - 1][j] == '.')\n\t\t\tDSU :: link (Id[i][j], Id[i - 1][j]);\n\n\t\tfor (int j = 1; j <= M; ++j) if (A[i][j] == '.' && DSU :: get_fa (Id[i][j]) == Id[i][j])\n\t\t\tDSU :: add (Id[i][j]);\n\t}\n\n\tint ans = 1;\n\tfor (int i = 1; i <= N * M; ++i) if (DSU :: get_fa (i) == i) ans = (LL) ans * DSU :: get_ans (i) % MOD;\n\n\tcout << ans << endl;\n}\n\ninline void Input ()\n{\n\tN = read<int>(), M = read<int>();\n\tfor (int i = N; i >= 1; --i) scanf(\"%s\", A[i] + 1);\n}\n\nint main ()\n{\n\n\tfreopen(\"cave.in\", \"r\", stdin);\n\tfreopen(\"cave.out\", \"w\", stdout);\n\n\tInput ();\n\tSolve ();\n\n\treturn 0;\n}\n\n```\n\n</details>\n\n## [Non-Decreasing Subsequences](https://loj.ac/problem/3247)\n\n### Solution\n\n暴力dp是$f[i][j]$表示到$i$, 最后以$j$结尾的方案数。因为$j$很小，所以可以线段树维护矩阵直接做，但是复杂度不够优秀\n\n考虑优化成线性，发现就是要求区间矩阵的乘积，考虑求出矩阵的前缀积及其逆矩阵。求逆矩阵可以类似线性求`ifac`的方法去做，即先正着求出所有前缀积，对最后一个矩阵求逆，再依次乘回来。所以复杂度瓶颈在于求矩阵的前缀积，以及回答询问\n\n注意到本题的初始矩阵很特殊，只有对角线和某半列上有值。所以可以直接枚举有值的位置进行转移，具体细节可见代码，这里不多赘述。复杂度可降为$O(nk^2)$\n\n询问同理，因为要求的值的位置很少，也可以优化到$O(qk^2)$。再通过前缀和优化一次即可做到$O(qk)$\n\n总复杂度$O(nk^2 + qk)$\n\n<details>\n<summary>Code</summary>\n\n```cpp\n#include <iostream>\n#include <ctime>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <climits>\n#include <queue>\n#include <set>\n#include <cmath>\n#include <map>\n#include <bitset>\n#include <fstream>\n#include <tr1/unordered_map>\n#include <assert.h>\n\n#define x first\n#define y second\n#define y0 Y0\n#define y1 Y1\n#define mp make_pair\n#define pb push_back\n#define DEBUG(x) cout << #x << \" = \" << x << endl;\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int MAXN = 5e4;\nconst int MAXM = 2e5;\nconst int MAXK = 20;\nconst int MOD = 1e9 + 7;\n\n\nnamespace MATH\n{\n\tinline void ADD (int &a, int b) { if ((a += b) >= MOD) a -= MOD; }\n\n\tinline int Pow (int a, int b)\n\t{\n\t\tint ans = 1;\n\t\tfor (int i = b; i; i >>= 1, a = (LL) a * a % MOD) if (i & 1) ans = (LL) ans * a % MOD;\n\t\treturn ans;\n\t}\n}\n\nusing namespace MATH;\n\nint N, K, Q;\n\nstruct matrix\n{\n\tint A[MAXK + 1][MAXK + 1];\n\n\tinline int* operator [] (const int &x) { return A[x]; }\n\n\tinline matrix () { memset (A, 0, sizeof A); }\n\n} prefix[MAXN + 5], iprefix[MAXN + 5];\n\ninline matrix get_inv (matrix A)\n{\n\tmatrix I;\n\tfor (int i = 1; i <= K; ++i) I[i][i] = 1;\n\n\tfor (int i = 1; i <= K; ++i)\n\t{\n\t\tfor (int j = i; j <= K; ++j) if (A[i][j])\n\t\t{\n\t\t\tfor (int k = 1; k <= K; ++k) swap (A[i][k], A[j][k]), swap (I[i][k], I[j][k]);\n\t\t\tbreak;\n\t\t}\n\n\t\tint res = Pow (A[i][i], MOD - 2);\n\t\tfor (int j = 1; j <= K; ++j)\n\t\t{\n\t\t\tA[i][j] = (LL) A[i][j] * res % MOD;\n\t\t\tI[i][j] = (LL) I[i][j] * res % MOD;\n\t\t}\n\n\t\tfor (int j = 1; j <= K; ++j) if (i != j)\n\t\t{\n\t\t\tint tmp = A[j][i];\n\t\t\tfor (int k = i; k <= K; ++k) \n\t\t\t{\n\t\t\t\tADD (A[j][k], MOD - (LL) tmp * A[i][k] % MOD);\n\t\t\t\tADD (I[j][k], MOD - (LL) tmp * I[i][k] % MOD);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn I;\n}\n\nint A[MAXN + 5];\n\ninline void Init ()\n{\n\tfor (int i = 1; i <= N; ++i) prefix[0][i][i] = 1;\n\n\tfor (int i = 1; i <= N; ++i) \n\t{\n\t\tint x = read<int>(); A[i] = x;\n\n\t\tprefix[i] = prefix[i - 1];\n\t\tfor (int j = 1; j <= x; ++j)\n\t\t\tfor (int k = 1; k <= K; ++k)\n\t\t\t\tADD (prefix[i][k][x], prefix[i - 1][k][j]);\n\t}\n\n\tiprefix[N] = get_inv (prefix[N]);\n\n\tfor (int i = N - 1; i >= 0; --i)\n\t{\n\t\tint x = A[i + 1];\n\n\t\tiprefix[i] = iprefix[i + 1];\n\n\t\tfor (int j = 1; j <= x; ++j)\n\t\t\tfor (int k = 1; k <= K; ++k)\n\t\t\t\tADD (iprefix[i][j][k], iprefix[i + 1][x][k]);\n\t}\n}\n\nint Sum[MAXN + 5][MAXK + 1];\n\ninline void Solve ()\n{\n\tInit ();\n\n\tfor (int i = 1; i <= N; ++i)\n\t{\n\t\tfor (int j = 1; j <= K; ++j)\n\t\t\tfor (int k = 1; k <= K; ++k) \n\t\t\t\tADD (Sum[i][j], prefix[i][j][k]);\n\t}\n\n\tQ = read<int>();\n\twhile (Q--)\n\t{\n\t\tint l = read<int>(), r = read<int>();\n\n\t\tint ans = 0;\n\t\tfor (int i = 1; i <= K; ++i) ADD (ans, (LL) iprefix[l - 1][1][i] * Sum[r][i] % MOD);\n\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}\n\ninline void Input ()\n{\n\tN = read<int>(), K = read<int>();\n}\n\nint main ()\n{\n\n\tfreopen(\"nondec.in\", \"r\", stdin);\n\tfreopen(\"nondec.out\", \"w\", stdout);\n\n\tInput ();\n\tSolve ();\n\n\treturn 0;\n}\n```\n\n</details>\n\n## [Falling Portals](https://loj.ac/problem/3248)\n\n### Solution\n\n> solution from jambow\n\n![20-2-4-1](/images/20-2-4-1.png)\n\n![20-2-4-2](/images/20-2-4-2.png)\n\n![20-2-4-3](/images/20-2-4-3.png)\n\n<details>\n<summary>Code</summary>\n\n```cpp\n#include <iostream>\n#include <ctime>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <climits>\n#include <queue>\n#include <set>\n#include <cmath>\n#include <map>\n#include <bitset>\n#include <fstream>\n#include <tr1/unordered_map>\n#include <assert.h>\n\n#define x first\n#define y second\n#define y0 Y0\n#define y1 Y1\n#define mp make_pair\n#define pb push_back\n#define DEBUG(x) cout << #x << \" = \" << x << endl;\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int MAXN = 2e5;\n\nint N, Q[MAXN + 5];\npii Ans[MAXN + 5];\n\nint Pos[MAXN + 5];\npii A[MAXN + 5], stk[MAXN + 5];\n\ninline int cmp1 (const pii &a, const pii &b) { return a.y == b.y ? a.x > b.x : a.y > b.y; }\ninline int cmp2 (const pii &a, const pii &b) { return a.y == b.y ? a.x < b.x : a.y < b.y; }\n\ninline pii operator - (const pii &a, const pii &b) { return mp (a.x - b.x, a.y - b.y); }\n\ninline LL cross (pii o, pii a, pii b)\n{\n\ta = a - o, b = b - o;\n\treturn (LL) a.x * b.y - (LL) a.y * b.x;\n}\n\ninline void solve1 ()\n{\n\tsort (A + 1, A + N + 1, cmp1);\n\tfor (int i = 1; i <= N; ++i) Pos[A[i].x] = i;\n\n\tint top = 0;\n\tfor (int i = 1; i <= N; ++i)\n\t{\n\t\twhile (top && stk[top].x < A[i].x) --top;\n/**/\twhile (top > 1 && cross (A[i], stk[top - 1], stk[top]) > 0) --top;\n\t\tstk[++top] = A[i];\n\n\t\tif (A[Pos[Q[A[i].x]]].y <= A[i].y)\n\t\t{\n\t\t\tpii to = mp (A[Pos[Q[A[i].x]]].x, A[Pos[Q[A[i].x]]].y);\n\t\t\tint l = 1, r = top, ans = 0;\n\t\t\twhile (l <= r)\n\t\t\t{\n\t\t\t\tint mid = (l + r) >> 1;\n\t\t\t\tif (stk[mid].x > to.x && (mid == 1 || cross (to, stk[mid], stk[mid - 1]) >= 0)) ans = mid, l = mid + 1;\n\t\t\t\telse r = mid - 1;\n\t\t\t}\n\n\t\t\tif (ans) Ans[A[i].x] = stk[ans] - to;\n\t\t}\n\t}\n}\n\ninline void solve2 ()\n{\n\tsort (A + 1, A + N + 1, cmp2);\n\tfor (int i = 1; i <= N; ++i) Pos[A[i].x] = i;\n\n\tint top = 0;\n\tfor (int i = 1; i <= N; ++i)\n\t{\n\t\twhile (top && stk[top].x > A[i].x) --top;\n\t\twhile (top > 1 && cross (A[i], stk[top - 1], stk[top]) > 0) --top;\n\t\tstk[++top] = A[i];\n\n\t\tif (A[Pos[Q[A[i].x]]].y > A[i].y)\n\t\t{\n\t\t\tpii to = mp (A[Pos[Q[A[i].x]]].x, A[Pos[Q[A[i].x]]].y);\n\t\t\tint l = 1, r = top, ans = 0;\n\t\t\twhile (l <= r)\n\t\t\t{\n\t\t\t\tint mid = (l + r) >> 1;\n\t\t\t\tif (stk[mid].x < to.x && (mid == 1 || cross (to, stk[mid], stk[mid - 1]) >= 0)) ans = mid, l = mid + 1;\n\t\t\t\telse r = mid - 1;\n\t\t\t}\n\n\t\t\tif (ans) Ans[A[i].x] = to - stk[ans];\n\t\t}\n\t}\n}\n\ninline void Solve ()\n{\n\tfor (int i = 1; i <= N; ++i) Ans[i].x = -1;\n\tsolve1 ();\n\tsolve2 ();\n\n\tfor (int i = 1; i <= N; ++i) \n\t\tif (Ans[i].x == -1) puts(\"-1\");\n\t\telse printf(\"%d/%d\\n\", Ans[i].y / __gcd (Ans[i].x, Ans[i].y), Ans[i].x / __gcd (Ans[i].x, Ans[i].y));\n}\n\ninline void Input ()\n{\n\tN = read<int>();\n\tfor (int i = 1; i <= N; ++i) A[i] = mp (i, read<int>());\n\tfor (int i = 1; i <= N; ++i) Q[i] = read<int>();\n}\n\nint main ()\n{\n\n\tfreopen(\"falling.in\", \"r\", stdin);\n\tfreopen(\"falling.out\", \"w\", stdout);\n\n\tInput ();\n\tSolve ();\n\n\treturn 0;\n}\n```\n\n</details>\n","categories":["Problem"],"tags":["单调栈","并查集","二分","矩阵","usaco","凸壳"]},{"title":"「2-3模拟赛」B. 图 - 状压DP","url":"/2020/02/03/%E3%80%8C2-3%E6%A8%A1%E6%8B%9F%E8%B5%9B%E3%80%8DB-%E5%9B%BE-%E7%8A%B6%E5%8E%8BDP/","content":"","categories":["Problem"],"tags":["动态规划","状态压缩","hide"]},{"title":"「2-3模拟赛」C. 字符串 - 后缀自动机 + dsu on tree + 二维数点","url":"/2020/02/03/%E3%80%8C2-3%E6%A8%A1%E6%8B%9F%E8%B5%9B%E3%80%8DC-%E5%AD%97%E7%AC%A6%E4%B8%B2-%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA-dsu-on-tree-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%82%B9/","content":"","categories":["Problem"],"tags":["树状数组","毒瘤","扫描线","dsu on tree","后缀自动机","hide","二维数点"]},{"title":"「雅礼集训 2017 Day1」字符串 - 后缀自动机 + 根号平衡","url":"/2020/02/01/%E3%80%8C%E9%9B%85%E7%A4%BC%E9%9B%86%E8%AE%AD-2017-Day1%E3%80%8D%E5%AD%97%E7%AC%A6%E4%B8%B2-%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA-%E6%A0%B9%E5%8F%B7%E5%B9%B3%E8%A1%A1/","content":"\n给出一个长度为 $n$ 的字符串 $s$ 和 $m$ 个区间 $[l_i, r_i]$, **给定$k$**\n\n$q$次 询问. 每次给定一个长度为 $k$ 的字符串 $w$ 以及一对 $L,R$, 求所有满足 $i\\in[L, R]$的 $w[l_i:r_i]$ 在 $s$ 中的出现次数之和.\n\n$n,m,k,q\\le 1\\times 10^5$, $\\sum |w|\\le 1\\times 10^5$\n\n<!--more-->\n\n### Link\n\n[LOJ6031](https://loj.ac/problem/6031)\n\n### Solution\n\n因为$k$一定，且$\\sum|w|$不大，考虑根号平衡\n\n先对$s$串建`SAM`，设$kq = T$\n\n* 当$k \\le \\sqrt m$ 时:\n\n  因为$k$很小，所有可能的区间$[l_i, r_i]$只有$k^2$种，可以对每个询问暴力$O(k^2)$枚举子串，丢到`SAM`上匹配求出对应`right集合`大小，再乘上这个子串对应的区间在$[L, R]$中的出现次数(用`vector`二分实现)即可\n\n  复杂度是$O(k^2q\\log n = O(T\\sqrt m\\log n)$\n\n* 当$k > \\sqrt m$时:\n\n  此时询问很少，考虑对每个询问都暴力枚举$[L, R]$中的区间，然后倍增在`SAM`上匹配，复杂度是单词询问$O(m \\log n)$\n\n  要想每次倍增求的话首先要对$w$预处理出以每个点为右端点时，在`SAM`上匹配的节点，和最大匹配长度，这部分复杂度是单次询问$O(n)$的\n\n  总复杂度$O\\big(q(n + m\\log n)\\big) = O(n\\sqrt m + T\\sqrt m\\log n)$\n\n### Code\n\n```cpp\n#include <iostream>\n#include <ctime>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <climits>\n#include <queue>\n#include <set>\n#include <cmath>\n#include <map>\n#include <bitset>\n#include <fstream>\n#include <tr1/unordered_map>\n#include <assert.h>\n\n#define x first\n#define y second\n#define y0 Y0\n#define y1 Y1\n#define mp make_pair\n#define pb push_back\n#define DEBUG(x) cout << #x << \" = \" << x << endl;\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int MAXN = 1e5;\nconst int LIM = sqrt (MAXN);\n\nint N, M, Q, K;\nchar S[MAXN + 5];\n\nnamespace SAM\n{\n\tconst int MAXN = ::MAXN * 2;\n\n\tstruct info\n\t{\n\t\tint fa, ch[26], maxlen, size;\n\t} node[MAXN + 5];\n\n\tint node_cnt = 1, lst = 1;\n\n\tinline int new_node (int pre)\n\t{\n\t\tint o = ++node_cnt;\n\t\tnode[o].maxlen = node[pre].maxlen + 1;\n\t\tnode[o].size = 1;\n\t\treturn o;\n\t}\n\n\tinline void extend (int c)\n\t{\n\t\tint o = new_node (lst), pre = lst; lst = o;\n\n\t\tfor (; pre && !node[pre].ch[c]; pre = node[pre].fa) node[pre].ch[c] = o;\n\t\t\n\t\tif (!pre) node[o].fa = 1;\n\t\telse\n\t\t{\n\t\t\tint x = node[pre].ch[c];\n\t\t\tif (node[x].maxlen == node[pre].maxlen + 1) node[o].fa = x;\n\t\t\telse\n\t\t\t{\n\t\t\t\tint y = ++node_cnt; node[y] = node[x], node[y].maxlen = node[pre].maxlen + 1;\n\t\t\t\tnode[y].size = 0, node[x].fa = node[o].fa = y;\n\t\t\t\tfor (; node[pre].ch[c] == x; pre = node[pre].fa) node[pre].ch[c] = y;\n\t\t\t}\n\t\t}\n\t}\n\n\tvector <int> G[MAXN + 5];\n\n\tconst int MAX_LOG = log2(MAXN);\n\tint anc[MAX_LOG + 1][MAXN + 5];\n\n\tinline void dfs (int x) \n\t{ \n\t\tfor (int i = 1; 1 << i <= N; ++i) anc[i][x] = anc[i - 1][anc[i - 1][x]];\n\n\t\tfor (int i = 0; i < G[x].size(); ++i) \n\t\t{ \n\t\t\tint y = G[x][i]; \n\t\t\tdfs (y); \n\t\t\tnode[x].size += node[y].size; \n\t\t}\n\t}\n\t\n\tinline void build ()\n\t{\n\t\tfor (int i = 1; i <= N; ++i) extend (S[i] - 'a');\n\t\tfor (int i = 1; i <= node_cnt; ++i) G[node[i].fa].pb (i), anc[0][i] = node[i].fa;\n\t\tdfs (1);\n\t}\n\n\tinline void match (char *S, int *O, int *Len)\n\t{\n\t\tint o = 1, len = 0;\n\t\tfor (int i = 1; i <= K; ++i)\n\t\t{\n\t\t\tint c = S[i] - 'a';\n\t\t\twhile (o > 1 && !node[o].ch[c]) o = node[o].fa, len = node[o].maxlen;\n\n\t\t\tif (node[o].ch[c]) o = node[o].ch[c], O[i] = o, ++len;\n\t\t\telse O[i] = 0;\n\n\t\t\tLen[i] = len;\n\t\t}\n\t}\n\n\tinline int get_anc (int o, int len)\n\t{\n\t\tfor (int i = MAX_LOG; i >= 0; --i) if (node[anc[i][o]].maxlen >= len)\n\t\t\to = anc[i][o];\n\t\treturn o;\n\t}\n}\n\nnamespace S1\n{\n\tvector <int> vec[LIM + 5][LIM + 5];\n\n\tinline void main ()\n\t{\n\t\tfor (int i = 1; i <= M; ++i) \n\t\t{\n\t\t\tint l = read<int>() + 1, r = read<int>() + 1;\n\t\t\tvec[l][r].pb (i);\n\t\t}\n\n\t\twhile (Q--)\n\t\t{\n\t\t\tstatic char S[LIM + 5];\n\t\t\tscanf(\"%s\", S + 1);\n\t\t\tint l = read<int>() + 1, r = read<int>() + 1;\n\t\t\tLL ans = 0;\n\t\t\tfor (int i = 1; i <= K; ++i)\n\t\t\t\tfor (int j = i, o = 1; j <= K; ++j)\n\t\t\t\t{\n\t\t\t\t\to = SAM :: node[o].ch[S[j] - 'a'];\n\t\t\t\t\tif (!o) break;\n\t\t\t\t\tint x = lower_bound (vec[i][j].begin(), vec[i][j].end(), l) - vec[i][j].begin();\n\t\t\t\t\tint y = upper_bound (vec[i][j].begin(), vec[i][j].end(), r) - vec[i][j].begin() - 1;\n\t\t\t\t\tans += (LL) SAM :: node[o].size * max (0, y - x + 1);\n\t\t\t\t}\n\t\t\tprintf(\"%lld\\n\", ans);\n\t\t}\n\t}\n}\n\nnamespace S2\n{\n\tint L[MAXN + 5], R[MAXN + 5];\n\n\tinline void main ()\n\t{\n\t\tfor (int i = 1; i <= M; ++i) L[i] = read<int>() + 1, R[i] = read<int>() + 1;\n\t\twhile (Q--)\n\t\t{\n\t\t\tstatic char S[MAXN + 5];\n\t\t\tscanf(\"%s\", S + 1);\n\t\t\tint x = read<int>() + 1, y = read<int>() + 1;\n\n\t\t\tstatic int O[MAXN + 5], Len[MAXN + 5];\n\t\t\tSAM :: match (S, O, Len);\n\t\t\t\n//\t\t\tfor (int i = 1; i <= K; ++i) cout << O[i] << ' ' ; puts(\"\");\n\n\t\t\tLL ans = 0;\n\t\t\tfor (int i = x; i <= y; ++i)\n\t\t\t{\n\t\t\t\tint l = L[i], r = R[i];\n\t\t\t\tif (r - l + 1 > Len[r]) continue;\n\t\t\t\tint o = SAM :: get_anc (O[r], r - l + 1);\n//\t\t\t\tcout << l << ' ' << r << ' ' << o << ' ' << SAM :: node[o].maxlen << endl;\n\t\t\t\tans += SAM :: node[o].size;\n\t\t\t}\n\n\t\t\tprintf(\"%lld\\n\", ans);\n\t\t}\n\t}\n}\n\ninline void Solve ()\n{\n\tSAM :: build ();\n\tif (K <= LIM) S1 :: main ();\n\telse S2 :: main ();\n}\n\ninline void Input ()\n{\n\tN = read<int>(), M = read<int>(), Q = read<int>(), K = read<int>();\n\tscanf(\"%s\", S + 1);\n}\n\nint main ()\n{\n\n#ifdef hk_cnyali\n\tfreopen(\"A.in\", \"r\", stdin);\n\tfreopen(\"A.out\", \"w\", stdout);\n#endif\n\n\tInput ();\n\tSolve ();\n\n\treturn 0;\n}\n```\n\n\n\n","categories":["Problem"],"tags":["倍增","字符串","后缀自动机","根号平衡"]},{"title":"「十二省联考2019」字符串问题 - 后缀自动机 + 拓扑排序","url":"/2020/01/31/%E3%80%8C%E5%8D%81%E4%BA%8C%E7%9C%81%E8%81%94%E8%80%832019%E3%80%8D%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%97%AE%E9%A2%98-%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/","content":"\n给定一个字符串，从中取出若干个可能相交的子串，其中一些为$A$串，另一些为$B$串。并且给定若干个从$A$串连向$B$串的单向边\n\n规定，$A$串$A_i$到$A_j$之间有单向边当且仅当存在一个$B$串$B_k$，使得$A_i$与$B_k$相连，且$B_k$为$A_j$的前缀\n\n$A$串的串长为其价值，求最长链\n\n所有值不超过$2 \\times 10^5$\n\n<!--more-->\n\n### Link\n\n[LOJ3049](https://loj.ac/problem/3049)\n\n### Solution\n \n这题很明显就是要优化建边过程。而前缀关系很明显可以用`SAM`的`parent树`来优化建边\n\n具体来说，先对反串建`SAM`，那么`parent树`上一个节点**子树中的所有字符串**就都是**这个节点的字符串**的前缀了。原题中对所有前缀连边就可以只对一个点连边了\n\n但是直接这样做是有问题的，因为`SAM`的**一个节点**会代表很多个长度不等的串。如果在连边过程中，直接从长到短往下连边的话，可能会出现从$A$向$B$连边的情况\n\n显然，只要对每个节点包含的所有的$A/B$串排序，按`len`为第一关键字，`len`相同时$B$串在$A$串之前的顺序，再按如下方式连边即可：\n\n```cpp\nfor (int x = 1; x <= node_cnt; ++x)\n{\n\tsort (vec[x].begin(), vec[x].end());\n\n\tint pre = x;\n\tfor (int i = 0; i < vec[x].size(); ++i)\n\t{\n\t\tadd_edge (pre, vec[x][i].id);\n\t\tif (vec[x][i].is_a == 0) pre = vec[x][i].id;\n\t}\n\tlst[x] = pre;\n}\n```\n\n### Code\n\n```cpp\n#include <iostream>\n#include <ctime>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <climits>\n#include <queue>\n#include <set>\n#include <cmath>\n#include <map>\n#include <bitset>\n#include <fstream>\n#include <tr1/unordered_map>\n#include <assert.h>\n\n#define x first\n#define y second\n#define y0 Y0\n#define y1 Y1\n#define mp make_pair\n#define pb push_back\n#define DEBUG(x) cout << #x << \" = \" << x << endl;\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int MAXN = 2e5;\n\nchar S[MAXN + 5];\nint NA, NB, M;\nint node_cnt = 1;\n\nnamespace SAM\n{\n\tconst int MAXN = ::MAXN * 2;\n\n\tint O[MAXN + 5];\n\n\tstruct info\n\t{\n\t\tint ch[26], fa, maxlen;\n\t} node[MAXN + 5];\n\n\tint lst = 1;\n\n\tinline int new_node (int pre)\n\t{\n\t\tint o = ++node_cnt;\n\t\tnode[o].maxlen = node[pre].maxlen + 1;\n\t\treturn o;\n\t}\n\n\tinline int extend (int c)\n\t{\n\t\tint o = new_node (lst), pre = lst; lst = o;\n\n\t\tfor (; pre && !node[pre].ch[c]; pre = node[pre].fa) node[pre].ch[c] = o; \n\n\t\tif (!pre) node[o].fa = 1;\n\t\telse\n\t\t{\n\t\t\tint x = node[pre].ch[c];\n\t\t\tif (node[x].maxlen == node[pre].maxlen + 1) node[o].fa = x;\n\t\t\telse\n\t\t\t{\n\t\t\t\tint y = ++node_cnt; node[y] = node[x];\n\t\t\t\tnode[y].maxlen = node[pre].maxlen + 1;\n\t\t\t\tnode[x].fa = node[o].fa = y;\n\t\t\t\tfor (; node[pre].ch[c] == x; pre = node[pre].fa) node[pre].ch[c] = y;\n\t\t\t}\n\t\t}\n\n\t\treturn o;\n\t}\n\n\tconst int MAX_LOG = log2(MAXN);\n\t\n\tint anc[MAX_LOG + 1][MAXN + 5];\n\n\tinline void build ()\n\t{\n\t\tfor (int i = 1; i <= node_cnt; ++i) anc[0][i] = node[i].fa;\n\n\t\tfor (int i = 1; (1 << i) <= node_cnt; ++i)\n\t\t\tfor (int j = 1; j <= node_cnt; ++j)\n\t\t\t\tanc[i][j] = anc[i - 1][anc[i - 1][j]];\n\t}\n\n\tinline int get_anc (int x, int len)\n\t{\n\t\tfor (int i = MAX_LOG; i >= 0; --i) if (node[anc[i][x]].maxlen >= len) x = anc[i][x];\n\t\treturn x;\n\t}\n\n\tinline void init () \n\t{ \n\t\tlst = 1; \n\t\tfor (int i = 0; i <= min (MAXN, node_cnt); ++i)\n\t\t{\n\t\t\tnode[i].fa = node[i].maxlen = 0;\n\t\t\tfor (int j = 0; j < 26; ++j) node[i].ch[j] = 0;\n\t\t}\n\t}\n}\n\nusing SAM :: O;\n\nnamespace GRA\n{\n\tconst int MAXN = ::MAXN * 4;\n\n\tvector <int> G[MAXN + 5];\n\tint deg[MAXN + 5], Val[MAXN + 5];\n\tLL Dis[MAXN + 5];\n\n\tstruct point\n\t{\n\t\tint id, len, is_a;\n\n\t\tpoint (int _id = 0, int _len = 0, int _is_a = 0) { id = _id, len = _len, is_a = _is_a; }\n\n\t\tinline bool operator < (const point &rhs) const { return len == rhs.len ? is_a < rhs.is_a : len < rhs.len; }\n\t};\n\n\tvector <point> vec[MAXN + 5];\n\n\tinline void add_edge (int x, int y) { G[x].pb (y), ++deg[y]; }\n\n\tint lst[MAXN + 5];\n\n\tinline void build_edge ()\n\t{\n\t\tfor (int x = 1; x <= node_cnt; ++x)\n\t\t{\n\t\t\tsort (vec[x].begin(), vec[x].end());\n\n\t\t\tint pre = x;\n\t\t\tfor (int i = 0; i < vec[x].size(); ++i)\n\t\t\t{\n\t\t\t\tadd_edge (pre, vec[x][i].id);\n\t\t\t\tif (vec[x][i].is_a == 0) pre = vec[x][i].id;\n\t\t\t}\n\t\t\tlst[x] = pre;\n\t\t}\n\n\t\tfor (int i = 1; i <= min (SAM :: MAXN, node_cnt); ++i) if (SAM :: node[i].fa) add_edge (lst[SAM :: node[i].fa], i);\n\t}\n\n\tinline void top_sort ()\n\t{\n\t\tstatic queue <int> Q;\n\n\t\twhile (!Q.empty()) Q.pop();\n\t\tfor (int i = 1; i <= node_cnt; ++i) if (!deg[i]) Q.push (i), Dis[i] = Val[i];\n\n\t\tint cnt = 0;\n\t\tLL ans = 0;\n\t\twhile (!Q.empty())\n\t\t{\n\t\t\tint x = Q.front(); Q.pop(); ++cnt;\n\t\t\tChkmax (ans, Dis[x]);\n\n\t\t\tfor (int i = 0; i < G[x].size(); ++i)\n\t\t\t{\n\t\t\t\tint y = G[x][i];\n\t\t\t\tChkmax (Dis[y], Dis[x] + Val[y]);\n\t\t\t\tif (!(--deg[y])) Q.push (y);\n\t\t\t}\n\t\t}\n\n\t\tif (cnt != node_cnt) puts(\"-1\");\n\t\telse printf(\"%lld\\n\", ans);\n\t}\n\n\tinline void init ()\n\t{\n\t\tfor (int i = 0; i <= node_cnt; ++i)\n\t\t{\n\t\t\tlst[i] = deg[i] = Val[i] = Dis[i] = 0;\n\t\t\tvec[i].clear(), G[i].clear();\n\t\t}\n\t}\n}\n\ninline void Solve ()\n{\n\tGRA :: build_edge ();\n\tGRA :: top_sort ();\n}\n\ninline void Input ()\n{\n\tscanf(\"%s\", S + 1);\n\tfor (int i = strlen (S + 1); i >= 1; --i) O[i] = SAM :: extend (S[i] - 'a'); \n\tSAM :: build ();\n\n\tstatic int id[MAXN * 2 + 5];\n\n\tNA = read<int>(); \n\tfor (int i = 1; i <= NA; ++i)\n\t{\n\t\tint l = read<int>(), r = read<int>();\n\t\tint p = SAM :: get_anc (O[l], r - l + 1);\n\t\tGRA :: vec[p].pb (GRA :: point (id[i] = ++node_cnt, r - l + 1, 1));\n\t\tGRA :: Val[id[i]] = r - l + 1;\n\t}\n\n\tNB = read<int>(); for (int i = 1; i <= NB; ++i)\n\t{\n\t\tint l = read<int>(), r = read<int>();\n\t\tint p = SAM :: get_anc (O[l], r - l + 1);\n\t\tGRA :: vec[p].pb (GRA :: point (id[i + NA] = ++node_cnt, r - l + 1, 0));\n\t}\n\n\tM = read<int>();\n\twhile (M--)\n\t{\n\t\tint x = read<int>(), y = read<int>() + NA;\n\t\tGRA :: add_edge (id[x], id[y]);\n\t}\n}\n\ninline void Init ()\n{\n\tGRA :: init ();\n\tSAM :: init ();\n\tnode_cnt = 1;\n}\n\nint main ()\n{\n\n#ifdef hk_cnyali\n\tfreopen(\"string.in\", \"r\", stdin);\n\tfreopen(\"string.out\", \"w\", stdout);\n#endif\n\n\tint Te = read<int>();\n\n\twhile (Te--)\n\t{\n\t\tInput ();\n\t\tSolve ();\n\t\tInit ();\n\t}\n\n\treturn 0;\n}\n```\n","categories":["Problem"],"tags":["字符串","拓扑排序","后缀自动机"]},{"title":"「十二省联考2019」皮配 - 动态规划 + 背包","url":"/2020/01/31/%E3%80%8C%E5%8D%81%E4%BA%8C%E7%9C%81%E8%81%94%E8%80%832019%E3%80%8D%E7%9A%AE%E9%85%8D-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%83%8C%E5%8C%85/","content":" \n题面太长，不放了\n\n<!--more-->\n\n### Link\n\n[LOJ3051](https://loj.ac/problem/3051)\n\n### Solution\n\n按城市类型把学校排序（把处于相同城市的学校放在一起）之后就可以DP了。首先有两个部分分做法：\n\n* 算法一：$O(nm^2)$的暴力DP： \n\n\t$dp[i][c0][d0][0/1]$ 表示到第$i$个学校，在蓝阵营的有$c0$人，鸭派系的有$d0$人，且第$i$个学校在蓝/红阵营的方案数\n\n\t暴力枚举每个学校所处阵营和派系转移即可\n\t\n* 算法二：$k=0$ 的做法：\n\n\t注意到，只要分别确定了每个学校的所属派系，并且确定了每个城市的所属阵营，就能确定每个学校的导师了。并且这两部分是独立的，可以分别求出方案再相乘\n\n\t即设$f[i][j]$表示到第$i$个学校，处于鸭派系的有$j$人, $g[i][j]$表示到第$i$个城市，处于蓝阵营的有$j$人。直接背包转移即可\n\n\t这部分复杂度$O(nm)$\n\n---\n\n$k <= 30$，限制比较少，考虑把这两个做法结合起来。定义**坏学校**为有限制的学校，**坏城市**为`含有坏学校` 的城市；**好学校/好城市**反之\n\n比较暴力的想法是，对所有坏城市**中**的学校做`算法一`，对剩下来的学校和好城市做`算法二`，最后再合并(因为记录的状态是相同，所以可以直接合并)\n\n但是这样复杂度会很高，因为**坏城市**中可能还有**好学校**，它们被迫要在复杂度的劣的`算法一`中被计算（因为要和这个城市中的坏学校保持**阵营**一致）\n\n优化很简单，考虑在`算法一`的转移中把**阵营**和**派系**的转移拆开，先把坏城市中所有城市的**阵营**选好，再去选其中所有坏学校的**派系**，而其中的好学校的派系就可以放到`算法二`中去选择了。这样做就把这一部分好学校独立开了(因为其**阵营**已经被选好了)\n\n注意到最终拿到`算法一`中`d0`这一维不会超过`ks`，所以`算法一`部分的复杂度为$O(k^2sm)$\n\n总复杂度为 $O(k^2sm + nm)$，代码有点小长\n\n### Code\n```cpp\n#pragma GCC optimize(3)\n#include <iostream>\n#include <ctime>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <climits>\n#include <queue>\n#include <set>\n#include <cmath>\n#include <map>\n#include <bitset>\n#include <fstream>\n#include <tr1/unordered_map>\n#include <assert.h>\n\n#define x first\n#define y second\n#define y0 Y0\n#define y1 Y1\n#define mp make_pair\n#define pb push_back\n#define DEBUG(x) cout << #x << \" = \" << x << endl;\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int MOD = 998244353;\n\nnamespace MATH\n{\n\tinline void ADD (int &a, int b) { if ((a += b) >= MOD) a -= MOD; }\n\n\tinline int Pow (int a, int b)\n\t{\n\t\tint ans = 1;\n\t\tfor (int i = b; i; i >>= 1, a = (LL) a * a % MOD) if (i & 1) ans = (LL) ans * a % MOD;\n\t\treturn ans;\n\t}\n}\n\nusing namespace MATH;\n\nconst int MAXN = 1000;\nconst int MAXS = 600;\nconst int MAXM = 2500;\n\nint N, K;\nint C0, C1, D0, D1;\n\nint belong[MAXN + 5], size[MAXN + 5], ban[MAXN + 5], has_ban[MAXN + 5];\nvector <int> City[MAXN + 5];\n\nint A[MAXN + 5], B[MAXN + 5];\nint SA[MAXN + 5], SB[MAXN + 5];\nint f[MAXN + 5][MAXM + 5], g[MAXN + 5][MAXM + 5]; // f[i][j]: 到第 i 个学校, D0派系有 j 个人的方案数;  g[i][j]: 到第 i 个城市, C0阵营有 j 个人的方案数\nint prefix[2][MAXM + 5];\n\ninline void init_prefix ()\n{\n\tprefix[0][0] = f[N][0], prefix[1][0] = g[N][0];\n\tfor (int i = 1; i <= D0; ++i) prefix[0][i] = (prefix[0][i - 1] + f[N][i]) % MOD;\n\tfor (int i = 1; i <= C0; ++i) prefix[1][i] = (prefix[1][i - 1] + g[N][i]) % MOD;\n}\n\ninline int get_sum (int l, int r, int k)\n{\n\tif (l > r) return 0;\n\tif (l == 0) return prefix[k][r];\n\treturn (prefix[k][r] - prefix[k][l - 1] + MOD) % MOD;\n}\n\ninline void init_dp ()\n{\n\tfor (int i = 1; i <= N; ++i) SA[i] = SA[i - 1] + A[i];\n\tfor (int i = 1; i <= N; ++i) SB[i] = SB[i - 1] + B[i];\n\n\tf[0][0] = 1;\n\tfor (int i = 1; i <= N; ++i)\n\t{\n\t\tfor (int j = 0; j <= D0; ++j)\n\t\t{\n\t\t\tf[i][j] = f[i - 1][j];\n\t\t\tif (j >= A[i] && A[i] && ban[i] == -1) ADD (f[i][j], f[i - 1][j - A[i]]);\n\t\t}\n\t}\n\n\tg[0][0] = 1;\n\tfor (int i = 1; i <= N; ++i)\n\t{\n\t\tfor (int j = 0; j <= C0; ++j)\n\t\t{\n\t\t\tg[i][j] = g[i - 1][j];\n\t\t\tif (j >= B[i] && B[i] && has_ban[i] == 0) ADD (g[i][j], g[i - 1][j - B[i]]);\n\t\t}\n\t}\n\n\tinit_prefix ();\n}\n\nint S[MAXN + 5];\n\nint Dp[2][2][MAXM + 1][MAXS + 1];\npii key[MAXN + 5];\nint key_cnt;\n\ninline void Solve ()\n{\n\tinit_dp ();\n\n\tint lim = 0;\n\tfor (int i = 1; i <= N; ++i) if (has_ban[i])\n\t{\n\t\tkey[++key_cnt] = mp (-1, B[i]);\n\t\tfor (int j = 0; j < City[i].size(); ++j)\n\t\t{\n\t\t\tint x = City[i][j];\n\t\t\tif (ban[x] == -1) continue;\n\t\t\tkey[++key_cnt] = mp (ban[x], size[x]);\n\t\t\tlim += size[x];\n\t\t}\n\t}\n\n\tint n = key_cnt, LIM = min (lim, D0);\n\tDp[0][0][0][0] = 1;\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int c0 = 0; c0 <= C0; ++c0)\n\t\t\tfor (int d0 = 0; d0 <= LIM; ++d0)\n\t\t\t{\n#define now (i & 1)\n#define pre (!(i & 1))\n\t\t\t\tDp[0][now][c0][d0] = Dp[1][now][c0][d0] = 0;\n\t\t\t\tif (key[i].x == -1)\n\t\t\t\t{\n\t\t\t\t\tif (c0 >= key[i].y) Dp[0][now][c0][d0] = Dp[0][pre][c0 - key[i].y][d0] + Dp[1][pre][c0 - key[i].y][d0];\n\t\t\t\t\tDp[1][now][c0][d0] = Dp[0][pre][c0][d0] + Dp[1][pre][c0][d0];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (key[i].x != 0 && d0 >= key[i].y) Dp[0][now][c0][d0] += Dp[0][pre][c0][d0 - key[i].y];\n\t\t\t\t\tif (key[i].x != 1) Dp[0][now][c0][d0] += Dp[0][pre][c0][d0];\n\t\t\t\t\tif (key[i].x != 2 && d0 >= key[i].y) Dp[1][now][c0][d0] += Dp[1][pre][c0][d0 - key[i].y];\n\t\t\t\t\tif (key[i].x != 3) Dp[1][now][c0][d0] += Dp[1][pre][c0][d0];\n\t\t\t\t}\n\n\t\t\t\tif (Dp[0][now][c0][d0] >= MOD) Dp[0][now][c0][d0] -= MOD;\n\t\t\t\tif (Dp[1][now][c0][d0] >= MOD) Dp[1][now][c0][d0] -= MOD;\n\n//\t\t\t\tDEBUG (i);\n//\t\t\t\tcout << Dp[0][now][c0][d0] << ' ' << Dp[1][now][c0][d0] << endl;\n#undef now\n#undef pre\n\t\t\t}\n\n\tint ans = 0;\n\tfor (int c0 = 0; c0 <= C0; ++c0)\n\t\tfor (int d0 = 0; d0 <= LIM; ++d0)\n\t\t{\n\t\t\tint sum = (Dp[0][n & 1][c0][d0] + Dp[1][n & 1][c0][d0]) % MOD;\n\t\t\tint sum_d = get_sum (max (0, SA[N] - D1 - d0), D0 - d0, 0);\n\t\t\tint sum_c = get_sum (max (0, SA[N] - C1 - c0), C0 - c0, 1);\n\n\t\t\tADD (ans, (LL) sum * sum_c % MOD * sum_d % MOD);\n\t\t}\n\n\tcout << ans << endl;\n}\n\ninline void Input ()\n{\n\tN = read<int>(), read<int>();\n\tC0 = read<int>(), C1 = read<int>(), D0 = read<int>(), D1 = read<int>();\n\n\tfor (int i = 1; i <= N; ++i)\n\t{\n\t\tbelong[i] = read<int>(), size[i] = read<int>();\n\t\tA[i] = size[i], B[belong[i]] += size[i];\n\t\tCity[belong[i]].pb(i);\n\t}\n\n\tK = read<int>();\n\twhile (K--) \n\t{\n\t\tint x = read<int>(), p = read<int>();\n\t\tban[x] = p;\n\t\thas_ban[belong[x]] = 1;\n\t}\n}\n\ninline void Clear ()\n{\n\tfor (int i = 0; i < 2; ++i) for (int j = 0; j < 2; ++j)\n\t\tfor (int c0 = 0; c0 <= C0; ++c0)\n\t\t\tfor (int d0 = 0; d0 <= MAXS; ++d0)\n\t\t\t\tDp[j][i][c0][d0] = 0;\n\tfor (int i = 1; i <= N; ++i)\n\t{\n\t\tCity[i].clear(); \n\t\tB[i] = has_ban[i] = 0, ban[i] = -1;\n\t}\n\n\tkey_cnt = 0;\n}\n\ninline void Init ()\n{\n\tmemset (ban, -1, sizeof ban);\n}\n\nint main ()\n{\n\n\tfreopen(\"mentor.in\", \"r\", stdin);\n\tfreopen(\"mentor.out\", \"w\", stdout);\n\n\tint Te = read<int>();\n\n\tInit ();\n\twhile (Te--)\n\t{\n\t\tInput ();\n\t\tSolve ();\n\t\tClear ();\n\t}\n\n\treturn 0;\n}\n\n```\n","categories":["Problem"],"tags":["动态规划","背包","省选"]},{"title":"「Algorithm」后缀自动机复习","url":"/2020/01/29/%E3%80%8CAlgorithm%E3%80%8D%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%A4%8D%E4%B9%A0/","content":"\n`SAM`又忘得差不多了...\n\n<!--more-->\n\n## 构建\n\n> [yyb的这篇文章](https://www.cnblogs.com/cjyyb/p/8446205.html) 还写得挺好的\n\n[之前的笔记](https://hk-cnyali.com/2019/03/05/后缀自动机学习笔记)\n\n再举一个例子理解一下克隆节点的过程：\n\n![20-1-29-1](/images/20-1-29-1.jpg)\n\n## \n","categories":["Algorithm"],"tags":["字符串","后缀自动机"]},{"title":"「CF1287F」LCC - 概率和期望 + 动态DP","url":"/2020/01/28/%E3%80%8CCF1287F%E3%80%8DLCC-%E6%A6%82%E7%8E%87%E5%92%8C%E6%9C%9F%E6%9C%9B-%E5%8A%A8%E6%80%81DP/","content":"\n有$n$个粒子位于一个数轴上，第$i$个粒子都有$p_i$的概率往右移动，否则往左移动，并且初始位于坐标$x_i$处，其移动速度为$v_i$。问粒子第一次发生碰撞的期望时间，保证不存在坐标相同的两个粒子\n\n$n \\leq 10^5, -10^9 \\leq x \\leq 10^9, 1 \\leq v \\leq 10^6$\n\n<!--more-->\n\n### Link\n\n[CF1287F](https://codeforces.com/contest/1287/problem/F)\n\n### Solution\n\n能够发生第一次碰撞的粒子对，一开始肯定是**相邻**的，所以我们可以处理出所有**可能会发生的碰撞**的时间。\n\n考虑按时间排序后的第$i$种碰撞的情况，其发生的概率为$P($前$i-1$种碰撞均未发生且第$i$种碰撞发生$) = P($前$i-1$种碰撞均未发生$) - P($前$i$种碰撞均未发生$)$\n\n考虑对**所有的时刻**进行 $dp$，设$dp_{i,0/1}$表示考虑了前$i$个点，且第$i$个点往左/右时，在**当前时刻**之前没有发生碰撞的概率\n\n相当于是在对于时间维扫描线，随着时间的推移，需要动态禁止一些转移途径，直接`动态DP`即可\n\n> 具体实现可以看代码\n\n时间复杂度：$O(n \\times \\log n \\times 2^3)$\n\n### Code\n```cpp\n#include <iostream>\n#include <ctime>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <climits>\n#include <queue>\n#include <set>\n#include <cmath>\n#include <map>\n#include <bitset>\n#include <fstream>\n#include <tr1/unordered_map>\n#include <assert.h>\n\n#define x first\n#define y second\n#define y0 Y0\n#define y1 Y1\n#define mp make_pair\n#define pb push_back\n#define DEBUG(x) cout << #x << \" = \" << x << endl;\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef long double LD;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int MAXN = 1e5;\nconst int MOD = 998244353;\n\nnamespace MATH\n{\n\tinline void ADD (int &a, int b) { if ((a += b) >= MOD) a -= MOD; }\n\n\tinline int Pow (int a, int b)\n\t{\n\t\tint ans = 1;\n\t\tfor (int i = b; i; i >>= 1, a = (LL) a * a % MOD) if (i & 1) ans = (LL) ans * a % MOD;\n\t\treturn ans;\n\t}\n}\n\nusing namespace MATH;\n\nint N;\nstruct info\n{\n\tint x, v, p;\n\t\n\tinline void read () { x = ::read<int>(), v = ::read<int>(), p = (LL) ::read<int>() * Pow (100, MOD - 2) % MOD; }\n\n} A[MAXN + 5];\n\nstruct matrix // 右1左0\n{\n\tint A[2][2];\n\n\tinline matrix () { memset (A, 0, sizeof A); }\n\n\tinline int* operator [] (const int &x) { return A[x]; }\n\n\tinline matrix operator * (const matrix &rhs) const\n\t{\n\t\tmatrix now;\n\t\tfor (int i = 0; i < 2; ++i)\n\t\t\tfor (int k = 0; k < 2; ++k) if (A[i][k])\n\t\t\t\tfor (int j = 0; j < 2; ++j)\n\t\t\t\t\tADD (now.A[i][j], (LL) A[i][k] * rhs.A[k][j] % MOD);\n\t\treturn now;\n\t}\n};\n\nnamespace SEG\n{\n#define mid ((l + r) >> 1)\n#define ls o << 1\n#define rs o << 1 | 1\n#define lson ls, l, mid\n#define rson rs, mid + 1, r\n\tconst int MAX_NODE = MAXN * 4;\n\n\tmatrix node[MAX_NODE + 5];\n\n\tinline void push_up (int o) { node[o] = node[ls] * node[rs]; }\n\n\tinline void build (int o, int l, int r)\n\t{\n\t\tif (l == r)\n\t\t{\n\t\t\tint p = A[l].p;\n\t\t\tnode[o][0][0] = node[o][1][0] = (1 - p + MOD) % MOD;\n\t\t\tnode[o][0][1] = node[o][1][1] = p;\n\t\t\treturn ;\n\t\t}\n\t\tbuild (lson), build (rson);\n\t\tpush_up (o);\n\t}\n\n\tinline void modify (int o, int l, int r, int x, int s0, int s1)\n\t{\n\t\tif (l == r) { node[o][s0][s1] = 0; return ; }\n\t\tif (x <= mid) modify (lson, x, s0, s1);\n\t\telse modify (rson, x, s0, s1);\n\t\tpush_up (o);\n\t}\n\n\tinline int query () { return (node[1][0][0] + node[1][0][1]) % MOD; }\n\n#undef mid\n}\n\nstruct point\n{\n\tint x, s0, s1, t;\n\tLD tt;\n\n\tinline point (int _x = 0, int _s0 = 0, int _s1 = 0, int _t = 0, LD _tt = 0) { x = _x, s0 = _s0, s1 = _s1, t = _t, tt = _tt; }\n};\n\ninline int cmp_t (point a, point b) { return a.tt < b.tt; }\n\nvector <point> vec;\n\ninline void Init ()\n{\n\tfor (int i = 1; i < N; ++i)\n\t{\n\t\tinfo l = A[i], r = A[i + 1];\n\t\tif (l.p != 0 && r.p != 1) \n\t\t\tvec.pb (point (i + 1, 1, 0, (LL) (r.x - l.x) * Pow (l.v + r.v, MOD - 2) % MOD, (LD) (r.x - l.x) / (l.v + r.v)));\n\t\tif (l.p != 0 && r.p != 0 && l.v > r.v) \n\t\t\tvec.pb (point (i + 1, 1, 1, (LL) (r.x - l.x) * Pow (l.v - r.v, MOD - 2) % MOD, (LD) (r.x - l.x) / (l.v - r.v)));\n\t\tif (l.p != 1 && r.p != 1 && l.v < r.v) \n\t\t\tvec.pb (point (i + 1, 0, 0, (LL) (r.x - l.x) * Pow (r.v - l.v, MOD - 2) % MOD, (LD) (r.x - l.x) / (r.v - l.v)));\n\t}\n\n\tsort (vec.begin(), vec.end(), cmp_t);\n\n\tSEG :: build (1, 1, N);\n}\n\ninline void Solve ()\n{\n\tif (N == 1) return void (puts(\"0\"));\n\tInit ();\n\n\tint ans = 0, lst = 1;\n\tfor (int i = 0; i < vec.size(); ++i)\n\t{\n\t\tint x = vec[i].x, s0 = vec[i].s0, s1 = vec[i].s1, t = vec[i].t;\n\t\tSEG :: modify (1, 1, N, x, s0, s1);\n\t\tint p = (lst - SEG :: query () + MOD) % MOD;\n\t\tADD (ans, (LL) p * t % MOD);\n\t\tlst = SEG :: query ();\n\t}\n\n\tcout << ans << endl;\n}\n\ninline void Input ()\n{\n\tN = read<int>();\n\tfor (int i = 1; i <= N; ++i) A[i].read();\n}\n\nint main ()\n{\n\n#ifdef hk_cnyali\n\tfreopen(\"F.in\", \"r\", stdin);\n\tfreopen(\"F.out\", \"w\", stdout);\n#endif\n\n\tInput ();\n\tSolve ();\n\n\treturn 0;\n}\n```\n","categories":["Problem"],"tags":["Codeforces","动态规划","概率和期望","动态DP"]},{"title":"「CF1287E」Madhouse - 交互 + 构造","url":"/2020/01/28/%E3%80%8CCF1287E%E3%80%8DMadhouse-%E4%BA%A4%E4%BA%92-%E6%9E%84%E9%80%A0/","content":"\n**本题为交互题**\n\n有一个长度为$n$的字符串，你每次询问给定一对$(l, r)$，然后交互库会乱序给出区间$[l, r]$内所有子串的乱序。你最多可以询问$3$次，并且需要保证所有询问给出的串个数之和不能超过$\\lceil 0.777(n + 1)^2 \\rceil$\n\n你需要根据交互库给出的信息还原出原字符串\n\n$n \\leq 100$\n\n<!--more-->\n\n### Link\n\n[CF1287E](https://codeforces.com/contest/1287/problem/E2)\n\n### Solution\n\n因为乱序，所以先把所有得到的字符串，在读进来的时候直接$sort$一下\n\n先考虑一种比较暴力确定所有位置的方法: \n\n先询问$(1,n)$，然后询问$(1,n - 1)$，把第一次询问得到的字符串可重集去掉第二次询问得到的字符串可重集，那么剩下的一定就是原串的**每一个后缀**。根据这些后缀即可还原原串。但此时询问复杂度是$O(n^2)$的\n\n---\n\n对于正解做法，首先考虑对于给定串长的前一半执行上面的算法，得到这个字符串的前一半。再询问一次整个串，并统计出$cnt_{i,x}$表示所有长度为$i$的串中$x$字符出现的次数。\n\n不难发现当$i > \\lfloor \\frac{n}{2} \\rfloor$时，$cnt_{i,x} - cnt_{i + 1, x}$表示的就是$[n - i + 1, i]$中$x$字符出现的次数。\n\n从小到大依次考虑$i \\in [\\frac{n}{2} + 1, n]$，那么此时$[1,i-1]$中每一个位置的字符都已经确定了，所以就可以很轻松地确定位置$i$是什么字符了\n\n总询问复杂度：$O(2 \\times \\dfrac{(\\frac{n}{2})^2}{2} + \\frac{n^2}{2}) = O(\\frac{3}{4}n)$\n\n### Code\n```cpp\n#include <iostream>\n#include <ctime>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <climits>\n#include <queue>\n#include <set>\n#include <cmath>\n#include <map>\n#include <bitset>\n#include <fstream>\n#include <tr1/unordered_map>\n#include <assert.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n#define DEBUG(x) cout << #x << \" = \" << x << endl;\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int MAXN = 100;\n\nint N, M;\n\ninline void Query (int l, int r) { cout << \"? \" << l << ' ' << r << endl;  cout.flush(); }\n\nmap <string, int> Map;\nstring S, T;\nvector <string> vec;\n\ninline int cmp (string a, string b) { return a.size() < b.size(); }\n\ninline void solve_pre ()\n{\n\tQuery (1, M - 1);\n\tfor (int t = 1; t <= M * (M - 1) >> 1; ++t)\n\t{\n\t\tcin >> T;\n\t\tsort (T.begin(), T.end());\n\t\t++Map[T];\n\t}\n\n\tQuery (1, M);\n\tfor (int t = 1; t <= M * (M + 1) >> 1; ++t)\n\t{\n\t\tcin >> T;\n\t\tsort (T.begin(), T.end());\n\t\tif (Map[T]) --Map[T];\n\t\telse vec.pb (T);\n\t}\n\n\tsort (vec.begin(), vec.end(), cmp);\n\n\tstatic string suf;\n\tfor (int i = 0; i < vec.size(); ++i)\n\t{\n\t\tif (!i) suf.pb (vec[0][0]);\n\t\telse\n\t\t{\n\t\t\tstatic int bkt[30];\n\t\t\tfor (int j = 0; j < vec[i].size(); ++j) ++bkt[vec[i][j] - 'a'];\n\t\t\tfor (int j = 0; j < vec[i - 1].size(); ++j) --bkt[vec[i - 1][j] - 'a'];\n\t\t\tfor (int j = 0; j < 26; ++j) if (bkt[j])\n\t\t\t{\n\t\t\t\tbkt[j] = 0;\n\t\t\t\tsuf.pb ('a' + j);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treverse (suf.begin(), suf.end());\n\tS.pb ('0'); S += suf;\n}\n\nint cnt[MAXN + 5][MAXN + 5];\n\ninline void solve_suf ()\n{\n\tQuery (1, N);\n\tfor (int i = 1; i <= N * (N + 1) >> 1; ++i)\n\t{\n\t\tcin >> T;\n\t\tfor (int j = 0; j < T.size(); ++j) ++cnt[T.size()][T[j] - 'a'];\n\t}\n\n\tfor (int i = M + 1; i <= N; ++i)\n\t{\n\t\tfor (int j = N - i + 1; j < i; ++j) --cnt[i][S[j] - 'a'];\n\t\tfor (int j = 0; j < 26; ++j) if (cnt[i][j] - cnt[i + 1][j])\n\t\t{\n\t\t\tS.pb ('a' + j);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\ninline void Solve ()\n{\n\tif (N == 1)\n\t{\n\t\tQuery (1, 1);\n\t\tcin >> T;\n\t\tcout << \"! \" << T << endl;\n\t\treturn ;\n\t}\n\n\tsolve_pre ();\n\tsolve_suf ();\n\n\tcout << \"! \";\n\tfor (int i = 1; i <= N; ++i) printf(\"%c\", S[i]);\n\tfflush (stdout);\n}\n\ninline void Input ()\n{\n\tN = read<int>(), M = max (2, N >> 1);\n}\n\nint main ()\n{\n\n#ifdef hk_cnyali\n\tfreopen(\"E.in\", \"r\", stdin);\n\tfreopen(\"E.out\", \"w\", stdout);\n#endif\n\n\tInput ();\n\tSolve ();\n\n\treturn 0;\n}\n```\n","categories":["Problem"],"tags":["Codeforces","构造","交互"]},{"title":"「CF1293E」Xenon's Attack on the Gangs - 动态规划","url":"/2020/01/28/%E3%80%8CCF1293E%E3%80%8DXenon-s-Attack-on-the-Gangs-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","content":"\n给出一颗$n$个点的树，树上随机分配$0$到 $n-1$ 的边权，不存在权值相同的两条边。\n\n定义$mex(u,v)$为：树上$u$到$v$的简单路径中所有边权的$mex$。 求\n\n$$\n\\sum_{1\\leq u\\leq v\\leq n}mex(u,v)\n$$\n\n$n \\le 3000$\n\n<!--more-->\n\n### Link\n\n[CF1293E](https://codeforces.com/contest/1293/problem/E)\n\n### Solution\n\n考虑从小到大填入权值， 发现$mex$这个限制其实很紧，只要没经过$0$边的路径答案都是$0$，剩下路径中只要没经过$1$边的路径答案都是$1$$\\dots$\n\n即对答案产生贡献的边最后只会在一条链上，且一定是一段值域上的前缀，且每次在链的两段填入新的权值是更优的。\n\n考虑对每条链DP出答案，设$dp(x, y)$表示$(x, y)$这条链的答案，$size(x, y)$表示以$x$为根时$y$的$size$，$fa(x, y)$表示以$x$为根时$y$的父亲\n\n转移很简单：\n\n$$\ndp(x, y) = \\max \\{dp\\Big(fa(y, x), y\\Big), dp\\Big(x, fa(x, y)\\Big)\\} + size(x, y) * size(y, x)\n$$\n\n记忆化搜索实现\n\n### Code\n```cpp\n#include <iostream>\n#include <ctime>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <climits>\n#include <queue>\n#include <set>\n#include <cmath>\n#include <map>\n#include <bitset>\n#include <fstream>\n#include <tr1/unordered_map>\n#include <assert.h>\n\n#define x first\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n#define DEBUG(x) cout << #x << \" = \" << x << endl;\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int MAXN = 3000;\n\nint N, e, Begin[MAXN + 5], To[MAXN * 2 + 5], Next[MAXN * 2 + 5];\n\ninline void add_edge (int x, int y) { To[++e] = y; Next[e] = Begin[x]; Begin[x] = e; }\n\nint size[MAXN + 5][MAXN + 5], fa[MAXN + 5][MAXN + 5];\n\ninline void dfs (int x, int f, int s)\n{\n\tsize[s][x] = 1;\n\tfor (int i = Begin[x]; i; i = Next[i])\n\t{\n\t\tint y = To[i];\n\t\tif (y == f) continue;\n\t\tfa[s][y] = x;\n\t\tdfs (y, x, s);\n\t\tsize[s][x] += size[s][y];\n\t}\n}\n\nLL Dp[MAXN + 5][MAXN + 5];\n\ninline LL get_dp (int x, int y)\n{\n\tif (~Dp[x][y]) return Dp[x][y];\n\tif (!x || !y || x == y) return Dp[x][y] = 0;\n\tDp[x][y] = max (get_dp (fa[y][x], y), get_dp (x, fa[x][y])) + (LL) size[y][x] * size[x][y];\n\treturn Dp[x][y];\n}\n\ninline void Solve ()\n{\n\tmemset (Dp, -1, sizeof Dp);\n\tfor (int i = 1; i <= N; ++i) dfs (i, 0, i);\n\n\tLL ans = 0;\n\tfor (int i = 1; i <= N; ++i) for (int j = i + 1; j <= N; ++j) Chkmax (ans, get_dp (i, j));\n\tcout << ans << endl;\n}\n\ninline void Input ()\n{\n\tN = read<int>();\n\tfor (int i = 1; i < N; ++i)\n\t{\n\t\tint x = read<int>(), y = read<int>();\n\t\tadd_edge (x, y);\n\t\tadd_edge (y, x);\n\t}\n}\n\nint main ()\n{\n\n#ifdef hk_cnyali\n\tfreopen(\"E.in\", \"r\", stdin);\n\tfreopen(\"E.out\", \"w\", stdout);\n#endif\n\n\tInput ();\n\tSolve ();\n\n\treturn 0;\n}\n```\n","categories":["Problem"],"tags":["Codeforces","动态规划"]},{"title":"「1-17模拟赛」B. 小B的夏令营 - 动态规划 + 概率和期望","url":"/2020/01/28/%E3%80%8C1-17%E6%A8%A1%E6%8B%9F%E8%B5%9B%E3%80%8DB-%E5%B0%8FB%E7%9A%84%E5%A4%8F%E4%BB%A4%E8%90%A5-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%A6%82%E7%8E%87%E5%92%8C%E6%9C%9F%E6%9C%9B/","content":"","categories":["Problem"],"tags":["动态规划","概率和期望","hide"]},{"title":"「1-20模拟赛」C. 几何考试 - 概率和期望 + 差分","url":"/2020/01/28/%E3%80%8C1-20%E6%A8%A1%E6%8B%9F%E8%B5%9B%E3%80%8DC-%E5%87%A0%E4%BD%95%E8%80%83%E8%AF%95-%E6%A6%82%E7%8E%87%E5%92%8C%E6%9C%9F%E6%9C%9B-%E5%B7%AE%E5%88%86/","content":"","categories":["Problem"],"tags":["差分","概率和期望","hide"]},{"title":"「1-19模拟赛」C. 抓兔子 - 交互 + 二分","url":"/2020/01/20/%E3%80%8C1-19%E6%A8%A1%E6%8B%9F%E8%B5%9B%E3%80%8DC-%E6%8A%93%E5%85%94%E5%AD%90-%E4%BA%A4%E4%BA%92-%E4%BA%8C%E5%88%86/","content":"","categories":["Problem"],"tags":["二分","交互","hide"]},{"title":"「CF1284E」New Year and Castle Construction - 计算几何","url":"/2020/01/20/%E3%80%8CCF1284E%E3%80%8DNew-Year-and-Castle-Construction-%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/","content":"\n给出平面上$n$个点. 对于点$x$，定义$f(x)$为有多少个四边形(不要求凸)能把这个点包在内部\n\n求所有点的$f(x)$之和\n\n$n \\le 2500$\n\n<!--more-->\n\n### Link\n\n[CF1284E](https://codeforces.com/contest/1284/problem/E)\n\n### Solution\n\n先枚举$X$，然后计算$f(X)$\n\n考虑把$X$看做原点，把所有点按$X$的极角排序，统计**不满足条件**的四边形个数\n\n把不满足条件的四边形放在极角序最小的点$A$上统计，发现不合法的情况一定是，四边形上的所有点都在射线$AX$的上方，如图所示\n\n![20-1-20-1](/images/20-1-20-1.png)\n\n`two pointers`扫一下即可\n\n### Code\n```cpp\n#include <iostream>\n#include <ctime>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <climits>\n#include <queue>\n#include <set>\n#include <cmath>\n#include <map>\n#include <bitset>\n#include <fstream>\n#include <tr1/unordered_map>\n#include <assert.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n#define DEBUG(x) cout << #x << \" = \" << x << endl;\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int MAXN = 5000;\n\nint N;\npii A[MAXN + 5], P[MAXN + 5];\n\ninline int check (pii p)\n{\n\tif (p.x >= 0 && p.y >= 0) return 0;\n\tif (p.x < 0 && p.y >= 0) return 1;\n\tif (p.x < 0 && p.y < 0) return 2;\n\treturn 3;\n}\n\ninline LL cross (pii a, pii b) { return (LL) a.x * b.y - (LL) a.y * b.x; }\n\ninline int cmp (pii a, pii b)\n{\n\tif (check (a) == check (b)) return cross (a, b) > 0;\n\treturn check (a) < check (b);\n}\n\nLL ans;\n\ninline LL C3 (int x) { return (LL) x * (x - 1) * (x - 2) / 6; }\n\ninline void calc (int s)\n{\n\tint M = 0;\n\tfor (int i = 1; i <= N; ++i) if (i != s) P[++M] = mp (A[i].x - A[s].x, A[i].y - A[s].y);\n\tsort (P + 1, P + M + 1, cmp);\n\n\tfor (int i = 1; i <= M; ++i) P[i + M] = P[i];\n\n\tint p = 1;\n\tfor (int i = 1; i <= M; ++i)\n\t{\n\t\twhile (p < i + M && cross (P[i], P[p]) >= 0) ++p;\n\t\tint up = p - i - 1;\n\t\tif (up >= 3) ans -= (LL) C3 (up);\n\t}\n}\n\ninline void Solve ()\n{\n\tans = (LL) (LL)N * (N - 1) * (N - 2) * (N - 3) * (N - 4) / 24;\n\tfor (int i = 1; i <= N; ++i) calc (i);\n\tcout << ans << endl;\n}\n\ninline void Input ()\n{\n\tN = read<int>();\n\tfor (int i = 1; i <= N; ++i) A[i].x = read<int>(), A[i].y = read<int>();\n}\n\nint main ()\n{\n\n#ifdef hk_cnyali\n\tfreopen(\"E.in\", \"r\", stdin);\n\tfreopen(\"E.out\", \"w\", stdout);\n#endif\n\n\tInput ();\n\tSolve ();\n\n\treturn 0;\n}\n```\n","categories":["Problem"],"tags":["Codeforces","two pointers","计算几何","极角排序"]},{"title":"「1-19模拟赛」A. 分居 - 最短路 + 分类讨论","url":"/2020/01/20/%E3%80%8C1-19%E6%A8%A1%E6%8B%9F%E8%B5%9B%E3%80%8DA-%E5%88%86%E5%B1%85-%E6%9C%80%E7%9F%AD%E8%B7%AF-%E5%88%86%E7%B1%BB%E8%AE%A8%E8%AE%BA/","content":"","categories":["Problem"],"tags":["最短路","hide","分类讨论"]},{"title":"「Summary」1月集训","url":"/2020/01/18/%E3%80%8CSummary%E3%80%8D1%E6%9C%88%E9%9B%86%E8%AE%AD/","content":"","categories":["Summary"]},{"title":"「1-15模拟赛」A. yuyuko - FWT","url":"/2020/01/18/%E3%80%8C1-15%E6%A8%A1%E6%8B%9F%E8%B5%9B%E3%80%8DA-yuyuko-FWT/","content":"","categories":["Problem"],"tags":["FWT","hide"]},{"title":"「1-16模拟赛」B. 小B的环 - Hash","url":"/2020/01/18/%E3%80%8C1-16%E6%A8%A1%E6%8B%9F%E8%B5%9B%E3%80%8DB-%E5%B0%8FB%E7%9A%84%E7%8E%AF-Hash/","content":"","categories":["Problem"],"tags":["Hash","hide"]},{"title":"「1-16模拟赛」A. 小B的班级 - 构造 + 计数","url":"/2020/01/18/%E3%80%8C1-16%E6%A8%A1%E6%8B%9F%E8%B5%9B%E3%80%8DA-%E5%B0%8FB%E7%9A%84%E7%8F%AD%E7%BA%A7-%E6%9E%84%E9%80%A0-%E8%AE%A1%E6%95%B0/","content":"","categories":["Problem"],"tags":["构造","计数","hide"]},{"title":"「1-14模拟赛」A. 序列 - ST表 + 堆 + 贪心","url":"/2020/01/18/%E3%80%8C1-14%E6%A8%A1%E6%8B%9F%E8%B5%9B%E3%80%8DA-%E5%BA%8F%E5%88%97-ST%E8%A1%A8+%E5%A0%86+%E8%B4%AA%E5%BF%83/","content":"","categories":["Problem"],"tags":["堆","贪心","set","ST表","hide"]},{"title":"「1-13模拟赛」C. 生成树 - Matrix-Tree + 拉格朗日插值","url":"/2020/01/18/%E3%80%8C1-13%E6%A8%A1%E6%8B%9F%E8%B5%9B%E3%80%8DC-%E7%94%9F%E6%88%90%E6%A0%91-Matrix-Tree-%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC/","content":"","categories":["Problem"],"tags":["矩阵","Matrix-Tree","hide","拉格朗日插值","多项式"]},{"title":"「1-13模拟赛」B. 传送 - 树形DP","url":"/2020/01/13/%E3%80%8C1-13%E6%A8%A1%E6%8B%9F%E8%B5%9B%E3%80%8DB-%E4%BC%A0%E9%80%81-%E6%A0%91%E5%BD%A2DP/","content":"","categories":["Problem"],"tags":["动态规划","树形DP","hide"]},{"title":"「1-13模拟赛」A. 同桌与室友 - 图论 + 计数","url":"/2020/01/13/%E3%80%8C1-13%E6%A8%A1%E6%8B%9F%E8%B5%9B%E3%80%8DA-%E5%90%8C%E6%A1%8C%E4%B8%8E%E5%AE%A4%E5%8F%8B-%E5%9B%BE%E8%AE%BA-%E8%AE%A1%E6%95%B0/","content":"","categories":["Problem"],"tags":["计数","图论","hide"]},{"title":"「1-12模拟赛」C. 城市破坏 - 线段树分治 + 可撤销并查集","url":"/2020/01/12/%E3%80%8C1-12%E6%A8%A1%E6%8B%9F%E8%B5%9B%E3%80%8DC-%E5%9F%8E%E5%B8%82%E7%A0%B4%E5%9D%8F-%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%88%86%E6%B2%BB-%E5%8F%AF%E6%92%A4%E9%94%80%E5%B9%B6%E6%9F%A5%E9%9B%86/","content":"","categories":["Problem"],"tags":["数据结构","并查集","线性基","hide","线段树分治"]},{"title":"「CF1285F」Classical - 数论 + 栈","url":"/2020/01/12/%E3%80%8CCF1285F%E3%80%8DClassical-%E6%95%B0%E8%AE%BA-%E6%A0%88/","content":"\n给出一个长度为$n$的数组$a_i$, 求\n\n$$\n\\max\\limits_{1 \\le i < j \\le n} LCM(a_i,a_j)\n$$\n\n$n \\le 10^5, a_i \\le 10^5$\n\n<!--more-->\n\n### Link\n\n[CF1285H](https://codeforces.com/contest/1285/problem/F)\n\n### Pre-knowledge \n\n维护一个集合$S$，支持下列操作:\n\n1. 插入/删除一个数$x$\n\n2. 查询集合中与$x$互质的数有多少个\n\n每个操作的复杂度需均为$O\\Big(\\sigma_0(x)\\Big)$\n\n---\n\n化式子，查询即要求:\n\n$$\n\\begin{aligned}\n\n&\\sum_{y \\in S} [(x, y) == 1] \\\\\n\n= &\\sum_{y \\in S} \\sum_{d|x, d|y} \\mu(d)\\\\\n\n= &\\sum_{y \\in S} \\sum_{d|x} \\mu(d)\\cdot [d | y]\\\\\n\n= &\\sum_{d|x} \\mu(d)\\cdot \\sum_{y \\in S} [d | y]\\\\\n\n= &\\sum_{d|x} \\mu(d)\\cdot cnt(d)\\\\\n\n\\end{aligned}\n$$ \n\n其中$cnt(d)$表示集合中$d$的倍数的数的个数，显然$cnt(d)$可以在插入/删除时通过枚举约数维护，答案也可以直接枚举约数计算\n\n所有操作的复杂度均为$O\\Big(\\sigma_0(x)\\Big)$\n\n### Solution\n\n$\\displaystyle LCM(a_i, a_j) = \\frac{a_i a_j}{\\gcd (a_i, a_j)}$，显然枚举$g$，计算$(a_i, a_j) = g$的所有$i, j$中，$a_ia_j$的最大值\n\n首先可以$O(n \\ln n)$直接枚举$g$的所有倍数$x$，然后判断原序列中是否存在$x$。这样可以得到一个新的序列$b_i$，题目便转化为在$b$中找到一对$i, j$，使得$(b_i, b_j) = 1$，且$b_ib_j$最大\n\n> 考虑如何将 Pre-knowledge 中的数据结构派上用场\n\n将$b$数组降序排列，维护一个栈。设当前数字为 $x$ ，只要栈中存在与 $x$ 互质的数，就拿栈顶与 $x$ 的乘积更新 $ans$ ，然后弹掉栈顶，循环如此，最后把 $x$ 入栈。因为比 $x$ 更小的数乘上栈顶一定不优，而若栈顶与 $x$ 并不互质，这样得到的值也一定会被覆盖掉，所以正确性是对的。\n\n总复杂度$\\displaystyle O\\big(\\sum_{i=1}^{n}\\sigma_0^2(i)\\big)$\n\n### Code\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <climits>\n#include <queue>\n#include <set>\n#include <cmath>\n#include <map>\n#include <bitset>\n#include <fstream>\n#include <tr1/unordered_map>\n#include <assert.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n#define DEBUG(x) cout << #x << \" = \" << x << endl;\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int MAXN = 1e5;\n\nint N = MAXN, A[MAXN + 5], Mu[MAXN + 5];\n\nvector <int> G[MAXN + 5]; \n\ninline void Init ()\n{\n\tfor (int i = 1; i <= N; ++i) \n\t\tfor (int j = i; j <= N; j += i)\n\t\t\tG[j].pb (i);\n\n\tstatic bitset <MAXN + 5> Vis;\n\tstatic int prime[MAXN + 5];\n\n\tMu[1] = 1;\n\tfor (int i = 2; i <= N; ++i) \n\t{\n\t\tif (!Vis[i])\n\t\t{\n\t\t\tprime[++prime[0]] = i;\n\t\t\tMu[i] = -1;\n\t\t}\n\n\t\tfor (int j = 1; j <= prime[0] && (LL) i * prime[j] <= N; ++j)\n\t\t{\n\t\t\tVis[i * prime[j]] = 1;\n\t\t\tif (!(i % prime[j]))\n\t\t\t{\n\t\t\t\tMu[i * prime[j]] = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tMu[i * prime[j]] = -Mu[i];\n\t\t}\n\t}\n}\n\nnamespace DS\n{\n\tint cnt[MAXN + 5];\n\n\tinline void insert (int x) { for (int y : G[x]) ++cnt[y]; }\n\t\n\tinline void erase (int x) { for (int y : G[x]) --cnt[y]; }\n\n\tinline int query (int x)\n\t{\n\t\tint ans = 0;\n\t\tfor (int y : G[x]) ans += Mu[y] * cnt[y];\n\t\treturn ans;\n\t}\n}\n\nLL ans;\n\ninline void Solve ()\n{\n\tInit ();\n\t\n\tfor (int g = 1; g <= N; ++g)\n\t{\n\t\tstatic vector <int> vec; \n\t\tfor (int i = g; i <= N; i += g) if (A[i]) vec.pb (i / g);\n\n\t\tif (vec.size() == 0) continue;\n\n\t\tstatic int stk[MAXN + 5], top;\n\n\t\tfor (int i = vec.size() - 1; i >= 0; --i)\n\t\t{\n\t\t\twhile (top && DS :: query (vec[i])) Chkmax (ans, (LL) g * vec[i] * vec[stk[top]]), DS :: erase (vec[stk[top]]), --top;\n\t\t\tstk[++top] = i, DS :: insert (vec[i]);\n\t\t}\n\n\t\twhile (top) DS :: erase (vec[stk[top]]), --top;\n\t\tvec.clear();\n\t}\n\n\tcout << ans << endl;\n}\n\ninline void Input ()\n{\n\tint n = read<int>();\n\twhile (n--)\n\t{\n\t\tint x = read<int>();\n\t\tA[x] = 1;\n\t\tChkmax (ans, (LL) x);\n\t}\n}\n\nint main ()\n{\n\n#ifdef hk_cnyali\n\tfreopen(\"F.in\", \"r\", stdin);\n\tfreopen(\"F.out\", \"w\", stdout);\n#endif\n\n\tInput ();\n\tSolve ();\n\n\treturn 0;\n}\n\n\n```\n","categories":["Problem"],"tags":["Codeforces","数论","数据结构","栈"]},{"title":"「1-12模拟赛」B. 基因进化 - Hash + 栈","url":"/2020/01/12/%E3%80%8C1-12%E6%A8%A1%E6%8B%9F%E8%B5%9B%E3%80%8DB-%E5%9F%BA%E5%9B%A0%E8%BF%9B%E5%8C%96-Hash-%E6%A0%88/","content":"","categories":["Problem"],"tags":["数据结构","栈","Hash","字符串","hide"]},{"title":"「CF1270H」Number of Components - 线段树","url":"/2020/01/12/%E3%80%8CCF1270H%E3%80%8DNumber-of-Components-%E7%BA%BF%E6%AE%B5%E6%A0%91/","content":"\n给定一个长度为$n$的序列$a_i$，序列的每个位置对应着图上的一个点，点$i$与点$j$之间存在连边，当且仅当$i < j \\And a_i < a_j$。现在有$q$次修改操作，每次操作会修改某个位置上的值，你需要在每次修改之后回答图中有多少个联通块\n\n$n, q \\leq 5 \\times 10^5, a_i \\leq 10^6$\n\n<!--more-->\n\n### Link\n\n[CF1270H](https://codeforces.com/contest/1270/problem/H)\n\n### Solution\n\n不难发现，一个联通块一定是序列上的一段区间。即原序列被若干个分界点分成若干个联通块，且对于每个分界点，一定满足往前的前缀$min$不小于往后的后缀$max$。我们需要找到所有的分界点。\n\n但是不好直接在序列上进行维护，因为修改一个数字可以会修改很多连边，于是可以考虑每一种权值对答案的贡献。\n\n> 为了方便边界处理，首先设$a_0 = \\infty, a_{n + 1} = 0$。\n\n对于权值$x$而言，若把序列中所有$\\ge x$的数设为$1$，$< x$的数设为$0$，那么权值$x$是分界点当且仅当新序列**只存在一个$01$交界处**(即新序列形如$11111000$)\n\n考虑用线段树**对权值**维护一个函数$f(x)$，表示对于权值$x$而言，新序列$01$交界处的个数。显然只有当$f(x) = 1$的时候，该权值才会产生贡献。\n\n考虑如何处理修改。不难发现修改一个位置的值的时候，只需要考虑**和相邻两个位置大小关系**的变化，在线段树上对于$f(x)$区间加减就可以了，所以线段树每个节点维护的是$f(x)$等于当前区间$f(x)$最小值的**个数**\n\n需要注意只有在序列中出现了的权值需要考虑贡献，所以在线段树上还要维护一个是否存在的标记，以维护权值的出现和消失\n\n### Code\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <climits>\n#include <queue>\n#include <set>\n#include <cmath>\n#include <map>\n#include <bitset>\n#include <fstream>\n#include <tr1/unordered_map>\n#include <assert.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n#define DEBUG(x) cout << #x << \" = \" << x << endl;\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int MAXN = 5e5;\nconst int MAXM = 1e6 + 1;\n\nint N, Q;\nint A[MAXN + 5], times[MAXM + 5];\n\nnamespace SEG\n{\n#define mid ((l + r) >> 1)\n#define ls o << 1\n#define rs o << 1 | 1\n#define lson ls, l, mid\n#define rson rs, mid + 1, r\n\n\tconst int MAX_NODE = MAXM << 2;\n\n\tstruct info\n\t{\n\t\tint min, cnt, chk, tag;\n\n\t\tinfo (int _min = 0, int _cnt = 0, int _chk = 0, int _tag = 0) { min = _min, cnt = _cnt, chk = _chk, tag = _tag; }\n\n\t\tinline info operator + (const info &rhs) const\n\t\t{\n\t\t\tinfo o;\n\t\t\to.tag = 0;\n\t\t\to.min = min < rhs.min ? min : rhs.min;\n\n\t\t\tif (min < rhs.min) o.cnt = cnt;\n\t\t\telse if (min > rhs.min) o.cnt = rhs.cnt;\n\t\t\telse o.cnt = cnt + rhs.cnt;\n\n\t\t\treturn o;\n\t\t}\n\t\t\n\t} node[MAX_NODE + 5];\n\n\tinline void push_up (int o) { node[o] = node[ls] + node[rs]; }\n\n\tinline void push_down (int o)\n\t{\n\t\tint &tag = node[o].tag;\n\t\tif (!tag) return ;\n\t\tnode[ls].min += tag, node[ls].tag += tag;\n\t\tnode[rs].min += tag, node[rs].tag += tag;\n\t\ttag = 0;\n\t}\n\n\tinline void update (int o, int l, int r, int x, int y, int val)\n\t{\n\t\tif (x > y) return ;\n\t\tif (x <= l && r <= y)\n\t\t{\n\t\t\tnode[o].min += val, node[o].tag += val;\n\t\t\treturn ;\n\t\t}\n\n\t\tpush_down (o);\n\t\tif (x <= mid) update (lson, x, y, val);\n\t\tif (y > mid) update (rson, x, y, val);\n\n\t\tpush_up (o);\n\t}\n\n\tinline void insert (int o, int l, int r, int x)\n\t{\n\t\tif (l == r) return void (node[o].chk = node[o].cnt = 1);\n\t\tpush_down (o);\n\t\tif (x <= mid) insert (lson, x);\n\t\telse insert (rson, x);\n\t\tpush_up (o);\n\t}\n\n\tinline void erase (int o, int l, int r, int x)\n\t{\n\t\tif (l == r) return void (node[o].chk = node[o].cnt = 0);\n\t\tpush_down (o);\n\t\tif (x <= mid) erase (lson, x);\n\t\telse erase (rson, x);\n\t\tpush_up (o);\n\t}\n\n#undef mid\n}\n\ninline void Init ()\n{\n\tA[0] = MAXM, A[N + 1] = 0;\n\tfor (int i = 1; i <= N + 1; ++i) \n\t{\n\t\tint l = min (A[i], A[i - 1]) + 1, r = max (A[i], A[i - 1]);\n\t\tSEG :: update (1, 1, MAXM, l, r, 1);\n\t}\n\n\tfor (int i = 1; i <= N; ++i) ++times[A[i]], SEG :: insert (1, 1, MAXM, A[i]);\n}\n\ninline void Update (int l, int r, int val) { SEG :: update (1, 1, MAXM, l, r, val); }\n\ninline void Solve ()\n{\n\tInit ();\n\twhile (Q--)\n\t{\n\t\tint x = read<int>(), y = read<int>();\n\n\t\tUpdate (min (A[x], A[x - 1]) + 1, max (A[x], A[x - 1]), -1);\n\t\tUpdate (min (A[x], A[x + 1]) + 1, max (A[x], A[x + 1]), -1);\n\t\tUpdate (min (y, A[x - 1]) + 1, max (y, A[x - 1]), 1);\n\t\tUpdate (min (y, A[x + 1]) + 1, max (y, A[x + 1]), 1);\n\n\t\tif ((--times[A[x]]) == 0) SEG :: erase (1, 1, MAXM, A[x]);\n\t\tif ((++times[y]) == 1) SEG :: insert (1, 1, MAXM, y);\n\n\t\tA[x] = y;\n\n\t\tprintf(\"%d\\n\", SEG :: node[1].cnt);\n\t}\n}\n\ninline void Input ()\n{\n\tN = read<int>(), Q = read<int>();\n\tfor (int i = 1; i <= N; ++i) A[i] = read<int>();\n}\n\nint main ()\n{\n\n#ifdef hk_cnyali\n\tfreopen(\"H.in\", \"r\", stdin);\n\tfreopen(\"H.out\", \"w\", stdout);\n#endif\n\n\tInput ();\n\tSolve ();\n\n\treturn 0;\n}\n\n\n```\n","categories":["Problem"],"tags":["Codeforces","线段树","数据结构"]},{"title":"「Codeforces」Good Bye 2019","url":"/2020/01/12/%E3%80%8CCodeforces%E3%80%8DGood-Bye-2019/","content":"\n[CF1270](https://codeforces.com/contest/1270)\n\n<!--more-->\n\n## A. Card Game\n\n比较最大值即可\n\n## B. Interesting Subarray\n\n给出长度为$n$的序列$a_i$，问是否存在一个子区间$[l, r]$满足$\\max_{i=l}^{r} a_i - \\min_{i=l}^{r} a_i \\ge r - l + 1$\n\n$n \\le 2 * 10^5$\n\n---\n\n考场上写了个比较复杂的做法，实际上只需要检验所有相邻两个位置是否满足即可\n\n## C. Make Good\n\n给出一个长度为$n$的序列$a_i$，你需要在末尾添加$d(d \\le 3)$个数，使得$\\sum_{i=1}^{n+d} a_i = 2 * \\bigoplus_{i=1}^{n+d} a_i$\n\n$n \\le 10^5$\n\n---\n\n只需要添加一个数$X$. 设原序列的和为$S_1$，异或和为$S_2$\n\n乘二相当于二进制下左移一位，于是从低到高位考虑，若$S_1$该位上的值不等于$S_2$下一位上的值，则调整$X$，使得$S_2$的下一位变成$S_1$该位的值\n\n## D. Strange Device \n\n交互题.\n\n有一个长度为$n$的序列$a_i$，和参数$m, k$\n\n给出$n$和$k$，你可以向交互库询问一个大小为$k$的下标集合，交互库会返回这个下标集合中权值第$m$小的数的下标和权值\n\n用不超过$n$次询问求出$m$\n\n$1 \\le k < n \\le 500$\n\n---\n\n[交互]\n\n考场降智，没做出来\n\n询问$k+1$次，第$i$次询问$[1, i) \\cup (i, k+1]$这个集合。总共会返回两种不同的值，其中较大的那个值的出现次数就等于$m$\n\n证明略\n\n## E. Divide Points \n\n平面上 $n$ 个互不相同的点，要求分成两个非空集合，使得不存在一种点对之间的距离长度 $x$ 满足 $x$ 既可以被同一集合内的两个点连出，又可以被跨集合的两个点连出。\n\n$n \\le 10^{3}, -10^{6} \\le x_{i},y_{i} \\le 10^{6}$\n\n---\n\n[构造]\n\n考虑按 $x + y$ 的奇偶性分集合，显然能够满足题意。但是这样分出来不一定满足集合非空，于是考虑 $x + y$ 均为偶的情况怎么做。为奇的时候可以平移成为偶的情况。\n\n不断**旋转并缩小坐标系**，即 $(x, y) \\Rightarrow (\\frac{x+y}{2}, \\frac{x-y}{2})$ (类似于曼哈顿转切比雪夫距离)，再检查此时是否所有点 $x + y$ 的奇偶性相同。若不全相同则输出答案，否则继续旋转缩小。这样最终一定可以区分出两个集合。\n\n> 感性理解一下正确性\n> \n> 因为在旋转缩小坐标系时，一定是成比例缩小的，所以任意两个点的坐标一定不相同\n>\n> 但是如果无穷无尽地缩小的话，点坐标会越来越接近$(0, 0)$，会越来越趋近相等，所以会在相等前的那一次缩小被分出奇偶性\n\n## F. Awesome Substrings \n\n定义一个区间 $[l, r]$ 是好的，当且仅当$r - l + 1$ 是 $[l, r]$中$1$的个数的倍数\n\n给出一个长度为$n$的01串，统计好区间的个数\n\n$n \\le 200000$\n\n--- \n\n[根号平衡]\n\n考虑固定右端点$r$统计答案，若区间$[l + 1, r]$合法，则需要满足 $r - l = k \\cdot (sum_r - sum_l)$. $sum_i$表示前缀和数组\n\n发现要统计$l, k$这两维的信息，考虑根号平衡，设参数$T$\n\n1. 若 $k \\le T$:\n\n\t$l - k \\cdot sum_l = r - k \\cdot sum_r$. 枚举$k$，用个桶统计合法$l$的个数即可\n\n\t复杂度$O(n\\cdot T)$\n\n2. 若 $k > T$:\n\n\t$\\displaystyle sum_r - sum_l = \\frac{r - l}{k} \\le \\frac{n}{T}$. 枚举$sum_l$，则得到对应的$l$的范围，统计存在其中存在多少个合法$k$即可\n\n\t复杂度$O(n \\cdot \\frac{n}{T})$\n\n$T$取根号时最优，复杂度$O(n\\sqrt n)$\n\n## G. Subset with Zero Sum \n\n给出一个长度为$n$的序列$a_i$，满足$i - n \\le a_i \\le i - 1$\n\n找出一个下标集合$i_1, i_2 \\dots i_k$，满足$\\displaystyle a_{i_1} + a_{i_2} + \\dots + a_{i_k} = 0$\n\n$n \\le 10^6$\n\n---\n\n[构造] [思维]\n\n好巧妙的一道构造题.\n\n题目条件转化为 $1 \\le i - a_i \\le n$，即$i \\rightarrow (i - a_i)$会构成一棵基环内向树，考虑把环$i_1, i_2 \\dots i_k$提出来会发生什么\n\n$$\n\\begin{aligned}\n\ni_1 - a_{i_1} &= i_2 \\\\\n\ni_2 - a_{i_2} &= i_3 \\\\\n\n&\\vdots \\\\\n\ni_k - a_{i_k} &= i_1 \\\\\n\n\\end{aligned}\n$$\n\n把上述式子相加，发现 $\\displaystyle a_{i_1} + a_{i_2} + \\dots + a_{i_k} = 0$\n\n## H. Number of Components\n\n[「CF1270H」Number of Components - 线段树](http://hk-cnyali.com/2020/01/12/%E3%80%8CCF1270H%E3%80%8DNumber-of-Components-%E7%BA%BF%E6%AE%B5%E6%A0%91/)\n","categories":["Problem"],"tags":["Codeforces","构造","交互","思维","根号平衡"]},{"title":"「1-11模拟赛」A. 小D的奶牛 - 高维前缀和","url":"/2020/01/11/%E3%80%8C1-11%E6%A8%A1%E6%8B%9F%E8%B5%9B%E3%80%8DA-%E5%B0%8FD%E7%9A%84%E5%A5%B6%E7%89%9B-%E9%AB%98%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C/","content":"","categories":["Problem"],"tags":["meet in middle","状态压缩","hide","高维前缀和"]},{"title":"「Summary」THUWC2020游记","url":"/2019/12/24/%E3%80%8CSummary%E3%80%8DTHUWC2020%E6%B8%B8%E8%AE%B0/","content":"\n运气不错\n\n<!--more-->\n\n## Day1\n\n题意：\n\n### T1\n\n一开始有一个长为$k$的数组$a_i$\n\n$n$次操作，每次给出一个$p$和$b$数组(长为$k$)，若$b_p > a_p$，则用$b$替换掉$a$(整个数组的替换)\n\n$q$次询问，每次给出数组$a$，求最终得到的数组\n\n$n, q \\le 10^5, k \\le 20$\n\n### T2\n\n给出一张$n$个点$m$条边的有向图。每条边有权值$w_i$, 表示它被经过$w_i$次之后会消失\n\n$q$次**不独立**的操作，每次给出$x$和$d$。 从$x$开始，每次走其编号最小的出边，知道走了$d$步或无路可走。\n\n每次操作完后输出停在了哪个点\n\n$n, q \\le 10^5, m \\le 1.5 \\times 10^5, s \\le 10^9, w \\le 10^{18}$\n\n### T3\n\n给出一棵$n$个点的树，每条边长度为$1$，给定常数$X$\n\n$m$次询问，每次问编号$\\in[l, r]$的点构成了多少个联通块。两个点联通当且仅当它们的距离不超过$X$\n\n$n \\le 3 \\times 10^5, m \\le 6 \\times 10^5$\n\n---\n\n开考之后脑子不太清醒，感觉$T1$是思博题，但是没怎么想清楚就开始写，结果写了一个假做法，拍了半天才意识到有问题。最后写了线段树二分，前前后后总共花了一个多小时才过...\n\n然后去写了T2暴力，写完一交直接过了前三个包和倒数第二个包（pretest好水），然后写了一下$w = 10^{18}$和树的部分分。本来想写环套树的，想了想感觉有点麻烦就先看T3了\n\nT3看了好久题才看懂题意，然后自闭了，根本不会。写了一个裸暴力和$X = 299999$，加起来才8分。想$X = 299900$的部分分想了好久，只想到一个根号做法（考场降智），最后一个小时写了一下，根本跑不过\n\npretest分数165，垫底了\n\n## Day2\n\n题意：\n\n### T1\n\n给出$n$个函数，形如$a_i|x| + b_i x + c_i$ \n\n给出一开始$x$的值$s$，要你将这些函数重新排序，并按顺序复合后，把$s$代入函数中，使得结果尽量大，求这个最大值\n\n保证答案在`__int128`范围内\n\n$n, |a|, |b|, |c|, |s| \\le 15$\n\n### T2\n\n给出一个$n$个点$m$条边的`DAG`，保证$1$号点能到达其他每个点。把每个点的所有出边排序后dfs得到`DAG`的一棵以1为根的生成树\n\n$q$次询问，每次给出$a, b$，保证$a$在生成树上是$b$的祖先。问删除生成树上$a$到$b$的路径的所有边后，$b$子树内有多少个点不能从1号点出发到达\n\n$n, m, q \\le 10^5$\n\n### T3\n\n给你一棵$n$个点的点权树，点权构成为$n$的排列\n\n$m$次询问，每次给出$u, v, k$，问有多少个序列满足冒泡排序$k$轮后等于树上$(u, v)$这条路径上点权构成的序列\n\n$n, m, k\\le 5 \\times 10^5$\n\n---\n\n开场感觉$T1$是睿智状压，推了一会儿之后发现好像并不太好搞，有点慌。写了一个记正/负数最大最小值的乱搞状压，过了后三个包(pretest好水*2)，但是实在想不到正解怎么做，就套了个暴力和退火走人了\n\n先把T3的5分暴力写了，剩下时间基本都在搞T2。先写了20分暴力，感觉$m=n$的随便做，意识流写了一发，结果拍WA了。但是小数据都拍不出错，只好自己手动构造数据hack。考场上不太清醒，手玩的时候玩着玩着就忘记保证$m=n$了，然后以为根本不可做。第二档部分分也想了半天，无果。\n\n最后半个小时一直在打摆，玩了好久土豆OJ。F12的时候惊奇地发现可以把每道题的config调出来，点开T1的config看了一眼，发现最终测试数据中最后一个subtask居然有二十多个测试点，而pretest只有5个左右...\n\npretest分数125，又垫底了\n\n下午跟着[大哥](http://shinetism.cn/)清华里转了一圈，骑了44分钟的自行车，在咖啡厅聊了很久的天，还在食堂吃了饭。非常感谢大哥在即将期末考试的百忙之中还陪我溜达了一下午！\n\n## Day2+\n\n考了cache相关\n\nT1调了一个半小时，猜了几次终于把执行顺序猜对了\n\nT2很快写完了，但是T3的交互库玩了半天都没看懂什么意思，最后96分自闭了\n\n## Day3\n\n踩线苟进了面试，晚上准备了一下自我介绍，写了篇稿子\n\n早上在候场的时候特别紧张，进考场之后感觉三个老师都比较和善。自我介绍讲了比较长的时间，然后老师就抓着我的自我介绍问了很多问题。\n\n读了一篇关于图论的英语文章，恰好早上在准备的时候才翻到了一篇thuwc2018的游记说读了图论的文章，于是早上在Wikipedia搜了图论。感觉读得比较流畅，只有一个很长的副词不太认识，卡了半天。翻译的时候看左边的老师一直在点头233\n\n问了一点专业性的问题，形如“你以后想从事计算机哪个方面的工作”, “你了解些什么计算机相关的前沿科技”\n\n估计是自我介绍时间太长，问完这个问题就时间到了。没有问到数学问题，自我感觉良好\n\n---\n\n最后苟到了一等奖，居然靠面试翻盘了。jwb、hh、初三的zzm也拿了一等，cxr二等，xhb和csy三等。北大那边gc拿了二等(好可惜，差一点就一等了) 不过这次的奖似乎发得前所未有的多，一等奖也很多，可能以后真的没有大幅度的降分了吧\n\n## Summary\n\n这次THUWC算是吃了一颗定心丸，但更重要的还是之后的省选。况且这次考试还是脑子犯浑，丢了很多不该丢的分(D1T2的环套树，D1T3的$X=299900$，D2T2的$m=n$，包括D1T1浪费了太长时间)，如果不是因为这次约发得多，我可能连进面试的机会都没有。以后决不能再犯这样的低级错误了\n\n接下来的时间，要尽快把省选知识点补完，多做题，提高思维能力。希望今年省选不要留下遗憾吧！\n","categories":["Summary"],"tags":["Summary","OI历程"]},{"title":"「XJOI1343」A. 不知道 unknow - 树链剖分 + 李超线段树 + 分块 + 凸包","url":"/2019/12/18/%E3%80%8CXJOI1343%E3%80%8DA-%E4%B8%8D%E7%9F%A5%E9%81%93-unknow-%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86-%E6%9D%8E%E8%B6%85%E7%BA%BF%E6%AE%B5%E6%A0%91-%E5%88%86%E5%9D%97-%E5%87%B8%E5%8C%85/","content":"","categories":["Problem"],"tags":["分块","树链剖分","李超线段树","hide","凸包"]},{"title":"「XJOI1345」B. 平面图 planar - 对偶图 + 并查集 + 启发式分裂","url":"/2019/12/18/%E3%80%8CXJOI1345%E3%80%8DB-%E5%B9%B3%E9%9D%A2%E5%9B%BE-planar-%E5%AF%B9%E5%81%B6%E5%9B%BE-%E5%B9%B6%E6%9F%A5%E9%9B%86-%E5%90%AF%E5%8F%91%E5%BC%8F%E5%88%86%E8%A3%82/","content":"","categories":["Problem"],"tags":["并查集","对偶图","hide","平面图","启发式分裂"]},{"title":"「XJOI1345」A. GCD和LCM gcdlcm - 整除分块 + 树状数组","url":"/2019/12/17/%E3%80%8CXJOI1345%E3%80%8DA-GCD%E5%92%8CLCM-gcdlcm-%E6%95%B4%E9%99%A4%E5%88%86%E5%9D%97-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/","content":"","categories":["Problem"],"tags":["数论","树状数组","整除分块","hide"]},{"title":"「XJOI1341」C. 浑水摸鱼 waterflow - Hash + 主席树","url":"/2019/12/16/%E3%80%8CXJOI1341%E3%80%8DC-%E6%B5%91%E6%B0%B4%E6%91%B8%E9%B1%BC-waterflow-Hash+%E4%B8%BB%E5%B8%AD%E6%A0%91/","content":"","categories":["Problem"],"tags":["主席树","Hash","hide"]},{"title":"「XJOI1337」C. 毛皮立方体 furcube - 二分图 + ex_gcd + 补图bfs","url":"/2019/12/16/%E3%80%8CXJOI1337%E3%80%8DC-%E6%AF%9B%E7%9A%AE%E7%AB%8B%E6%96%B9%E4%BD%93-furcube-%E4%BA%8C%E5%88%86%E5%9B%BE-ex-gcd-%E8%A1%A5%E5%9B%BEbfs/","content":"","categories":["Problem"],"tags":["二分图","ex_gcd","hide","补图bfs"]},{"title":"「XJOI1342」A. 矩阵 matrix - 线性基 + 贪心","url":"/2019/12/10/%E3%80%8CXJOI1342%E3%80%8DA-%E7%9F%A9%E9%98%B5-matrix-%E7%BA%BF%E6%80%A7%E5%9F%BA-%E8%B4%AA%E5%BF%83/","content":"","categories":["Problem"],"tags":["贪心","线性基","hide"]},{"title":"「Summary」12月集训","url":"/2019/12/10/%E3%80%8CSummary%E3%80%8D12%E6%9C%88%E9%9B%86%E8%AE%AD/","content":"\n### 12-6\n\n#### [A. APPLE buSinEss](http://hk-cnyali.com/2019/12/10/%E3%80%8CXJOI1337%E3%80%8DA-APPLE-buSinEss-Hall%E5%AE%9A%E7%90%86-%E6%A0%91%E5%BD%A2DP/)\n\n[Hall定理] [树形DP]\n\n---\n\n#### [C. 毛皮立方体](https://hk-cnyali.com/2019/12/16/%E3%80%8CXJOI1337%E3%80%8DC-%E6%AF%9B%E7%9A%AE%E7%AB%8B%E6%96%B9%E4%BD%93-furcube-%E4%BA%8C%E5%88%86%E5%9B%BE-ex-gcd-%E8%A1%A5%E5%9B%BEbfs/)\n\n[ex_gcd] [二分图] [补图bfs]\n\n---\n\n### 12-7\n\n#### [C. 鱼和熊掌不可兼得](http://hk-cnyali.com/2019/12/10/%E3%80%8CXJOI1338%E3%80%8DC-%E9%B1%BC%E5%92%8C%E7%86%8A%E6%8E%8C%E4%B8%8D%E5%8F%AF%E5%85%BC%E5%BE%97-Game-%E4%BA%A4%E4%BA%92-%E6%9E%84%E9%80%A0-%E6%80%9D%E7%BB%B4-%E5%88%86%E6%B2%BB/)\n\n[交互] [构造] [思维] [分治]\n\n---\n\n### 12-8\n\n#### [A. 鱼死网破](https://hk-cnyali.com/2019/12/09/%E3%80%8CXJOI1341%E3%80%8DA-%E9%B1%BC%E6%AD%BB%E7%BD%91%E7%A0%B4-clash-%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95-%E4%BA%8C%E5%88%86-%E6%80%9D%E7%BB%B4/)\n\n[计算几何] [二分] [思维]\n\n---\n\n#### [C. 浑水摸鱼](https://hk-cnyali.com/2019/12/16/%E3%80%8CXJOI1341%E3%80%8DC-%E6%B5%91%E6%B0%B4%E6%91%B8%E9%B1%BC-waterflow-Hash+%E4%B8%BB%E5%B8%AD%E6%A0%91/)\n\n[Hash] [主席树] [数据结构]\n\n---\n\n### 12-9\n\n#### [A. 矩阵](http://hk-cnyali.com/2019/12/10/%E3%80%8CXJOI1342%E3%80%8DA-%E7%9F%A9%E9%98%B5-matrix-%E7%BA%BF%E6%80%A7%E5%9F%BA-%E8%B4%AA%E5%BF%83/)\n\n[线性基] [贪心]\n\n---\n\n### 12-11\n\n#### [A. 不知道](https://hk-cnyali.com/2019/12/18/%E3%80%8CXJOI1343%E3%80%8DA-%E4%B8%8D%E7%9F%A5%E9%81%93-unknow-%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86-%E6%9D%8E%E8%B6%85%E7%BA%BF%E6%AE%B5%E6%A0%91-%E5%88%86%E5%9D%97-%E5%87%B8%E5%8C%85/)\n\n[树链剖分] [李超线段树] [分块] [凸包] [数据结构]\n\n---\n\n### 12-13\n\n#### [A. GCD和LCM](https://hk-cnyali.com/2019/12/17/%E3%80%8CXJOI1345%E3%80%8DA-GCD%E5%92%8CLCM-gcdlcm-%E6%95%B4%E9%99%A4%E5%88%86%E5%9D%97-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/)\n\n[整除分块] [树状数组]\n\n---\n\n#### [B. 平面图](https://hk-cnyali.com/2019/12/18/%E3%80%8CXJOI1345%E3%80%8DB-%E5%B9%B3%E9%9D%A2%E5%9B%BE-planar-%E5%AF%B9%E5%81%B6%E5%9B%BE-%E5%B9%B6%E6%9F%A5%E9%9B%86-%E5%90%AF%E5%8F%91%E5%BC%8F%E5%88%86%E8%A3%82/)\n\n[对偶图] [平面图] [并查集] [启发式分裂]\n\n---\n\n","categories":["Summary"]},{"title":"「XJOI1338」C. 鱼和熊掌不可兼得 game - 交互 + 构造 + 思维 + 分治","url":"/2019/12/10/%E3%80%8CXJOI1338%E3%80%8DC-%E9%B1%BC%E5%92%8C%E7%86%8A%E6%8E%8C%E4%B8%8D%E5%8F%AF%E5%85%BC%E5%BE%97-Game-%E4%BA%A4%E4%BA%92-%E6%9E%84%E9%80%A0-%E6%80%9D%E7%BB%B4-%E5%88%86%E6%B2%BB/","content":"","categories":["Problem"],"tags":["构造","分治","交互","hide","思维"]},{"title":"「XJOI1337」A. APPLE buSinEss - Hall定理 + 树形DP","url":"/2019/12/10/%E3%80%8CXJOI1337%E3%80%8DA-APPLE-buSinEss-Hall%E5%AE%9A%E7%90%86-%E6%A0%91%E5%BD%A2DP/","content":"","categories":["Problem"],"tags":["动态规划","树形DP","hide","Hall定理"]},{"title":"「XJOI1341」A. 鱼死网破 clash - 计算几何 + 二分 + 思维","url":"/2019/12/09/%E3%80%8CXJOI1341%E3%80%8DA-%E9%B1%BC%E6%AD%BB%E7%BD%91%E7%A0%B4-clash-%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95-%E4%BA%8C%E5%88%86-%E6%80%9D%E7%BB%B4/","content":"","categories":["Problem"],"tags":["二分","计算几何","模拟","hide","思维"]},{"title":"2019年11月","url":"/2019/11/02/2019%E5%B9%B411%E6%9C%88/","content":"\n[Summary]\n\n11月搞颓记录\n\n<!--more-->\n\n## 11-2\n\n### Process\n\n现在是下午16:15 今天三道题都不难\n\n### T1\n\n[贪心]\n\n直接贪心，每次看当前最小的 + 最大的是否 $\\le k$ ，如果是则放两个最小的，否则就放最小的和最大的。正确性显然\n\n### T2\n\n[kruskal重构树]\n\n建kruskal重构树，在树上找到子树中最小的 $b$ 去更新答案即可\n\n### T3\n\n[动态规划]  [背包]\n\n直接dp，设 $dp[i][j]$ 在 $i$ 子树选了 $j$ 个的答案，树上背包转移即可\n\n## 11-3\n\n搞不动\n\n## 11-4\n\n### Process\n\n状态不好，什么都想不清\n\n### T1\n\n[子集和DP]\n\n![19-11-5-1](/images/19-11-5-1.png)\n\n### T2\n\n题意写得*一样\n\n直接算两边的总方案减去不合法方案，再乘起来即可\n\n### T3\n\n[动态规划]\n\n简单 DP ，设 $dp[i]$ 表示冻住前 $i$ 长度的最小代价。可以用线段树维护区间最小值做到 $O(n \\log n)$\n\n显然这个 DP 数组是单调不降的，于是只要找到最靠前的，能转移到它的位置往它转移就行了，随便搞下就能 $O(n)$ 了\n\n## 11-5\n\n### Process\n\n随便写了个T3，T1T2都不会做\n\n### T1\n\n[动态规划] [DP优化]\n\n状态形如若干个段，每个段都满足 $sum(l, r) = r - l + 1$\n\n射击的顺序与答案没有关系，那么可以从左往右考虑，设 $f[i]$ 表示最右边的段以 $i$ 为右端点时的方案数，有转移：\n\n$$\nf[i] = \\sum_{j, sum(i, j) = i - j} \\sum_{sum (j - k, j) = 0} f[j - k - 1]\n$$\n\n> 后面那个 $\\sum$ 是因为 $j$ 前面那些空的位置实际上都能作为合法的左端点\n\n因为 $sum(i, j) = i - j$ 可以拆成 $sum (1, i) - i = sum (1, j) - j$ ，所以用桶记录就能做到 $O(1)$ 转移\n\n### T2\n\n[概率和期望] [方差] \n\n容易发现实际上每一个结点只会在最后一次涉及到它的操作中被影响到，考虑把每一次染色的操作看做是把 x 与它相邻的结点从原所属块中拎出来放在同一个块内，那么最后只要对每一个块分别去考虑即可，并且注意到，块与块之间是不会互相影响的。\n\n用 $c_{i}$ 表示第 i 个块的大小，w 表示白色结点个数，那么推式子得到：\n\n$$\n\\begin{aligned}\nD(w) &= E(w^{2}) - E^{2}(w) \\\\\n&= E( \\sum c_{i}^{2} + \\sum_{i!=j} c_{i} c_{j} ) - (\\sum pc_{i})^{2} \\\\\n\\end{aligned}\n$$\n\n注意 $E(\\sum c_{i}^{2}) = \\sum p c_{i}^{2}$ 而不是 $\\sum (pc_{i})^{2}$ ，继续推式子得到\n\n$$\nD(w) = \\sum c_{i}^{2} (p - p^{2})\n$$\n\n那么只需要维护 $\\sum c_{i}^{2}$ 即可。这个时候就可以 $O(n^{2})$ 做了，即每次暴力把与 x 及与其相邻的结点从所属块中拎出来。\n \n考虑优化，动态维护 $\\sum c_{i}^{2}$。 把一次操作看成给它周围的边定向，即一开始每条边全都无向，对 $x$ 操作就是将与 $x$ 相邻的点都指向它\n\n对每个点维护一个 vector, 记录所有它相邻，且未指向它 (包括未定向或指出去) 的点的集合。每次只需要动态更新这些点的 $c^2$ 即可\n\n复杂度是均摊 $O(n\\log n)$ 的\n\n```cpp\n\ninline void update (int x, int d)\n{\n\tADD (ans, MOD - (LL) size[x] * size[x] % MOD);\n\tsize[x] += d;\n\tADD (ans, (LL) size[x] * size[x] % MOD);\n}\n\ninline void Solve ()\n{\n\tP = (P - (LL) P * P % MOD + MOD) % MOD;\n\n\twhile (Q--)\n\t{\n\t\tint op = read<int>();\n\t\tif (op == 1)\n\t\t{\n\t\t\tint x = read<int>();\n\n\t\t\tfor (int i = 0; i < G[x].size(); ++i)\n\t\t\t{\n\t\t\t\tint y = G[x][i];\n\t\t\t\tif (col[y]) update (col[y], -1), G[col[y]].pb (y);\n\t\t\t\tcol[y] = x, update (col[y], 1);\n\t\t\t}\n\n\t\t\tG[x].clear ();\n\t\t}\n\t\telse printf(\"%lld\\n\", (LL) P * ans % MOD);\n\t}\n}\n```\n\n### expr\n\n直接模拟即可\n\n## 11-7\n\n### Process\n\n又是搞一上午T1，太菜了\n\n### T1\n\n[数学] \n\n因为所有可以被表示出来的数 num ，总满足 $\\exists ~ i \\in [0,a-1] , num - ib \\equiv 0 \\pmod p$ 。所以对于模 a 等于 x 的所有数而言，不能被表示出来的数一定是**一段前缀**。\n\n于是可以对 $x \\in [0, a-1]$ 找到最小的 $p$ 满足对于当 $num \\equiv x \\pmod a$ 且 $num \\ge pa$ 时，num 都能够被表示，然后差分标记，每次计算一个长为 a 的段内，不能表示出来的数的数量即可 $O(a+b)$ 计算答案。\n\n考虑优化，发现贡献不同的段实际上最多只有 a 个，所以可以一次性把它们全部计算，就能 $O(a)$ 做了。\n\n### T2\n\n[概率和期望] [构造] [贪心]\n\n看到这个题可能直觉会想到一个做法：选一个 x ，把 $< x$ 的全部修改为 x。除此之外，还存在一种方案：保持原来的最小值最小，其它的至少都比最小值大 1 ，这样转只可能转出这些最小值，获得更大的收益。\n\n因为有 37 个盘而倍数为 36 ，所以按下注金大小轮流考虑，在不超过下一个大小的值时下注金一定越多越好。\n\n详见代码。\n\n### T3\n\n[二分答案] [最短路] [贪心]\n\n二分答案，问题转化为判断一个前缀是否可以是最短路。\n\n首先这个前缀的边肯定是最小值，而其它边可能是最大值。\n\n考虑两个人同时从起点到终点，第一个人一定走这个前缀，通过控制边权使得第一个人不比第 二个人慢。很容易想到第一个人跑一条边就设为最小值，第二个人跑就设为最大值，但是这样可能会两个人同时经过一条边的情况。\n\n注意到如果其中一个人先走一条边，另一个人后走，那么后走的人肯定追不上先走的了。于是可以把边权按照先到的是第一个人还是第二个人来决定。由于第一个人只要不比第二个人晚到就可以，可以给第一个人的最短路长度 −0.5 来避免同时到。\n\n具体而言，把边权翻倍并初始化 dis(1)=1 ，确定当前前缀的边权最小，然后初始化前缀末尾的 dis ，然后做 dijkstra ，这样就可以通过当前 dis 是奇还是偶来判断是谁先到达的了。注意理解除去前缀末尾，其余的点都不能初始化 dis ，否则可能会错误地用其更新到 dis(2) ，达不到强制第一个人走前缀的效果。\n\n## 11-8\n\n### Process\n\nT1总共花了50分钟，T2想 $O(n*k^2)$ 做法想了很久，T3写完暴力后想到了答案序列一定形如 $2^x3^y$ 但是来不及写了\n\n### T1\n\n[树状数组] [计数]\n\n发现就是要对每条连接$x$和儿子$y$的边$(x, y)$，求出$y$子树内有多少个点的编号大小比$y$大\n\n把子树转化成祖先，树状数组统计答案即可\n\n### T2\n\n[概率和期望] [组合数学] [树形DP] [背包]\n\n统计方案数，考虑每个联通块的贡献，一个大小为 $x$ 的联通块对第$k$次询问的贡献就是 $x^k$\n\n我考场上的$O(nk^2)$的做法就是直接维护这个答案，设$f[x][i]$表示$x$子树内，所有包含$x$的联通块的$x^i$之和\n\n树上背包，考虑一个大小为$a$的联通块和一个大小为$b$的联通块如何合并，显然合并之后对答案的贡献就是 $(a + b) ^ i$ \n\n暴力直接二项式展开，即 $\\sum_{j = 0} ^ i a^jb^{i - j}$，于是可以利用已经计算好的$f[][j]$和$f[][i-j]$相乘来计算答案了\n\n---\n\n下面是$O(nk)$的正解\n\n考虑用经典组合式子把$x^k$拆开\n\n$$\n\\begin{aligned}\nx^k &=\\sum_{i=0} ^{k} {k \\brace i} * i! * \\binom{x}{i} \\\\\nans_k&=\\sum_{i=0} ^{k} {k \\brace i} * i! * \\Big(\\sum \\binom{x}{i}\\Big)\n\\end{aligned}\n$$\n\n> 看成球盒问题，枚举空盒个数，[具体见此](https://hk-cnyali.com/2019/08/22/%E3%80%8CAlgorithm%E3%80%8D%E6%94%BE%E7%90%83%E9%97%AE%E9%A2%98/)\n\n\n那么我们只需要对于每个$i\\in[0, k]$快速计算 $\\displaystyle \\Big(\\sum \\binom{x}{i}\\Big)$ 即可。注意到此时我们已经将限制变得更加严格，现在选出来的$i$个关键点必须是互不相同的，可以直接通过树上背包DP计算得到。这样做 DP 的话第二维就能对$size$取min了，复杂度是$O(nk)$的\n\n### T3\n\n显然第一个数一定形如$2^x$或$2^x3$，那么就很好 DP 了。\n\n设 $f[i][x][y]$ 表示填到第 $i$ 个数，前$i$个数的$gcd$ 为$2^x3^y$的方案数（$x\\in[0, \\log n], y\\in [0, 1]$）转移很简单，见代码\n\n## 11-9\n\n### Process \n\n40分钟把T1T3写完了，然后T2一开始写了一个假做法，因为时间比较充裕，所以有足够时间重新想做法，最后还是过了\n\n题解不想写了\n\n## 11-10\n\n两道期望一道概率\n\n## 11-11\n\n### Process\n\n三道计数，T2T3都很简单，T1其实也很简单，但是考场上没想到，写了一个复杂度和$k$相关的暴力，居然过了（考后自己卡T了）\n\n### T1\n\n[动态规划]\n\n发现就是要优化一个这样的四方DP：\n\n```cpp\nfor (int i = 1; i <= N; ++i)\n\tfor (int j = 1; j <= M; ++j) if (A[i] == B[j])\n\t{\n\t\tfor (int a = 0; a < i; ++a) for (int b = 0; b < j; ++b) if (A[a] == B[b] && Map[A[a]][A[i]])\n\t\t\tADD (Dp[i][j], Dp[a][b]);\n\t\tADD (ans, Dp[i][j]);\n\t}\n```\n\n首先可以把 $a$ 这一维用前缀和优化掉，这样是 $O(n^3)$ 的，因为还是需要枚举 $b$\n\n但是显然，对于不同的 $j$, 在枚举 $b$ 时有很大一部分是重复枚举的。再记一个前缀和即可\n\n讲不太清，不如看代码\n\n```cpp\nDp[0][0] = 1; prefix[0] = 1;\nint ans = 0;\nfor (int i = 1; i <= N; ++i)\n{\n\tint res = 0;\n\tfor (int j = 0; j <= M; ++j) \n\t{\n\t\tif (A[i] == B[j]) Dp[i][j] = res, ADD (ans, Dp[i][j]);\n\t\tif (Map[B[j]][A[i]]) ADD (res, prefix[j]);\n\t}\n\n\tfor (int j = 0; j <= M; ++j) if (A[i] == B[j]) ADD (prefix[j], Dp[i][j]);\n}\n\ncout << ans << endl;\n```\n","categories":["Summary"]},{"title":"「CometOJ」Contest #9 & X Round 3","url":"/2019/10/16/%E3%80%8CCometOJ%E3%80%8DContest-9/","content":"\n[Link](https://cometoj.com/contest/64)\n\n<!--more-->\n\n## 等差数列\n\n直接算\n\n## 小道消息\n\n先把`n++, k++`，若$k$是个质数，且$k\\in[\\frac{n}{2}, n]$，那么答案为$1$\n\n否则，因为$\\frac{n}{2}, n]$之间一定有个质数，所以答案为$2$\n\n## 核心城市\n\n[贪心] [堆]\n\n贪心，显然直径的中点是必须要选的。预处理从每个点往下走的最长的dep，以这个为关键字建堆，每次找到最大的点选进答案集合，再把它所有儿子加入堆中\n\n## 系统设计 \n\n[Hash] [线段树] [数据结构]\n\n从$x$开始遍历可以看作先从根开始走到$x$，再往下走。将根到节点$x$的简单路径依次经过的边的排名记作⼀个字符串$s_x$，每次询问$[x, l, r]$时，就相当于查询$s_x + a_{l, r}$（这里+就是直接连接）这个字符串在树种最长能匹配到哪个点\n\n可以直接Hash，预处理每个节点的$s$，存在哈希表中。用线段树维护$a$的哈希值，查询时在线段树上二分即可\n\n<details>\n<summary> Code </summary>\n\n```cpp\n#include <bits/stdc++.h>\n#include <bits/extc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n#define DEBUG(x) cout << #x << \" = \" << x << endl;\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int MAXN = 5e5;\n\nint N, M, Q, o;\nint A[MAXN + 5];\n\nnamespace HASH\n{\n\ttypedef unsigned long long ULL;\n\n\tconst ULL base = 20030123;\n\n\tULL Val[MAXN + 5], Hash[MAXN + 5], mul[MAXN + 5];\n\tgp_hash_table <ULL, int> Map;\n\n\tstruct info\n\t{\n\t\tULL val; int len;\n\n\t\tinfo (ULL _val = 0, int _len = 0) { val = _val, len = _len; }\n\n\t};\n\n\tinline info merge (info x, info y)\n\t{\n\t\tinfo o;\n\t\to.len = x.len + y.len;\n\t\to.val = x.val * mul[y.len] + y.val;\n\t\treturn o;\n\t}\n\n\tint fg;\n\n\tnamespace SEG\n\t{\n#define mid ((l + r) >> 1)\n#define ls o << 1\n#define rs o << 1 | 1\n#define lson ls, l, mid\n#define rson rs, mid + 1, r\n\n\t\tconst int MAX_NODE = MAXN * 4;\n\n\t\tinfo node[MAX_NODE + 5];\n\n\t\tinline void push_up (int o) { node[o] = merge (node[ls], node[rs]); }\n\n\t\tinline void build (int o, int l, int r)\n\t\t{\n\t\t\tif (l == r) return void (node[o] = info (Val[A[l]], 1));\n\t\t\tbuild (lson), build (rson);\n\t\t\tpush_up (o);\n\t\t}\n\n\t\tinline void modify (int o, int l, int r, int x, ULL val)\n\t\t{\n\t\t\tif (l == r) return void (node[o] = info (val, 1));\n\t\t\tif (x <= mid) modify (lson, x, val);\n\t\t\telse modify (rson, x, val);\n\t\t\tpush_up (o);\n\t\t}\n\n\t\tinline void query (int o, int l, int r, int x, int y, info &res)\n\t\t{\n\t\t\tif (fg) return ;\n\t\t\tif (x <= l && r <= y)\n\t\t\t{\n\t\t\t\tif (Map[merge (res, node[o]).val]) { res = merge (res, node[o]); return ; }\n\t\t\t\telse if (l == r) { fg = 1; return ; }\n\t\t\t}\n\n\t\t\tif (x <= mid) query (lson, x, y, res);\n\t\t\tif (y > mid) query (rson, x, y, res);\n\t\t}\n\n#undef mid\n\t}\n\t\n\tinline void init ()\n\t{\n\t\tfor (int i = 1; i <= N; ++i) Val[i] = (ULL) rand() * rand() * rand() + (ULL) rand() * rand() + rand();\n\t\tmul[0] = 1;\n\t\tfor (int i = 1; i <= N; ++i) mul[i] = mul[i - 1] * base;\n\t}\n}\n\nusing namespace HASH;\n\nvector <int> G[MAXN + 5];\n\ninline void dfs (int x, int f, ULL hash)\n{\n\tHash[x] = hash;\n\tMap[hash] = x;\n\tsort (G[x].begin(), G[x].end());\n\n\tfor (int i = 0; i < G[x].size(); ++i)\n\t{\n\t\tint y = G[x][i]; if (y == f) continue;\n\t\tdfs (y, x, hash * base + Val[i + 1]);\n\t}\n}\n\ninline void Solve ()\n{\n\tHASH :: init ();\n\tdfs (o, 0, 0); SEG :: build (1, 1, M);\n\n\twhile (Q--)\n\t{\n\t\tint op = read<int>(), x = read<int>();\n\t\tif (op == 1)\n\t\t{\n\t\t\tint ql = read<int>(), qr = read<int>();\n\t\t\tinfo now (Hash[x], 1);\n\n\t\t\tfg = 0;\n\t\t\tSEG :: query (1, 1, M, ql, qr, now);\n\t\t\tprintf(\"%d\\n\", Map[now.val]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint y = read<int>();\n\t\t\tSEG :: modify (1, 1, M, x, Val[y]);\n\t\t}\n\t}\n}\n\ninline void Input ()\n{\n\tN = read<int>(), M = read<int>(), Q = read<int>();\n\tfor (int i = 1; i <= N; ++i)\n\t{\n\t\tint f = read<int>();\n\t\tif (!f) o = i;\n\t\telse G[f].pb (i);\n\t}\n\tfor (int i = 1; i <= M; ++i) A[i] = read<int>();\n}\n\nint main()\n{\n\n#ifndef ONLINE_JUDGE\n\tfreopen(\"D.in\", \"r\", stdin);\n\tfreopen(\"D.out\", \"w\", stdout);\n#endif\n\n\tInput ();\n\tSolve ();\n\n\treturn 0;\n}\n\n```\n\n</details>\n\n## Namid[A]me \n\n[暴力]\n\n> 设$V$为最大权值\n\n正解要离散对数$O(P)$预处理$x^x$，我直接快速幂$\\log P$算的也能过。。。\n\n考虑每个叶子到根的路径上，最多只会有$\\log V$种不同的权值，于是考虑暴力对每个点维护它子树里所有被取到的值和分别取到了多少次\n\n因为叶子个数很少，所以这样做复杂度其实是对的。因为任意两个叶子只会在它们的lca处产生复杂度为$(\\log V) ^ 2$的贡献，所以最多产生$O(d\\log V)^2$的复杂度；又因为每条路径肯定只会被算一次，即复杂度不会超过$O(n^2)$，所以总复杂度为$\\min \\{n^2, (d\\log V)^2\\}$。又因为$\\min \\{a, b\\} \\le \\sqrt{ab}$，所以复杂度为$O(nd \\log V)$\n\n","categories":["Problem"],"tags":["线段树","数据结构","堆","贪心","暴力","Hash"]},{"title":"「CodeChef」MAXDTREE - dp of dp","url":"/2019/10/08/%E3%80%8CCodeChef%E3%80%8DMAXDTREE%20-dp-of-dp/","content":"\n![19-10-8-1](/images/19-10-8-1.png)\n\n$n\\le 500, 2\\le k\\le 10$\n\n原题有加强\n\n<!--more-->\n\n### Solution\n\n首先考虑如何判定一个数存在于$a$中\n\n每次加上的数$\\in [1, k)$，所以除个位外，其他每一位每次最多$+1$. 也就是说，主要就是要判断满足某条件下，个位是否合法\n\n记$g[i][p][x][a]$表示，从第$i+1$位开始往上都填完了，前面的数位最大值为$p$，个位为$a$，要在第$i$位填$x$的话，$a$会变成多少\n\n直接处理$g$并不好处理，考虑再记$f[i][p][a]$表示第$i+1$位开始往上都填完了，前面的数位最大值为$p$，个位为$a$，要在$i+1$位产生$1$的进位，$a$会变成多少\n\n> $g$是处理一次进位，$f$处理某一位填某个数\n\n这样就能判定一个数是否合法了\n\n---\n\n接着考虑进行计数dp，设$dp[i][j][p][x]$表示当前到点$i$，判定到第$j$位，最大值为$p$，个位为$x$的方案数\n\n枚举下一个点$k$，有转移：$dp[k][j - 1][\\max \\{p, d[k]\\}][g[j - 1][p][d[k][x]] \\leftarrow dp[i][j][p][x]$\n\n直接转移是$O(n^3k^2)$的\n\n将刷表转化为填表，发现上一个点是dfs序连续的一段区间（在$i$的父亲后，在$i$前面），于是可以前缀和优化到$O(n^2k^2)$了\n\n---\n\n需要注意，在进行转移的时候，状态不一定合法。所以需要预处理出合法的转移状态，具体见代码\n\n\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n#define DEBUG(x) cout << #x << \" = \" << x << endl;\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int MAXN = 500;\nconst int MAXK = 10;\nconst int MOD = 998244353;\n\ninline void Add (int &a, int b) { if ((a += b) >= MOD) a -= MOD; }\n\nint N, K, A[MAXN + 5];\nvector <int> G[MAXN + 5];\nint dfn[MAXN + 5], idfn[MAXN + 5], dfs_clock;\nint fa[MAXN + 5];\n\ninline void dfs (int x, int f)\n{\n\tfa[x] = f, idfn[dfn[x] = ++dfs_clock] = x;\n\tfor (int i = 0; i < G[x].size(); ++i)\n\t{\n\t\tint y = G[x][i];\n\t\tif (y == f) continue;\n\t\tdfs (y, x);\n\t}\n}\n\nint f[MAXN + 5][MAXK + 5][MAXK + 5];\nint g[MAXN + 5][MAXK + 5][MAXK + 5][MAXK + 5];\nint can[MAXK + 5][MAXK + 5][MAXK + 5]; // 需要判断个位是否合法\n\ninline void Init ()\n{\n\tfor (int i = 1; i <= N; ++i) sort (G[i].begin(), G[i].end());\n\tdfs (1, 0);\n\n\tfor (int p = 0; p < K; ++p) \n\t\tfor (int q = 0; q < K; ++q) if (p > 0 || q > 0)\n\t\t{\n\t\t\tint now = q;\n\t\t\twhile (now < K) can[p][q][now] = 1, now += max (now, p);\n\t\t\tf[0][p][q] = now % K;\n\t\t}\n\n\tfor (int i = 1; i <= N; ++i)\n\t\tfor (int p = 0; p < K; ++p)\n\t\t\tfor (int q = 0; q < K; ++q) if (p > 0 || q > 0)\n\t\t\t{\n\t\t\t\tint now = q;\n\t\t\t\tfor (int t = 0; t < K; ++t) now = f[i - 1][max (p, t)][now];\n\t\t\t\tf[i][p][q] = now;\n\t\t\t}\n\n\tfor (int i = N; i >= 1; --i)\n\t\tfor (int p = 0; p < K; ++p)\n\t\t\tfor (int q = 0; q < K; ++q) if (p > 0 || q > 0)\n\t\t\t{\n\t\t\t\tint now = q;\n\t\t\t\tg[i][p][0][q] = now;\n\t\t\t\tfor (int j = 1; j < K; ++j)\n\t\t\t\t{\n\t\t\t\t\tnow = f[i - 1][max (j - 1, p)][now];\n\t\t\t\t\tg[i][p][j][q] = now;\n\t\t\t\t}\n\t\t\t}\n}\n\nint Dp[MAXN + 5][MAXN + 5][MAXK + 5][MAXK + 5];\nint prefix[MAXN + 5][MAXN + 5][MAXK + 5][MAXK + 5];\n\ninline int init_sum (int i)\n{\n\tfor (int j = 0; j <= N; ++j)\n\t\tfor (int p = 0; p < K; ++p)\n\t\t\tfor (int q = 0; q < K; ++q)\n\t\t\t\tif (!i) prefix[i][j][p][q] = Dp[i][j][p][q];\n\t\t\t\telse prefix[i][j][p][q] = (prefix[i - 1][j][p][q] + Dp[i][j][p][q]) % MOD;\n}\n\ninline int get_sum (int l, int r, int j, int p, int q)\n{\n\tif (!l) return prefix[r][j][p][q];\n\treturn (prefix[r][j][p][q] - prefix[l - 1][j][p][q] + MOD) % MOD;\n}\n\ninline void Solve ()\n{\n\tInit ();\n\n\tfor (int i = 1; i <= N; ++i) Dp[0][i][0][1] = 1;\n\tinit_sum (0);\n\n\tfor (int i = 1; i <= N; ++i)\n\t{\n\t\tfor (int j = 1; j <= N; ++j)\n\t\t\tfor (int p = 0; p < K; ++p)\n\t\t\t\tfor (int q = 0; q < K; ++q) if (p > 0 || q > 0)\n\t\t\t\t{\n\t\t\t\t\tint x = idfn[i];\n\t\t\t\t\tint l = dfn[fa[x]], r = i - 1;\n\n\t\t\t\t\tif (j > 1) Add (Dp[i][j - 1][max (p, A[x])][g[j - 1][p][A[x]][q]], get_sum (l, r, j, p, q));\n\t\t\t\t\telse if (can[p][q][A[x]]) Add (Dp[i][0][max (p, A[x])][q], get_sum (l, r, j, p, q));\n\t\t\t\t}\n\n\t\tinit_sum (i);\n\t}\n\t\n\tint ans = 0;\n\tfor (int p = 0; p < K; ++p)\n\t\tfor (int q = 0; q < K; ++q)\n\t\t\tAdd (ans, prefix[N][0][p][q]);\n\n\tcout << ans << endl;\n}\n\ninline void Input ()\n{\n\tN = read<int>(), K = read<int>();\n\tfor (int i = 1; i <= N; ++i) A[i] = read<int>();\n\tfor (int i = 1; i < N; ++i)\n\t{\n\t\tint x = read<int>(), y = read<int>();\n\t\tG[x].pb (y);\n\t\tG[y].pb (x);\n\t}\n}\n\nint main()\n{\n\n\tfreopen(\"buried.in\", \"r\", stdin);\n\tfreopen(\"buried.out\", \"w\", stdout);\n\n\tInput ();\n\tSolve ();\n\n\treturn 0;\n}\n\n```\n\n","categories":["Problem"],"tags":["动态规划","前缀和","dp of dp"]},{"title":"「CometOJ」2019国庆欢乐赛","url":"/2019/10/05/%E3%80%8CCometOJ%E3%80%8D2019%E5%9B%BD%E5%BA%86%E6%AC%A2%E4%B9%90%E8%B5%9B/","content":"\n[Link](https://cometoj.com/contest/68)\n\n<!--more-->\n\n## A\n\n只有三种情况，讨论即可\n\n## B\n\n一个小贪心\n\n```cpp\nsort (A + 1, A + 5 + 1);\nfor (int i = 1; i <= 5; ++i) ans1 += A[i];\nfor (int i = 1; i < 5; ++i) ans2 += A[i];\ncout << min (ans1 / 2, ans2) << endl;\n```\n\n## C\n\n随便数点\n\n## D\n\n当$n \\le 10^5$时，可以枚举做了$Q$张试卷，剩下的题按时间从小到大做\n\n$n$更大时，直观的想法是猜答案关于$Q$单峰。但实际上函数会有一部分是平的（斜率为$0$），无法三分\n\n于是考虑和$m$相关的做法：暴力做法在枚举做完$Q$张试卷后，剩下的题按顺序做到第$P$**种**。考虑枚举这个$P$，在枚举出$P$后，合法的$Q$是一段区间$[Q_l, Q_r]$，并且答案在$[Q_l, Q_r]$上单调（可以感性理解）\n\n因此只需要对于每个$P$，计算$Q_l, Q_r$处的答案即可\n\n\n\n##  E\n\n对$n$奇偶分情况讨论，$O(1)$直接计算答案\n\n## F\n\n> 先把原题的$a_i$都除10，最后再乘回来\n\n若不允许超速，那么每个点会有一个速度上限$lim_i$。它们之间相互限制，即$lim_i = \\min \\{a_i,lim_{i - 1} + 1, lim_{i + 1}+ 1\\}$。然而限制关系不会互相影响（即不会从左边限制到右边，再又限制回左边），所以可以从前后分别扫一次更新$lim$值\n\n允许超速的话，相当于把某个$a_i$设成$\\infty$. 显然只有$lim_i = a_i$的$i$才可能超速\n\n对于每个关键点暴力重新算一遍$lim$是$O(n^2)$的，注意到算当前关键点的答案时，上一个关键点之前和下一个关键点之后的$lim$是不会变的，所以每次只需要处理到前后第一个关键点位置即可，均摊复杂度$O(n)$\n\n\n\n## G\n\n[后缀自动机] [字符串]\n\n建`SAM`，每个节点存在原串中最前的位置。查询时暴力匹配，用$\\ge c$的边更新答案\n\n## H\n\n[拓扑排序] [博弈]\n\n> sol from xcy\n\n设二元组$(x,y)$表示当前要进行操作的人持有$x$, 不进行操作的人持有$y$. 则必胜点为$(x,0)\\ (x\\in[1,n-1])$. $(x,y)$可转移到$(y,(x+y)\\ mod\\ n),(y,xy\\ mod\\ n)$. \n\n如果是DAG, 可以直接确定每个点为必胜点还是必败点. 但会有环. \n\n如果不考虑环边, 一个点为必胜点, 则加上环边它仍为必胜点, 因为走到那个点的人会往必胜的那条边走. 而如果为必败点, 走到那个点的人不希望自己输, 于是会走到环上, 而无论环长为奇数还是偶数, 都可以无限地走下去, 故为平局.\n\n> 因为有环所以才存在平局，否则每个点的状态都是确定的！\n\n故可以从$(x,0)$开始反推. 如果当前点为必败点, 则连向它的点为必胜点. 如果当前点为必胜点, 则先不管连向它的点. 等到有两个必胜点同时被一个点连向时, 该点就是必败点(除$(x, 0)$外每个点出度都为$2$). 最后没有被扩展到的点一定为平局.\n\n注意环上的必败点不能被扩展到, 只要在环上连向的点是必胜点, 另一条边连向的也是必胜点, 它就可以被确定为必败点. 而平局点也不一定在环上, 因为可能出现一个点连向环上的平局点的情况, 此时该点也是平局点.","categories":["Problem"],"tags":["博弈","字符串","拓扑排序","后缀自动机"]},{"title":"2019年10月","url":"/2019/10/02/2019%E5%B9%B410%E6%9C%88/","content":"\n[Summary]\n\n一点小记录\n\n<!--more-->\n\n## 10-2\n\n### Process\n\nT1开场就写了，T2一开始想到了一个贪心做法，后面发现是错的。最后写了一个退火，花了较长时间。T3不太会做，博弈论不太熟悉，就只写了30分\n\n### T1\n\n[区间dp] [动态规划]\n\n直接区间dp即可\n\n### T2\n\n[贪心] \n\n直接贪心是假的，因为 $A_{i}-B_{i}$ 的大小会影响到当天是否会被淹没，而又应该将 $A_{i}$ 更大的留到最后一次爬上去。(但是也 A 掉了 )\n\n所以要枚举最后一天爬上去用的是哪个药丸，然后剩下的就可以根据 $A_{i}-B_{i}$ 的大小贪心了\n\n暴力做是$O(n^2)$的，可以用数据结构维护，做到$O(n \\log n)$\n\n![2019-10-02 16-12-31 的屏幕截图.png](http://ww1.sinaimg.cn/large/006KJ9z7gy1g7jxbbix13j30pz03dgn5.jpg)\n\n\n\n### T3\n\n[2-SAT] [SG函数] [博弈]\n\n> sol from [GC](https://gongchen618.gitee.io/blog/)\n\n首先可以把行列抽象成点，连出一个 2-sat ，并且因为边双向，所以只要联通就是强连通，并查集就可以处理。因为玩家只考虑最大化自己的分数，所以首先会尽量齐心协力达到所有硬币都为正的局面，然后再根据操作步数去判断谁多 1 分。\n\n把 $x_{0}$ 和 $x_{1}$ 在同一个强连通分量里的情况特判掉，然后考虑对联通块黑白染色，染成黑色表示选择这个联通块内点所表示的翻转方案 ，那么显然对于 $x_{0}$ 和 $x_{1}$ 所在的联通块，它们不能染成相同的颜色，我们把这种关系连上边，会得到若干个二级联通块，每个二级联通块可以看做一个独立的游戏，并且只有两种方案可选。\n\n若两种方案需要翻转的行列数皆为奇，先手胜，SG=1 ；皆为偶，SG=0 ；一奇一偶，根据 SG 定理，SG=Mex{0,1}=2 。然后把所有子游戏的 SG 异或起来即可，若为 0 ，先手败。\n\n\n\n## 10-3\n\n### Process\n\nT1搞的时间有点长，期间一度陷入死胡同。T2开始没想到点子上，在想如何优化单次$n^2$的dp。后来往组合方面想，就一步步推出来了。T3没动\n\n思维太慢了！！！T2一个简单的$n^2$暴力都想了很久才**找到方向**\n\n个人觉得今天的题出得非常好，T2有点`THUSC2019 D1T1`的感觉，只是码量稍微有点大了...\t\n\n### T1\n\n一开始想的是从根开始依次还原，发现有问题，后来发现从叶子开始依次还原就可以了\n\n\n\n### T2\n\n[方差] [组合数学] [计数] [线段树] [NTT] [卷积]\n$$\nD(X) = E(X^2) - E^2(X)\n$$\n考虑枚举子序列的长度$len$\n\n$\\displaystyle \\sum E(X^2)$很好算，它就等于$\\displaystyle \\sum_{i}\\frac{\\sum_{j} a_j^2 \\times \\binom{len-1}{i-1}}{i}$（考虑每个数的贡献，因为地位等价所以可以一起算）\n\n但是$\\displaystyle \\sum E^2(X)$不好算，因为不等于$\\Big(\\displaystyle \\sum E(x)\\Big)^2$\n\n可以把式子展开\n\n> 利用$(x_1+x_2+\\dots +x_k)^2 = \\Big(x_1^2 + x_2^2 + \\dots+x_k^2\\Big) + 2(x_1x_2 + x_1x_3+\\dots) = \\sum x_i^2 + 2\\sum x_u x_v$\n\n所以$\\displaystyle \\sum E^2(X) = \\sum_{i}\\frac{\\sum_{j}a_j^2 \\times \\binom{len-1}{i - 1} + 2\\cdot \\sum a_ua_v \\times \\binom{len - 2}{i - 2}}{i^2}$\n\n又因为和$a$有关的项可以提出来算，所以问题就转化成了两部分：计算$\\sum a_i、\\sum a_ua_v$，以及对于每个$len$计算后面那一坨式子\n\n* 前半部分：因为$\\sum a_ua_v = \\big(\\sum a_i\\big)^2 - \\sum a_i^2$，所以线段树维护$\\sum a_i$和$\\sum a_i^2$即可\n\n* 后半部分有三个式子：\n  $$\n  \\begin{aligned}\n  f[n] &= \\sum_{i=1}^{n}\\binom{n - 1}{i - 1}\\times \\frac{1}{i}\\\\\n  g[n] &= \\sum_{i=1}^{n}\\binom{n - 1}{i - 1}\\times \\frac{1}{i^2}\\\\\n  h[n] &= \\sum_{i=2}^{n}\\binom{n - 2}{i - 2}\\times \\frac{1}{i^2}\\\\\n  \\end{aligned}\n  $$\n  都可以卷积，或者也可以神仙推式子\n\n### T3\n\n[神仙题] [组合数学] [计数]\n\n![19-10-3-1](/images/19-10-3-1.png)\n\n讲一下如何算答案\n$$\n\\begin{aligned}\nans &= \\sum_{m=0}^{\\lfloor \\frac{n}{2} \\rfloor} \\binom{n-m}{m}\\sum_{i=0}^{m}\\binom{m}{i}\\binom{k}{n-i}\\\\\n\t&= \\sum_{m=0}^{\\lfloor \\frac{n}{2} \\rfloor} \\binom{n-m}{m} \\binom{m +k}{n}\n\\end{aligned}\n$$\n枚举长度为$2$的段数$m$，第一个组合数就是枚举所有可能的排列方式，乘上它后相当于已经确定了序列的形态了\n\n接下来确定取值：先从$m$个长度为$2$的段中，选出$i$个段作为长度相等的段。那么剩下要选的，互不相等的取值就只有$n-i$个了。从$1\\sim k$这$k$个数中选$n-i$个数，然后按顺序依次填到之前确定的序列中去即可\n\n最后再用范德蒙德卷积优化一下\n\n\n\n## 10-4\n\n### Process\n\nT1写了个暴力找找规律就搞出来了，T2花了较长时间，写了一个细节稍多的做法，最后还是调出来了。T3一开始想写$O(n^2)$的做法，但细节没有想清楚，导致没时间写了\n\n想题还是太慢，这两天T2都是中等偏简单的题，自己却花了很长时间才想清楚。\n\n### T1\n\n[组合数学]\n\n![19-10-4-1](/images/19-10-4-1.png)\n\n\n### T2\n\n[线段树] [数据结构] [分治]\n\n我的做法：\n\n把线段树看成一个分治结构，每次统计跨中点的区间的答案\n\n需要对于每个节点维护答案、前后缀和，以及深度\n\n具体细节见代码\n\n\n\n### T3\n\n[栈] [贪心]\n\n首先有一个贪心：从右往左扫，若当前数与左边的数合并后$\\ge 0$，则把他们合并。最后再将得到的新序列从左往右依次合并\n\n设$pre_i$表示第$i$个数最多能往左合并到的位置，那么会形成一些$[pre_i, i]$这样的段\n\n显然从$r$开始不断跳$pre$，再特殊处理一下$l$所在段，即能求出答案\n\n把询问离线，挂在右端点上，用个栈动态维护上述过程即可\n\n> 需要注意的是，在用栈动态维护的过程中，得到的数可能很大。但若在某一时刻答案$\\ge 10^9$，则它再以后都会$\\ge 10^9$，不会更小了\n>\n> 这是因为$a_i$最小也只有$-10^9$，而每次答案会先翻倍再加上前面的数，所以一定不会更小\n\n\n\n## 10-5\n\n### Process\n\n一个小时搞完的T1（实际上是错的。。。），开始以为T2可以直接缩边双跑$O(n^2)$暴力，写了一两个小时之后发现假了，必须要缩点双。T3看懂题花了好长时间，20分暴力还写挂了（以为题目给的点权是十进制的）\n\n### T1\n\n[构造]\n\n先特判$n$和$m$不全为偶数的情况，然后有两种构造方法：\n\n```\n.((((.\n(()())\n()()()\n(()())\n()()()\n.)))).\n```\n\n这样构造是$n+m-4$的\n\n```\n((((((\n()()()\n)()()(\n))))))\n```\n\n这样构造是$\\max \\{n, m\\} + \\frac{\\min\\{n, m\\}}{2} - 1$的\n\n两种取最优的即可\n\n\n\n### T2\n\n[仙人掌] [最小生成树] [图论]\n\n题目给出的图实际上就是一个仙人掌（每条边只属于一个简单环中）\n\n考虑对于原图中的每个环，把环上的最小的边断掉，再把这个环上其他边加上该边的权值，得到的答案是相同的\n\n> 因为在环上任意两点的答案一定会包含最小的边\n\n这样操作完后，原图就变成一棵树了。直接按边权从大到小排序，用并查集考虑每条边对答案的贡献即可\n\n\n\n### T3\n\n[见此](https://hk-cnyali.com/2019/10/08/%E3%80%8CCodeChef%E3%80%8DMAXDTREE%20-dp-of-dp/)\n\n\n\n## 10-7\n\n### Process\n\n拿到题之后以为T1是找规律，找了好久都没找出来，于是写了一个~~自认为~~复杂度错的dp，后来仔细想想发现是对的。T2写了整除分块，一个细节地方写错了，爆成20，T3没时间看了。。。\n\n### T1\n\n[记忆化搜索] [树形DP]\n\n树形DP ，设 f(0/1, x) 为 x 是否选择时，以 x 子树的最大匹配和匹配数。发现对于表示区间长度相同的结点，它们的 DP 值是相同的，于是 map 记忆化 $O(n \\log n)$ DP 即可。\n\n复杂度正确的关键在于线段树同一层上最多只有两种表示区间的长度相差 1 的结点。\n\n> Proof ：若某一层有两种节点，设大小分别为 2n 和 2n+1 ，则每个节点会分成两个大小为 n 的节点或一个大小为 n ，另一个大小为 n+1 的节点，下一层依然只有两种大小的节点，成立。\n\n### T2\n\n[整除分块]\n\n对于确定的 x ，它在区间 [L,R] 内的倍数有 $cnt=\\lfloor \\frac{R}{x} \\rfloor-\\lfloor \\frac{L-1}{x} \\rfloor$ 个，其中最小一个的系数为 $k_{mn}=\\lfloor \\frac{L-1}{x} \\rfloor + 1$ ，那么 S(x) 的所有非空子集的元素大小和可以表示为 $2^{cnt-1} \\times x \\times \\frac{cnt \\times (2k_{mn}+cnt-1)}{2}$ \n\n整除分块即可\n\n\n\n### T3\n\n[贪心] [二分答案]\n\n二分答案\n\n设$f[i]$表示在 $i$ 放技能能否存活， $a[i]$ 为前$ i$ 秒累计的被动血量变化，那么上一次放技能的点 $j$ 必须满足 $f[j]=1,i-j \\ge cd$ 并且 $\\max_{k \\le} \\lbrace a(k) \\rbrace \\le hp+k\\cdot j , k\\in [j+1,i]$ \n\n但实际上通过思考可以发现，若把判断条件改成$k\\in [1, i]$也并不影响答案，于是符合条件的$j$必然是单调不降的\n\n另一种情况，$i$ 是第一次放技能的点，那就只需要 $hp \\ge \\max \\lbrace a[k] \\rbrace, k\\in [1, i]$ \n\n只要预处理$a[i]$ 的前缀 max 即可\n\n\n\n## 10-8\n\n### Process\n\n考了我、jwb、cxr出的联考题。校内效果似乎不是很理想，我的T2得分的人并不多。。。T1是一道FST好题。cxr的T3出得非常好！\n\n### T3\n\n#### Description\n\n给一个长度为$n$的数字串$S$（包含$?$，$?$表示可以任填$0\\sim 9$）和一个长度为$m$的数字串$T$。定义一个串$S$是好的，当且仅当$T$作为子串在$S$中出现至少一次\n\n$Q$次询问，每次给出$k$，求第$k$大的好串\n\n$n\\le 5\\times 10^4, m\\le 20, q\\le 10^5, k\\le 10^{18}$\n\n#### Solution\n\n[倍增] [数位dp] [动态规划] [树链剖分] [KMP]\n\n首先可以数位dp，设$dp[i][j]$表示$S$考虑到第$i$位，匹配了$T$串$j$位的方案数。kmp处理下一位填$0\\sim9$的数时$j$如何变化。转移和[这道题](https://hk-cnyali.com/2019/09/16/「ACM-ICPC2019」上海网络赛-简要题解/#F)类似\n\n这样做是单次$O(n)$，因为需要依次确定每一位填什么，考虑优化\n\n类似重链剖分的过程，每一位选出一个dp值最大的后继作为重儿子，倍增预处理出重链信息，查询时如果能跳重链就跳重链，否则暴力确定后继\n\n这样做的复杂度是$O(\\log k \\log n)$的，因为每暴力确定一次后继，$k$减少至少一半；而每跳完一次重链都一定会暴力确定一次后继（否则肯定可以继续往后跳重链）。所以经过的轻重链都是$O(\\log k)$级别的，而每次跳重链复杂度为$O(\\log n)$\n\n总复杂度$O(nm\\log  + q\\log k \\log n)$\n\n\n\n## 10-10\n\n### Process\n\n几乎一整场在写T1，开场写了个贪心过了大样例， 但是小数据随便拍就错了，然后就一直在修修补补，最后写了个二分图匹配才拍上。写完T1只剩半小时，T3暴力写完就没时间了。结果大家T1都写的贪心还都A了。。。感觉好不公平。。。\n\n### T1\n\n[贪心] [二分图匹配]\n\n直观想法是直接贪心，即从大到小考虑每一行/列，尽量把行列最大值相同的交一起。但这是错的，因为这样做出来的交点个数不一定最优。用二分图匹配实现行列配对的过程即可\n\n### T2\n\n[长链剖分] [数据结构]\n\n之前考过这道题的一个部分分，居然忘了怎么做。。。\n\n首先对于一个确定的$d$，肯定是贪心选最长的$l$条链，可以用类似长剖的方法实现\n\n考虑每次增加 1 的深度，然后加入该层的结点并更新当前所有链的长度，并维护前 $l$ 长的链。显然可以预处理出原树的长链剖分，那么就唯一确定了每个点在任意时刻所属的链\n\n$\\log$可以随便做，但这题必须$O(n)$。考虑利用每次每条链长度最多变化 1 的性质，用桶来 $O(1)$ 更新前 $l$ 长的链。具体而言，对每个长度维护有多少链属于前 $l$ 大，每次尽量把长度 +1 的链看做位于前 $l$ 长使得答案更优\n\n\n\n### T3\n\n[矩阵快速幂]\n\n考虑用矩阵**依次**处理整个过程，只要能够做到**依次**处理每个字符，那么#运算就能用矩阵快速幂优化\n\n如何构造矩阵呢？显然，构造的矩阵在运算时必须要满足**线性性**，否则不能矩乘\n\n因为题目没有括号，只有`+ - *`，考虑把某一时刻的答案拆成`a + b * c`的形式，分别维护`a、b、b * c`这三项（注意必须是`b * c`，否则不满足线性性）。讨论一下`+ - *`这三种运算符，以及新加一个数字这四种情况时的转移矩阵即可\n\n> 举个例子：往后加一个数字$d$\n>\n> $a+b * c \\rightarrow a + b * (10c + d)$，所以`a、b`项不变，`b * c`项乘十再加$b * d$\n>\n> 所以`T[2][2] = 1, T[3][3] = 10, T[2][3] = d;`\n>\n> 剩下的转移矩阵类似，具体见代码\n\n\n## 10-11\n\n### Process\n\n先开的T2，写了一个线段树 + set 的做法，卡了卡常能过样例就没管了。然后去搞T1，式子化到一半不会处理组合数前缀和~~我是个智障~~...于是写了个40分暴力，并且因为常数太大T了一个subtask。T3基本没看\n\n### T1\n\n> 注：以下的整除符号均省略\n\n\n考场上想到的化式子方法：\n\n$$\nans = \\sum_{d=1}^{\\min\\{n, m\\}} \\binom{d}{B} \\sum_{g=1}^{\\min\\{\\frac{n}{d}, \\frac{m}{d}\\}} \\mu(g) \\frac{n}{dg} \\frac{m}{dg}\\\\\n$$\n\n然后不会求$\\binom{d}{B}$的前缀和。。。（显然前缀和就是杨辉三角最右边右下角的那个值）不过这样算复杂度不对，也跑不过去\n\n正解需要换一个思路，考虑把上式的$dg$提到前面去\n\n$$\n\\begin{aligned}\nans &=\\sum_{dg=1}^{min(n, m)} \\frac{n}{dg} \\frac{m}{dg} \\sum_{d|dg} \\binom{d}{B} \\mu(\\frac{dg}{d})\\\\\n\n\t&=\\sum_{i=1}^{\\min\\{n, m\\}} \\frac{n}{i} \\frac{m}{i} \\sum_{d | i} \\binom{d}{B} \\mu(\\frac{i}{d}) \\\\\n\n\t&=\\sum_{i=1}^{\\min\\{n, m\\}} \\frac{n}{i} \\frac{m}{i} f(i)\n\\end{aligned}\n$$\n\n只要快速计算$f(i)$前缀和即可\n\n$\\displaystyle f(i) = \\sum_{d | i}\\binom{d}{B}\\mu(\\frac{i}{d})$\n\n设$g(i) = \\binom{i}{B}$, 那么$f = g * \\mu \\Rightarrow g = f * 1$\n\n$g$的前缀和很好算，所以可以直接杜教筛，复杂度不会算\n\n### T2\n\n我的做法: 显然，合法情况不能有越过$[r_1, r_2]$的弦，所以只需要计算$r_1$的答案。用线段树 + set 维护一下**不合法**的位置即可\n\ncxr的做法: 算$r_1$的答案时，可以给每条线段随机赋一个权值，统计前缀异或和相等的区间有多少个即可\n\n## 10-13\n\n### Process\n\n想了一上午的T1都没想出来，不知道怎么回事。T2大家都做过原题，T3找了下规律写了32分暴力\n\n### T1\n\n[数据结构] [时光倒流]\n\n> 感觉很巧妙的一道题，好像很睿智但是自己就是想不到。。。\n\n把操作倒着考虑，设当前操作$[l, r]$，那么$[r + 1, r + (r - l)]$这一段的字符肯定是当前这一次操作\"造\"出来的，所以可以把它们的父亲指向$[l, r]$中对应位置，然后把他们删掉，再处理前一次操作（因为在前一次操作中这段字符肯定是没有出现的）\n\n用`vector`维护即可（因为需要找当前存在的第$l$个位置在哪里，所以不能直接并查集维护。也可以用平衡树实现）\n\n<details>\n<summary> Code </summary>\n\n```cpp\ninline void Solve ()\n{\n\tstatic vector <int> vec;\n\tstatic int fa[MAXN + 5];\n\n\tfor (int i = 1; i <= K; ++i) vec.pb (i);\n\n\tfor (int t = Q; t >= 1; --t)\n\t{\n\t\tint l = A[t].x, r = A[t].y, len = r - l + 1;\n\t\tif (vec.size() <= r) continue;\n\n\t\tint p = ((l & 1) || (l == r)) ? l : l + 1;\n\t\tfor (int i = r; i < min ((int) vec.size(), r + len); ++i)\n\t\t{\n\t\t\tfa[vec[i]] = vec[p - 1];\n\t\t\tp += 2;\n\t\t\tif (p > r) p = (l & 1) ? l + 1 : l;\n\t\t}\n\n\t\tvec.erase (vec.begin() + r, vec.begin() + min ((int) vec.size(), r + len));\n\t}\n\n\tfor (int i = 1, j = 1; i <= K; ++i)\n\t{\n\t\tif (!fa[i]) Ans[i] = S[j++];\n\t\telse Ans[i] = Ans[fa[i]];\n\t\tprintf(\"%c\", Ans[i]);\n\t}\n}\n```\n</details>\n\n### T2\n\n之前做过，见[这里](https://hk-cnyali.com/2019/08/31/%E3%80%8CARC083%E3%80%8DF-Collecting-Balls-%E5%9F%BA%E7%8E%AF%E6%A0%91-%E6%80%9D%E7%BB%B4/)\n\n## 10-14\n\n### Process\n\nT1搞了比较长的时间，一开始sb了以为最多就一种顺子。。。拍出错了之后才发现要搜顺子。。。T2直接写了个5行的bitset。T3把读入格式的$c_i$和$v_i$看反了，调了好久的样例，最后没时间优化了\n\n做题速度太慢，感觉还没找到自己考试的节奏，要抓紧时间调整状态了！！\n\n### T1\n\n[搜索] [贪心]\n\n本质有用的牌型只有对子、三张、三带一、四带二、顺子\n\n爆搜顺子，剩下的贪心\n\n### T2\n\n[bitset]\n\n数据随机，期望分布得会比较均匀，用bitset的`_Find_next`找后继即可\n\n\n### T3\n\n[动态规划] [背包] [bitset] [二进制拆分]\n\n设$dp[i][j][k]$表示到第$i$种，选了$j$种，容量为$k$是否可行，暴力背包转移是$n^4$的\n\n考虑优化，首先可以bitset除掉一个$\\omega$\n\n<details>\n\n<summary> 大概是这个意思 </summary>\n\n```cpp\nfor (int i = 1; i <= N; ++i)\n    for (int j = i - 1; j >= 0; --j)\n        for (int l = 1; l <= A[i].y && l * A[i].x <= L; ++l)\n            Dp[j + 1] |= Dp[j] << (A[i].x * l);\n```\n\n</details>\n\n然后可以二进制拆分，这样就能优化到$\\frac{n^3 * \\log c_i}{\\omega}$了\n\n<details>\n\n<summary> Code </summary>\n\n```cpp\nfor (int i = 1; i <= N; ++i)\n\tfor (int j = i - 1; j >= 0; --j)\n\t{\n\t\tint res = 1, now = A[i].y;\n\t\tbitset <MAXN + 5> tmp;\n\t\twhile (now >= res)\n\t\t{\n\t\t\tif (A[i].x * res <= L) tmp |= (tmp << (A[i].x * res)) | (Dp[j] << (A[i].x * res));\n\t\t\tnow -= res;\n\t\t\tres <<= 1;\n\t\t}\n\t\tif (now && A[i].x * now <= L) tmp |= (tmp << (A[i].x * now)) | (Dp[j] << (A[i].x * now));\n\t\tDp[j + 1] |= tmp;\n\t}\n```\n</details>\n\n## 10-15\n\n### Process\n\nT1是gc讲过的题，之前没写，考试当场写的。T2猜了个结论，估计是spj的原因只有25分。T3贴了之前考过的一道题的程序，有一点不一样，但是拿到了90分\n\n### T1\n\n[二分答案] [主席树]\n\n对于一次询问，可以二分答案，把$\\ge mid$的数设成$1$，$< mid$的数设成$-1$，那么只要左端点$\\in[l1, r1]$， 右端点$\\in[l2, r2]$的区间中，存在某个区间和非负，则说明答案大于等于$mid$。这个判断不难\n\n多组询问的话，每次不能暴力设数，那么主席树预处理即可\n\n### T2\n\n[构造] [贪心]\n\n设$leaf$为叶子数量，则答案为$\\lceil \\frac{leaf}{2} \\rceil$\n\n考虑构造，先随便`dfs`一次，把所有叶子按dfs序排序，每次取第$i$个叶子和第$i + \\frac{leaf}{2}$个叶子连边即可\n\n<details>\n<summary> Proof </summary>\n\n![19-10-16-1](/images/19-10-16-1.png)\n\n</details>\n\n### T3\n\n[贪心] [堆]\n\nsol写得很好：\n\n<details>\n<summary> Sol </summary>\n\n<p>\n\n![19-10-16-2](/images/19-10-16-2.png)\n\n</p>\n\n<p>\n\n![19-10-16-3](/images/19-10-16-3.png)\n\n</p>\n\n<p>\n\n![19-10-16-4](/images/19-10-16-4.png)\n\n</p>\n\n</details>\n\n需要注意，算答案的时候两种类型的点都要一起合，不能只合$a < b$的；以及`operator <`要注意细节问题\n\n<details>\n<summary> Code </summary>\n\n```cpp\n#include <bits/stdc++.h>\n\n#define int long long\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n#define DEBUG(x) cout << #x << \" = \" << x << endl;\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int MAXN = 1e5;\n\nint N, A[MAXN + 5], B[MAXN + 5];\nvector <int> G[MAXN + 5];\n\nstruct info\n{\n\tint x, a, b;\n\n\tinfo (int _x = 0, int _a = 0, int _b = 0) { x = _x, a = _a, b = _b; }\n\n\tinline bool operator < (const info &rhs) const\n\t{\n\t\tint op0 = (a <= b), op1 = (rhs.a <= rhs.b);\n\t\tif (op0 != op1) return op0 < op1;\n\t\tif (!op0)\n\t\t{\n\t\t\tif (b != rhs.b) return b < rhs.b;\n\t\t\tif (a == rhs.a) return 0;\n\t\t\treturn a < rhs.a;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (a != rhs.a) return a > rhs.a;\n\t\t\tif (b == rhs.b) return 0;\n\t\t\treturn b < rhs.b;\n\t\t}\n\t}\n};\n\nnamespace DSU\n{\n\tint fa[MAXN + 5];\n\tinline void init () { for (int i = 1; i <= N; ++i) fa[i] = i; }\n\tinline int get_fa (int x) { return x == fa[x] ? x : fa[x] = get_fa (fa[x]); }\n\tinline void link (int x, int f) { x = get_fa (x), f = get_fa (f); fa[x] = f; }\n}\n\nint fa[MAXN + 5];\n\ninline void dfs_pre (int x)\n{\n\tsort (G[x].begin(), G[x].end());\n\tfor (int i = 0; i < G[x].size(); ++i)\n\t{\n\t\tint y = G[x][i];\n\t\tif (y == fa[x]) continue;\n\t\tfa[y] = x;\n\t\tdfs_pre (y);\n\t}\n\n\tif (fa[x]) G[x].erase (lower_bound (G[x].begin(), G[x].end(), fa[x]));\n}\n\ninline void Init ()\n{\n\tDSU :: init ();\n\n\tdfs_pre (1);\n\tstatic priority_queue <info> Q;\n\tstatic int vis[MAXN + 5];\n\tfor (int i = 2; i <= N; ++i) Q.push (info (i, A[i], B[i]));\n\n\twhile (!Q.empty())\n\t{\n\t\tint x = Q.top().x, a = Q.top().a, b = Q.top().b; Q.pop();\n\n\t\tif (vis[x]) continue;\n\t\tvis[x] = 1;\n\n\t\tint f = DSU :: get_fa (fa[x]), _a = A[f], _b = B[f];\n\t\tif (f && info (f, _a, _b) < info (x, a, b))\n\t\t{\n\t\t\tDSU :: link (x, f);\n\t\t\tA[f] = max (_a, _a - _b + a);\n\t\t\tB[f] = A[f] - _a + _b - a + b;\n\t\t\tQ.push (info (f, A[f], B[f]));\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= N; ++i) if (DSU :: get_fa (i) != i) G[DSU :: get_fa (i)].insert (G[DSU :: get_fa (i)].end(), G[i].begin(), G[i].end());\n}\n\ninline void Solve ()\n{\n\tInit ();\n\n\tstatic priority_queue <info> Q;\n\tQ.push ((info) {1, A[1], B[1]});\n\n\tint ans = 0, res = 0;\n\twhile (!Q.empty())\n\t{\n\t\tint x = Q.top().x, a = Q.top().a, b = Q.top().b; Q.pop();\n\n\t\tres -= a;\n\t\tif (res < 0) Chkmax (ans, -res);\n\t\tres += b;\n\n\t\tfor (int i = 0; i < G[x].size(); ++i)\n\t\t{\n\t\t\tint y = G[x][i];\n\t\t\tif (DSU :: get_fa (y) != y) continue;\n\t\t\tQ.push (info (y, A[y], B[y]));\n\t\t}\n\t}\n\n\tcout << ans << endl;\n}\n\ninline void Input ()\n{\n\tN = read<int>();\n\tfor (int i = 2; i <= N; ++i) A[i] = read<int>(), B[i] = read<int>();\n\tfor (int i = 1; i < N; ++i)\n\t{\n\t\tint x = read<int>(), y = read<int>();\n\t\tG[x].pb (y);\n\t\tG[y].pb (x);\n\t}\n}\n\nsigned main()\n{\n\n#ifdef hk_cnyali\n\tfreopen(\"tree.in\", \"r\", stdin);\n\tfreopen(\"tree.out\", \"w\", stdout);\n#endif\n\n\tInput ();\n\tSolve ();\n\n\treturn 0;\n}\n\n```\n\n</details>\n\n## 10-16\n\n### Process\n\n今天考了杨光的题，T1简单容斥计数，T3可以找规律，T2是个有点难的数据结构题\n\n写了270分，T2因为常数问题挂掉了17分\n\n### T1\n\n[容斥] [计数]\n\n先把所有点排序， 设 $f_i$ 表示从原点到$i$号点，不经过其他障碍点的方案数。它就等于总方案减去其他障碍点的方案。可以枚举第一个碰到的是哪个障碍来计算。最后答案就是总方案减$\\sum f_i$\n\n### T2\n\n[bitset] [扫描线]\n\n把每个正方形放到其左下角的点处统计答案， 对每种颜色计算哪些正方形能覆盖到它。只有一个点$(a, b)$时，$x \\in [a, a + k - 1], y\\in [b - k + 1, b]$的所有点都能覆盖。但如果有多个点的话，直接算就会算重\n\n考虑扫描线（从上往下依次加行），每种颜色维护一个`bitset`。每新加一行的第$j$列元素$A_{i, j}$时，在对应颜色的`bitset`中找到第$j$列的前驱和后继，这样就知道这次操作真正会贡献的位置了。\n\n扫描线在删除时会有小问题，因为你并不知道把这个点删掉后，是否还存在一个位于这一列的点。（即在同一列有多个点）这个问题很好解决，预处理$g[i][j]$表示从$(i, j)$往下的$K$个位置是否有和$A_{i, j}$相同的值即可\n\n具体实现时，维护每一行的差分标记，每次做一遍前缀和即可\n\n<details>\n<summary> Code </summary>\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n#define DEBUG(x) cout << #x << \" = \" << x << endl;\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int MAXN = 3000;\nconst int MAX_VAL = 1e5;\n\nint N, M, K;\nint A[MAXN + 5][MAXN + 5];\nint Down[MAXN + 5][MAXN + 5];\n\ninline void Init ()\n{\n\tstatic int buc[MAX_VAL + 5];\n\tfor (int i = 1; i <= MAX_VAL; ++i) buc[i] = INT_MAX;\n\t\n\tfor (int j = 1; j <= M; ++j)\n\t{\n\t\tfor (int i = N; i >= 1; --i)\n\t\t{\n\t\t\tif (buc[A[i][j]] - i <= K) Down[i][j] = 1;\n\t\t\tbuc[A[i][j]] = i;\n\t\t}\n\n\t\tfor (int i = 1; i <= N; ++i) buc[A[i][j]] = INT_MAX;\n\t}\n}\n\nbitset <MAXN + 5> L[MAX_VAL + 5], R[MAX_VAL + 5];\n\nint delta[MAXN + 5];\n\ninline int get_pre (int id, int x) { return M - (int) L[id]._Find_next (M - x); }\n\ninline int get_next (int id, int x) { return (int) R[id]._Find_next (x); }\n\ninline void Solve ()\n{\n\tInit ();\n\n\tstatic int cur[MAXN + 5];\n\tint ans1 = 0; LL ans2 = 0;\n\n\tfor (int i = 1; i <= N; ++i)\n\t{\n\t\tfor (int j = 1; j <= M; ++j)\n\t\t{\n\t\t\tint c = A[i][j];\n\t\t\tint l = max (1, max (j - K + 1, get_pre (c, j) + 1)), r = min (j, get_next (c, j) - K);\n\n\t\t\tif (l <= r && !R[c][j]) ++cur[l], --cur[r + 1];\n\t\t\tL[c][M - j] = R[c][j] = 1;\n\t\t}\n\n\t\tif (i > K)\n\t\t{\n\t\t\tfor (int j = 1; j <= M; ++j)\n\t\t\t{\n\t\t\t\tint c = A[i - K][j], x = i - K, y = j;\n\t\t\t\tint l = max (1, max (y - K + 1, get_pre (c, y) + 1)), r = min (y, get_next (c, y) - K);\n\t\t\t\tif (!Down[x][y]) L[c][M - y] = R[c][y] = 0;\n\t\t\t\tif (l <= r && !R[c][y]) --cur[l], ++cur[r + 1];\n\t\t\t}\n\t\t}\n\n\t\tif (i >= K)\n\t\t{\n\t\t\tfor (int j = 1; j <= M - K + 1; ++j)\n\t\t\t{\n\t\t\t\tdelta[j] = cur[j] + delta[j - 1];\n\t\t\t\tChkmax (ans1, delta[j]);\n\t\t\t\tans2 += delta[j];\n\t\t\t}\n\t\t}\n\n\t}\n\n\tcout << ans1 << ' ' << ans2 << endl;\n}\n\ninline void Input ()\n{\n\tN = read<int>(), M = read<int>(), K = read<int>();\n\n\tfor (int i = 1; i <= N; ++i) for (int j = 1; j <= M; ++j) A[i][j] = read<int>();\n}\n\nint main()\n{\n\n\tfreopen(\"b.in\", \"r\", stdin);\n\tfreopen(\"b.out\", \"w\", stdout);\n\n\tInput ();\n\tSolve ();\n\n\treturn 0;\n}\n\n```\n\n</details>\n\n### T3\n\n把逆矩阵打出来找规律后不难发现，第$i$行$j$列的值的平方就是$\\big(C_i^j\\big)^2 \\times i^{2m}$\n\n再找找规律发现$\\sum_j \\big(C_i^j\\big)^2$就等于$\\binom{2i}{i} - 1$，直接计算即可\n\n## 10-17\n\n### Process\n\n今天是dy的题，开场先把T3模板题写了，然后就一直在想T2正解。最后没想出来，就只有最裸的暴力分了\n\n### T1\n\n[博弈] [拓扑排序]\n\n和[这道题](https://hk-cnyali.com/2019/10/05/%E3%80%8CCometOJ%E3%80%8D2019%E5%9B%BD%E5%BA%86%E6%AC%A2%E4%B9%90%E8%B5%9B/#H)几乎一模一样\n\n![19-10-17-1](/images/19-10-17-1.png)\n\n### T2\n\n[bfs] [并查集]\n\n![19-10-18-1](/images/19-10-18-1.png)\n\n需要桶排，直接sort会被卡常\n\n\n### T3\n\n[CDQ分治]\n\n考虑每个询问/修改在生效时产生的贡献，是个比较裸的三维偏序，直接cdq分治即可\n\n## 10-18\n\n### Process\n\n想了一会儿T1无果，然后先开的T2，发现是思博题。最后T1写了个暴力加了点剪枝，T3写了个线性基的暴力就交了。没想到T1居然A了。。。数据太水了。。。\n\n### T1\n\n[堆] [数据结构]\n\n考虑对每个值预处理出答案。用大根堆维护一些值域上的连续段，每个段维护两个信息：长度和初始值域上的起始位置（堆以长度为关键字）。即一开始只有`(max_val, 1)`这一个段。\n\n对于每个操作$x$，只需要找到长度$\\ge x$的段，暴力拆开。因为每次拆开后，上半部分的段就一定会沉到最底下。\n\n这样做复杂度是对的，因为每个段长度至少为$1$，所以总共最多切$O(max\\_val)$次\n\n### T2\n\n[矩阵快速幂]\n\n直接矩阵快速幂\n\n### T3\n\n[线性基] [分治] [树]\n\n如果有$n$个数，其线性基内元素可以异或出$k$，则异或和为$k$的方案数等于$2^{n - x}$，其中$x$为线性基内元素个数；否则为0\n\n因为线性基只能合并无法删除，考虑如何把原树扣掉一条链合并出出来\n\n> 定义逆序遍历为，把每个点的儿子都`reverse`后的遍历\n\n先考虑$x$是$y$祖先的情况：求出原树的后续遍历，以及逆后序遍历。那么$x$到$y$的路径就是`后序遍历在y之前的点`（红色 + 绿色） 并上 `逆后序遍历在y之前的点`(紫色 + 绿色) 并上 `x的所有祖先`\n\n![19-10-20-1](/images/19-10-20-1.png)\n\n---\n\n当$x$和$y$没有祖先关系时（假设$x$在$y$左边），$x$左边和$y$右边的部分，以及$lca$上面的部分都很好算。但是还有一部分是$lca$子树内，在$x$右边且$y$左边的部分。这一部分可以由`dfs序`以及`逆dfs序`的一段连续的区间拼凑起来\n\n对于这些连续区间的询问，我们可以离线分治处理，也可以用猫树（其实就是把分治结构预处理出来）在线回答\n\n总复杂度$O(\\log^2 n)$\n\n<details>\n\n<summary> Code (6.8K) </summary>\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n#define DEBUG(x) cout << #x << \" = \" << x << endl;\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int MAXN = 2e5;\nconst int MAXM = 4e5;\nconst int MAX_VAL = 32767;\nconst int MOD = 998244353;\n\nint N, M, W[MAXN + 5];\nvector <int> G[MAXN + 5];\n\nnamespace HLD\n{\n\tint fa[MAXN + 5], dep[MAXN + 5], size[MAXN + 5], son[MAXN + 5];\n\tint top[MAXN + 5], dfn[MAXN + 5], idfn[MAXN + 5], dfs_clock;\n\n\tinline void dfs (int x)\n\t{\n\t\tdep[x] = dep[fa[x]] + 1;\n\t\tsize[x] = 1;\n\t\tfor (int i = 0; i < G[x].size(); ++i)\n\t\t{\n\t\t\tint y = G[x][i];\n\t\t\tif (y == fa[x]) continue;\n\t\t\tfa[y] = x;\n\t\t\tdfs (y);\n\t\t\tsize[x] += size[y];\n\t\t\tif (size[y] > size[son[x]]) son[x] = y;\n\t\t}\n\t}\n\n\tinline void dfs (int x, int now)\n\t{\n\t\tidfn[dfn[x] = ++dfs_clock] = x;\n\t\ttop[x] = now;\n\t\tif (son[x]) dfs (son[x], now);\n\t\tfor (int i = 0; i < G[x].size(); ++i)\n\t\t{\n\t\t\tint y = G[x][i];\n\t\t\tif (y == fa[x] || y == son[x]) continue;\n\t\t\tdfs (y, y);\n\t\t}\n\t}\n\n\tinline void init () { dfs (1), dfs (1, 1); }\n\n\tinline int get_lca (int x, int y)\n\t{\n\t\twhile (top[x] != top[y])\n\t\t{\n\t\t\tif (dep[top[x]] < dep[top[y]]) swap (x, y);\n\t\t\tx = fa[top[x]];\n\t\t}\n\t\tif (dep[x] > dep[y]) swap (x, y);\n\t\treturn x;\n\t}\n\n\tinline int get_dis (int x, int y) { return dep[x] + dep[y] - 2 * dep[get_lca (x, y)] + 1; }\n\n\tinline int get_son (int x, int anc)\n\t{\n\t\tint d = dep[anc] + 1;\n\t\twhile (dep[top[x]] > d) x = fa[top[x]];\n\t\treturn idfn[dfn[x] - (dep[x] - d)];\n\t}\n}\n\nusing HLD :: size;\nusing HLD :: get_lca;\nusing HLD :: get_dis;\nusing HLD :: get_son;\nusing HLD :: get_son;\n\nstruct basis\n{\n\tstatic const int MAX_LEN = 15;\n\n\tint A[MAX_LEN + 1], cnt;\n\n\tinline void init () { memset (A, 0, sizeof A); cnt = 0; }\n\n\tbasis () { init (); }\n\n\tinline int insert (int x)\n\t{\n\t\tfor (int i = MAX_LEN; i >= 0; --i)\n\t\t{\n\t\t\tif (!(x & (1 << i))) continue;\n\t\t\tif (!A[i])\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < i; ++j) if (x & (1 << j)) x ^= A[j];\n\t\t\t\tfor (int j = i + 1; j <= MAX_LEN; ++j) if (A[j] & (1 << i)) A[j] ^= x;\n\t\t\t\tA[i] = x;\n\t\t\t\t++cnt;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tx ^= A[i];\n\t\t}\n\t\treturn 0;\n\t}\n\n\tinline int query (int x)\n\t{ \n\t\tfor (int i = MAX_LEN; i >= 0; --i)\n\t\t\tif (x & (1 << i))\n\t\t\t{\n\t\t\t\tif (!A[i]) return 0;\n\t\t\t\tx ^= A[i];\n\t\t\t}\n\t\treturn 1;\n\t}\n\t\n\tinline basis operator + (const basis &rhs) const\n\t{\n\t\tbasis now = *this;\n\t\tfor (int i = 0; i <= MAX_LEN; ++i) if (rhs.A[i])\n\t\t\tnow.insert (rhs.A[i]);\n\t\treturn now;\n\t}\n\n};\n\nstruct Graph\n{\n\tint dfn[MAXN + 5], idfn[MAXN + 5], dfs_clock;\n\tbasis prefix[MAXN + 5];\n\n\tinline void dfs (int x, int f)\n\t{\n\t\tfor (int i = 0; i < G[x].size(); ++i)\n\t\t{\n\t\t\tint y = G[x][i];\n\t\t\tif (y == f) continue;\n\t\t\tdfs (y, x);\n\t\t}\n\n\t\tidfn[dfn[x] = ++dfs_clock] = x;\n\n\t\tprefix[dfs_clock] = prefix[dfs_clock - 1], prefix[dfs_clock].insert (W[x]);\n\t}\n\n\tinline void init (int op)\n\t{\n\t\tif (op) for (int i = 1; i <= N; ++i) reverse (G[i].begin(), G[i].end());\n\n\t\tdfs (1, 0);\n\n\t\tif (op) for (int i = 1; i <= N; ++i) reverse (G[i].begin(), G[i].end());\n\t}\n\n} Gra[2];\n\nint dfn[2][MAXN + 5], idfn[2][MAXN + 5], dfs_clock[2];\nbasis prefix[MAXN + 5];\n\ninline void dfs0 (int x, int f)\n{\n\tidfn[0][dfn[0][x] = ++dfs_clock[0]] = x;\n\tprefix[dfs_clock[0]] = prefix[f], prefix[x].insert (W[x]);\n\n\tfor (int i = 0; i < G[x].size(); ++i)\n\t{\n\t\tint y = G[x][i];\n\t\tif (y == f) continue;\n\t\tdfs0 (y, x);\n\t}\n}\n\ninline void dfs1 (int x, int f)\n{\n\tidfn[1][dfn[1][x] = ++dfs_clock[1]] = x;\n\n\treverse (G[x].begin(), G[x].end());\n\n\tfor (int i = 0; i < G[x].size(); ++i)\n\t{\n\t\tint y = G[x][i];\n\t\tif (y == f) continue;\n\t\tdfs1 (y, x);\n\t}\n\t\n\treverse (G[x].begin(), G[x].end());\n}\n\ninline void Init ()\n{\n\tGra[0].init (0), Gra[1].init (1);\n\tdfs0 (1, 0), dfs1 (1, 0);\n\tHLD :: init ();\n}\n\nint K[MAXN + 5];\nbasis Ans[MAXN + 5];\n\nstruct query\n{\n\tint l, r, id;\n\tquery (int _l = 0, int _r = 0, int _id = 0) { l = _l, r = _r, id = _id; }\n};\n\nnamespace DIV\n{\n#define mid ((l + r) >> 1)\n\n\tinline void solve (int l, int r, vector <query> res, int op)\n\t{\n\t\tif (!res.size()) return ;\n\n\t\tif (l == r)\n\t\t{\n\t\t\tfor (int i = 0; i < res.size(); ++i)\n\t\t\t{\n\t\t\t\tint id = res[i].id;\n\t\t\t\tAns[id].insert (W[idfn[op][l]]);\n\t\t\t}\n\t\t\treturn ;\n\t\t}\n\n\t\tstatic basis A[MAXN + 5], B[MAXN + 5];\n\t\tvector <query> L, R; L.clear(), R.clear();\n\n\t\tA[mid + 1].init (), B[mid].init ();\n\t\tfor (int i = mid; i >= l; --i) A[i] = A[i + 1], A[i].insert (W[idfn[op][i]]);\n\t\tfor (int i = mid + 1; i <= r; ++i) B[i] = B[i - 1], B[i].insert (W[idfn[op][i]]);\n\n\t\tfor (int i = 0; i < res.size(); ++i)\n\t\t{\n\t\t\tint ql = res[i].l, qr = res[i].r, id = res[i].id;\n\t\t\tif (ql > qr) continue;\n\t\t\tif (ql <= mid && mid <= qr) Ans[id] = Ans[id] + A[ql] + B[qr];\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (qr < mid) L.pb (res[i]);\n\t\t\t\telse R.pb (res[i]);\n\t\t\t}\n\t\t}\n\n\t\tsolve (l, mid, L, op), solve (mid + 1, r, R, op);\n\t}\n\n#undef mid\n}\n\nquery Que[MAXN + 5];\n\ninline void Solve ()\n{\n\tInit ();\n\n\tstatic vector <query> Q[2];\n\n\tfor (int i = 1; i <= M; ++i)\n\t{\n\t\tint x = read<int>(), y = read<int>(), k = read<int>(), lca = get_lca (x, y); \n\t\tif (dfn[0][x] > dfn[0][y]) swap (x, y);\n\t\tQue[i] = query (x, y, k);\n\n\t\tif (lca == x)\n\t\t{\n\t\t\tAns[i] = Gra[0].prefix[Gra[0].dfn[y] - 1] + Gra[1].prefix[Gra[1].dfn[y] - 1] + prefix[dfn[0][lca] - 1];\n\t\t\tcontinue;\n\t\t}\n\n\t\tAns[i] = Gra[0].prefix[Gra[0].dfn[x] - 1] + Gra[1].prefix[Gra[1].dfn[y] - 1] + prefix[dfn[0][lca] - 1];\n\n\t\tint ls = get_son (x, lca), rs = get_son (y, lca);\n\n\t\tQ[0].pb (query (dfn[0][x] + size[x], dfn[0][rs] - 1, i));\n\t\tQ[1].pb (query (dfn[1][y] + size[y], dfn[1][rs] + size[rs] - 1, i));\n\t}\n\n\tfor (int k = 0; k < 2; ++k) DIV :: solve (1, N, Q[k], k);\n\n\tstatic int pw[MAXN + 5];\n\tpw[0] = 1;\n\tfor (int i = 1; i <= MAXN; ++i) pw[i] = (LL) pw[i - 1] * 2 % MOD;\n\n\tfor (int i = 1; i <= M; ++i)\n\t{\n\t\tint x = Que[i].l, y = Que[i].r, k = Que[i].id;\n\t\tint all = N - get_dis (x, y);\n\n\t\tif (Ans[i].query (k)) printf(\"%d\\n\", pw[all - Ans[i].cnt]);\n\t\telse puts(\"0\");\n\t}\n}\n\ninline void Input ()\n{\n\tN = read<int>(), M = read<int>();\n\tfor (int i = 1; i < N; ++i)\n\t{\n\t\tint x = read<int>(), y = read<int>();\n\t\tG[x].pb (y);\n\t\tG[y].pb (x);\n\t}\n\tfor (int i = 1; i <= N; ++i) W[i] = read<int>();\n}\n\n\nint main()\n{\n\n#ifdef hk_cnyali\n\tfreopen(\"celebration.in\", \"r\", stdin);\n\tfreopen(\"celebration.out\", \"w\", stdout);\n#endif\n\n\n\tInput ();\n\tSolve ();\n\n\treturn 0;\n}\n\n```\n\n</details>\n\n## 10-20\n\n### Process\n\n花了将近一个小时才写完T1，不知道怎么回事看错了数据范围，把3e5看成2e5了，炸成$50$。T2花了一点时间，大概在11:20左右拍上了。T3没来得及写\n\n### T1\n\n发现$n>7$时肯定能凑出来0，直接输出，否则爆搜\n\n### T2\n\n[KMP] [二分] [Hash]\n\n总方案减去重复的\n\n对于$t$的每个前缀，求出其在$s$中的出现次数`prefix[i]`(二分哈希求)。再对$t$串kmp一下，此时多算的部分就是`prefix[i - fail[i]]`\n\n\n### T3\n\n[动态规划] [直径] [树]\n\n> sol from GC\n\n把一条边删掉后，连边后树的最长链要么是两个连通块内的最长链，要么就会过加上的这条边，而这条边的端点一定是两个连通块最长链的**中点(加权中点)**。\n\n只需要考虑最长链上的边，因为其他边删掉后答案是原直径\n\n枚举最长链上的每条边 $(u, v)$ \n\n* 对于第一种情况，沿着链正反两次树形 dp 就可以解决。\n\n* 对于第二种情况，分开对断边后形成的两个联通块进行考虑，链上的点 $a$ 作为新边端点时，其所在联通块内以它为根的最长链为\n\n\t1. 它到原最长链端点\n\n\t2. 它往 $(u,v)$ 方向走并在中途转向叶子结点 \n\n  这两种情况中的较大值，而我们要最小化这个。可以发现随着 $(u,v)$ 的变化，最优点 $a$ 的变化是单调的，所以预处理链上每个结点到叶子的最长路，求链上每条边两端联通块的最优点 $a$ ，再连起来与第一种情况的答案 chkmax 即可。\n\n时间复杂度 $O(n)$, 具体细节见代码吧\n\n<details>\n\n<summary> Code </summary>\n\n```cpp\n\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n#define DEBUG(x) cout << #x << \" = \" << x << endl;\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int MAXN = 2e6;\nconst int MAXM = 4e6;\nconst int MOD = 998244353;\n\nint N, e = 1, Begin[MAXN + 5], To[MAXM + 5], Next[MAXM + 5], W[MAXM + 5];\n\ninline void add_edge (int x, int y, int z) { To[++e] = y; Next[e] = Begin[x]; Begin[x] = e; W[e] = z; }\n\nnamespace INPUT\n{\n\ttypedef unsigned long long ULL;\n\tint B,D;\n\tULL num;\n\tinline ULL get ()\n\t{\n\t\tnum ^= (num << 13);\n\t\tnum ^= (num >> 17);\n\t\tnum ^= (num << 5);\n\t\treturn num;\n\t}\n\tinline void gen() \n\t{\n\t\tscanf(\"%d%llu%d%d\",&N,&num,&B,&D);\n\t\tfor (int i = 2; i <= N; ++i)\n\t\t{\n\t\t\tint a = get() % min (i - 1, B) + i - min (i - 1, B);\n\t\t\tint b = get() % D;\n\t\t\tadd_edge (a, i, b);\n\t\t\tadd_edge (i, a, b);\n\t\t}\n\t}\n}\n\nnamespace DIAMETER\n{\n\tint o;\n\tLL maxdep;\n\n\tinline void dfs (int x, int f, LL d)\n\t{\n\t\tif (Chkmax (maxdep, d)) o = x;\n\n\t\tfor (int i = Begin[x]; i; i = Next[i])\n\t\t{\n\t\t\tint y = To[i];\n\t\t\tif (y == f) continue;\n\t\t\tdfs (y, x, d + W[i]);\n\t\t}\n\t}\n\n\tint stk[MAXN + 5], top;\n\tint stk_id[MAXN + 5], top_id;\n\tint D[MAXN + 5], Id[MAXN + 5];\n\n\tinline void dfs_path (int x, int t, int f)\n\t{\n\t\tif (D[0]) return ;\n\t\tstk[++top] = x;\n\n\t\tif (x == t)\n\t\t{\n\t\t\tint _top = top;\n\t\t\twhile (_top) D[++D[0]] = stk[_top--];\n\t\t\t_top = top_id;\n\t\t\twhile (_top) Id[++Id[0]] = stk_id[_top--];\n\t\t\treturn ;\n\t\t}\n\n\t\tfor (int i = Begin[x]; i; i = Next[i])\n\t\t{\n\t\t\tint y = To[i];\n\t\t\tif (y == f) continue;\n\n\t\t\tstk_id[++top_id] = i >> 1;\n\t\t\tdfs_path (y, t, x);\n\t\t\t--top_id;\n\t\t}\n\n\t\t--top;\n\t}\n\n\tinline void work ()\n\t{\n\t\to = maxdep = 0; dfs (1, 0, 0);\n\t\tint p = o; \n\t\tmaxdep = 0; dfs (o, 0, 0);\n\t\tdfs_path (p, o, 0);\n\t}\n}\n\nusing DIAMETER :: D;\nusing DIAMETER :: Id;\n\nint is_key[MAXN + 5];\nLL dis[2][MAXN + 5], to_leaf[2][MAXN + 5]; // dis: 到直径端点的距离，to_leaf: 到最远的叶子的距离\nLL f[2][MAXN + 5], g[2][MAXN + 5]; // f: 子树内直径, g: 以它为端点的直径\n\ninline void dfs (int x, int fa, int op)\n{\n\tLL max = 0, sec = 0;\n\tfor (int i = Begin[x]; i; i = Next[i])\n\t{\n\t\tint y = To[i];\n\n\t\tif (y == fa) continue;\n\n\t\tdfs (y, x, op);\n\n\t\tif (is_key[x] && is_key[y]) dis[op][x] = dis[op][y] + W[i];\n\t\tif (!is_key[y]) Chkmax (to_leaf[op][x], to_leaf[op][y] + W[i]);\n\n\t\tChkmax (f[op][x], f[op][y]);\n\t\tif (g[op][y] + W[i] > max) sec = max, max = g[op][y] + W[i];\n\t\telse if (g[op][y] + W[i] > sec) sec = g[op][y] + W[i];\n\t}\n\n\tChkmax (f[op][x], max + sec);\n\tg[op][x] = max;\n}\n\nLL Ans[MAXN + 5];\n\ninline void Solve ()\n{\n\tDIAMETER :: work ();\n\tfor (int i = 1; i <= D[0]; ++i) is_key[D[i]] = 1;\n\n\tdfs (D[D[0]], 0, 0);\n\tdfs (D[1], 0, 1);\n\n\tstatic LL diam[2][MAXN + 5], _max;\n\t\n#define calc(a) max(dis[0][D[a]], _max - dis[0][D[a]])\n\tfor (int i = 1, a = 1; i < D[0]; ++i)\n\t{\n\t\tint x = D[i];\n\t\tChkmax (_max, dis[0][x] + to_leaf[0][x]);\n\t\twhile (a < i && calc (a) > calc (a + 1)) ++a;\n\t\tdiam[0][x] = calc (a);\n\t}\n\t\n#undef calc\n#define calc(a) max(dis[1][D[a]], _max - dis[1][D[a]])\n\t_max = 0;\n\tfor (int i = D[0], a = D[0]; i > 1; --i)\n\t{\n\t\tint x = D[i];\n\t\tChkmax (_max, dis[1][x] + to_leaf[1][x]);\n\t\twhile (a > i && calc (a) > calc (a - 1)) --a;\n\t\tdiam[1][x] = calc (a);\n\t}\n\n#undef calc\n\n\tfor (int i = 1; i < N; ++i) Ans[i] = DIAMETER :: maxdep;\n\tfor (int i = 1; i < D[0]; ++i)\n\t{\n\t\tint x = D[i], y = D[i + 1], id = Id[i];\n\t\tAns[id] = max (max (f[0][x], f[1][y]), diam[0][x] + diam[1][y] + W[id << 1]);\n\t}\n\n\tLL ans = 0;\n\tfor (int i = 1; i < N; ++i) ans ^= (LL) i * (Ans[i] % MOD) % MOD;\n\n\tcout << ans << endl;\n}\n\ninline void Input () { INPUT :: gen (); }\n\nint main ()\n{\n\n\tfreopen(\"path.in\", \"r\", stdin);\n\tfreopen(\"path.out\", \"w\", stdout);\n\n\tInput ();\n\tSolve ();\n\n\treturn 0;\n}\n\n```\n\n</details>\n\n## 10-21\n\n### Process\n\n这场考得比较正常，T1T2都比较简单，T2写了个无脑李超树，T3考场上只会暴力，但实际上也不难\n\n### T1\n\n要么取左端点要么取右端点\n\n### T2\n\n[kruskal重构树] [李超线段树]\n\n首先按点权从大到小建出kruskal重构树，对于每个 $\\min\\{a_i\\}$ 求出最大的$n$。也就是求出来了若干个函数$f(x) = kx+b$，每次询问一个$x$，求所有函数的最大值。无脑李超树即可\n\n### T3\n\n[线段树] [数据结构] [前缀和]\n\n![19-10-23-1](/images/19-10-23-1.png)\n\n* 这个做法本质上是在优化暴力，即先从前往后考虑一次，再从后往前考虑一次\n\n* $t_i = s_i + s_{l - 1} - \\min\\{s_j\\}$，它的意义为，正着考虑完一遍$[l, r]$后的**前缀和**数组。$\\max\\{t_i - t_r\\}$实际上就是要求每个后缀合法\n\n* 设 $ans$ 表示$[l - 1, r]$中选出两个数使右边的减左边的最大的结果，那么 \n  \n  $$\n\n  \\begin{aligned}\n  &\\max\\{t_i - t_r\\} \\\\\n  =& \\max\\{t_i\\} - t_r \\\\\n  =& \\big(s_{l - 1} + ans \\big) - \\big(s_r + s_{l - 1} + \\min\\{s_i\\}\\big) \\\\\n  =& ans - s_{r} + \\min\\{s_i\\}\n  \\end{aligned}\n  $$\n\n  又因为答案还要加上$s_{l - 1} - \\min\\{s_i\\}$，所以最后剩下 $ans - s_r + s_{l - 1}$\n\n## 10-22\n\n### Process\n\n这场打自闭了，搞了几乎一整场的T1，写了个假的树套树做法，到快考完的时候才发现是错的。T2一开始想了个贪心没调出来（实际上就是正解，只是细节有问题），后来搞了个乱搞A了。T3题都没看\n\n### T1\n\n[线段树] [二分]\n\n考虑依次确定每个位置的值。预处理出最大得分，那么当前这个位置填$>a_i$的数时，合法区间是一段前缀；填$\\le a_i$的数时，合法区间也是一段前缀，于是可以二分。\n\n如何快速判断是否合法？\n\n把所有数（$a_i, b_i$）一起排序，按顺序建线段树。统计每个区间中有多少个$a_i$，多少个$b_i$，尽量多地在底层合并。 只需要支持单点修改。\n\n<details>\n<summary> 大概是这个意思 </summary>\n\n```cpp\ninline void push_up (int o)\n{\n\tint res = min (node[ls].sum[0], node[rs].sum[1]);\n\tnode[o].ans = node[ls].ans + node[rs].ans + res;\n\tnode[o].sum[0] = node[ls].sum[0] + node[rs].sum[0] - res;\n\tnode[o].sum[1] = node[ls].sum[1] + node[rs].sum[1] - res;\n}\n```\n\n</details>\n\n### T2\n\n[树状数组] [贪心]\n\n按权值从小到大考虑每个数，每次取往左/往右更小的那边走，用树状数组维护位置。权值相等的数要一起考虑\n\n### T3\n\n[栈] [启发式合并] [堆]\n\n排序，栈建树，设 $f(i,j)$ 表示在以 $i$ 为根的子树内所选择的第 $j$ 层的最大权值和。显然对于确定的 $i$ 而言 $f(i,j)$ 单调递减，然后按照深度启发式合并，每次将子树的信息直接相加，再将根的权值丢入堆作为新增一层的抉择即可。\n\n## 10-23\n\n### Process\n\n今天考得比较正常，只是T1花的时间太长了，一个半小时才写完，开始一直卡在如何区间加等差数列上了，想半天才发现可以二阶差分。T2一开始只会暴力，一步步优化之后A了。T3没时间做了，就写了个暴力\n\n### T1\n\n[差分]\n\n动态维护答案，$(d - x)^2 = d^2 - 2dx + x^2$，分别维护这三项的和即可\n\n### T2\n\n[最短路] [FWT] [子集和DP]\n\n先对每个关键点求一遍单源最短路，那么我们就知道对于每个点而言，在某些关键点中**只要选了任意一个**，就不满足题意了\n \n然后补集转化，设 $F(S)$ 表示在只保留 $S$ 中的关键点的前提下一共有多少个点不可在 $T$ 时间内到达，然后就能子集和 DP 了，也可以FWT\n\n### T3\n\n考虑把操作倒过来，看作从$1\\sim n$的排列，入栈出栈后，能构成多少种不同的排列，且第$pos$位为$x$\n\n> 注意，需要将`pos = n - pos + 1, x = n - x + 1`\n\n定义$Catalan(n, m) = \\binom{n + m}{m} - \\binom{n + m}{m - 1}$, 它的意义为，用$n$个左括号，$m$个右括号能凑出多少种合法的括号序列（任意前缀左括号数$\\ge$右括号数）\n\n枚举位置在$pos$之前，且权值大于$x$的数的个数$i$，那么这$i$个数一定是$x + 1 \\sim x + i$（证明不难），即这$i$个数需要构成合法的括号序列，方案为$Catalan(i, i)$。剩下在$pos$前的数中，还剩下$pos - i - 1$个数，它们的权值比$x$要小。而在$x$之前已经有$x-1$个数入栈了，所以相当于要求$x-1$个左括号，$pos - i - 1$个右括号能构成多少种括号序列，方案数为$Catalan(x - 1, pos - i - 1)$\n\n最后考虑位置在$pos$后的数，它们有一部分的权值比$x$小，一部分比$x$大。那么相当于钦定了一部分左括号放在最前面，并且后面有一些任意填的左括号和右括号需要组合。所以最后这一部分可以倒着考虑，即先不考虑权值比$x$小的那些左括号，而是考虑剩下的右括号如何和左括号匹配。考虑完这些括号之后，权值比$x$小的那些左括号就自然匹配上了。方案数为$Catalan (n - pos, n - x - i)$\n\n<details>\n<summary> Code </summary>\n\n```cpp\nint ans = 0;\npos = n - pos + 1, x = n - x + 1;\nfor (int i = 0; i <= n; ++i)\n\tADD (ans, (LL) Catalan (i, i) * Catalan (x - 1, pos - 1 - i) % MOD * Catalan (n - pos, n - x - i) % MOD);\ncout << ans << endl;\n```\n\n</details>\n\n## 10-24\n\n### Process\n\n今天题目中规中矩，都是中等偏简单一点的题目，感觉三道题都在考算法，会这个算法就能秒掉，不会就没了\n\n### T1\n\n[tarjan] [点双] [缩点]\n\n先`tarjan`求一遍点双，标记连接点双的环，若存在一条连接点双内的两点，且不在环上的边，则该点双不合法\n\n注意在点双内遍历出边时，不能遍历割点的出边，因为割点可能被算多次复杂度。\n\n### T2\n\n[AC自动机] [矩阵快速幂] [动态规划]\n\nAC自动机模板题\n\n暴力DP是$dp[i][j]$表示到$i$节点，已经填了$j$个字母的答案。对AC自动机上每个点预处理fail树上所有祖先的权值和，直接转移即可\n\n然后显然可以矩乘优化，把普通矩乘的`*、+`变成`+、max`即可\n\n### T3\n\n[线段树] [线段树优化建边] [拓扑排序]\n\n暴力做法是对于这$k$个点，直接向$[l, r]$内的其他点连边，然后直接拓扑排序。线段树优化建边即可\n\n## 10-25\n\n### Process\n\n考得比较差，T2很简单的题想了很久才想出来，T3又没时间做了。时间分配上还是存在比较大的问题。只有20天了，赶快抓紧时间调整状态\n\n### T1\n\n枚举$c$，把$a * b$加到map中，每次查$\\frac{1}{c}$即可。需要注意**本质不同**相关的一些细节\n\n### T2\n\n[二分答案] [动态规划]\n\n把物品和背包从小到大排序，那么就是要在物品序列上选出尽量长的子序列满足题意\n\n因为背包一定是取一段后缀，所以可以先二分答案，转化成判定性问题，再贪心地对物品权值从小到大这个限制做dp即可\n\n### T3 \n\n[动态规划] [背包] \n\n设 $dp[i][j]$ 表示深度**至多**为$i$，由$j$个点构成的有根树的数目，答案就是$dp[i][n] - dp[i - 1][n]$\n\n考虑编号从大到小加点，每次相当于把若干个$i-1$的树选出来构成一个森林，再把当前点作为根把这片森林连起来\n\n显然选的过程可以用完全背包转移:\n\n假设当前有一个大小为$j$的森林$A$，要往其中加入一个大小为$k$的树$B$。钦定$B$的根的编号为$A、B$的所有点中最小的（否则会算重），然后只需要在$j + k - 1$个编号中选$k - 1$个给$B$的子树即可。因为$A$中编号的相对大小关系已经确定了（实际上本身它们的编号是确定的，不过是相对于$j$个点来说的，而现在需要扩展到$j + k$个点）\n\n<details>\n<summary> 代码长这样 </summary>\n\n```cpp\nfor (int j = 0; j <= N; ++j) if (g[j])\n\tfor (int k = 1; j + k <= N; ++k) if (dp[k])\n\t\tAdd (g[j + k], (LL) g[j] * dp[k] % MOD * C (j + k - 1, k - 1) % MOD);\n```\n\ng是临时转移数组。注意需要先枚举$j$再枚举$k$，因为用到的`g[j]`必须是完整的\n\n</details>\n\n## 10-26\n\n### Process\n\n考得还算正常，T1一开始没看清楚题，花了40分钟左右；T2是个已经烂大街的套路；T3题面写得太*，没看懂\n\n### T1\n\n直接差分即可\n\n### T2\n\n[高斯消元] [树上高消]\n\n根据树上高消的套路，把$f[x]$写成`f[x] = A[x] * f[fa] + B[x] * f[anc] + C[x]`的形式即可\n\n时间复杂度$O(n)$\n\n### T3\n\n看懂题意之后就变成sb题了\n\n题目就是要求满足$d = \\sum_{i = 1}^m |d - i| \\times \\frac{w_i}{\\sum w}$ 的$d$\n\n也就是$\\sum_{i = 1}^m |d - i| \\times w_i - \\sum w\\times d = 0$\n\n把它看成一个函数，发现当$d$增加的时候，前面那一堆的变化量小于等于后面的变化量，所以它是单调不升的，即可以二分\n\n因为$d$可能是小数，不好直接二分。但可以先二分$d$的整数部分，然后可以将绝对值去掉，再直接解一个一元一次方程\n\n用树状数组动态维护一下上面那个函数即可（维护$\\sum_{i=1}^d w_i$和$\\sum_{i=1}^d w_i * i$）\n\n## 10-27\n\n### Process\n\n被gc爆踩！T2睿智$n^2$DP居然想不出来。。。\n\n### T1\n\n[容斥]\n\n直接容斥，对列容斥，行的方案数可以直接算\n\n$$\nans = sum_{i} \\binom{n}{i} (2^i - 1) ^ m\n$$\n\n### T2\n\n[动态规划] [k-d tree]\n\n考场降智。显然每个点最多被两条线段覆盖。区间按右端点排序，$dp[i][j]$表示放到第$i$个区间，上一个放的区间为$j$的答案，暴力转移是$O(n^3)$的，前缀最小值优化即可，复杂度$O(n^2)$\n\n我考场上的做法是不记第二维状态，而是记录到DP的值中，但是这是错的，但在外面套一个二分就对了。然后里面的dp就变成了一个二维数点，KDT即可。复杂度$O(n \\log n \\sqrt n)$的\n\n### T3\n\n咕咕咕\n\n## 10-28\n\n### Process\n\n爆零了，T2睿智题考场上想复杂了~~其实是没想清楚~~，调到考试结束才调出来\n\n### T1\n\n扫雷大模拟\n\n### T2\n\n[dsu on tree] [启发式合并]\n\n我的做法可以对每个$u$求出答案，但是做法很复杂~~现在也想不清了~~\n\n![19-10-29-1](/images/19-10-29-1.png)\n\n判断`子树/挖掉子树是否可行`可以dsu on tree，求最长路径直接换根dp\n\n### T3\n\n咕咕咕\n\n## 10-29\n\n### Process\n\n肝了一整场T1，一开始没想清楚导致最后没调出来\n\n### T1\n\n[概率和期望] [毒瘤]\n\n期望很好算，根据期望的线性性直接算每个格子的期望，再求和即可\n\n> 具体计算方法：\n> 设$a$为它周围的空位数量，$b$为它周围的雷的数量，则它的贡献为\n> $$\n\t\\sum_{i=0} ^ {a} \\binom{a}{i} \\binom{n * m - k - a - 1}{w - k - i} \\times (b + i)\n> $$\n\n方差还是转化成平方期望减期望平方，平方期望的式子直接拆开：\n\n$$\nE\\big((\\sum_{i=1}^{n}x_i)^2\\big) = \\sum_{i=1}^{n}\\sum_{j=1}^{n}E(x_ix_j)\n$$\n\n只要快速计算$E(x_ix_j)$即可\n\n发现$x_ix_j$不独立，不能拆开，只能合一起算。具体计算方法与求期望方法类似，详见代码\n\n直接这样做是$O((nm)^2)$的，预处理一些东西，再动态维护一些东西就能做到$O(nm)$了，细节就不具体展开了。。。\n\n### T3\n\n[字符串] [AC自动机]\n\n建出trie，发现trie树上只要有祖孙关系的两点一定不能同时选\n\n先考虑前缀两两不包含的情况，那么求出trie树的深度就是答案（同一深度的点可以同时选）\n\n若前缀有包含，建出`AC自动机`后，在trie树的基础上，从`fail[x]`向`x`连边，求DAG最长链即为答案。（因为fail链上的点不能同时选）\n\n<details>\n<summary> Solution </summary>\n![19-10-29-2](/images/19-10-29-2.png)\n</details>\n\n## 10-30\n\n### Process\n\nT1很快写完，然后就在搞T3，搞了很久搞了89分。T2没什么思路\n\n### T1\n\n[线段树] [set]\n\n直接暴力做，把相同的一起做即可。复杂度可以均摊分析。\n\n写的时候再一次用线段树代替了set，细节少很多\n\n### T2\n\n[树]\n\n维护答案集合（有人的点的集合），发现每次会把叶子缩起来（还有可能新加一个点），模拟一下这个过程即可\n\n### T3\n\n[组合数学] [打表]\n\n考虑一些子问题：\n\n* $(0, 0)$走到$(n, m)$的方案数：$\\displaystyle G(n, m) = \\binom{n + m}{n}$\n\n* $(0, 0)$走到第$n$行第$i$列($i \\le m$)的方案和：$\\displaystyle \\sum_{i=0}^{m} G(n, i) = G(n + 1, m)$\n\n* $(0, 0)$走到第$i$行第$j$列($i \\le n, j \\le m$)的方案和：$\\displaystyle \\sum_{i=0}^{n} \\sum _{j = 0} ^{m} G(i, j) = G(n + 1, m + 1) - 1$\n\n* $(0, 0)$走到矩形$(x_1, y_1), (x_2, y_2)$的方案和：$\\displaystyle \\sum_{i=x_1}^{x_2} \\sum _{j = y_1} ^{y_2} G(i, j) = G(x_2 + 1, y_2 + 1) - G(x_2 + 1, y_1) - G(x_1, y_2 + 1) + G(x_1, y_1)$\n\n那么在不考虑矩形B的情况下，从矩形A走到矩形C的方案数就可以利用上面最后一个式子，通过$O(16)$枚举两个矩形的边界计算\n\n考虑在此基础上计算经过矩形B的方案数，枚举在走的过程中先碰到矩形B的哪个点，发现只可能在左边界或下边界上，因为这个范围很小所以可以直接暴力枚举统计\n\n最后再优化一下组合数，分块打表就能通过了\n\n## 10-31\n\n### Process\n\n开场先找了T2的规律，然后去写T3的部分分，本来想写个乱搞的，结果想着想着就想出来正解了。T1最后十几分钟看了下，发现和xcy之前讲的那道题很像，但想不清正确性，最后没时间了就还是贴了个上去，没想到A掉了。。。\n\n### T1\n\n就是[这道题](https://hk-cnyali.com/2019/08/27/%E3%80%8CBZOJ2138%E3%80%8Dstone-Hall%E5%AE%9A%E7%90%86-%E7%BA%BF%E6%AE%B5%E6%A0%91/)，只不过这里先按$g$从大到小排个序就行了\n\n### T2\n\n通过找规律发现$D(n, k) = \\sum_{i=0}^{k}\\binom{n}{i}$，组合数随便拆开算算就行了\n\n### T3\n\n按P的顺序去填A，贪心填就行了（讲不清楚，不如看代码）\n\n<details>\n<summary> Code </summary>\n```cpp\nfor (int i = 1; i <= N; ++i) A[P[i]] = - (N - i + 1);\n\nfor (int i = 1; i <= N; ++i)\n\tif (K > (Q[i] - 1)) K -= Q[i] - 1, B[Q[i]] = 0;\n\telse\n\t{\n\t\tputs(\"Yes\");\n\n\t\tstatic int buc[MAXN + 5];\n\t\tfor (int j = 1; j < Q[i]; ++j) buc[j] = -A[j];\n\t\tnth_element (buc + 1, buc + K, buc + Q[i], greater <int>());\n\t\tB[Q[i]] = buc[K] - 1;\n\n\t\tfor (int j = i + 1; j <= N; ++j) B[Q[j]] = N;\n\n\t\tfor (int j = 1; j <= N; ++j) printf(\"%d \", A[j]); puts(\"\");\n\t\tfor (int j = 1; j <= N; ++j) printf(\"%d \", B[j]); puts(\"\");\n\t\texit (0);\n\t}\n```\n</details>\n\n","categories":["Summary"],"tags":["卷积","容斥","Summary","动态规划","最短路","tarjan","缩点","构造","二分答案","二分图匹配","线段树","数据结构","并查集","堆","贪心","树状数组","主席树","点双","倍增","计数","set","差分","概率和期望","栈","树","FWT","KMP","NTT","bfs","Hash","2-SAT","二分","分治","博弈","图论","打表","搜索","方差","毒瘤","直径","背包","bitset","区间dp","数位dp","树形DP","SG函数","k-d tree","仙人掌","前缀和","字符串","扫描线","神仙题","线性基","CDQ分治","子集和DP","AC自动机","dsu on tree","拓扑排序","整除分块","时光倒流","树上高消","树链剖分","组合数学","长链剖分","高斯消元","二进制拆分","启发式合并","最小生成树","李超线段树","矩阵快速幂","记忆化搜索","kruskal重构树","线段树优化建边"]},{"title":"「CometOJ」模拟赛测试 Day2","url":"/2019/09/29/%E3%80%8CCometOJ%E3%80%8D%E6%A8%A1%E6%8B%9F%E8%B5%9B%E6%B5%8B%E8%AF%95-Day2-Solution/","content":"","categories":["Problem"],"tags":["动态规划","计数","状态压缩","组合数学","Trie"]},{"title":"「51nod 1824」染色游戏 + Lucas定理 + 子集卷积 + FWT","url":"/2019/09/26/%E3%80%8C51nod%201824%E3%80%8D%E6%9F%93%E8%89%B2%E6%B8%B8%E6%88%8F-Lucas%E5%AE%9A%E7%90%86-%E5%AD%90%E9%9B%86%E5%8D%B7%E7%A7%AF-FWT/","content":"\n有$n$个红球，$m$个蓝球，从中选出$x$个红球和$y$个蓝球排成一排的得分是$a_x \\cdot b_y$，其中$a_0 = b_0  = 1$\n\n设$f(t)$表示恰好取出$t$个球排成一排的所有局面的得分之和\n\n> 两个局面相同，当且仅当这两排球的个数相等，且在对应列位置上的颜色都是相同的\n\n求所有满足$f(t)$为奇数的$t^2$之和\n\n$n, m\\le 2^{20}$\n\n<!--more-->\n\n### Link\n\n[51nod 1824](https://www.51nod.com/Challenge/Problem.html#problemId=1824)\n\n### Solution\n\n就是要求：\n$$\nf(t) = \\sum_{i=0}^{t}\\binom{t}{i}a_ib_{t - i} \\bmod 2\n$$\n第一反应是直接卷，但是模2肯定不能FFT\n\n根据`Lucas定理`，$\\displaystyle \\binom{n}{m}$在模$2$意义下的值就是$n$和$m$二进制下每一位的组合数相乘\n\n因此，$\\displaystyle \\binom{n}{m}\\bmod 2 = [m\\subseteq n]$\n\n那么原式就变成了\n$$\nf(t) = \\sum_{i\\subseteq t}a_ib_{t - i}\n$$\n这就是子集卷积的形式了\n\n但是这里$n + m$有$2^{21}$，直接$O(n\\log^2 n)$的子集卷积是过不了的。\n\n提两个改动比较大的优化：\n\n* `DWT`中因为`(x + y) % MOD`和`(y - x + MOD) % MOD`在模2意义下都是`x ^ y`，所以可以放一起写\n\n* 压位，从$O(n\\log^2 n)$优化到$O(n \\log n)$\n\n  把原来需要开`f[21][2^21]`的数组的信息压到`f[2^21]`中，即把第一维压到值里（因为原本的值只有0/1）这样做并不会影响`DWT`的运算，因为有了上一个优化后，`DWT`是按位异或的\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n#define DEBUG(x) cout << #x << \" = \" << x << endl;\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int Maxn = ((1 << 20) << 1) + 5;\n\nint N, M;\nint A[Maxn], B[Maxn];\n\ninline void DWT (int *A, int n)\n{\n\tfor (int mid = 1; mid < n; mid <<= 1)\n\t\tfor (int i = 0, len = mid << 1; i < n; i += len)\n\t\t\tfor (int j = i; j < i + mid; ++j)\n\t\t\t\tA[j + mid] = A[j] ^ A[j + mid];\n}\n\nint cnt[Maxn], pw2[Maxn];\n\ninline void Solve ()\n{\n\tstatic int f[Maxn], g[Maxn], h[Maxn];\n\n\tint n = 1, lg = 0; pw2[0] = 1;\n\twhile (n <= N + M) n <<= 1, pw2[++lg] = n;\n\n\tfor (int i = 1; i < n; ++i) cnt[i] = cnt[i >> 1] + (i & 1);\n\n\tfor (int i = 0; i <= N; ++i) if (A[i] & 1) f[i] = pw2[cnt[i]];\n\tfor (int i = 0; i <= M; ++i) if (B[i] & 1) g[i] = pw2[cnt[i]];\n\n\tDWT (f, n), DWT (g, n);\n\n\tfor (int S = 0; S < n; ++S)\n\t\tfor (int j = 0; j <= lg; ++j) if ((f[S] >> j) & 1)\n\t\t{\n\t\t\tfor (int i = j; i <= lg; ++i)\n\t\t\t\tif ((g[S] >> (i - j)) & 1)\n\t\t\t\t\th[S] ^= pw2[i];\n\t\t}\n\n\tDWT (h, n);\n\n\tLL ans = 0;\n\tfor (int i = 1; i < n; ++i)\n\t\tif (h[i] & pw2[cnt[i]])\n\t\t\tans += (LL) i * i;\n\n\tcout << ans << endl;\n}\n\ninline void Input ()\n{\n\tN = read<int>(), M = read<int>();\n\n\tstatic char S[Maxn];\n\tscanf(\"%s\", S + 1);\n\tfor (int i = 1; i <= N; ++i) A[i] = S[i] - '0';\n\tscanf(\"%s\", S + 1);\n\tfor (int i = 1; i <= M; ++i) B[i] = S[i] - '0';\n\tA[0] = B[0] = 1;\n\n}\n\nint main()\n{\n\n#ifdef hk_cnyali\n\tfreopen(\"A.in\", \"r\", stdin);\n\tfreopen(\"A.out\", \"w\", stdout);\n#endif\n\n\tInput ();\n\tSolve ();\n\n\treturn 0;\n}\n\n```\n\n","categories":["Problem"],"tags":["FWT","多项式","Lucas","子集卷积"]},{"title":"「WC2018」州区划分 - 状压dp + 子集卷积 + FWT","url":"/2019/09/25/%E3%80%8CWC2018%E3%80%8D%E5%B7%9E%E5%8C%BA%E5%88%92%E5%88%86-%E7%8A%B6%E5%8E%8Bdp-%E5%AD%90%E9%9B%86%E5%8D%B7%E7%A7%AF-FWT/","content":"\n![19-9-25-3](/images/19-9-25-3.png)\n\n<!--more-->\n\n### Link\n\n[LOJ 2340](https://loj.ac/problem/2340)\n\n### Solution\n\n考虑状压$dp$\n\n设$F_{S}$表示$S$集合的答案，$W_S$表示$S$集合中的点权和，$G_S = [S~is~valid]W_S$，枚举最后加进去的集合$T$，那么有\n$$\n\\begin{aligned}\nF_S &= \\sum_{T\\subseteq S, T\\ne \\emptyset} \\frac{G_{T}}{W_S}\\cdot F_{S - T}\\\\\n\t&= \\frac{1}{W_S}\\sum_{T\\subseteq S, T\\ne \\emptyset} G_{T}\\cdot F_{S - T}\\\\\n\\end{aligned}\n$$\n显然可以子集卷积\n\n具体在判断一个集合是否合法的时候注意要判所有度数为偶数和联通性\n\n然后这里的子集卷积必须每次都`IDWT`出来，除掉$W_S$之后再`DWT`回去。。。\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n#define DEBUG(x) cout << #x << \" = \" << x << endl;\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int Maxn = 21 + 5, Maxs = (1 << 21) + 5;\nconst int Mod = 998244353;\n\nnamespace MATH\n{\n\tinline void Add (int &a, int b) { if ((a += b) >= Mod) a -= Mod; }\n\n\tinline int Pow (int a, int b)\n\t{\n\t\tint ans = 1;\n\t\tfor (int i = b; i; i >>= 1, a = (LL) a * a % Mod) if (i & 1) ans = (LL) ans * a % Mod;\n\t\treturn ans;\n\t}\n}\n\nusing namespace MATH;\n\nint N, M, P, ALL;\nint G[Maxn], W[Maxs], IW[Maxs];\nint f[Maxn][Maxs], g[Maxn][Maxs];\n\nnamespace DSU\n{\n\tint fa[Maxn];\n\tinline void init () { for (int i = 0; i < N; ++i) fa[i] = i; }\n\tinline int get_fa (int x) { return fa[x] == x ? x : fa[x] = get_fa (fa[x]); }\n\tinline void link (int x, int y) { fa[get_fa (x)] = get_fa (y); }\n}\n\ninline int check (int S)\n{\n\tstatic int deg[Maxn];\n\tfor (int i = 0; i < N; ++i) deg[i] = 0;\n\tDSU :: init ();\n\n\tfor (int i = 0; i < N; ++i) if (S & (1 << i)) \n\t\tfor (int j = i + 1; j < N; ++j) if ((S & (1 << j)) && (G[i] & (1 << j)))\n\t\t\tDSU :: link (i, j), ++deg[i], ++deg[j];\n\n\tint cnt = 0;\n\tfor (int i = 0; i < N; ++i) if ((1 << i) & S)\n\t{\n\t\tif (DSU :: fa[i] == i) ++cnt;\n\t\tif (deg[i] & 1) return 1;\n\t}\n\tif (cnt > 1) return 1;\n\treturn 0;\n}\n\ninline void Init ()\n{\n\tALL = (1 << N) - 1;\n\tfor (int i = 1; i <= ALL; ++i)\n\t{\n\t\tint p = i & (-i);\n\t\tW[i] = (W[i ^ p] + W[p]) % Mod;\n\t}\n\n\tfor (int i = 0; i <= ALL; ++i)\n\t{\n\t\tW[i] = Pow (W[i], P);\n\t\tIW[i] = Pow (W[i], Mod - 2);\n\n\t\tint len = __builtin_popcount (i);\n\t\tif (check (i)) g[len][i] = W[i];\n\t}\n}\n\ninline void DWT (int *A, int n, int fg)\n{\n\tfor (int mid = 1; mid < n; mid <<= 1)\n\t\tfor (int i = 0, len = mid << 1; i < n; i += len)\n\t\t\tfor (int j = i; j < i + mid; ++j)\n\t\t\t{\n\t\t\t\tint x = A[j], y = A[j + mid];\n\t\t\t\tif (!fg) A[j + mid] = (x + y) % Mod;\n\t\t\t\telse A[j + mid] = (y - x + Mod) % Mod;\n\t\t\t}\n}\n\ninline void Solve ()\n{\n\tInit ();\n\n\tf[0][0] = 1;\n\tDWT (f[0], 1 << N, 0);\n\tfor (int i = 0; i <= N; ++i) DWT (g[i], 1 << N, 0);\n\n\tfor (int i = 1; i <= N; ++i)\n\t{\n\t\tfor (int j = 0; j < i; ++j)\n\t\t\tfor (int S = 0; S <= ALL; ++S)\n\t\t\t\tAdd (f[i][S], (LL) f[j][S] * g[i - j][S] % Mod);\n\n\t\tDWT (f[i], 1 << N, 1);\n\t\t\n\t\tfor (int S = 0; S <= ALL; ++S) f[i][S] = (LL) f[i][S] * IW[S] % Mod;\n\n\t\tDWT (f[i], 1 << N, 0);\n\t}\n\n\tDWT (f[N], 1 << N, 1);\n\tprintf(\"%d\\n\", f[N][ALL]);\n}\n\ninline void Input ()\n{\n\tN = read<int>(), M = read<int>(), P = read<int>();\n\tfor (int i = 1; i <= M; ++i)\n\t{\n\t\tint x = read<int>() - 1, y = read<int>() - 1;\n\t\tG[x] |= (1 << y);\n\t\tG[y] |= (1 << x);\n\t}\n\tfor (int i = 0; i < N; ++i) W[1 << i] = read<int>();\n}\n\nint main()\n{\n\n#ifdef hk_cnyali\n\tfreopen(\"A.in\", \"r\", stdin);\n\tfreopen(\"A.out\", \"w\", stdout);\n#endif\n\n\tInput ();\n\tSolve ();\n\n\treturn 0;\n}\n\n```\n\n","categories":["Problem"],"tags":["状态压缩","FWT","生成函数","多项式","子集卷积"]},{"title":"「Algorithm」FWT学习笔记","url":"/2019/09/24/%E3%80%8CAlgorithm%E3%80%8DFWT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"\n参考了hometown的课件和xcy的笔记\n\n<!--more-->\n\n## Perface\n\nFWT主要是用来快速计算$\\displaystyle c_i = \\sum_{j\\otimes k = i}a_j\\times b_k$，其中$\\otimes\\in \\{and, or, xor\\}$\n\n在普通FFT中，这个运算符为+\n\n本质和FFT一样，也是把系数表达式转化成点值表达式，把对应位置的值相乘相加，再转回系数表达式\n\n## Algorithm\n\n回想一下FFT的过程，我们实际上是给原式的每一项乘上了一个系数($\\omega_{n}^{ik}$)，使得$DFT(A)_i \\times DFT(B)_i = DFT(A * B)_i$（这里的$*$是卷积的意思）\n\n那在FWT中，我们就需要找到一个变化系数$f_{i, j}$，当$\\displaystyle DWT(A)_i = \\sum_{j=0}^{n-1}a_j\\times f_{i, j}$后，使得\n$$\nDWT(A)_i \\times DWT(B)_i = DWT(A\\otimes B)_i\n$$\n把式子代入，得到\n$$\n\\begin{aligned}\n\\Big(\\sum_{j}a_j\\times f_{i, j}\\Big) \\times \\Big(\\sum_{k}b_k\\times f_{i, k}\\Big) &= \\sum_{j}\\sum_{k}a_j\\otimes b_k\\times f_{i, j\\otimes k}\\\\\n\\Rightarrow f_{i, j}\\times f_{i, k} &= f_{i, j \\otimes k}\n\\end{aligned}\n$$\n\n### 构造系数\n\n- $\\otimes$为$and$（集合交卷积）：$f_{i, j} = [i \\& j= i]$（即$[i\\subseteq j]$）\n- $\\otimes$为$or$（集合并卷积）：$f_{i, j} = [i | j= i]$（即$[j\\subseteq i]$）\n- $\\otimes$为$xor$（集合对称差卷积）：$f_{i, j}=(-1)^{popcount(i\\&j)}$\n\n这样构造的巧妙之处在于，$f$可以把**每一位拆开算**，即$\\displaystyle f_{i, j} = \\prod f_{i_p, j_p}$其中$i_p$表示$i$二进制下第$p$位\n\n---\n\n### DWT\n\n设$i_0 = [i\\ge \\frac{n}{2}], i_1 = i \\bmod \\frac{n}{2}$（即$i_0$表示$i$的当前这一位，$i_1$表示$i$去掉当前这一位剩下的值）\n$$\n\\begin{align}\nDWT(A)_i&=\\sum_{j=0}^{n-1}f_{i, j}\\times a_j\\\\\n&=\\sum_{j=0}^{\\frac{n}{2}-1}f_{i, j}\\times a_j+\\sum_{j=\\frac{n}{2}}^{n-1}f_{i, j}\\times a_j\\\\\n&=\\sum_{j=0}^{\\frac{n}{2}-1}f_{i_0, 0}\\times f_{i_1, j}\\times a_j+\\sum_{j=\\frac{n}{2}}^{n-1}f_{i_0, 1}\\times f_{i_1, j - \\frac{n}{2}}\\times a_j\\\\\n&=f_{i_0, 0}\\times DWT(A_L)_{i_1} + f_{i_0, 1}\\times DWT(A_R)_{i_1}\n\\end{align}\n$$\n这样就让问题规模减半了。于是对于$i\\in[0, \\frac{n}{2})$：\n$$\n\\begin{align}\nDWT(A)_i&=f_{0,0}\\times DWT(A_L)_i+f_{0,1}\\times DWT(A_R)_i\\\\\nDWT(A)_{i+{n\\over 2}}&=f_{1,0}\\times DWT(A_L)_i+f_{1,1}\\times DWT(A_R)_i\n\\end{align}\n$$\n把四个$f$代进去，分治即可，最底层就是$f_{0, 0}\\times a_i$，而$f_{0, 0}$在$and, or, xor$时都是$1$，所以最底层就是原来$A$的每一项系数\n\n### IDWT\n\nDWT相当于从下往上合并，而IDWT就相当于从上往下解方程\n\n> 以异或为例:\n> $$\n> \\begin{align}\n> DWT(A)_i&=DWT(A_L)_i+DWT(A_R)_i\\\\\n> DWT(A)_{i+{n\\over 2}}&=DWT(A_L)_i-DWT(A_R)_i\n> \\end{align}\n> $$\n> 则可解出\n> $$\n> DWT(A_L)_i=\\frac{DWT(A)_i+DWT(A)_{i+{n\\over 2}}}{2}\\\\\n> DWT(A_R)_i=\\frac{DWT(A)_i-DWT(A)_{i+{n\\over 2}}}{2}\n> $$\n> 所以就有\n> $$\n> IDWT(A)_i=\\frac{IDWT(A_L)_i+IDWT(A_R)_i}{2}\\\\\n> IDWT(A)_{i + {n\\over 2}}=\\frac{IDWT(A_L)_i-IDWT(A_R)_i}{2}\n> $$\n\n### Notice\n\n注意，这里并不需要FFT中的二进制翻转。因为FFT中是按奇偶分治的，而FWT中就是直接左右分治\n\n并且一般FWT的题$n$都是$2$的整数次幂，不用补全\n\n\n\n### Code\n\n```cpp\n// operator is OR\ninline void DWT (int *A, int n, int op)\n{\n\tfor (int mid = 1; mid < n; mid <<= 1)\n\t\tfor (int i = 0, len = mid << 1; i < n; i += len)\n\t\t\tfor (int j = i; j < i + mid; ++j)\n\t\t\t{\n\t\t\t\tint x = A[j], y = A[j + mid];\n\t\t\t\tif (!op) A[j + mid] = (x + y) % Mod;\n\t\t\t\telse A[j + mid] = (y - x + Mod) % Mod;\n\t\t\t}\n}\n```\n\n\n\n\n\n## 子集卷积\n\n又称不相交集合并卷积，即给定$f, g$，求$h$满足：\n$$\n\\begin{align}\nh_S&=\\sum_{T\\subseteq S}f_T\\times g_{S- T}\\\\\n&=\\sum_{A\\subseteq U}\\sum_{B\\subseteq U}[A\\bigcup B=S][A\\bigcap B=\\phi]f_Ag_B\\\\\n&=\\sum_{A\\subseteq U}\\sum_{B\\subseteq U}[|A|+|B|=|S|][A\\bigcup B=S]f_Ag_B\\\\\n\\end{align}\n$$\n其实就是在集合并卷积的基础上，再记录一维表示集合的大小，这样就能保证两个集合不交了\n\n\n\n## [BZOJ4589 Hard Nim](https://darkbzoj.tk/problem/4589)\n\n### Description\n\nClaris和NanoApe在玩石子游戏，他们有$n$堆石子，规则如下：\n\n1.  Claris和NanoApe两个人轮流拿石子，Claris先拿。\n\n2. 每次只能从一堆中取若干个，可将一堆全取走，但不可不取，拿到最后$1$颗石子的人获胜。\n\n你需要求，若这$n$堆石子满足每堆石子的初始数量是不超过$m$的**质数**，而且他们都会按照最优策略玩游戏，那么NanoApe能获胜的局面有多少种。\n\n答案对$10^9 + 7$取模\n\n### Solution\n\n算是模板题吧\n\n设生成函数$\\displaystyle F(x) = \\sum_{k=0}^{m}[k~is~prime]x^k$表示一堆石子的状态\n\n因为先手必胜当且仅当所有石子异或和为$0$，所以在异或卷积的意义下，$\\displaystyle [x^0]F^n(x)$就是答案\n\n因为是异或运算意义下，长度不会增长，所以可以直接`DWT`后，对每个点值快速幂再`IDWT`回去\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n#define DEBUG(x) cout << #x << \" = \" << x << endl;\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int Maxn = 1e6 + 100;\nconst int Mod = 1e9 + 7;\n\nnamespace MATH\n{\n\tinline void Add (int &a, int b) { if ((a += b) >= Mod) a -= Mod; }\n\n\tinline int Pow (int a, int b)\n\t{\n\t\tint ans = 1;\n\t\tfor (int i = b; i; i >>= 1, a = (LL) a * a % Mod) if (i & 1) ans = (LL) ans * a % Mod;\n\t\treturn ans;\n\t}\n}\n\nusing namespace MATH;\n\nint N, M;\nint A[Maxn], Prime[Maxn];\n\ninline void Init ()\n{\n\tstatic bitset <Maxn> vis;\n\tN = 1e5;\n\tfor (int i = 2; i <= N; ++i)\n\t{\n\t\tif (!vis[i]) Prime[++Prime[0]] = i;\n\t\tfor (int j = 1; j <= Prime[0] && (LL) i * Prime[j] <= N; ++j)\n\t\t{\n\t\t\tvis[i * Prime[j]] = 1;\n\t\t\tif (!(i % Prime[j])) break;\n\t\t}\n\t}\n}\n\ninline void DWT (int *A, int n, int fg)\n{\n\tfor (int mid = 1; mid < n; mid <<= 1)\n\t{\n\t\tint len = mid << 1;\n\t\tfor (int i = 0; i < n; i += len)\n\t\t\tfor (int j = i; j < i + mid; ++j)\n\t\t\t{\n\t\t\t\tint x = A[j], y = A[j + mid];\n\t\t\t\tA[j] = (x + y) % Mod;\n\t\t\t\tA[j + mid] = (x - y + Mod) % Mod;\n\n\t\t\t\tif (fg)\n\t\t\t\t{\n\t\t\t\t\tA[j] = (LL) A[j] * (Mod + 1) / 2 % Mod;\n\t\t\t\t\tA[j + mid] = (LL) A[j + mid] * (Mod + 1) / 2 % Mod;\n\t\t\t\t}\n\t\t\t}\n\t}\n}\n\ninline void Solve ()\n{\n\tfor (int i = 1; i <= Prime[0]; ++i) \n\t\tif (Prime[i] <= M) A[Prime[i]] = 1; \n\t\telse break;\n\n\tint n; \n\tfor (n = 1; n <= M << 1; n <<= 1);\n\n\tDWT (A, n, 0);\n\tfor (int i = 0; i < n; ++i) A[i] = Pow (A[i], N);\n\tDWT (A, n, 1);\n\n\tprintf(\"%d\\n\", A[0]);\n\n\tfor (int i = 0; i < n; ++i) A[i] = 0;\n}\n\nint main()\n{\n\n#ifdef hk_cnyali\n\tfreopen(\"A.in\", \"r\", stdin);\n\tfreopen(\"A.out\", \"w\", stdout);\n#endif\n\n\tInit ();\n\twhile (scanf(\"%d%d\", &N, &M) != EOF)\n\t\tSolve ();\n\n\treturn 0;\n}\n\n```\n\n","categories":["Algorithm"],"tags":["FWT","多项式","子集卷积"]},{"title":"「CometOJ」Contest #11","url":"/2019/09/23/%E3%80%8CCometOJ%E3%80%8DContest-11/","content":"\n[Link](https://cometoj.com/contest/67)\n\n<!--more-->\n\n## Aeon\n\n显然字典序最大就是把最小的字母放在最后\n\n## Business\n\n[动态规划]\n\n简单dp\n\n$dp[i][j]$表示到第$i$天，当前有$j$块钱，最后返还的钱最多为多少\n\n完全背包转移\n\n## Celebration\n\n### Description\n\n有一个**环** $a[1\\dots n]$，求把它分成三段，使得每一段内无重复元素，且三段长度可以作为某个三角形的三边的方案数。\n\n一个拆分方案可以看作一个三元组 $(a,b,c)$，其中 $0\\lt a\\lt b \\lt c \\le n$，表示在第 $a,b,c$个位置之前断开。两个拆分不同当且仅当其对应的三元组不同。\n\n$n\\le 2\\times10^6$\n\n### Solution\n\n[计数] [树状数组]\n\n定义长度不超过 $\\frac{n-1}{2}$ ，且不含重复颜色的段为合法的段。记 $pre_x$ 为以$x − 1$ 为右端点的合法段最远的左端点，$nxt_x$ 为以 $x$ 为左端点的合法段最远的右端点。\n\n先枚举题目中的$a$，那么$b\\in(a, nxt_a + 1]$。在确定了$a, b$的位置后，合法的$c$位于$(b, nxt_b + 1]$和$[pre_a, n]$的交集中\n\n> 注意，这里的$pre_a$必须是大于$a$的，即绕了一圈绕到右边去。否则一定不合法\n\n可以用树状数组维护：\n\n从左往右枚举$a$，把合法的$b$对应的$(b, nxt_b + 1]$这段区间在树状数组中+1；查询就直接查$[pre_a, n]$的区间和；在离开$a$的时候把$(a, nxt_a + 1]$区间-1\n\n<details>\n<summary>Code</summary>\n\n```cpp\n\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n#define DEBUG(x) cout << #x << \" = \" << x << endl;\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int Maxn = 2e6 + 10;\n\nint N;\nint A[Maxn];\nint vis[Maxn];\nint L[Maxn], R[Maxn];\n\ninline int fix (int x) { return ((x - 1) % N + N) % N + 1; }\n\nnamespace BIT\n{\n\tstruct bit\n\t{\n\t\tLL sum[Maxn];\n\t\tinline void add (int x, int val) { for (; x <= N; x += x & (-x)) sum[x] += val; }\n\t\tinline LL query (int x) { LL ans = 0; for (; x; x -= x & (-x)) ans += sum[x]; return ans; } \n\t} A, B;\n\n\tinline void update (int x, int y, int val)\n\t{\n\t\tif (x > y) return ;\n\t\tA.add (x, val * x), A.add (y + 1, -val * (y + 1));\n\t\tB.add (x, val), B.add (y + 1, -val);\n\t}\n\t\n\tinline LL query (int x) { return B.query (x) * (x + 1) - A.query (x); }\n\t\n\tinline LL query (int x, int y) { if (x > y) return 0; return query (y) - query (x - 1); }\n}\n\ninline void Init ()\n{\n\tint r = 0;\n\tfor (int i = 1; i <= N; ++i)\n\t{\n\t\twhile (r < N && !vis[A[r + 1]]) ++r, ++vis[A[r]];\n\t\tR[i] = min (r, i + (N - 1) / 2 - 1);\n\t\tif (vis[A[i]]) --vis[A[i]];\n\t}\n\n\tmemset (vis, 0, sizeof vis);\n\tint l = 1;\n\twhile (!vis[A[fix (l - 1)]]) l = fix (l - 1), ++vis[A[l]];\n\tL[1] = fix (max (l, N - (N - 1) / 2 + 1));\n\t\n\tfor (int i = 2; i <= (N - 1) / 2; ++i)\n\t{\n\t\twhile (vis[A[i - 1]]) --vis[A[l]], l = fix (l + 1);\n\t\tif (l < i) break;\n\t\tL[i] = max (l, fix ((i - 1 + N) - (N - 1) / 2 + 1));\n\t\t++vis[A[i - 1]];\n\t}\n}\n\ninline void Solve ()\n{\n\tInit ();\n\n\tLL ans = 0;\n\tint\tp = 1;\n\tfor (int i = 1; i <= N; ++i)\n\t{\n\t\tif (L[i] < i) break;\n\t\twhile (p < N && p + 1 <= R[i] + 1)\n\t\t{\n\t\t\t++p;\n\t\t\tBIT :: update (p + 1, R[p] + 1, 1);\n\t\t}\n\t\tans += BIT :: query (L[i], N);\n\t\tBIT :: update ((i + 1) + 1, R[i + 1] + 1, -1);\n\t}\n\t\n\tcout << ans << endl;\n}\n\ninline void Input ()\n{\n\tN = read<int>();\n\tfor (int i = 1; i <= N; ++i) A[i] = read<int>();\n}\n\nint main()\n{\n\n#ifdef hk_cnyali\n\tfreopen(\"C.in\", \"r\", stdin);\n\tfreopen(\"C.out\", \"w\", stdout);\n#endif\n\n\tInput ();\n\tSolve ();\n\t\n\treturn 0;\n}\n\n```\n\n</details>\n\n\n## Disaster\n\n[kruskal重构树]\n\nkruskal重构树模板题\n\n## Effort\n\n### Description\n\n有 $m$种数据结构(可把数据结构想像成游戏中的种族)，第 $i$种有 $a_i$个，每个可给敌人造成至少 $1$ 次，至多 $b_i$次伤害。有$ n$名敌人，**每人承担至少一次伤害**。求总情况数模 $998244353$的值\n\n数据结构两两不同 (同种的任两个也不同)，敌人两两不同。\n\n两种方案不同当且仅当某个数据结构造成的伤害不同，或某个敌人受到的伤害不同。\n\n$n \\times m\\le 10^5, a_i\\le 10^5, b_i\\ < 998244353$\n\n### Solution\n\n[组合数学] [生成函数] [多项式] [NTT]\n\n注意到每个敌人的伤害是**无序**的，即这个敌人在被第几次攻击到都是一样的，而其他限制都是**有序**的\n\n于是可以钦定攻击顺序和受到伤害的顺序。形象地理解就是先把所有数据结构按顺序摆一排，确定每**个**数据结构攻击多少次，这样就确定出一个攻击序列。再在这个攻击序列上插$n-1$个板就是这个攻击序列方案数\n\n看上去这是由两个部分构成的（先确定攻击序列，再插板），但实际上可以同时算\n\n设$F_i(x)$表示**一个**第$i$种数据结构插板方案的生成函数，它的$k$次项系数表示插$k$个板的方案数。那么$\\displaystyle [x^k]F_i^{a_i}(x)$就是在第$i$种里插$k$个板的方案数了\n\n---\n\n考虑如何求$F_i(x)$\n\n第$k$项系数其实就是\n$$\n\\binom{1}{k} + \\binom{2}{k} + \\cdots + \\binom{b_i}{k}\n$$\n\n> 枚举这个数据结构攻击$t$次\n>\n> 那么就相当于有$t$个空位（最后一个位置也是空位，但最后一个数据结构不是，需要单独考虑），插$k$个板，就是$\\binom{t}{k}$\n\n发现除了$k=0$之外，都是是杨辉三角一列的之和，就等于$\\binom{b_i + 1}{k + 1}$\n\n因为$b_i$很大，不能直接算，但是$k$比较小，所以可以先$O(1)$计算出$k=1$时的值，然后$O(1)$递推下一个$k$的值\n\n---\n\n由于只有$n-1$个板，所以多项式长度始终不超过$n-1$。直接做多项式快速幂即可，再把$m$个多项式依次合起来\n\n<details>\n<summary>Code</summary>\n\n```cpp\n\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n#define DEBUG(x) cout << #x << \" = \" << x << endl;\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int Maxn = 5e5 + 100;\nconst int Mod = 998244353;\n\nnamespace MATH\n{\n\tinline void Add (int &a, int b) { if ((a += b) >= Mod) a -= Mod; }\n\n\tinline int Pow (int a, int b)\n\t{\n\t\tint ans = 1;\n\t\tfor (int i = b; i; i >>= 1, a = (LL) a * a % Mod) if (i & 1) ans = (LL) ans * a % Mod;\n\t\treturn ans;\n\t}\n}\n\nusing namespace MATH;\n\nint N, M;\nint A[Maxn], B[Maxn];\n\nnamespace Poly\n{\n\tint rev[Maxn], n;\n\tint _Wn[2][Maxn];\n\n\tinline void init ()\n\t{\n\t\tn = 5e5;\n\t\tfor (int mid = 1; mid <= n; mid <<= 1)\n\t\t{\n\t\t\t_Wn[0][mid] = Pow (3, (Mod - 1) / (mid << 1));\n\t\t\t_Wn[1][mid] = Pow (_Wn[0][mid], Mod - 2);\n\t\t}\n\t}\n\t\n\tinline void dft (int *A, int fg)\n\t{\n\t\tfor (int i = 0; i < n; ++i) if (rev[i] < i) swap (A[rev[i]], A[i]);\n\t\tfor (int mid = 1; mid < n; mid <<= 1)\n\t\t{\n\t\t\tint Wn = _Wn[fg][mid], len = mid << 1;\n\t\t\tfor (int i = 0; i < n; i += len)\n\t\t\t\tfor (int j = i, W = 1; j < i + mid; ++j, W = (LL) W * Wn % Mod)\n\t\t\t\t{\n\t\t\t\t\tint x = A[j], y = (LL) W * A[j + mid] % Mod;\n\t\t\t\t\tA[j] = (x + y) % Mod;\n\t\t\t\t\tA[j + mid] = (x - y + Mod) % Mod;\n\t\t\t\t}\n\t\t}\n\t\tif (fg) for (int i = 0, inv = Pow (n, Mod - 2); i < n; ++i) A[i] = (LL) A[i] * inv % Mod;\n\t}\n\t\n\tinline void mul (int *A, int *B, int *C, int N)\n\t{\n\t\tfor (n = 1; n <= (N << 1); n <<= 1);\n\t\tfor (int i = 0; i < n; ++i) rev[i] = (rev[i >> 1] >> 1) + ((i & 1) ? (n >> 1) : 0);\n\t\n\t\tstatic int F[Maxn], G[Maxn];\n\t\tfor (int i = 0; i < n; ++i) F[i] = (i <= N) ? A[i] : 0;\n\t\tfor (int i = 0; i < n; ++i) G[i] = (i <= N) ? B[i] : 0;\n\t\n\t\tdft (F, 0), dft (G, 0);\n\t\tfor (int i = 0; i < n; ++i) F[i] = (LL) F[i] * G[i] % Mod;\n\t\tdft (F, 1);\n\t\n\t\tfor (int i = 0; i <= (N << 1); ++i) C[i] = F[i];\n\t}\n}\n\nint F[Maxn], G[Maxn]; // G: 总的; F: 当前的\nint H[Maxn];\n\ninline void Solve ()\n{\n\t++M;\n\tA[M] = 1, B[M] = B[M - 1] - 1;\n\t--A[M - 1];\n\n\tG[0] = 1;\n\tfor (int i = 1; i <= M; ++i)\n\t{\n\t\tif (!A[i]) continue;\n#define n (B[i] + 1)\n#define m (j + 1)\n\t\tF[0] = (i == M) ? n : (n - 1);\n\n\t\tint res = (LL) n * (n - 1) / 2 % Mod;\n\t\tfor (int j = 1; j <= N; ++j)\n\t\t{\n\t\t\tF[j] = res;\n\t\t\tres = (LL) res * (n - m) % Mod * Pow (m + 1, Mod - 2) % Mod;\n\t\t}\n\t\n\t\tfor (int j = 0; j <= N; ++j) H[j] = 0;\n\t\tH[0] = 1;\n\t\n\t\tfor (int j = A[i]; j; j >>= 1, Poly :: mul (F, F, F, N)) \n\t\t\tif (j & 1) \n\t\t\t\tPoly :: mul (H, F, H, N);\n\t\n\t\tPoly :: mul (G, H, G, N);\n#undef n\n#undef m\n\t}\n\n\tcout << G[N] << endl;\n}\n\ninline void Input ()\n{\n\tN = read<int>() - 1, M = read<int>();\n\tfor (int i = 1; i <= M; ++i) A[i] = read<int>(), B[i] = read<int>();\n}\n\nint main()\n{\n\n#ifdef hk_cnyali\n\tfreopen(\"E.in\", \"r\", stdin);\n\tfreopen(\"E.out\", \"w\", stdout);\n#endif\n\n\tPoly :: init ();\n\tInput ();\n\tSolve ();\n\t\n\treturn 0;\n}\n\n```\n\n</details>\n\n## Farewell\n\n### Description\n\n有一张 $n$个点 $m$条边的图，第 $i$条边 $u_i,v_i$有 $\\frac{1}{3}$的概率从$ u_i$指向 $v_i$ ，另 $\\frac{1}{3}$ 的概率从 $v_i$ 指向 $u_i$ ，剩下 $\\frac{1}{3}$的概率被删除。求这张图是有向无环图的概率\n\n$n\\le 20$\n\n### Solution\n\n[FWT] [子集卷积] [动态规划] [状态压缩]\n\n设$F_S$表示$S$是DAG的方案数，$E_S$表示点集$S$内部的边数，$E_{S, T}$表示$S$与$T$之间的边数\n\nDAG计数显然枚举入度为$0$的点容斥\n$$\nF_S = \\sum_{T\\subseteq S, T\\ne \\emptyset} (-1)^{|T| + 1}F_{S - T}\\times 2^{E_{T, S - T}}\n$$\n$ 2^{E_{T, S - T}}$是因为从$S-T $到$ T$的边只能断掉或指向$T$\n\n又因为$ 2^{E_{T, S - T}} = 2^{E_S - E_T - E_{S - T}}$，所以式子可以化为\n$$\n\\frac{F_S}{2^{E_S}} = \\sum_{T\\subseteq S, T\\ne \\emptyset} \\frac{(-1)^{|T| + 1}}{2^{E_{T}}} \\times \\frac{F_{S - T}}{2^{E_{S - T}}}\n$$\n[子集卷积](https://hk-cnyali.com/2019/09/24/「Algorithm」FWT学习笔记/)即可\n\n<details>\n<summary>Code</summary>\n\n```cpp\n\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n#define DEBUG(x) cout << #x << \" = \" << x << endl;\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int Maxn = 20 + 5, Maxs = (1 << 20) + 5;\nconst int Mod = 998244353;\n\nnamespace MATH\n{\n\tinline void Add (int &a, int b) { if ((a += b) >= Mod) a -= Mod; }\n\n\tinline int Pow (int a, int b)\n\t{\n\t\tint ans = 1;\n\t\tfor (int i = b; i; i >>= 1, a = (LL) a * a % Mod) if (i & 1) ans = (LL) ans * a % Mod;\n\t\treturn ans;\n\t}\n}\n\nusing namespace MATH;\n\nint N, M, ALL;\nint A[Maxs];\nint E[Maxs];\nint f[Maxn][Maxs], g[Maxn][Maxs];\nint pw[Maxn * Maxn];\n\ninline void Init ()\n{\n\tALL = (1 << N) - 1;\n\tpw[0] = 1;\n\tfor (int i = 1; i <= M; ++i) pw[i] = (LL) pw[i - 1] * (Mod + 1) / 2 % Mod;\n\n\tfor (int i = 1; i <= ALL; ++i)\n\t{\n\t\tint p = i & (-i);\n\t\tE[i] = E[i ^ p] + __builtin_popcount (A[p] & i);\n\t\n\t\tint len = __builtin_popcount (i);\n\t\tg[len][i] = (LL) ((len & 1) ? 1 : (Mod - 1)) * pw[E[i]] % Mod;\n\t}\n}\n\ninline void DWT (int *A, int n, int op)\n{\n\tfor (int mid = 1; mid < n; mid <<= 1)\n\t\tfor (int i = 0, len = mid << 1; i < n; i += len)\n\t\t\tfor (int j = i; j < i + mid; ++j)\n\t\t\t{\n\t\t\t\tint x = A[j], y = A[j + mid];\n\t\t\t\tif (!op) A[j + mid] = (x + y) % Mod;\n\t\t\t\telse A[j + mid] = (y - x + Mod) % Mod;\n\t\t\t}\n}\n\ninline void Solve ()\n{\n\tInit ();\n\n\tf[0][0] = 1;\n\tDWT (f[0], 1 << N, 0);\n\tfor (int i = 0; i <= N; ++i) DWT (g[i], 1 << N, 0);\n\t\n\tfor (int i = 1; i <= N; ++i)\n\t\tfor (int j = 0; j < i; ++j)\n\t\t\tfor (int S = 0; S <= ALL; ++S)\n\t\t\t\tAdd (f[i][S], (LL) f[j][S] * g[i - j][S] % Mod);\n\t\n\tDWT (f[N], 1 << N, 1);\n\t\n\tcout << (LL) f[N][ALL] * Pow (2, M) % Mod * Pow (Pow (3, M), Mod - 2) % Mod << endl; \n}\n\ninline void Input ()\n{\n\tN = read<int>(), M = read<int>();\n\n\tfor (int i = 1; i <= M; ++i)\n\t{\n\t\tint x = read<int>() - 1, y = read<int>() - 1;\n\t\tA[1 << x] |= (1 << y);\n\t\tA[1 << y] |= (1 << x);\n\t}\n}\n\nint main()\n{\n\n#ifdef hk_cnyali\n\tfreopen(\"F.in\", \"r\", stdin);\n\tfreopen(\"F.out\", \"w\", stdout);\n#endif\n\n\tInput ();\n\tSolve ();\n\t\n\treturn 0;\n}\n\n```\n</details>","categories":["Problem"],"tags":["动态规划","树状数组","计数","状态压缩","FWT","NTT","组合数学","kruskal重构树","生成函数","多项式","子集卷积"]},{"title":"「HAOI2018」染色 - 容斥 + NTT","url":"/2019/09/19/%E3%80%8CHAOI2018%E3%80%8D%E6%9F%93%E8%89%B2-%E5%AE%B9%E6%96%A5-NTT/","content":"\n有一块长度为 $n$ 的画布,每个位置可以染成 $[1, m]$ 这些颜色中的一种。\n\n如果画布上恰好有 $k$ 种颜色恰好出现了 $s$ 次,则会产生 $w_k$ 的愉悦度,求所有不同画布的愉悦度之和,对 $1004535809$ 取模。\n\n$n\\le 10^6, m\\le 10^6, s\\le 150$\n\n<!--more-->\n\n### Link\n\n[LOJ 2527](https://loj.ac/problem/2527)\n\n### Solution\n\n感觉是一道容斥的入门题。。。\n\n设$f_i$表示**钦定**$i$种颜色出现了恰好$s$次的方案数，$g_i$表示**恰好**$i$种颜色出现了$s$次的方案数，$lim = \\min\\{m, \\frac{n}{s}\\}$\n$$\n\\begin{aligned}\nf_i &= \\binom{m}{i}\\binom{n}{is}\\frac{(is)!}{(s!)^i}\\times(m-i)^{n-is}\\\\\n\\end{aligned}\n$$\n\n$$\n\\begin{aligned}\ng_i &= \\sum_{j=i}^{lim}(-1)^{j-i}\\binom{j}{i}f_j\\\\\n&=\\frac{1}{i!}\\sum_{j=i}^{lim}\\frac{(-1)^{j-i}}{(j-i)!}\\times j!\\cdot f_j\\\\\n\\end{aligned}\n$$\n直接卷积即可\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int Maxn = 2e6 + 100;\nconst int Mod = 1004535809;\n\nint N, M, S;\nint W[Maxn];\n\nnamespace MATH\n{\n\tconst int maxn = 1e7 + 5;\n\tint fac[maxn], ifac[maxn];\n\n\tinline void Add (int &a, int b) { if ((a += b) >= Mod) a -= Mod; }\n\n\tinline int Pow (int a, int b)\n\t{\n\t\tint ans = 1;\n\t\tfor (int i = b; i; i >>= 1, a = (LL) a * a % Mod) if (i & 1) ans = (LL) ans * a % Mod;\n\t\treturn ans;\n\t}\n\n\tinline void init (int n)\n\t{\n\t\tfac[0] = 1;\n\t\tfor (int i = 1; i <= n; ++i) fac[i] = (LL) fac[i - 1] * i % Mod;\n\t\tifac[n] = Pow (fac[n], Mod - 2);\n\t\tfor (int i = n - 1; i >= 0; --i) ifac[i] = (LL) ifac[i + 1] * (i + 1) % Mod;\n\t}\n\n\tinline int C (int n, int m) { if (n < m) return 0; return (LL) fac[n] * ifac[m] % Mod * ifac[n - m] % Mod; }\n}\n\nusing namespace MATH;\n\nnamespace Poly\n{\n\tconst int g = 3;\n\tint n, rev[Maxn];\n\n\tinline void dft (int *A, int fg)\n\t{\n\t\tfor (int i = 0; i < n; ++i) if (i < rev[i]) swap (A[i], A[rev[i]]);\n\t\tfor (int mid = 1; mid < n; mid <<= 1)\n\t\t{\n\t\t\tint Wn = Pow (g, (Mod - 1) / (mid << 1));\n\t\t\tif (fg == -1) Wn = Pow (Wn, Mod - 2);\n\t\t\tfor (int i = 0; i < n; i += mid << 1)\n\t\t\t\tfor (int j = i, W = 1; j < i + mid; ++j, W = (LL) W * Wn % Mod)\n\t\t\t\t{\n\t\t\t\t\tint x = A[j], y = (LL) W * A[j + mid] % Mod;\n\t\t\t\t\tA[j] = (x + y) % Mod;\n\t\t\t\t\tA[j + mid] = (x - y + Mod) % Mod;\n\t\t\t\t}\n\t\t}\n\t\tif (fg == -1) for (int i = 0, inv = Pow (n, Mod - 2); i < n; ++i) A[i] = (LL) A[i] * inv % Mod;\n\t}\n\n\tinline void mul (int *A, int *B, int *C, int N)\n\t{\n\t\tfor (n = 1; n <= N << 1; n <<= 1);\n\t\tfor (int i = 0; i < n; ++i) rev[i] = (rev[i >> 1] >> 1) + ((i & 1) ? (n >> 1) : 0);\n\n\t\tstatic int F[Maxn], G[Maxn];\n\n\t\tfor (int i = 0; i < n; ++i) F[i] = (i <= N) ? A[i] : 0;\n\t\tfor (int i = 0; i < n; ++i) G[i] = (i <= N) ? B[i] : 0;\n\n\t\tdft (F, 1), dft (G, 1);\n\t\tfor (int i = 0; i < n; ++i) F[i] = (LL) F[i] * G[i] % Mod;\n\t\tdft (F, -1);\n\n\t\tfor (int i = 0; i <= N << 1; ++i) C[i] = F[i];\n\t}\n}\n\nint F[Maxn], G[Maxn], H[Maxn];\n\ninline void Solve ()\n{\n\tint LIM = min (M, N / S);\n\tfor (int i = 0; i <= LIM; ++i) F[i] = (LL) C (M, i) * C (N, i * S) % Mod * fac[i * S] % Mod * Pow (ifac[S], i) % Mod * Pow (M - i, N - i * S) % Mod * fac[i] % Mod;\n\tfor (int i = 0; i <= LIM; ++i) G[i] = (LL) Pow (Mod - 1, i) * ifac[i] % Mod;\n\treverse (F, F + LIM + 1);\n\n\tPoly :: mul (F, G, H, LIM);\n\n\treverse (H, H + LIM + 1);\n\n\tint ans = 0;\n\tfor (int i = 0; i <= LIM; ++i) Add (ans, (LL) H[i] * ifac[i] % Mod * W[i] % Mod);\n\tcout << ans << endl;\n}\n\ninline void Input ()\n{\n\tN = read<int>(), M = read<int>(), S = read<int>();\n\tfor (int i = 0; i <= M; ++i) W[i] = read<int>();\n}\n\nint main()\n{\n\n#ifdef hk_cnyali\n\tfreopen(\"A.in\", \"r\", stdin);\n\tfreopen(\"A.out\", \"w\", stdout);\n#endif\n\n\tMATH :: init (1e7);\n\tInput ();\n\tSolve ();\n\n\treturn 0;\n}\n```\n\n","categories":["Problem"],"tags":["容斥","NTT","省选","多项式"]},{"title":"「POJ2888」Magic Bracelet - Polya定理 + 欧拉函数 + 矩阵快速幂","url":"/2019/09/18/%E3%80%8CPOJ2888%E3%80%8DMagic-Bracelet-Polya%E5%AE%9A%E7%90%86-%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0-%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/","content":"\n对$n$个珠子构成的环染$m$种颜色, 并且规定一些颜色不能相邻. **旋转**后相同算是同一种方案, 求本质不同的着色方案数\n\n$n\\le 10^9, m\\le 10$\n\n<!--more-->\n\n### Link\n\n[POJ 2888](http://poj.org/problem?id=2888)\n\n### Solution\n\n一道很好的`Polya定理`的题\n\n> 1. Burnside引理：对于一个置换$f$,若一个染色方案$s$经过置换后不变，称$s$为$f$的不动点。将$f$的不动点数目记为$C(f)$，则可以证明等价类数目为所有$C(f)$的平均值\n>\n> 2. Polya定理：假设一个置换有$k$个循环，易知每个循环对应的所有位置颜色需一致，而任意两个循环之间选什么颜色互不影响。因此，如果有$m$种可选颜色，则该置换对应的不动点个数为$m^k$。所以等价类数目为：$\\displaystyle \\frac{\\sum_{i=0}^{|F}m^{k_i}}{|F|}$\n>\n>    其中$|F|$表示置换的数目，$k_i$表示第$i$个置换包含的循环个数\n\n我们称把环旋转$\\frac{k}{n}\\cdot \\pi$度的置换为$k$置换。显然$k\\in[0, n)$，即总共只有$n$种置换，但本质不同的置换只有$n$的约数种\n\n这是因为，$k$置换的循环长度为$\\frac{n}{\\gcd(k, n)}$，循环个数为$\\gcd(k, n)$\n\n> 想象一下在环上，一个点从$1$开始，每次往后跳$k$步，最终跳回$1$号点所需要的步数，就是循环长度\n\n根据`Polya定理`化式子：\n$$\n\\begin{aligned} \nans&=\\frac{1}{n}\\cdot \\sum_{i=1}^{n}m^{gcd(n,i)}\\\\ \n&=\\frac{1}{n}\\cdot \\sum_{d|n}\\cdot m^{d}\\cdot\\varphi(\\frac{n}{d}) \n\\end{aligned}\n$$\n\n> 枚举$\\gcd(n, i) = d$，那么这样的$i$会有$\\displaystyle \\varphi(\\frac{n}{d})$个（$i$要有$d$这个因子，且把$n$和$i$同除$d$后要互质）\n\n式子中\"$m^d$\"部分即为，当$\\gcd(n, i) = d$时不动点的个数。当没有限制时，这$d$个循环每个都可以任选一种颜色\n\n而这道题有颜色相邻的限制，所以需要预处理出$f_{i, j}$表示填了$i$种颜色，第$i$种颜色为$j$的方案数。显然可以矩阵快速幂优化\n\n> 一个小技巧：因为首尾也要满足条件，所以可以先多矩乘一次，然后把所有的$G_{i, i}$相加即为答案\n\n复杂度$O(\\sqrt n m^3\\log n)$，跑不满\n\n### Code\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n#define DEBUG(x) cout << #x << \" = \" << x << endl;\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\nconst int Mod = 9973;\nconst int Maxn = 15;\n\nint N, M, K;\n\nnamespace MATH\n{\n\tinline void Add (int &a, int b) { if ((a += b) >= Mod) a -= Mod; }\n\n\tinline int Pow (int a, int b)\n\t{\n\t\tint ans = 1;\n\t\tfor (int i = b; i; i >>= 1, a = (LL) a * a % Mod) if (i & 1) ans = (LL) ans * a % Mod;\n\t\treturn ans;\n\t}\n\n\tconst int maxn = 1e5 + 100;\n\n\tint prime[maxn], phi[maxn];\n\tbool vis[maxn];\n\n\tinline void init ()\n\t{\n\t\tint n = 1e5;\n\t\tphi[1] = 1;\n\t\tfor (int i = 2; i <= n; ++i)\n\t\t{\n\t\t\tif (!vis[i]) prime[++prime[0]] = i, phi[i] = i - 1;\n\t\t\tfor (int j = 1; j <= prime[0] && (LL) i * prime[j] <= n; ++j)\n\t\t\t{\n\t\t\t\tvis[i * prime[j]] = 1;\n\t\t\t\tif (!(i % prime[j]))\n\t\t\t\t{\n\t\t\t\t\tphi[i * prime[j]] = phi[i] * prime[j];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tphi[i * prime[j]] = phi[i] * phi[prime[j]];\n\t\t\t}\n\t\t}\n\t}\n\n\tinline int get_phi (int n)\n\t{\n\t\tif (n <= 1e5) return phi[n];\n\t\tint ans = n;\n\t\tfor (int i = 1; prime[i] * prime[i] <= n; ++i)\n\t\t\tif (!(n % prime[i]))\n\t\t\t{\n\t\t\t\tans -= ans / prime[i];\n\t\t\t\twhile (!(n % prime[i])) n /= prime[i];\n\t\t\t}\n\t\tif (n > 1) ans -= ans / n;\n\t\treturn ans % Mod;\n\t}\n}\n\nusing namespace MATH;\n\nstruct mat\n{\n\tint A[Maxn][Maxn];\n\tinline mat () { memset (A, 0, sizeof A); }\n\n\tinline int* operator [] (const int &x) { return A[x]; }\n\n\tinline mat operator * (const mat &rhs) const\n\t{\n\t\tmat now;\n\t\tfor (int i = 1; i <= M; ++i)\n\t\t\tfor (int k = 1; k <= M; ++k)\n\t\t\t\tif (A[i][k])\n\t\t\t\t\tfor (int j = 1; j <= M; ++j)\n\t\t\t\t\t\tAdd (now.A[i][j], A[i][k] * rhs.A[k][j] % Mod);\n\t\treturn now;\n\t}\n\n\tinline mat operator ^ (int b)\n\t{\n\t\tmat ans, a = *this;\n\t\tfor (int i = 1; i <= M; ++i) ans.A[i][i] = 1;\n\t\tfor (int i = b; i; i >>= 1, a = a * a) if (i & 1) ans = ans * a;\n\t\treturn ans;\n\t}\n\n\tinline void init () \n\t{\n\t\tfor (int i = 1; i <= M; ++i) \n\t\t\tfor (int j = 1; j <= M; ++j) \n\t\t\t\tA[i][j] = 1; \n\t}\n\n\tinline void print ()\n\t{\n\t\tfor (int i = 1; i <= M; ++i, puts(\"\"))\n\t\t\tfor (int j = 1; j <= M; ++j)\n\t\t\t\tcout << A[i][j] << \" \";\n\t}\n} trans;\n\nint ans;\n\ninline void Calc (int x)\n{\n\tmat res = trans ^ x;\n\tint sum = 0;\n\tfor (int i = 1; i <= M; ++i) Add (sum, res[i][i]);\n\tsum = (LL) sum * get_phi (N / x) % Mod;\n\tAdd (ans, sum);\n}\n\ninline void Solve ()\n{\n\tans = 0;\n\tint m = sqrt (N);\n\tfor (int i = 1; i <= m; ++i)\n\t\tif (!(N % i))\n\t\t{\n\t\t\tCalc (i);\n\t\t\tif (i * i != N) Calc (N / i);\n\t\t}\n\tans = (LL) ans * Pow (N, Mod - 2) % Mod;\n\tprintf(\"%d\\n\", ans);\n}\n\ninline void Input ()\n{\n\tN = read<int>(), M = read<int>(), K = read<int>();\n\ttrans.init ();\n\tfor (int i = 1; i <= K; ++i)\n\t{\n\t\tint x = read<int>(), y = read<int>();\n\t\ttrans[x][y] = trans[y][x] = 0;\n\t}\n}\n\nint main()\n{\n\n#ifdef hk_cnyali\n\tfreopen(\"C.in\", \"r\", stdin);\n\tfreopen(\"C.out\", \"w\", stdout);\n#endif\n\n\tMATH :: init ();\n\tint T = read<int>();\n\twhile (T--)\n\t{\n\t\tInput ();\n\t\tSolve ();\n\t}\n\n\treturn 0;\n}\n\n```\n\n","categories":["Problem"],"tags":["欧拉函数","计数","矩阵快速幂","Polya定理","Burnside引理"]},{"title":"「ACM-ICPC2019」上海网络赛 - 部分题解","url":"/2019/09/16/%E3%80%8CACM-ICPC2019%E3%80%8D%E4%B8%8A%E6%B5%B7%E7%BD%91%E7%BB%9C%E8%B5%9B-%E7%AE%80%E8%A6%81%E9%A2%98%E8%A7%A3/","content":"\n又是一场疯狂罚时的ACM\n\n![19-9-16-1](/images/19-9-16-1.png)\n\n<!--more-->\n\n[link](https://www.jisuanke.com/contest/3003?view=challenges)\n\n### A\n\n[线段树]\n\n树上某个点的最远点一定是直径的某个端点\n\n很老的套路，线段树动态维护直径，再用一个树状数组动态维护链长度信息即可\n\n\n\n### B\n\n直接差分\n\n\n\n### C\n\n[FFT]\n\n补集转化，不合法方案就是$A_i + B_j< C_k $，或$A_i + C_k < B_j$，或$B_j + C_k < A_i$\n\n显然这三个条件最多只能满足一个，于是可以直接FFT计算\n\n这道题还卡常，$n\\le 1000$的时候必须跑暴力才能过\n\n\n\n### D\n\n可以直接爆搜打表\n\n或者考虑一个更优秀一些的搜索：显然确定了$>1$的数的填数方案后，$1$的个数是可以算出来的\n\n所以只需要搜填$2$以上的数，随便剪下枝就跑得飞快\n\n\n\n### E\n\n[生成函数] [多项式]\n\n和[珍珠](https://hk-cnyali.com/2019/09/16/「CTS2019」珍珠-生成函数-NTT-容斥/)几乎一模一样\n\n设$m_0$表示$1$至$m$中偶数的个数，$m_1$表示奇数个数，那么题目就是要求\n$$\n\\begin{aligned}\n&n![x^n]\\Big(\\frac{e^x + e^{-x}}{2}\\Big)^{m_0} \\cdot (e^x)^{m_1}\\\\\n=&\\frac{n!}{2^{m_0}}[x^n]\\sum_{i=0}^{m_0}\\binom{m_0}{i}(e^x)^i(e^{-x})^{m_0 - i}\\cdot (e^x)^{m_1}\\\\\n=&\\frac{n!}{2^{m_0}}[x^n]\\sum_{i=0}^{m_0}\\binom{m_0}{i}\\cdot (e^{x})^{2i-m_0 + m_1}\\\\\n=&\\frac{n!}{2^{m_0}}\\sum_{i=0}^{m_0}\\binom{m_0}{i}\\cdot \\frac{(2i-m_0 + m_1)^{n}}{n!}\\\\\n=&\\frac{1}{2^{m_0}}\\sum_{i=0}^{m_0}\\binom{m_0}{i}(2i-m_0 + m_1)^{n}\n\\end{aligned}\n$$\n直接算就行\n\n\n\n### F\n\n[动态规划]\n\n$dp[i][j]$表示当前填到$i$，前$i$位总共用了$j$种字符，后面所有方案的方案数\n\n贪心从小到大考虑每一位填什么，类似于二分往左右走的过程\n\n\n\n### G\n\n[分块] [字符串]\n\n对询问串长度分块\n\n预处理长度$\\le K$的答案；$>K$就暴力（$K$实测可能只能开到$5$左右。。。）\n\n暴力Hash就是类似于一个滑动窗口在字符串上面跑\n\n因为这里的Hash是无序Hash，所以每次移动滑动窗口时直接加加减减，很方便动态维护Hash值\n\n$P.S.$空间卡得很紧，具体实现可以把询问离线，空间就不用开那么多了\n\n\n\n### H\n\n[栈]\n\n昨天才考了一个这样的套路\n\n用两个栈模拟队列，`push`就压入栈A，`pop`就弹栈B。`pop`时若栈B为空，则把栈A的元素依次取出，压入栈B\n\n复杂度显然是对的，每个元素最多被考虑3次：`push`、从A转移到B、`pop`\n\n这样就只用加入和回溯，而不需要删除了\n\n\n\n### I\n\n#### Description\n\n长为 $n$ 的序列里有一个 bug ，你每次可以用 $b$ 的代价插一个板，或者用 $a$ 的代价确认 bug 在被已有板隔出的哪一个区间内，问最坏情况下最小代价\n\n$n, a, b\\le 10^{18}$\n\n#### Solution\n\n确认的次数显然不会超过$O(\\log n)$，所以可以直接枚举。对于固定的确认次数来说，若第$j$次确认时隔出来$k_j$个区域，那么要保证$\\displaystyle \\lceil \\frac{n}{\\prod k_j}\\rceil \\le 1$\n\n> 这里要用到一个结论：$\\displaystyle \\lceil \\frac{n}{ab}\\rceil  = \\lceil\\frac{\\lceil\\frac{n}{a}\\rceil}{b}\\rceil$\n>\n> xz会证，我只会感性理解\n\n因为和一定差小积大，所以$k_j$要尽量接近\n\n最优解一定形如：$k_{1\\cdots p} =\\lfloor \\sqrt[i]{n}\\rfloor, k_{p+1\\cdots i} =\\lfloor \\sqrt[i]{n}\\rfloor+1$，暴力找到最小的$p$即可\n\n### J\n\n[动态规划]\n\n要求$(\\sum A) - \\max\\{A\\} \\le \\sum (S - A) \\le \\sum A$的$A$集合个数\n\n把集合排序，从小到大考虑，动态维护$f[i]$表示和为$i$的方案\n\n因为从小到大考虑，所以当前的数一定是$\\max$，直接算即可\n\n\n\n### K\n\n[计算几何]\n\n先枚举其中一个点，圆上的整点只有$\\sqrt n$个，[方法在这里](https://oi.men.ci/haoi2008-cir/)\n\n求出来后，由于三条边长度已知，可以求出其夹角，进而通过旋转求出另外一点坐标\n\n\n\n### L\n\n数位dp模板题","categories":["Problem"],"tags":["分块","动态规划","线段树","栈","字符串","FFT","计算几何","生成函数","ACM-ICPC","多项式"]},{"title":"「Algorithm」关于容斥/多项式/生成函数","url":"/2019/09/16/%E3%80%8CAlgorithm%E3%80%8D%E5%85%B3%E4%BA%8E%E5%AE%B9%E6%96%A5-%E5%A4%9A%E9%A1%B9%E5%BC%8F-%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/","content":"\n恶补大家小学就会的知识点\n\n其实是一些乱七八糟的基础知识\n\n<!--more-->\n\n## 容斥\n\n$n$种限制，算方案数\n\n### 不满足任何限制\n\n$$\n\\begin{aligned}\nans &= \\sum_{S} (-1)^{|S|}f_S\\\\\n\t&= \\sum_{i=0}^{n}(-1)^{i}\\binom{n}{i}f_i\n\\end{aligned}\n$$\n\n$f_S$表示**钦定**满足$S$集合限制，**其他任意**的方案数\n\n$f_i$表示**钦定**满足$i$种限制，**其他任意**的方案数\n\n---\n\n假设有一种方案满足$k>0$种限制，那么它会被算这么多次：\n$$\n\\begin{aligned}\n&\\binom{k}{0}-\\binom{k}{1} + \\binom{k}{2} - \\binom{k}{3} -...+(-1)^{k}\\binom{k}{k}\\\\\n=&1-\\Bigg(\\binom{k-1}{0}+\\binom{k-1}{1}\\Bigg)+ \\Bigg(\\binom{k-1}{1}+\\binom{k-1}{2}\\Bigg)-...+\\Bigg(\\binom{k-1}{k-1}\\Bigg)\\\\\n=&1-\\binom{k-1}{0}\\\\\n=0\n\\end{aligned}\n$$\n而只有当$k=0$时，才会被算$\\binom{0}{0} = 1$次\n\n所以这样算就对了\n\n### 至少满足一个限制\n\n$$\nans = \\sum_{i=1}^{n}(-1)^{i+1}\\binom{n}{i}f_i\n$$\n\n$f_i$定义相同，证明方法同上\n\n另外也可以通过维恩图理解\n\n### 恰好满足k​个限制(广义容斥原理)\n\n设$g_k$表示答案\n$$\ng_k = \\sum_{i=k}^{n}(-1)^{i-k}\\binom{i}{k}f_i\n$$\n$f_i$定义相同\n\n---\n\n证明方法只能（~~我只知道~~）通过二项式反演。\n$$\n\\begin{aligned}\nf_k &= \\sum_{i=k}^{n}\\binom{i}{k}g_i\\\\\n\\Rightarrow g_k&=\\sum_{i=k}^{n}(-1)^{i-k}\\binom{i}{k}f_i\n\\end{aligned}\n$$\n上面的式子要乘个组合数是因为要枚举出在$i$个限制中是哪$k$个满足（$f$在乱选的时候会算重）\n\n### 至少满足k个限制(至多类似)\n\n$$\nans = \\sum_{i=k}^{n}g_i\n$$\n\n其中$g_i$表示恰好满足$i$个限制的方案，于是转化到上一个问题\n\n## 多项式\n\n### 一些零碎的东西\n\n在得到一个看起来很像卷积的式子后，先把枚举的部分通过变量替换得到$\\displaystyle \\sum_{j=0}^{i}$的形式\n\n> 比如，本身式子长这样：$\\displaystyle \\sum_{j=i}^{n}f[j-i]g[j]$，就可以把$j-i$替换成$k$，变成$\\displaystyle \\sum_{k=0}^{n-i}f[k]g[k+i]$\n\n然后通过翻转来凑出卷积的形式\n\n> 接着上面的式子，把$g$数组翻转后得到$\\displaystyle \\sum_{k=0}^{n-i}f[k]g[n-k-i]$，这样就能直接卷了，卷出来之后再翻转一下就得到要求的数组了\n\n## 生成函数\n\n就是把一个数列转化成多项式的形式，转化成更简洁的式子。通过多项式运算，计算系数，来得到答案\n\n用生成函数能快速得到每一项的答案\n\n有时候因为不好直接考虑很多个物品的组合，也可以通过把若干个生成函数直接相乘取$[x^n]$，以方便计算\n\n感觉这东西往往与值域有关\n\n### 泰勒展开\n\n[很好理解的视频](https://www.bilibili.com/video/av11251323/?from=search&seid=10355824295490802414)\n$$\nf(x) = \\sum_{n=0}^{\\infty}\\frac{f^{(n)}x_0}{n!}(x-x_0)^n\n$$\n\n> 其中$\\frac{1}{n!}$是为了把$x^n$一次一次求导后得到的系数$n!$消去\n\n### 指数型生成函数\n\n在取$[x^n]$的时候前面要乘一个$\\frac{1}{n!}$，因为指数型生成函数会带一个$\\frac{1}{i!}$\n$$\n\\begin{aligned}\ne^x &= \\sum_{i=0}^{\\infty}\\frac{1}{i!}x^i\\\\\n\\frac{e^x - e^{-x}}{2} &= \\sum_{i=0}^{\\infty}\\frac{1}{(2i+1)!}x^{2i+1}\\\\\n\\frac{e^x + e^{-x}}{2} &= \\sum_{i=0}^{\\infty}\\frac{1}{(2i)!}x^{2i}\\\\\n[x^n]e^{ax} &=\\frac{a^n}{n!}\n\\end{aligned}\n$$\n\n","categories":["Algorithm"],"tags":["容斥","Summary","生成函数","多项式"]},{"title":"「CTS2019」珍珠 - 生成函数 + NTT + 容斥","url":"/2019/09/16/%E3%80%8CCTS2019%E3%80%8D%E7%8F%8D%E7%8F%A0-%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0-NTT-%E5%AE%B9%E6%96%A5/","content":"\n称一个长度为 $n$，元素取值$\\in[1,D]$的整数序列是合法的，当且仅当其中能够选出至少 $m$ 对相同元素（不能重复选出元素）\n\n问合法序列个数，答案对$998244353$取模\n\n$n, m\\le 10^9, D\\le 10^5$\n\n<!--more-->\n\n### Link\n\n[LOJ 3120](https://loj.ac/problem/3120)\n\n### Solution\n\n打ACM的时候做到一道这道题的弱化版本，就干脆把这道题搞了\n\n首先，因为$D$范围比较小，考虑和$D$（即颜色种类）相关的做法\n\n题目要求的东西并不好直接算，因为一种颜色可能有多次贡献，于是考虑统计奇数的方案数\n\n设颜色为$i$的数量为$c_i$，那么一种方案合法，当且仅当\n$$\n\\sum_{i=1}^{D}c_i \\bmod 2 \\le n - 2m\n$$\n也就是满足$c\\bmod 2 = 1$的颜色种数不能超过$n-2m$\n\n先特判 $n-2m \\ge D$ 和 $n-2m < 0$的情况，答案分别为 $D^n$和 $0$\n\n设$f_i$为满足$c\\bmod 2=1$的颜色种数**恰好**为$i$的方案数，那么\n$$\nans = \\sum_{i=0}^{n-2m}f_i\n$$\n考虑求$f$\n\n最直观的方案是直接算\n$$\nf_i = \\binom{D}{i} n![x^n]\\Big(\\frac{e^x-e^{-x}}{2}\\Big)^i\\cdot \\Big(\\frac{e^x+e^{-x}}{2}\\Big)^{D-i}\n$$\n\n> 后面那一堆生成函数，就是有$i$个只能选奇数个数的物品，和$D-i$个只能选偶数个数的物品，把它们排列起来的方案数\n>\n> 乘$\\binom{D}{i}$是因为要确定这$i$个只能选奇数个的物品到底是哪$i$个（后面那一堆生成函数中并没有考虑这个问题！但一旦确定下来，就不需要考虑这$i$个的顺序了，顺序会在生成函数中被考虑到）\n\n但是这里有两个$(\\frac{e^x-e^{-x}}{2})^i$这样的东西，需要用二项式定理展开两次，不好算，于是考虑容斥，把其中一个变成更简洁的形式\n\n---\n\n根据广义容斥原理，设$g_i$为满足$c\\bmod 2=1$的颜色种数**至少**为$i$的方案数\n$$\n\\begin{aligned}\nf_i &= \\sum_{j=i}^{D}(-1)^{j-i}\\binom{j}{i}g_j\\\\\n\t&= \\frac{1}{i!}\\times \\sum_{j=i}^{D}\\frac{(-1)^{j-i}}{(j-i)!}\\times j!\\cdot g_j\\\\\n\t&= \\frac{1}{i!}\\times \\sum_{k=0}^{D-i}\\frac{(-1)^{k}}{-(k)!}\\times (k+i)!\\cdot g_{k+i}\\\\\n\\end{aligned}\n$$\n把后面那部分翻转\n$$\n\\begin{aligned}\n\t&= \\frac{1}{i!}\\times \\sum_{k=0}^{D-i}\\frac{(-1)^{k}}{-(k)!}\\times (D-k-i)!\\cdot g_{D-k-i}\\\\\n\\end{aligned}\n$$\n显然可以卷积，考虑求$g$\n$$\ng_i = \\binom{D}{i} n![x^n]\\Big(\\frac{e^x-e^{-x}}{2}\\Big)^i(e^x)^{D-i}\n$$\n\n> 原理和上面相同\n\n这样就只需要进行一次二项式展开了\n$$\n\\begin{aligned}\ng_i &= \\binom{D}{i}\\frac{n!}{2^i}[x^n]\\Big(e^x-e^{-x}\\Big)^i(e^x)^{D-i}\\\\\n&= \\binom{D}{i}\\frac{n!}{2^i}[x^n]\\sum_{j=0}^{i}\\binom{i}{j}(e^x)^j(-e^{-x})^{i-j}\\cdot (e^x)^{D-i}\\\\\n&= \\binom{D}{i}\\frac{n!}{2^i}[x^n]\\sum_{j=0}^{i}\\binom{i}{j}(-1)^{i-j}e^{(D-2(i-j))x}\\\\\n\\end{aligned}\n$$\n根据泰勒展开，有$\\displaystyle [x^n]e^{ax} = \\frac{a^n}{n!}$\n\n$$\n\\begin{aligned}\ng_i &= \\binom{D}{i}\\frac{n!}{2^i}[x^n]\\sum_{j=0}^{i}\\binom{i}{j}(-1)^{i-j}\\Big(D-2(i-j)\\Big)^{n}\\\\\n&=\\frac{D!}{2^{i}(D-i)!}\\sum_{j=0}^i \\frac{(-1)^{i-j}\\cdot \\Big(D-2(i-j)\\Big)^{n}}{(i-j)!}\\times\\frac{1}{j!}\n\\end{aligned}\n$$\n\n卷积即可\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n#define DEBUG(x) cout << #x << \" = \" << x << endl;\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int Maxn = 1e6 + 100;\nconst int Mod = 998244353;\n\nnamespace MATH\n{\n\tint fac[Maxn], ifac[Maxn];\n\n\tinline void Add (int &a, int b) { if ((a += b) >= Mod) a -= Mod; }\n\n\tinline int Pow (int a, int b)\n\t{\n\t\tint ans = 1;\n\t\tfor (int i = b; i; i >>= 1, a = (LL) a * a % Mod) if (i & 1) ans = (LL) ans * a % Mod;\n\t\treturn ans;\n\t}\n\n\tinline void init (int n = Maxn - 10)\n\t{\n\t\tfac[0] = 1;\n\t\tfor (int i = 1; i <= n; ++i) fac[i] = (LL) fac[i - 1] * i % Mod;\n\t\tifac[n] = Pow (fac[n], Mod - 2);\n\t\tfor (int i = n - 1; i >= 0; --i) ifac[i] = (LL) ifac[i + 1] * (i + 1) % Mod;\n\t}\n\n\tinline int C (int n, int m) { if (n < m) return 0; return (LL) fac[n] * ifac[m] % Mod * ifac[n - m] % Mod; }\n}\n\nusing namespace MATH;\n\nnamespace Poly\n{\n\tconst int g = 3;\n\tint n, rev[Maxn];\n\n\tinline void init (int N)\n\t{\n\t\tfor (n = 1; n <= 2 * N; n <<= 1);\n\t\tfor (int i = 0; i < n; ++i) rev[i] = (rev[i >> 1] >> 1) + ((i & 1) ? (n >> 1) : 0);\n\t}\n\n\tinline void dft (int *A, int fl)\n\t{\n\t\tfor (int i = 0; i < n; ++i) if (rev[i] < i) swap (A[i], A[rev[i]]);\n\n\t\tfor (int mid = 1; mid < n; mid <<= 1)\n\t\t{\n\t\t\tint Wn = Pow (g, (Mod - 1) / (mid << 1));\n\t\t\tif (fl == -1) Wn = Pow (Wn, Mod - 2);\n\t\t\tfor (int i = 0; i < n; i += mid << 1)\n\t\t\t\tfor (int j = i, W = 1; j < i + mid; ++j, W = (LL) W * Wn % Mod)\n\t\t\t\t{\n\t\t\t\t\tint x = A[j], y = (LL) W * A[j + mid] % Mod;\n\t\t\t\t\tA[j] = (x + y) % Mod;\n\t\t\t\t\tA[j + mid] = (x - y + Mod) % Mod;\n\t\t\t\t}\t\n\t\t}\n\n\t\tif (fl == -1) for (int i = 0, inv = Pow (n, Mod - 2); i < n; ++i) A[i] = (LL) A[i] * inv % Mod;\n\t}\n\n\tinline void mul (int *A, int *B, int *C, int N)\n\t{\n\t\tstatic int F[Maxn], G[Maxn];\n\t\tfor (int i = 0; i < n; ++i) F[i] = (i <= N) ? A[i] : 0; \n\t\tfor (int i = 0; i < n; ++i) G[i] = (i <= N) ? B[i] : 0; \n\n\t\tdft (F, 1), dft (G, 1);\n\t\tfor (int i = 0; i < n; ++i) F[i] = (LL) F[i] * G[i] % Mod;\n\t\tdft (F, -1);\n\t\tfor (int i = 0; i <= 2 * N; ++i) C[i] = F[i];\n\t}\t\n}\n\nint N, M, D;\nint F[Maxn], G[Maxn];\nint A[Maxn], B[Maxn];\n\ninline void Solve ()\n{\n\tif ((LL) N - 2ll * M >= D) return void (printf(\"%d\\n\", Pow (D, N)));\n\tif ((LL) N - 2ll * M <  0) return void (puts(\"0\"));\n\n\tPoly :: init (D);\n\n\tfor (int i = 0; i <= D; ++i) A[i] = (LL) Pow (Mod - 1, i) * Pow (D - 2 * i + Mod, N) % Mod * Pow (fac[i], Mod - 2) % Mod;\n\tfor (int i = 0; i <= D; ++i) B[i] = Pow (fac[i], Mod - 2);\n\tPoly :: mul (A, B, G, D);\n\tfor (int i = 0; i <= D; ++i) G[i] = (LL) G[i] * fac[D] % Mod * Pow ((LL) Pow (2, i) * fac[D - i] % Mod, Mod - 2) % Mod;\n\n\tfor (int i = 0; i <= D; ++i) A[i] = (LL) Pow (Mod - 1, i) * Pow (fac[i], Mod - 2) % Mod;\n\tfor (int i = 0; i <= D; ++i) B[i] = (LL) fac[i] * G[i] % Mod;\n\treverse (B, B + D + 1);\n\tPoly :: mul (A, B, F, D);\n\treverse (F, F + D + 1);\n\tfor (int i = 0; i <= D; ++i) F[i] = (LL) F[i] * ifac[i] % Mod;\n\n\tint ans = 0;\n\tfor (int i = 0; i <= N - 2 * M; ++i) Add (ans, F[i]);\n\tcout << ans << endl;\n}\n\ninline void Input ()\n{\n\tD = read<int>(), N = read<int>(), M = read<int>();\n}\n\nint main()\n{\n\n#ifndef ONLINE_JUDGE\n\tfreopen(\"A.in\", \"r\", stdin);\n\tfreopen(\"A.out\", \"w\", stdout);\n#endif\n\n\tMATH :: init ();\n\tInput ();\n\tSolve ();\n\n\treturn 0;\n}\n\n```\n\n","categories":["Problem"],"tags":["容斥","NTT","生成函数","多项式"]},{"title":"「笔记」一些字符串题","url":"/2019/09/14/%E3%80%8C%E7%AC%94%E8%AE%B0%E3%80%8D%E4%B8%80%E4%BA%9B%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%A2%98/","content":"\n[字符串]\n\n来自csy课件的一些字符串题\n\n<!--more-->\n\n## KMP\n\n### [HNOI2008 GT考试](https://hk-cnyali.com/2019/03/12/「HNOI2008」GT-考试-KMP-矩阵快速幂/)\n\n### [NOI2014 动物园](https://loj.ac/problem/2246)\n\n#### Description\n\n设 $num_i$ 为前缀 $i$ 所拥有的,与其相同⻓度后缀相等且不相交的的前缀个数。\n\n$T$ 组询问,每组询问给出一字符串,求 $\\prod (num_i + 1)$\n\n$T \\le5, |S| \\le 10^6$\n\n#### Solution\n\n[KMP]\n\n`KMP`又快忘光了。。。\n\n求出`fail`数组后倍增，跳到小于等于$\\frac{i}{2}$的位置，加上深度的贡献\n\n\n\n### [HNOI2019 JOJO](https://www.luogu.org/problem/P5287)\n\n大致思路是：\n\n* 通过离线dfs处理强制在线\n* 通过把连续的`字符`缩成一个`字段`，解决字符数量太多的问题\n* 利用`border`只要大于串长的一半就一定会出现循环，且若干个循环只有最后两个循环节才可能产生贡献的性质，使得`KMP`的复杂度不再是均摊，而是$\\log$（每次长度至少会减半）\n\n感觉还没完全把细节想清楚，先咕咕咕，贴一下csy的标程\n\n<details>\n<summary>Code</summary>\n\n```cpp\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <vector>\nusing namespace std;\nconst int Max_n = 1e5 + 5, mod = 998244353;\nint n;\nlong long Ans[Max_n];\nint fail[Max_n], l[Max_n], len[Max_n], sum[Max_n];\nchar P[Max_n], c[Max_n];\nint cntr, hd[Max_n], nx[Max_n], to[Max_n];\nvoid addr(int u, int v)\n{\n\tcntr++;\n\tnx[cntr] = hd[u], to[cntr] = v;\n\thd[u] = cntr;\n}\nvoid Mod(long long &x) { x %= mod; }\n\nvoid calc(int x, int L, long long ans)\n{\n\tif (len[x])\n\t{\n\t\tif (!L) Mod(ans = (len[x] - 1) * len[x] / 2);\n\t\tint maxx = 0, now = fail[L], lastgap = 0;\n\t\tfor (int i = fail[L]; ~i; i = fail[i]) // 算答案 \n\t\t{\n\t\t\tif (P[i + 1] == c[x] && min(l[i + 1], len[x]) > maxx)\n\t\t\t{\n\t\t\t\tint tp = maxx;\n\t\t\t\tmaxx = min(l[i + 1], len[x]);\n\t\t\t\tMod(ans +=\n\t\t\t\t\t\t1ll * (maxx - tp) * sum[i] + (maxx - tp) * (tp + 1 + maxx) / 2);\n\t\t\t}\n\t\t\tif ((i - fail[i] == lastgap) && i) i = i % lastgap + lastgap;\n\t\t\tlastgap = i - fail[i];\n\t\t}\n\t\tif (c[x] == P[1] && L) Mod(ans += (len[x] - maxx) * l[1]);\n\t\tlastgap = 0;\n\t\tfail[L + 1] = 0;\n\t\tfor (int i = fail[L++]; ~i; i = fail[i]) // 加入KMP\n\t\t{\n\t\t\tif (P[1] == c[x] && l[1] <= len[x]) fail[L] = 1;\n\t\t\tif (P[i + 1] == c[x] && l[i + 1] == len[x])\n\t\t\t{\n\t\t\t\tfail[L] = i + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (i - fail[i] == lastgap && i) i = i % lastgap + lastgap;\n\t\t\tlastgap = i - fail[i];\n\t\t}\n\t\tP[L] = c[x], sum[L] = sum[L - 1] + (l[L] = len[x]);\n\t}\n\tAns[x] = ans;\n\tfor (int i = hd[x]; i; i = nx[i]) calc(to[i], L, ans);\n}\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"5287.in\", \"r\", stdin);\n\tfreopen(\"5287.out\", \"w\", stdout);\n#endif\n\tscanf(\"%d\", &n);\n\tint opt, x;\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tscanf(\"%d%d\", &opt, &x);\n\t\tif (opt == 2) addr(x, i);\n\t\telse\n\t\t{\n\t\t\taddr(i - 1, i);\n\t\t\tscanf(\" %c\", &c[i]);\n\t\t\tlen[i] = x;\n\t\t}\n\t}\n\tfail[0] = -1;\n\tcalc(0, 0, 0);\n\tfor (int i = 1; i <= n; i++) printf(\"%lld\\n\", Ans[i]);\n}\n\n```\n\n</details>\n\n\n\n## AC自动机\n\n### [「NOI2011」阿狸的打字机](https://loj.ac/problem/2444)\n\n#### Description\n\n有一空串,接下来有 $n$ 个操作,一是在串尾加入小写字母,二是将当前串记录,三是删除当前串末尾字母。\n\n接下来 $m$ 个询问,每次询问第 $x$ 个记录的串在第 $y$ 个记录的串中出现了多少次。\n\n$n, m\\le 10^5$\n\n#### Solution\n\n[Trie] [AC自动机] [树状数组]\n\n加入/记录/删除都可以在`trie`上实现\n\n如何求$x$在$y$中出现了多少次？\n\n暴力做法：建出`AC自动机`后，把$y$放到`AC`自动机上跑，对于经过的每个节点，看它不断跳`fail`时能否跳到$x$所在节点\n\n发现就是问`fail树`上，$x$的**子树**里有多少个节点是**$y$到根路径（trie路径）上的节点**，显然子树的限制可以树状数组搞\n\n离线询问，把询问挂在$y$上。dfs整棵`trie`，访问一个点就在树状数组++，出去的时候--。这样的话，到这个点的时候树状数组里就只有它到根路径上的信息了，直接查询即可\n\n\n\n### [POI 2000 病毒](https://loj.ac/problem/10062)\n\n#### Description\n\n有 $n$ 个 01 串,问是否能构造出无限⻓的文本串使得任意一个 01 串都不为此串的子串。\n\n设 $len$ 为 $n$ 个 01 串的⻓度之和。\n\n$n\\le 2000, len\\le 30000$\n\n#### Solution\n\n[AC自动机]\n\n把`AC自动机`全建出来（建出`trie`图）后，就是要在上面找到一个环，使得它不包含任何一个给出的$01$串\n\n也就是说，给定的$01$串的结尾位置都不能走，并且如果某个节点的`fail`链上存在给定串的结尾标记，那么也不能走\n\n\n\n### [JSOI2007 文本生成器](https://www.luogu.org/problem/P4052)\n\n#### Description\n\n给出 $n$ 个模式串,皆有由大写字母组成。问有多少种由大写字母组成的,⻓度为 $m$ 的文本串满足其中至少有一\n个模式串。模式串不会超过 $m$ \n\n$n\\le 60, m\\le 100$\n\n####  Solution\n\n[AC自动机]\n\n补集转化，总方案减去不含模式串的情况。设$f_{i, j}$表示在`AC自动机`上到$i$号节点，长度为$j$且不含模式串的方案数。直接转移\n\n注意到`AC自动机`（实际是`trie图`）上可能会存在环，不过并不影响dp，因为长度是有限的。。。\n\n\n\n### [CF 86C](https://codeforces.com/contest/86/problem/C)\n\n#### Description\n\n给出 $m$ 个模式串 $s$,问有多少种⻓度为$ n$ 的字符串,使得对于任意一个位置 $i$ ,都满足存在一个区间 $l \\le i \\le r$,使得这段区间代表的子串与某一个模式串相等\n\n$n\\le 1000, m\\le 10, |s| \\le 10$\n\n#### Solution\n\n[AC自动机]\n\nAC自动机上dp\n\n设$f_{x, i, len}$表示走到$x$节点，构造到第$i$位，结尾有$len$个字符不合法（没有模式串与它们匹配）的方案数，倒着dp\n\n预处理$maxlen_x$，表示$x$节点所有后缀最长的那个可匹配的串的长度（这可以在`build_fail`时求出）\n\n枚举AC自动机上节点$y$，若$maxlen_y \\ge len + 1$，则可以从$f_{y, i + 1, 0}$转移过来；否则从$f_{y, i + 1, len + 1}$转移过来\n\n有很多无用状态，记忆化搜索即可","categories":["Note"],"tags":["Summary","树状数组","KMP","字符串","AC自动机","Trie"]},{"title":"「CF1217F」Forced Online Queries Problem - 线段树分治 + 可撤销并查集","url":"/2019/09/08/%E3%80%8CCF1217F%E3%80%8DForced-Online-Queries-Problem-%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%88%86%E6%B2%BB-%E5%8F%AF%E6%92%A4%E9%94%80%E5%B9%B6%E6%9F%A5%E9%9B%86/","content":"\n$n$个点，$m$次操作：\n\n* `1, _x, _y` \n\n  令$x = (\\_x + last - 1) \\mathrm{mod}~n + 1, y=(\\_y + last - 1) \\mathrm{mod}~n + 1$\n\n  若$(x, y)$已经连接，则删掉$(x, y)$，否则连接$(x, y)$\n\n* `2, _x, _y`\n\n  令$x = (\\_x + last - 1) \\mathrm{mod}~n + 1, y=(\\_y + last - 1) \\mathrm{mod}~n + 1$\n\n  询问$x$和$y$是否联通，输出$0/1$\n\n其中$last$表示上一次询问的答案\n\n$n, m\\le 2\\times 10^5$\n\n<!--more-->\n\n### Link\n\n[CF1217 F](https://codeforces.com/contest/1217/problem/F)\n\n### Solution\n\n看上去是一道动态图板子\n\n但实际上因为这里的答案只可能是$0/1$，可能的操作只有两种，所以可以离线线段树分治搞\n\n具体来说，对于一次修改，把两种可能的操作都先搞出来。对于一个操作$(x, y)$，处理出它后面第一个可能的操作时间$nxt$\n\n线段树分治时，维护一个全局的$S_{x, y}$，表示边$(x, y)$当前的状态（已经连上/没连上）\n\n线段树处理到`l ==r`的时候，我们是知道当前的答案的，于是把答案对应的那一种操作的$S$异或上$1$。再对两种操作看其$S$是否为$1$，若为$1$，则在分治的线段树中，把当前操作应用到$[l + 1, nxt]$区间上\n\n> 感觉没讲清楚。。。不过脑补一下并不难\n\n### Summary\n\n这个离线做法本质上是把所有可能的情况都处理出来，把操作拆成若干段，只有跨过段的时候这条边的影响才有可能变化\n\n感觉是很巧妙的一道题\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n#define DEBUG(x) cout << #x << \" = \" << x << endl;\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int Maxn = 2e5 + 100;\n\nint N, M;\nmap <pii, int> Map, S;\nstruct opt\n{\n\tint op, x, y, ban;\n\tint l[2], r[2];\n} Q[Maxn];\n\nint ans;\n\ninline int trans (int x, int k) { return (x + k - 1) % N + 1; }\n\nnamespace DSU\n{\n\tint fa[Maxn], size[Maxn], top;\n\n\tstruct edge\n\t{\n\t\tint x, y, f;\n\t} stk[Maxn];\n\n\tinline void init () { for (int i = 1; i <= N; ++i) fa[i] = i, size[i] = 1; }\n\n\tinline int get_fa (int x) { return fa[x] == x ? x : get_fa (fa[x]); }\n\n\tinline void link (int x, int y)\n\t{\n\t\tx = get_fa (x), y = get_fa (y);\n\t\tif (size[x] < size[y]) swap (x, y);\n\n\t\tstk[++top] = (edge) {x, y, fa[y]};\n\t\tif (x != y) fa[y] = x, size[x] += size[y];\n\t}\n\n\tinline void pop ()\n\t{\n\t\tint x = stk[top].x, y = stk[top].y, f = stk[top].f; --top;\n\t\tsize[x] -= size[y];\n\t\tfa[y] = f;\n\t}\n\n\tinline int query (int x, int y) { return get_fa (x) == get_fa (y); }\n}\n\nnamespace SEG\n{\n#define mid ((l + r) >> 1)\n#define ls o << 1 \n#define rs o << 1 | 1\n#define lson ls, l, mid\n#define rson rs, mid + 1, r\n\n\tvector <pii> node[Maxn << 2];\n\n\tinline void update (int o, int l, int r, int x, int y, pii val)\n\t{\n\t\tif (x > y) return ;\n\t\tif (x <= l && r <= y) return void (node[o].pb (val));\n\t\tif (x <= mid) update (lson, x, y, val);\n\t\tif (y > mid) update (rson, x, y, val);\n\t}\n\n\tinline void solve (int o, int l, int r)\n\t{\n\t\tfor (int i = 0; i < node[o].size(); ++i) DSU :: link (node[o][i].x, node[o][i].y);\n\n\t\tif (l == r)\n\t\t{\n\t\t\tif (Q[l].op == 2) printf(\"%d\", ans = DSU :: query (trans (Q[l].x, ans), trans (Q[l].y, ans)));\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor (int k = 0; k < 2; ++k)\n\t\t\t\t{\n\t\t\t\t\tif (Q[l].ban && ans != k) continue;\n\t\t\t\t\tint x = trans (Q[l].x, k), y = trans (Q[l].y, k);\n\t\t\t\t\tif (x > y) swap (x, y);\n\t\t\t\t\tif (ans == k) S[mp (x, y)] ^= 1;\n\t\t\t\t\tif (S[mp (x, y)]) SEG :: update (1, 1, M, Q[l].l[k], Q[l].r[k], mp (x, y));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse solve (lson), solve (rson);\n\n\t\tfor (int i = 0; i < node[o].size(); ++i) DSU :: pop ();\n\t}\n#undef mid\n}\n\ninline void Solve ()\n{\n\tfor (int i = M; i >= 1; --i)\n\t{\n\t\tif (Q[i].op == 2) continue;\n\t\tfor (int k = 0; k < 2; ++k)\n\t\t{\n\t\t\tint x = trans (Q[i].x, k), y = trans (Q[i].y, k);\n\t\t\tif (x > y) swap (x, y);\n\n\t\t\tQ[i].l[k] = i + 1, Q[i].r[k] = M;\n\t\t\tif (Map[mp (x, y)])\n\t\t\t{\n\t\t\t\tif (Map[mp (x, y)] == i) Q[i].ban = 1, Q[i].r[k] = Q[i].r[!k];\n\t\t\t\telse Q[i].r[k] = Map[mp (x, y)];\n\t\t\t}\n\t\t\tMap[mp (x, y)] = i;\n\t\t}\n\t}\n\n\tDSU :: init ();\n\tSEG :: solve (1, 1, M);\n}\n\ninline void Input ()\n{\n\tN = read<int>(), M = read<int>();\n\tfor (int i = 1; i <= M; ++i)\n\t\tQ[i].op = read<int>(), Q[i].x = read<int>(), Q[i].y = read<int>();\n}\n\nint main()\n{\n\n#ifndef ONLINE_JUDGE\n\tfreopen(\"F.in\", \"r\", stdin);\n\tfreopen(\"F.out\", \"w\", stdout);\n#endif\n\n\tInput ();\n\tSolve ();\n\n\treturn 0;\n}\n\n```\n\n","categories":["Problem"],"tags":["Codeforces","线段树","数据结构","并查集","线段树分治"]},{"title":"「CF1060F」Shrinking Tree - 概率 + 动态规划 + 计数","url":"/2019/09/05/%E3%80%8CCF1060F%E3%80%8DShrinking-Tree-%E6%A6%82%E7%8E%87-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%AE%A1%E6%95%B0/","content":"\n一棵$n$个点的树，进行$n−1$轮操作，每轮操作随机选择一条边$(u,v)$，将$u,v$两点合成一个点。即删去这两个点后新建一个点$x$，将原来与$u$或$v$连边的点连向$x$，接着$x$的编号随机为$u,v$中的一个。\n\n求每个点最终留下的概率。\n\n$n\\le 50$\n\n<!--more-->\n\n### Link\n\n[CF1060 F](https://codeforc.es/contest/1060/problem/F)\n\n### Solution\n\n> 神仙计数题。。。\n\n考虑枚举根结点，对每种缩边方案算出根结点存活的概率\n\n注意到几个比较显然的性质: \n\n1. 在同一个缩边方案中，标号分配不会使树的形态发生改变\n\n2. 两个子树合并到他们的$lca$上, 两个子树的方案相对独立\n\n   > 它们的根结点只是编号消失了, 但还是保持拥有根节点的形态\n\n3. 如果根结点固定了, 与它无关的边删除不会影响根节点存活的概率\n\n假设根结点固定为$r$t. 由于性质3, 我们可以将$dp[u]$的状态划分为两个部分, 一个部分是$rt$合并到$u$之前；另一部分是$rt$合并到$u$之后, 这时$u$每和一个节点合并都会产生$\\frac 12$的贡献.\n\n设$dp[u][i]$表示**在$u$子树内, $rt$合并到它时, 还剩$i$条边, 合并之后再删成只剩$rt$, 且$rt$存活的概率**. 这就描述了上述过程, 我们要求的就是$dp[rt][n - 1]$\n\n考虑怎么把子树$v$转移到父亲$u$上. 由于和边相关, 我们先将边$(u, v)$加入$dp[v]$的状态, 设新状态为$g[]$, 表示只关心$v$子树和$(u, v)$这条边时的概率（不考虑其他儿子所在子树）\n\n由于有两个部分, 我们可以枚举$rt$合并到$u$时还剩$i$, 接着子树$v$内部合并到只剩下$j$, 这时再合并$(u, v)$, 产生$\\frac 12$的贡献, 最后内部合并. \n\n那么$\\displaystyle g[i]= \\frac12\\sum_{j=0}^{i-1}dp[v][j] $. 边$(u, v)$还可能在$rt$到$u$之前就已经合并了, 此时在长度为$size_v - 1$的缩边序列中任意一个空位(包括开头,结尾)插入即可. 因此$dp[v][i] \\cdot (size[v] - i) \\rightarrow g[i]$. \n\n接下来对$u$一堆儿子的$g[]$进行两两合并, 左儿子状态$g[v][i]$, 右儿子状态$g[u][j]$. rt到后, i和j内部方案组合, 产生$\\displaystyle {i + j\\choose i}$的贡献, 同理到之前的状态, $\\displaystyle {siz[u] + siz[v] - i - j\\choose siz[u] - i}$, 由于包含父亲边, $siz$不用减$1$.\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n#define DEBUG(x) cout << #x << \" = \" << x << endl;\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int Maxn = 50 + 5;\n\nint N;\ndouble fac[Maxn];\ndouble Dp[Maxn][Maxn], g[Maxn], tmp[Maxn];\nint e, Begin[Maxn], To[Maxn << 1], Next[Maxn << 1];\nint size[Maxn];\n\ninline void add_edge (int x, int y) { To[++e] = y; Next[e] = Begin[x]; Begin[x] = e; }\n\ninline double C (int n, int m) { return fac[n] / fac[m] / fac[n - m]; }\n\ninline void get_g (int x)\n{\n\tfor (int i = 0; i <= size[x]; ++i)\n\t{\n\t\tg[i] = 0;\n\t\tfor (int j = 0; j < i; ++j) g[i] += Dp[x][j] / 2;\n\t\tg[i] += Dp[x][i] * (size[x] - i);\n\t}\n}\n\ninline void dfs (int x, int f)\n{\n\tsize[x] = 1;\n\tDp[x][0] = 1;\n\tfor (int i = Begin[x]; i; i = Next[i])\n\t{\n\t\tint y = To[i];\n\t\tif (y == f) continue;\n\t\tdfs (y, x);\n\n\t\tget_g (y);\n\n\t\tfor (int i = 0; i < size[x] + size[y]; ++i) tmp[i] = 0;\n\t\tfor (int i = 0; i < size[x]; ++i)\n\t\t\tfor (int j = 0; j <= size[y]; ++j)\n\t\t\t\ttmp[i + j] += C (i + j, i) * C(size[x] + size[y] - i - j - 1, size[x] - i - 1)  * Dp[x][i] * g[j];\n\n\t\tsize[x] += size[y];\n\t\tfor (int i = 0; i < size[x]; ++i) Dp[x][i] = tmp[i];\n\t}\n}\n\ninline void Solve ()\n{\n\tfor (int o = 1; o <= N; ++o)\n\t{\n\t\tmemset (Dp, 0, sizeof Dp);\n\t\tdfs (o, 0);\n\t\tprintf(\"%.7lf\\n\", Dp[o][N - 1] / fac[N - 1]);\n\t}\n}\n\ninline void Input ()\n{\n\tN = read<int>();\n\tfor (int i = 1; i < N; ++i)\n\t{\n\t\tint x = read<int>(), y = read<int>();\n\t\tadd_edge (x, y);\n\t\tadd_edge (y, x);\n\t}\n}\n\ninline void Init ()\n{\n\tfac[0] = 1;\n\tfor (int i = 1; i <= 50; ++i) fac[i] = fac[i - 1] * i;\n}\n\nint main()\n{\n\n#ifndef ONLINE_JUDGE\n\tfreopen(\"F.in\", \"r\", stdin);\n\tfreopen(\"F.out\", \"w\", stdout);\n#endif\n\n\tInit ();\n\tInput ();\n\tSolve ();\n\n\treturn 0;\n}\n\n```\n\n","categories":["Problem"],"tags":["Codeforces","动态规划","计数","概率和期望"]},{"title":"「ZJOI2015」地震后的幻想乡 - 概率和期望 + 状压dp","url":"/2019/09/04/%E3%80%8CZJOI2015%E3%80%8D%E5%9C%B0%E9%9C%87%E5%90%8E%E7%9A%84%E5%B9%BB%E6%83%B3%E4%B9%A1-%E6%A6%82%E7%8E%87%E5%92%8C%E6%9C%9F%E6%9C%9B-%E7%8A%B6%E5%8E%8Bdp/","content":"\n给一个 $n$ 个点,$m$ 条边的图,边权为 $[0, 1]$ 的均匀分布的随机实数,求最小生成树的最大边权的期望\n\n提示：对于 $n$ 个 $[0, 1]$ 之间的随机变量 $x_1, x_2,\\dots x_n$，第 $k$ 小的那个的期望值是$\\frac{k}{n + 1}$\n\n$n\\le 10, m\\le \\frac{n(n-1)}{2}$\n\n<!--more-->\n\n### Link\n\n[LOJ2136](https://loj.ac/problem/2136)\n\n### Solution\n\n![19-9-4-1](/images/19-9-4-1.png)\n\n设 $f[S][i]$ 为 $G(S)$ 中选 $i$ 条边使原图不连通的方案数, $g[S][i]$ 为 $G(S)$ 中选 $i$ 条边使原图连通的方案数, $ecnt[S]$ 为 $G(S)$ 中所包含的边数.\n\n首先显然有: $g[S][i] = {ecnt[S] \\choose i}- f[S][i]$ ，由于联通性的定义为任意两点可以到达，我们考虑**钦定一个点**，枚举它所能到的点集 $T$, 以及它不能到达的点集 $\\complement_{S}^T$, 有转移:\n$$\nf[S][i] = \\sum_{T\\subsetneqq S} \\sum_{j=0}^{\\min\\{i, ecnt[T]\\}} g[T][j] \\times {ecnt[\\complement_{S}^T]\\choose i - j}\n$$\n\n### Summary\n\n前面期望转概率的部分有点巧妙\n\n后半部分又是这种钦定某一个点的计数方法，一定要掌握\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n#define DEBUG(x) cout << #x << \" = \" << x << endl;\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int Maxn = 10 + 5, Maxs = (1 << 10) + 10, Maxm = 50 + 10;\n\nnamespace MATH\n{\n\tLL C[Maxm][Maxm];\n\n\tinline void init (int n = 45)\n\t{\n\t\tC[0][0] = 1;\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t{\n\t\t\tC[i][0] = 1;\n\t\t\tfor (int j = 1; j <= i; ++j)\n\t\t\t\tC[i][j] = C[i - 1][j] + C[i - 1][j - 1];\n\t\t}\n\t}\n}\n\nusing namespace MATH;\n\nint N, M, ALL;\nint A[Maxn][Maxn];\nint ecnt[Maxs];\n\ninline void print (int x)\n{\n\tint buc[30]; buc[0] = 0;\n\twhile (x) buc[++buc[0]] = x & 1, x >>= 1;\n\tfor (int i = 1; i <= buc[0]; ++i) cout << buc[i];\n\tfor (int i = buc[0] + 1; i <= N; ++i) cout << 0;\n}\n\ninline void Init ()\n{\n\tALL = (1 << N) - 1;\n\n\tfor (int S = 0; S <= ALL; ++S)\n\t{\n\t\tfor (int i = 1; i <= N; ++i)\n\t\t{\n\t\t\tif (S & (1 << (i - 1))) continue;\n\t\t\tint T = S | (1 << (i - 1));\n\t\t\tecnt[T] = ecnt[S];\n\t\t\tfor (int j = 1; j <= N; ++j)\n\t\t\t\tif (S & (1 << (j - 1)))\n\t\t\t\t\tecnt[T] += A[i][j];\n\t\t}\n\t}\n}\n\nLL f[Maxs][Maxm], g[Maxs][Maxm];\n\ninline void Solve () // f : 不联通， g : 联通\n{\n\tInit ();\n\n\tfor (int S = 0; S <= ALL; ++S)\n\t{\n\t\tif (__builtin_popcount (S) == 1) f[S][0] = 0, g[S][0] = 1;\n\n\t\tint pos = 0;\n\t\tfor (int j = 0; j < N; ++j) if (S & (1 << j)) pos = 1 << j;\n\n\t\tfor (int i = 0; i <= ecnt[S]; ++i)\n\t\t{\n\t\t\tg[S][i] = C[ecnt[S]][i];\n\t\t\tfor (int T = (S - 1) & S; T > 0; T = (T - 1) & S)\n\t\t\t{\n\t\t\t\tif (!(T & pos)) continue;\n\t\t\t\tfor (int j = 0; j <= min (i, ecnt[T]); ++j)\n\t\t\t\t\tf[S][i] += g[T][j] * C[ecnt[S ^ T]][i - j];\n\t\t\t}\n\t\t\tg[S][i] -= f[S][i];\n\t\t}\n\t}\n\n\tdouble ans = 0;\n\tfor (int i = 0; i < M; ++i) ans += 1.0 * f[ALL][i] / C[M][i];\n\n\tprintf(\"%.6lf\\n\", ans / (M + 1));\n}\n\ninline void Input ()\n{\n\tN = read<int>(), M = read<int>();\n\tfor (int i = 1; i <= M; ++i)\n\t{\n\t\tint x = read<int>(), y = read<int>();\n\t\tA[x][y] = A[y][x] = 1;\n\t}\n}\n\nint main()\n{\n\n#ifndef ONLINE_JUDGE\n\tfreopen(\"A.in\", \"r\", stdin);\n\tfreopen(\"A.out\", \"w\", stdout);\n#endif\n\n\tMATH :: init ();\n\tInput ();\n\tSolve ();\n\n\treturn 0;\n}\n\n```\n\n","categories":["Problem"],"tags":["动态规划","状态压缩","概率和期望","省选"]},{"title":"「AGC035」F - Two Histograms - 容斥","url":"/2019/09/04/%E3%80%8CAGC035%E3%80%8DF-Two-Histograms-%E5%AE%B9%E6%96%A5/","content":"\n你有一个 $n$ 行、$m$ 列的、每个格子都填写着 $0$ 的表格。你进行了下面的操作:\n\n* 对于每一行 $i$ ,选定自然数 $r_i (0 \\le r_i \\le m)$,将这一行最左边的 $r_i$ 个格子中的数 $+1$\n* 对于每一列 $i$ ,选定自然数 $c_i (0 \\le c_i \\le n)$, 将这一列最上面的 $c_i$ 个格子中的数 $+1$\n\n问最终表格有多少种本质不同的方案\n\n<!--more-->\n\n### Link\n\n[AGC035F](https://agc035.contest.atcoder.jp/tasks/agc035_f)\n\n### Solution\n\n只有这一种可能会算重：$r_i = j, c_j = i - 1$，和$r_i = j - 1, c_j = i$\n\n考虑把**包含前一种情况**的方案都减掉\n\n枚举**强制**有几对行列是前一种情况情况，剩下的随便填，然后容斥\n$$\nf(k) = \\binom{n}{k}\\times\\binom{m}{k}\\times k!\\times (m+1)^{n-k} \\times (n+1)^{m-k}\n$$\n\n$$\nans = \\sum_{k=0}^{\\min\\{n, m\\}}(-1)^{k}f(k)\n$$\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n#define DEBUG(x) cout << #x << \" = \" << x << endl;\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int Maxn = 5e5 + 100;\nconst int Mod = 998244353;\n\nnamespace MATH\n{\n\tint fac[Maxn], ifac[Maxn];\n\n\tinline void Add (int &a, int b) { if ((a += b) >= Mod) a -= Mod; }\n\n\tinline int Pow (int a, int b)\n\t{\n\t\tint ans = 1;\n\t\tfor (int i = b; i; i >>= 1, a = (LL) a * a % Mod) if (i & 1) ans = (LL) ans * a % Mod;\n\t\treturn ans;\n\t}\n\n\tinline void init (int n = 5e5)\n\t{\n\t\tfac[0] = 1;\n\t\tfor (int i = 1; i <= n; ++i) fac[i] = (LL) fac[i - 1] * i % Mod;\n\t\tifac[n] = Pow (fac[n], Mod - 2);\n\t\tfor (int i = n - 1; i >= 0; --i) ifac[i] = (LL) ifac[i + 1] * (i + 1) % Mod;\n\t}\n\n\tinline int C (int n, int m) { if (n < m) return 0; return (LL) fac[n] * ifac[m] % Mod * ifac[n - m] % Mod; }\n}\n\nusing namespace MATH;\n\nint N, M;\n\ninline void Solve ()\n{\n\tint ans = 0;\n\tfor (int k = 0; k <= min (N, M); ++k)\n\t{\n\t\tint sum = (LL) C (N, k) * C (M, k) % Mod * fac[k] % Mod * Pow (M + 1, N - k) % Mod * Pow (N + 1, M - k) % Mod;\n\t\tif (k & 1) Add (ans, Mod - sum);\n\t\telse Add (ans, sum);\n\t}\n\tcout << ans << endl;\n}\n\ninline void Input ()\n{\n\tN = read<int>(), M = read<int>();\n}\n\nint main()\n{\n\n#ifdef hk_cnyali\n\tfreopen(\"F.in\", \"r\", stdin);\n\tfreopen(\"F.out\", \"w\", stdout);\n#endif\n\n\tMATH :: init ();\n\tInput ();\n\tSolve ();\n\n\treturn 0;\n}\n\n```\n\n","categories":["Problem"],"tags":["容斥","计数","Atcoder"]},{"title":"2019年9月","url":"/2019/09/03/2019%E5%B9%B49%E6%9C%88/","content":"\n一点小记录\n\n<!--more-->\n\n## 好题选讲做题记录\n\n1. [「BZOJ2138」stone - Hall定理 + 线段树](https://hk-cnyali.com/2019/08/27/「BZOJ2138」stone-Hall定理-线段树)\n2. [「UR #5」怎样更有力气 - 并查集](https://hk-cnyali.com/2019/08/29/「UR-5」怎样更有力气-并查集/)\n3. [「ARC083」F - Collecting Balls - 基环树 + 思维](https://hk-cnyali.com/2019/08/31/「ARC083」F-Collecting-Balls-基环树-思维/)\n4. [「AGC028」D - Chords - 动态规划 + 计数](https://hk-cnyali.com/2019/07/31/Atcoder/#D)\n5. [「AGC012」E - Camel and Oases - 状压dp](https://hk-cnyali.com/2019/09/02/「AGC012」E-Camel-and-Oases-状压dp/)\n6. [「CTS2019」重复 - KMP自动机 + 动态规划](https://loj.ac/submission/590604)\n7. [「CF868E」Policeman and a Tree - 动态规划](https://hk-cnyali.com/2019/09/02/「CF868E」Policeman-and-a-Tree-动态规划/)\n8. [「AGC035」F - Two Histograms - 容斥](https://hk-cnyali.com/2019/09/04/「AGC035」F-Two-Histograms-容斥/)\n9. [「ZJOI2015」地震后的幻想乡 - 概率和期望 + 状压dp](https://hk-cnyali.com/2019/09/04/「ZJOI2015」地震后的幻想乡-概率和期望-状压dp/)\n10. [「CF1060F」Shrinking Tree - 概率 + 动态规划 + 计数](https://hk-cnyali.com/2019/09/05/%E3%80%8CCF1060F%E3%80%8DShrinking-Tree-%E6%A6%82%E7%8E%87-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%AE%A1%E6%95%B0/)\n11. [「UOJ #6」懒癌 - 思维 + 结论 + bitset](http://uoj.ac/submission/363009)\n12. [「CTS2019」珍珠 - 生成函数 + NTT + 容斥](https://hk-cnyali.com/2019/09/16/「CTS2019」珍珠-生成函数-NTT-容斥/)\n\n## 9-3\n\n### Process\n\n代码能力还是太差，写T4写了一上午。T2、T3根本来不及看\n\n以后还是要**合理分配时间**。。。\n\n### T1\n\n随便搞，我是直接枚举$[\\lfloor \\frac{n}{2}\\rfloor  - 3, \\lfloor\\frac{n}{2}\\rfloor + 3]$内的数划分...\n\n显然两个数差得越小越好\n\n### T2\n\n[计数][容斥] [巧妙]\n\n考虑和连通图计数类似的做法\n\n设$f_{i, j}$表示$i$个点的连通图，每种方案为边数的$j\\in[0, 1, 2]$次幂的答案，$g_{i, j}$表示$i$个点任意图的答案\n\n显然，$j=0$时就是裸的连通图计数\n$$\nf_{n, 0} = g_{n, 0} - \\sum_{i=1}^{n - 1}\\binom{n - 1}{i - 1}f_{i, 0} \\times g_{n - i, 0}\n$$\n考虑$j=1$：\n\n与$j=0$类似的方法，前面都是一样的，只是最后一坨东西算法不一样\n\n假设枚举出来的$i$个点图的连边方案的**边数**为集合$S$，$n-i$个点图的连边方案的**边数**为集合$T$\n\n那么我们就是要分别枚举$S,T$中的元素，然后合并起来，即\n$$\n\\sum_{x\\in S}\\sum_{y\\in T}(x + y)\n$$\n化下式子：\n$$\n\\sum_{x\\in S}x\\times \\Big(\\sum_{y\\in T}\\Big) + \\Big(\\sum_{x\\in S}\\Big) \\times \\sum_{y\\in T}y\n$$\n\n\n到这一步就很显然了\n$$\nf_{n, 1} = g_{n, 1} - \\sum_{i=1}^{n - 1}\\binom{n - 1}{i - 1}\\Big(f_{i, 1} \\times g_{n - i, 0} + f_{i, 0}\\times g_{n - i, 1}\\Big)\n$$\n继续考虑$j=2$：\n$$\n\\begin{aligned}\n&\\sum_{x\\in S}\\sum_{y\\in T}(x + y)^2\\\\\n=&\\Big(\\sum_{x\\in S}x^2\\Big) \\times \\Big(\\sum_{y\\in T}\\Big) + 2\\Big(\\sum_{x\\in S}x\\Big)\\times\\Big(\\sum_{y\\in T}y\\Big) + \\Big(\\sum_{x\\in S}\\Big) \\times \\Big(\\sum_{y\\in T}y^2\\Big)\n\\end{aligned}\n$$\ndp式子就不放了\n\n---\n\n然后考虑求$g$，设$m = \\frac{i (i - 1)}{2}$\n$$\n\\begin{aligned}\ng_{i, 0} &= 2^m\\\\\ng_{i, 1} &= m2^{m-1}\\\\\ng_{i, 2} &= m2^{m-1} + m(m-1)2^{m-2}\\\\\n\\end{aligned}\n$$\n\n>解释一下\n>\n>$j=1$时，考虑每条边的贡献，保证它出现，然后其他边随便选或不选的方案\n>\n>$j=2$时，对于某个边数为$d$的图，考虑把贡献看成$(1+1+1+\\dots+1)\\times(1+1+1+\\dots+1)$的形式\n>\n>即枚举图中的两条边，它们两的贡献是$1\\times1 = 1$，这样就把乘积转化为求和的形式了\n>\n>讨论一下这两条边是否是同一条边\n\n### T3\n\n[基环树] [动态规划] [背包] \n\n首先，对于一条边$(l_i, r_i, s_i)$而言，若被$l_i$选，则权值为$s_i$；否则为$-s_i$\n\n那么和[这道题](https://hk-cnyali.com/2019/08/31/「ARC083」F-Collecting-Balls-基环树-思维/)一样的转化后，显然是一棵基环树森林，每个基环树上只有可能是两种取值，假设它们为$a, b(a > b)$\n\n我们需要求出两种方案，一种的权值和在数轴上正方向最接近$0$，另一种在负方向上最接近$0$\n\n先每个基环树都取$a$权值（较大的），求出来的权值和在$t$的位置\n\n* 若$t \\le 0$，则再换小的肯定不会更优\n\n* 若$t > 0$，则有可能通过把某些$a$换成$b$之后，$t$会减小，且仍$>0$\n\n  再抽象一下，即现在有若干个的物品（权值为$a-b$），需要用它们填一个容积为$t$的背包，问最多能填多少\n\n  因为权值比较小，重复的物品较多，所以跑多重背包即可\n\n再对每个基环树取$b$权值，做一遍类似操作即可，即从负方向逼近$0$一次\n\n### T4\n\n[k-d tree]\n\n我直接写的三维`k-d tree`，过了\n\n## 9-4\n\n### Process\n\n三道题都比较简单，没有挂分。要继续保持\n\n### T1\n\n我直接用的`set+链表`模拟，实际上就是求最长上升子序列的长度\n\n### T2\n\n[动态规划] [字符串] [AC自动机]\n\n$dp[i][j]$表示到填第$i$位，从$i - 4$至$i$构成的数等于$j$的方案数\n\n转移的时候注意一下前导0\n\n> 实际上也可以AC自动机做\n\n### T3\n\n直接模拟，用`BIT`链加即可\n\n\n\n## 9-5\n\n### Process\n\n半个小时写完T1，想了很久的T2，无果，复习了一下SAM之后把T3写了。最后把T2写了个退火，获得了20分的好成绩\n\ndp掌握的不太熟练，要多加练习\n\n### T1\n\n[数学]\n\n令$a = E(A), b = E(B)$，则$f[i] = f[i - 1] * a + b$\n\n$ans = f[k]$\n\n等比数列求和即可，比较简单\n\n---\n\n注意特判公比为$1$的情况！！！ \n\n### T2\n\n[动态规划] [DP优化]\n\n首先需要注意到，最终的01串中的每一个数字展开（还原后）是一系列**不相交**的区间！！！\n\n于是可以区间dp，设$f[i][j][S]$表示区间$[i, j]$，合成的状态为$S$的最大分数\n\n因为区间长度确定，且每次操作后，长度都会减少$K-1$，因此$S$的位数是确定的\n\n设$len(i)$表示区间长度为$i$时， 最终合成的状态的长度，那么区间dp转移时枚举的$k$需要满足$len (k - i + 1) + len(j - k) \\le K$\n\n因此，所有$>K$的状态都可以通过若干个$\\le K$的状态合并出来\n\n再优化一下，发现只需要保证$len(j - k) = 1$即可，道理是一样的\n\n时间复杂度$O(n^3 2^k)$，常数很小\n\n---\n\n一道dp好题！\n\n只不过一开始的区间dp我就没想到，一开始觉得转移之间会有问题，就没去想了，自己yy了一个假做法\n\n后面的一些优化都比较~~套路，只是我不会~~巧妙\n\n### T3\n\n[字符串] [后缀自动机] [广义后缀自动机]\n\n建`广义SAM` ，处理出$size[i]$表示$i$节点，只有**$S$串的传统节点**有$1$的贡献的子树大小 $\\times $ $i$节点的$maxlen - minlen$；$sum[i]$是$i$到根的$size$之和\n\n在`SAM`上匹配$T$串，找到每个前缀的对应节点，答案加上该结点的$sum$\n\n> 即对$T$的每个前缀，把答案加上所有后缀在$S$中的出现次数\n>\n> 每个点到根的$size$之和，就是其所有后缀的出现次数\n\n\n\n## 9-6\n\n### Process\n\n\n\nT1的小结论我讲课讲过，积分部分也不难；T3是[已经没有什么好害怕的了](https://hk-cnyali.com/2018/12/20/「BZOJ3622」已经没有什么好害怕的了-容斥-二项式反演-动态规划/)的弱化版。。。\n\nT2题没看懂，写了个乱搞拿了20分\n\n考场上T3搞了很久才想起来做法，反映出自己容斥还是比较弱，需要加强\n\n### T1\n\n[积分] [概率和期望] [方差]\n\n首先有\n$$\nD(X) = E(X^2) - E^2(X)\n$$\n后面显然就是$(\\frac{l+r}{2})^2$，前面可以积分，原函数是$\\displaystyle h(x) = \\frac{1}{3}x^3 + C$，那么$\\displaystyle E(X^2) = \\frac{\\frac1 3x^3}{r - l}$\n\n最后化简一下，$\\displaystyle D(X) = \\frac{(r - l)^2}{12}$ \n\n### T2\n\n插头dp\n\n### T3\n\n[容斥] [动态规划] [斯特林数]\n\n容斥，设$f_i$为恰好违反$i$次规则的方案数，$g_i$为至少违反$i$次规则的方案数\n$$\n\\begin{aligned}\n&g_k = \\sum_{i=k}^{n}\\binom{i}{k}f_i\\\\\n\\Rightarrow &f_k = \\sum_{i=k}^{n} (-1)^{i-k}\\binom{i}{k}g_i\n\\end{aligned}\n$$\n然后考虑如何求$g$\n\n显然题目中的$v$没有意义，把$v$排序后就是一个$n$的排列。于是转化为，求有多少个排列$p$，至少有$k$个位置满足$p_i < i$\n\n设$dp_{i, j}$表示考虑到第$i$位，有$j$个位置满足限制（不考虑顺序）的方案数，那么$g_i = dp_{n, i}\\times\\binom{n}{i}\\times (n - i)!$\n\n> 今天才搞懂容斥是怎么回事。。。\n>\n> 这里$dp_{n, i}$表示的，有$i$个限制的方案，指的是只保证这$i$个限制一定满足，而其他的数完全不考虑如何填的方案数，它并没有什么实际意义。乘上$\\binom{n}{i}\\times(n-i)!$之后才表示至少有$i$个限制的方案数\n>\n> 而这里定义的，至少有$i$个限制的方案数，也并不是真正意义上的至少。因为这里的`至少`是会算重的，否则$f_i$为什么不等于$g_{i + 1} - g_i$\n>\n> 正确的定义应该是，强制（钦定）$i$个条件满足的方案数，只有这样才能从根本上使计数更加方便\n\n这个$dp$转移很简单，若第$i$个数满足限制，那么它能填前$i-1$个数的某一个；又因为前面已经选了$j-1$个数，所以它只有$i-j$种选法\n$$\ndp_{i, j} = dp_{i - 1, j} + (i - j)\\times dp_{i - 1, j - 1}\n$$\n注意到，把数组第二维翻转后就是第二类斯特林数的形式\n\n多项式可以优化到$O(n\\log n)$\n\n## 9-8\n\n### Process\n\nT1几分钟写完，T2看错题，以为所有关键点都要在联通块中，浪费了很久时间\n\nT3最后二十分钟rush出来了\n\n### T1\n\n或的答案就是整个数组，与的答案就是每个长度为$k$的区间\n\n### T2\n\n[动态规划]\n\n用`总联通块数` 减去 `不满足条件的联通块数`即可\n\n对于每个点，统计以它作为联通块的最低点的方案\n\n### T3\n\n[堆][贪心]\n\n贪心枚举最右边到了哪一列，中间每一列至少选一个，最多选$n$个，总共要选$k$个\n\n用一个小根堆随便维护一下\n\n## 9-9\n\n### Process\n\nT1搞了好久，矩阵快速幂推式子又推了半天！！！\n\n然后剩下时间都在搞T2，写了一个退火乱搞只拿到了35分。考完之后发现T3是sb题\n\n**简单题还是做得太慢！！！**\n\n### T1\n\n[矩阵快速幂]\n\n随便找规律/搞系数，矩阵快速幂优化\n\n### T2\n\n[边双] [缩点] [背包] [动态规划] [计数]\n\n显然先缩边双。一个直观的贪心是枚举每个点为根，然后每个点从父亲往它连边\n\n但是这个做法很容易被hack掉\n\n![19-9-9-1](/images/19-9-9-1.png)\n\n![19-9-9-2](/images/19-9-9-2.png)\n\n注意，题解中$deg[i]$是表示$i$这个边双的大小。。。\n\n第一部分就是那个看成树的贪心，第二部分直接背包\n\n### T3\n\n[set] [数据结构]\n\n因为$a_i\\le 100$，于是考虑和值域相关的做法\n\n对于每个权值维护一个`set`，存该权值的出现位置\n\n每次枚举一个权值，求出其位于当前区间内的出现次数，然后删掉这一段\n\n计算出平均值后，按照题意重新赋值\n\n直接暴力搞肯定不行，发现每次赋值都是一些连续段，于是`set`维护`pair`，存这样的连续段即可\n\n时间复杂度不太会分析，但是看上去很对，跑得也很快\n\n\n\n## 9-10\n\n### Process\n\n现在开始联考了，考场状态还是有点问题，要多锻炼\n\n先写的T2，写了个$O(nm)$的做法，随便找找规律就找出来了。T1暴力状压，复杂度$O(3^nk^2)$，可以随便跑。T3考场上想了个$O(n^3)$的背包，结果没调出来，应该是有问题的，因为不好组合\n\n最后T3暴力还挂了分，很不应该\n\n### T1\n\n[动态规划]\n\n暴力状压\n\n### T2\n\n找规律\n\n### T3\n\n[概率和期望] [动态规划] [换根dp] [前缀和]\n\n把题目中$p^k$的贡献拆开，把$p$拆到每个$k$上\n\n先枚举根，然后设$f[i]$表示只考虑$i$子树时的期望答案，因为$i$的每个子树是独立的，所以可以直接把期望乘起来，再考虑$i$这个点的影响。若在值域序列中，$i$插到最前面的位置（$\\frac{1}{size[i]}$的概率），则贡献$p$；否则（$\\frac{size[x] - 1}{size[x] }$的概率）贡献$1$\n$$\nf[x] = \\prod_{y\\in son[x]} f[y] \\times (\\frac{p}{size[x]} + \\frac{size[x] - 1}{size[x]})\n$$\n然后换根$dp$即可\n\n因为$\\frac{p + size[x] - 1}{size[x]}$可能等于0，所以要记个前后缀积来dp\n\n> 另外一种做法：考虑每个点的贡献，设$sz[x]$表示在$1$为根情况下的$size$，则它的$size$要么是$sz$，要么是$n-sz$，要么是$n$\n>\n> 在$dfn$上差分一下即可\n\n\n\n## 9-12\n\n### Process\n\n玩了好久的T1。T2考过。T3暴力没写完\n\n### Summary\n\n不知道为什么还是感觉时间不够，又出现了暴力写不完的情况\n\n感觉这几天有点集中不了精力去想题。。。\n\n### T1\n\n先从大到小贪心，然后前十二位爆搜一下所有方案\n\n### T2\n\n[对偶图]\n\n平面图转对偶图，把原图中的面看成点\n\n[具体见此](https://hk-cnyali.com/2018/09/25/9-24模拟赛-Summary/)\n\n### T3\n\n...\n\n\n\n## 9-14\n\n### Process\n\n三个比较规整的分，T2挂了20~30分，T3挂了20分\n\nT1想得有点久，花了快半个小时的时间才想出来。T2搞了很久，因为没见过这个套路所以没搞出来。T3想了个假做法，写到一半才发现有问题\n\n### T1\n\n[贪心]\n\n从高位往低位贪心，每次看所有符合条件的边是否能使$1$和$n$连通\n\n### T2\n\n[two pointers]\n\n又是经典套路我不会系列\n\n用两个栈维护队列，从而维护`two pointers`。这个东西常用于没有可减性的问题上\n\n具体实现[见此](https://hk-cnyali.com/2019/9/16/「ACM-ICPC2019」上海网络赛-简要题解/)\n\n### T3\n\n[kruskal重构树] [分块]\n\n建kruskal重构树，对询问分块\n\n## 9-18\n\n### Process\n\n今天可能是这段时间以来唯一一次自己稍微满意一点的模拟赛了吧。。。\n\nT1花了二十分钟，T2先写的$O(n^3)$，然后优化到$O(n^2)$，然后优化到了$O(10n)$的。T3写了个暴力\n\n没挂分，考试过程中比较虚，花了比较长时间检查，以至于T3没有太多时间思考\n\n### T1\n\n [前缀和] \n\n把坐标系旋转45度，然后直接前缀和\n\n### T2\n\n[计数]\n\n考虑枚举逆序对的位置$(i, j)$，统计它对答案的贡献\n\n暴力计算的时候需要枚举第一个没卡到上界的位置$k$，分五种情况讨论\n\n很容易用前缀和优化到$O(n^2)$\n\n再做一次前缀和，加上一点点非常简单的计数技巧就能优化到$O(10n)$了\n\n### T3\n\n[数据结构] [树状数组] [线段树] [set] [势能分析]\n\n![19-9-19-1](/images/19-9-19-1.png)\n\n> 主要思想就是把询问离线，动态维护每个元素最右端位置，以统计答案\n\n然后考虑链：给定的路径都是一段区间。也就是说，上述问题的每个元素变成了一段区间。\n\n仍考虑上述做法，但需要支持快速把某一段区间的信息都更新\n\n因为每次是整段整段地更新，每段内信息相同，于是考虑维护颜色段\n\n直观的做法就是维护一个`set`，每次找到与当前$[l, r]$相交的所有颜色段（包括包含），将它们暴力一个个删掉，再把当前段加入\n\n复杂度简单势能分析即可\n\n具体实现时，可以用线段树代替`set`，写起来更方便，没有细节。修改时要递归到只有一种颜色的区间（线段树维护`min、max`，判断`min == max`）\n\n\n\n## 9-20\n\n### Process\n\n先写的T2、T3，最后开的T1，T1写了很久，代码能力有点差。。。\n\n### T1\n\n[树链剖分] [暴力]\n\n注意到`add`数量很少，于是每次重构树剖即可\n\n如果线段树维护的话，重构复杂度是$O(n)$（线段树`build`是$O(n)$），询问$O(\\log^2n)$\n\n`ST表`维护的话，重构复杂度$O(n\\log n)$，询问$O(\\log n)$\n\n### T2\n\n[线性筛] [欧拉函数]\n\n线性筛$\\varphi$即可\n\n### T3\n\n [后缀自动机]\n\n`SAM`随便算一下本质不同子串\n\n\n\n## 9-21\n\n### Process\n\n这场考得中规中矩，`T3`还有一些部分分可以拿到的，还是因为搞`T2`时间太长了，没时间写了\n\n前两题没有挂分，希望以后也要保持\n\n### T1\n\n[概率和期望]\n\n根据期望的线性性，转化成求每个点期望之和。每个点期望就是$\\frac{1}{k!}$，$k$表示在它前面要经过多少个点才能到`-1`，树上算下深度即可\n\n\n\n### T2\n\n[动态规划] [贪心]\n\n设$f[x]$表示从$x$开始，需要多少体力才能不停顿地走完$x$的子树（也就是把所有体力放到一开始加满）\n\n设$g[x]$表示$x$子树中所有点权减两倍边权\n\n树形dp，考虑从$x$的儿子$y$转移到$x$\n\n此时，$f[y]$就要先加上$w_{x, y}$，$g[y]$要先减去$2\\cdot w_{x, y}$（考虑当前这条边，以下的$f$和$g$均已进行完此操作）\n\n不难发现，如果加满体力走完整棵子树的话，体力值会变化$g[y]$\n\n那么$g[y] > 0$的儿子肯定要先遍历，且按照$f[y]$从小到大遍历\n\n$g[y] \\le 0$的儿子后遍历，且按照$g[y] + f[y]$从大到小遍历\n\n按照这个顺序依次访问儿子即可\n\n\n\n### T3\n\n前70分都比较可做，组合计数随便算算。满分做法需要复杂的分类讨论\n\n\n\n## 9-23\n\n### Process\n\n今天T1卡了好久的常，T2T3都没什么时间了\n\nT2比较神仙，思路不是很容易想\n\n### T1\n\n[模拟]\n\n发现答案就是$k$进制下的数位和模$k$的值\n\n$O(R - L)$暴力模拟进位即可\n\n### T2\n\n[矩阵快速幂] [状态压缩]\n\n把排列看成置换。因为每个数地位相等，可以转化成某个排列要变成单位置换（$1,2,\\dots,n$）\n\n> 为什么要这么转化下面会讲\n\n考虑在暴力的基础上优化，要把状态数量从$n!$压下来：只记录本质不同的置换（只记录每种长度的轮换个数）\n\n> 举个例子：$(2, 4, 5, 1, 3, 6)$，它有三个轮换分别是$(2, 4, 1), (5, 3), (6)$。于是记录$<1,2,3>$表示有大小为$1, 2, 3$的轮换各一个\n>\n> 相当于是原来的一些本质相同的状态，被缩成了一个大状态\n>\n> 总状态数是整数分拆的方案数，只有$150$左右\n\n这样记录的话，处于同一个大状态中的每个小状态，它们的**所有后继状态所处的大状态集合**是相同的（好像有点绕）\n\n并且，这样记录能够使终结点唯一地表示出来（$n$个长度为$1$的环是唯一的，这就是为什么一开始要转化）\n\n于是就可以直接矩阵快速幂计算答案了\n\n具体实现上稍微有点复杂\n\n### T3\n\n[拓扑排序] [拆点]\n\n> sol from gc\n\n![19-9-25-1](/images/19-9-25-1.png)\n\n![19-9-25-1](/images/19-9-25-2.png)\n\n## 9-24\n\n### Process\n\nT3以前见jwb做过，但是自己写的时候还是花了很长时间，最后只剩半个多小时写T1和T2了。\n\n一开始花了很长时间看T1题意，但是又没写，浪费了较长时间，时间分配不合理，以后要注意\n\n\n\n### T1\n\n[模拟]\n\n化学题大模拟\n\n### T2\n\n[动态规划] [贪心]\n\n若给定的区间两两**互不包含**时是很好做的，因为排序后每次选的肯定是连续的一段\n\n$dp[i][j]$表示到第$i$个区间，分了$j$组的答案，枚举下一段是从$i+1$到$j$，有转移\n$$\ndp[i][k] + t_{a_i + 1} - s_{a_j} \\rightarrow dp[j][k + 1] ~(t_{a_i + 1} > s_{a_j})\n$$\n\n> $s, t$是区间的左右端点\n\n再考虑存在包含的情况\n\n若$A$含于$B$中，则 $B$要么和$A$放一组中，要么单独放一组\n\n> 若$B$和其他区间放一组，那把$B$放到$A$所在的组中，$A$组答案不变，$B$原来的组答案不会更劣\n\n于是把只要包含了别的区间的区间单独提出来，贪心取较长的；剩下的区间做上述dp即可\n\n最后再枚举两部分取的数目，把两部分合并起来即可\n\n### T3\n\n[启发式分治]\n\n先分解质因数，对每个位置求出，左边和右边第一个不与它互质的数的位置$L_i, R_i$\n\n这一步实现的时候要预处理每个数的最小质因子，否则时间很大\n\n首先发现一个性质：若序列中的某个子区间不合法，则整个序列一定不合法\n\n> 这个子区间无法被分隔开，最后一定会递归到这个区间上\n\n于是可以每次利用$L_i, R_i$，找出任意一个满足和其他数都互质的数作为根（$O(1)$判断），再递归两边处理，伪代码如下：\n\n![19-9-25-4](/images/19-9-25-4.png)\n\n但是这是$O(n^2)$的\n\n考虑启发式分治，即从两边同时向中间扩展：\n\n![19-9-25-5](/images/19-9-25-5.png)\n\n这样复杂度就是$O(n\\log n)$的了，因为$T(n) = T(x) + T(n - x) + O(\\min \\{x, n - x\\})$，是启发式合并的逆过程\n\n> 注意：从中间往两边搜是错的。因为只有从两边向中间搜才能保证搜到的点不在同一个区间中（左半边，右半边）\n\n\n\n## 9-26\n\n### Process\n\n两道原题，一道昨天才考过的题，不评价\n\n### T1\n\n[LOJ 3092](https://loj.ac/problem/3092)\n\n直接dp\n\n### T2\n\n启发式分治即可\n\n### T3\n\n[计算几何] [曼哈顿与切比雪夫距离]\n\n首先找到所有交点：把线段按左边从小到大加入，统计它被哪些线段穿过即可\n\n第二问直接曼哈顿转切比雪夫即可\n\n对于第一问，设交点个数为$k$，则\n\n“对向交换”最多发生$k$次，最少发生$n - p$次。其中$p$为“右边相对于左边的位置的排列的轮换数量”\n\n> 比如，右边从下往上依次是$3, 1, 2, 5, 4$.那么轮换就是$1\\rightarrow 3\\rightarrow 2,4\\rightarrow 5$.共两个\n\n\n\n## 9-27\n\n### Process\n\n状态不是很对，8:30之前一直没动键盘。T1想好久没想出来，T2也一直没想清楚\n\n感觉今天静不下心来想题，要赶快调整状态了\n\n### T1\n\n[生成函数] [卷积] [FWT]\n\n设生成函数$\\displaystyle F_k(x) = \\sum_{i} [a_i = k]x^i, G_k(x) = \\sum_{i}[b_i=k]x^i$\n\n那么在子集并卷积意义下，若$[x^p]\\displaystyle F_u * G_v \\ge 1$，那么$f[u][v]$就能对$p$产生贡献\n\n这样暴力每次把两个卷起来是$O(n^32^n)$的，但是因为$f[u][v]$也很小，所以先把每个$F_k、G_k$`DWT`一下，把相同的$f[u][v]$放一起加，最后在把每个$H$`IDWT`回去。大概是这个意思:\n\n```cpp\nfor (int i = 0; i < M; ++i) DWT (F[i], 1 << N, 0); \nfor (int i = 0; i < M; ++i) DWT (G[i], 1 << N, 0);\nfor (int i = 0; i < M; ++i)\n    for (int j = 0; j < M; ++j)\n        for (int S = 0; S < 1 << N; ++S)\n            H[f[i][j]] += F[i][S] * G[j][S];\nfor (int i = 0; i < M; ++i) DWT (H[i], 1 << N, 1);\n```\n\n复杂度$O(n^22^n)$\n\n### T2\n\n[启发式合并] [贪心] [set]\n\n显然可以从叶子往上贪心。一开始把所有路径都加上，碰到不合法的点就把**包含它且顶端深度最浅的路径**删掉\n\n**包含它**这个条件即为`路径底端的点`在它的子树内；可以在树上合并\n\n**深度最浅**的条件可以用`multiset`维护\n\n所以`multiset`启发式合并，动态维护可选路径集合即可\n\n### T3\n\n...\n\n\n\n## 9-30\n\n### Process\n\n一道高考题，一道模拟题，一道原题\n\n模拟题挂分挂得好惨。。。\n\n### T1\n\n[赌徒破产问题] [特征方程] [数学]\n\n2019年高考理科数学最后一题，只不过把数字换成了字母\n\n随便推下式子特征方程搞下就可以了\n\n### T2\n\n[模拟]\n\n简单模拟题。用`queue`和`list`模拟即可。`list`是维护当前场上还剩下的人，以优化常数\n\n\n\n### T3\n\n[「GXOI / GZOI2019」旅行者](https://hk-cnyali.com/2019/05/22/「Problems」各省省选乱做/)\n\n","categories":["Summary"],"tags":["数学","欧拉函数","卷积","斯特林数","容斥","Summary","分块","动态规划","缩点","线段树","数据结构","堆","贪心","树状数组","计数","set","状态压缩","概率和期望","暴力","FWT","方差","背包","k-d tree","前缀和","字符串","AC自动机","拓扑排序","树链剖分","启发式合并","矩阵快速幂","kruskal重构树","边双","换根DP","two pointers","计算几何","巧妙","拆点","模拟","积分","DP优化","基环树","对偶图","线性筛","势能分析","特征方程","生成函数","后缀自动机","启发式分治","赌徒破产问题","广义后缀自动机","曼哈顿与切比雪夫距离"]},{"title":"「CF868E」Policeman and a Tree - 动态规划","url":"/2019/09/02/%E3%80%8CCF868E%E3%80%8DPoliceman-and-a-Tree-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","content":"\n有一棵$n$个点的树, 边有边权.\n\n树上有k个点移动速度为正无穷,人初始在s位置,移动速度为1,求至少多少时间才能将抓住所有点(人和点都进行最优决策，点尽可能拖延时间).\n\n$ n,k<=50.$\n\n<!--more-->\n\n### Link\n\n[CF 868E](https://codeforces.com/contest/868/problem/E)\n\n### Solution\n\n设$f[p][u][s1][s2]$为当前即将从$p$走到$u$, 以$p$为根时，$u$子树中有$s_1$个人, 其他部分有$s_2$个人的**全局**的答案\n\n显然，若当前不在叶子，就会往某个叶子一直走，不会回头；如果在叶子节点就可以抓住全部$s$个点,再回去:$f[u][p][s2][0]$\n\n否则考虑点的策略：以背包的方式将$s$个点分配到$v$的一些子树中,最大化最小时间.\n\n> 最大化最小时间的意思是，人的方案是可以选择的，而在所有方案中，点会选择一个花费最大的方案跑\n\n记录临时转移数组$g[i]$表示将$i$个点分配到$v$的子树中的最大时间\n\n一个一个子树转移，枚举在新子树中放$i$个点:$\\max\\{g[j],\\min\\{g[j-i],f[p][v][i][k]\\}\\}$，是一个类似背包的转移方法\n\n具体实现可以记忆化搜索\n\n更详细的理解可以参考[GC's Blog](https://gongchen618.gitee.io/blog/2019/09/02/CF868E-Policeman-and-a-Tree/)\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n \n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n#define DEBUG(x) cout << #x << \" = \" << x << endl;\n \nusing namespace std;\n \ntypedef long long LL;\ntypedef pair <int, int> pii;\n \ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n \ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n \nconst int Maxn = 50 + 5;\nconst int inf = 0x3f3f3f3f;\n \nint N, S, M;\nint e, Begin[Maxn], To[Maxn << 1], Next[Maxn << 1];\n \ninline void add_edge (int x, int y) { To[++e] = y; Next[e] = Begin[x]; Begin[x] = e; }\n \nint is_leaf[Maxn], size[Maxn];\n \ninline void dfs (int x, int f)\n{\n\tint cnt = 0;\n\tfor (int i = Begin[x]; i; i = Next[i])\n\t{\n\t\tint y = To[i];\n\t\t++cnt;\n\t\tif (y == f) continue;\n\t\tdfs (y, x);\n\t\tsize[x] += size[y];\n\t}\n\tif (cnt == 1) is_leaf[x] = 1;\n}\n \nint Dp[Maxn][Maxn][Maxn][Maxn], A[Maxn][Maxn];\n \ninline int get_dp (int x, int to, int s1, int s2)\n{\n\tif (s1 + s2 == 0) return 0;\n\tif (!s1) return inf;\n\tif (Dp[x][to][s1][s2] < 1e9) return Dp[x][to][s1][s2];\n\tif (is_leaf[to]) return Dp[x][to][s1][s2] = get_dp (to, x, s2, 0) + A[x][to];\n \n\tint f[Maxn];\n\tmemset (f, 0, sizeof f);\n\tf[0] = inf;\n \n\tfor (int i = Begin[to]; i; i = Next[i])\n\t{\n\t\tint y = To[i];\n\t\tif (y == x) continue;\n\t\tfor (int j = s1; j >= 0; --j)\n\t\t\tfor (int k = 0; k <= j; ++k)\n\t\t\t\tChkmax (f[j], min (f[j - k], get_dp (to, y, k, s1 + s2 - k)));\n\t}\n \n \n\treturn Dp[x][to][s1][s2] = f[s1] + A[x][to];\n}\n \ninline void Solve ()\n{\n\tdfs (S, 0);\n\tmemset (Dp, 0x3f, sizeof Dp);\n\tint ans = inf;\n\tfor (int i = Begin[S]; i; i = Next[i])\n\t{\n\t\tint y = To[i];\n\t\tChkmin (ans, get_dp (S, y, size[y], M - size[y]));\n\t}\n\tcout << ans << endl;\n}\n \ninline void Input ()\n{\n\tN = read<int>();\n\tfor (int i = 1; i < N; ++i)\n\t{\n\t\tint x = read<int>(), y = read<int>(), z = read<int>();\n\t\tA[x][y] = A[y][x] = z;\n\t\tadd_edge (x, y);\n\t\tadd_edge (y, x);\n\t}\n\tS = read<int>(), M = read<int>();\n\tfor (int i = 1; i <= M; ++i) ++size[read<int>()];\n \n}\n \nint main()\n{\n \n#ifndef ONLINE_JUDGE\n\tfreopen(\"E.in\", \"r\", stdin);\n\tfreopen(\"E.out\", \"w\", stdout);\n#endif\n \n\tInput ();\n\tSolve ();\n \n\treturn 0;\n}\n```\n\n","categories":["Problem"],"tags":["Codeforces","动态规划"]},{"title":"「HNCPC2019」一些题","url":"/2019/09/02/%E3%80%8CHNCPC2019%E3%80%8D%E4%B8%80%E4%BA%9B%E9%A2%98/","content":"\n现场打的时候全程端茶送水...\n\n<!--more-->\n\n### C. Distinct Substrings\n\n#### Description\n\n给出一个长度为$n$的字符集大小为$m$的串，对于$\\forall i\\in[1,m]$，求往字符串后面新增一个字符$i$后增加了多少本质不同的子串\n\n$1\\le n, m\\le 10^6$\n\n#### Solution\n\n[字符串] [Hash]\n\n考虑往后接上颜色$c$时，用$n+1$减去前面出现过的串\n\n直接找到所有位置$i$，满足$S_i = c$，然后求出一个最大的$len$，满足$[i - len, i - 1]$能和$[n-len+1, n]$匹配\n\n二分哈希即可\n\n### D. Modulo Nine\n\n#### Description\n\n求有多少长度为$n$的序列$a_i$满足\n\n* $a_i\\in [0, 9]$\n* 满足$m$条限制$(l, r)$：要求$\\prod_{i=l}^ra_i \\equiv 0 \\bmod 9.$\n\n对$10^9+7$取模\n\n$1\\le n, m\\le 50$\n\n#### Solution\n\n[动态规划]\n\n限制即为要求区间内存在至少两个$3$的质因子\n\n$dp[i][j][k]$表示到第$i$位，最近的两个质因子在$j, k$的位置的方案数\n\n转移显然，讨论一下后一位填什么\n\n### G. 字典序\n\n#### Description\n\n给定 $n \\times m$矩阵，构造长为 $m$ 的排列使得对矩阵的每一行按其顺序取下标排序后字典序按行数非降，并且排列字典序尽量小\n\n$n, m\\le 2000$\n\n#### Solution\n\n[贪心]\n\n> from zusuyu\n\n![19-9-2](/images/19-9-2.png)\n\n---\n\n自己的理解：\n\n贪心地考虑，一开始就满足在这一位上全合法的列肯定能直接选，且一定是选字典序最小的\n\n在选完这个后，在分界线上的行就“解放”了，限制放宽\n\n如果某一列上所有的不合法的位置都“解放”了的话，那么它就可以选了\n\n用堆维护\n\n### H. 有向图\n\n#### Description\n\n一张$n+m$个点的图，初始在$1$号点，每次在$i$号点的时候有$P_{i,j}$的概率走到$j$号点，保证$\\forall i\\in[n+1,n+m],P_{i,j}=[i=j]$\n\n可以发现经过无限次行走后停留在前$n$号点上的概率是$0$，求停留在后$m$号点每个点的概率$\\bmod 10^9+7$\n\n#### Solution\n\n[概率和期望]\n\n把概率转化成期望来理解。。。\n\n显然这里概率就是期望，而只有按期望来理解的话$f_1$的那个$+1$才解释得通\n\n设$f_i$表示$i$的期望经过步数\n$$\nf_1=\\sum_{j=1}^nf_jP_{j,1}+1\\\\\nf_i=\\sum_{j=1}^nf_jP_{j,i}(i>1)\n$$\n高消即可\n\n### J. Parity of Tuples (Easy)\n\n#### Description\n\n给出$n$个$m$元组$(a_1,a_2,...,a_m)$，记$count(x)$表示有多少个$m$元组满足$\\forall j\\in[1,m],popcount(a_j\\land x)$为奇数\n\n求$\\sum_{x=0}^{2^k-1}count(x)3^x \\bmod 10^9+7$\n\n#### Solution\n\n[动态规划]\n\n显然可以对每个$m$元组算答案，然后加起来\n\n把$m$原组看成一个$k\\times m$的$01$矩阵，相当于选出一些行向量做异或运算，要求结果为$2^{m}-1$\n\n设$f[i][S]$表示处理到第$i$个向量，当前运算结果为$S$的方案数\n\n$3^x$的部分也可以拆到二进制的每一位算贡献，算在$f$里即可\n\n","categories":["Problem"],"tags":["动态规划","贪心","概率和期望","Hash","字符串","ACM-ICPC"]},{"title":"「AGC012」E - Camel and Oases - 状压dp","url":"/2019/09/02/%E3%80%8CAGC012%E3%80%8DE-Camel-and-Oases-%E7%8A%B6%E5%8E%8Bdp/","content":"\n一根数轴上分布着$n$个点，有一个人会在上面移动。首先会选择一个点作为起点，并有一个初始的能力值$v$，然后每次可以执行下面的一种操作：\n\n* 移动到一个相邻的点,并且该节点距离当前点不超过$v$\n* 跳跃到任意一个点,前提是$v > 0$,但是能力值会变为$\\lfloor\\frac v2\\rfloor$\n\n你需要求出对于每一个点作为起点，是否能够到达所有的点\n\n$n, v\\le 2\\times10^5$\n\n<!--more-->\n\n### Link\n\n[AGC012E](https://agc012.contest.atcoder.jp/tasks/agc012_e)\n\n### Solution\n\n这道题不难\n\n首先，不同的能力值只有$\\log$个，即最多只有$\\log$层。于是可以对每种不同的能力值，处理出一些可以相互到达的连续段\n\n问题就转化成，每种能力值最多取一根线段，能否把$[1, n]$覆盖\n\n先考虑除了$v$那一层的线段，设$f[S], g[S]$表示取了$S$集合的层， 能覆盖的最大前缀、最大后缀，随便转移\n\n考虑$v$那一层的每个线段$[l, r]$，若存在一个集合$S$，满足$l- 1\\le f[S]$且$g[ALL \\oplus j]\\le r + 1$，那么$[l, r]$中的数都合法\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n#define DEBUG(x) cout << #x << \" = \" << x << endl;\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int Maxn = 2e5 + 100;\nconst int Maxm = 20 + 5;\nconst int Maxs = (1 << 20) + 100;\n\nint N, V, Log;\nint A[Maxn];\n\nint L[Maxm][Maxn], R[Maxm][Maxn];\nint Next[Maxn];\n\ninline void get_seg ()\n{\n\tfor (int i = 0; i <= Log; ++i)\n\t{\n\t\tint v = V >> i;\n//\t\tDEBUG (v);\n\t\tfor (int j = N; j >= 1; --j)\n\t\t{\n\t\t\tint p = upper_bound (A + 1, A + N + 1, A[j] + v) - A - 1;\n\t\t\tNext[j] = 0;\n\t\t\tNext[j] = max (Next[p], j);\n\t\t}\n\t\tfor (int l = 1, r = 0; l <= N; l = r + 1)\n\t\t{\n\t\t\tr = Next[l];\n\t\t\tL[i][++L[i][0]] = l, R[i][++R[i][0]] = r;\n\t\t}\n\t}\n}\n\nint f[Maxs], g[Maxs];\n\ninline void get_f ()\n{\n\tint ALL = (1 << Log) - 1;\n\tfor (int i = 0; i <= ALL; ++i)\n\t{\n\t\tint preR = f[i];\n\t\tfor (int j = 1; j <= Log; ++j)\n\t\t{\n\t\t\tif (i & (1 << (j - 1))) continue;\n\t\t\tint x = upper_bound (L[j] + 1, L[j] + L[j][0] + 1, preR + 1) - L[j] - 1;\n\t\t\tint nowR = max (preR, R[j][x]);\n\t\t\tChkmax (f[i | (1 << (j - 1))], nowR);\n\t\t}\n\t}\n}\n\ninline void get_g ()\n{\n\tint ALL = (1 << Log) - 1;\n\tfor (int i = 0; i <= ALL; ++i) g[i] = N + 1;\n\tfor (int i = 0; i <= ALL; ++i)\n\t{\n\t\tint preL = g[i];\n\t\tfor (int j = 1; j <= Log; ++j)\n\t\t{\n\t\t\tif (i & (1 << (j - 1))) continue;\n\t\t\tint x = lower_bound (R[j] + 1, R[j] + R[j][0] + 1, preL - 1) - R[j];\n\t\t\tint nowL = min (preL, L[j][x]);\n\t\t\tChkmin (g[i | (1 << (j - 1))], nowL);\n\t\t}\n\t}\n}\n\ninline void Solve ()\n{\n\tget_seg ();\n\tget_f ();\n\tget_g ();\n\n\tif (L[0][0] > Log + 3) { for (int i = 1; i <= N; ++i) puts(\"Impossible\"); return ; }\n\n\tint ALL = (1 << Log) - 1;\n\tfor (int i = 1; i <= L[0][0]; ++i)\n\t{\n\t\tint l = L[0][i], r = R[0][i], fl = 0;\n\t\tfor (int j = 0; j <= ALL; ++j)\n\t\t\tif (l - 1 <= f[j] && g[ALL ^ j] <= r + 1)\n\t\t\t{\n\t\t\t\tfl = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (fl) for (int j = l; j <= r; ++j) puts(\"Possible\");\n\t\telse for (int j = l; j <= r; ++j) puts(\"Impossible\");\n\t}\n}\n\ninline void Input ()\n{\n\tN = read<int>(), V = read<int>(), Log = log2(V) + 1;\n\tfor (int i = 1; i <= N; ++i) A[i] = read<int>();\n}\n\nint main()\n{\n\n#ifdef hk_cnyali\n\tfreopen(\"E.in\", \"r\", stdin);\n\tfreopen(\"E.out\", \"w\", stdout);\n#endif\n\n\tInput ();\n\tSolve ();\n\n\treturn 0;\n}\n\n```\n\n\n\n","categories":["Problem"],"tags":["动态规划","状态压缩","Atcoder"]},{"title":"「笔记」一些图论题","url":"/2019/09/01/%E3%80%8C%E7%AC%94%E8%AE%B0%E3%80%8D%E4%B8%80%E4%BA%9B%E5%9B%BE%E8%AE%BA%E9%A2%98/","content":"\n[Summary]\n\n来自xhb课件的一些图论题\n\n<!--more-->\n\n## 最短路\n\n### [LG P3403 跳楼机](https://www.luogu.org/problem/P3403)\n\n#### Description\n\n楼高为$H$ ，初始位于 $1$ 楼，每次可以向上移动 $x/y/z$ 楼，问能到达的楼层数\n\n#### Solution\n\n[最短路]\n\n去掉一个限制，考虑在模$x$意义下，只通过走$y/z$步能到达的楼层\n\n设$f[i]$表示能到达的最小的，模$x$意义下为$i$的楼层\n\n$f[i] + y \\rightarrow f[(i + y)\\%x],f[i] + z \\rightarrow f[(i + z)\\%x]$\n\n跑最短路即可，答案就是$\\displaystyle \\sum_{i=0}^{x-1}\\lfloor\\frac{H-f[i]}{x}\\rfloor + 1$\n\n#### Summary\n\n同余最短路\n\n### [51nod1693 水群](https://www.51nod.com/Challenge/Problem.html#problemId=1693)\n\n#### Description\n\n初始有$1$ 个表情，每次可以复制所有/退一格/粘贴，问达到 $n$ 个表情的最小操作数 \n\n#### Solution\n\n[最短路]\n\n不难发现过程一定是一次复制后多次粘贴，再多次退格\n\n建图最短路，直观想法是$i$向$i\\times k$连边，向$i-1$连边。考虑优化：\n\n* 当$k$为和数的时候显然可以拆成质数的积，所以$k$只需要枚举质数\n* 不会利用到$k>11$的边\n\n\n\n### [BZOJ4289 Tax](https://www.lydsy.com/JudgeOnline/problem.php?id=4289)\n\n#### Description\n\n给出一个$n$个点$m$条边的无向图，经过一个点的代价是进入和离开这个点的两条边的边权的较大值\n\n求从起点$1$到点$n$的最小代价。起点的代价是离开起点的边的边权，终点的代价是进入终点的边的边权\n\n$n\\le 10^5, m\\le 2\\times10^5$\n\n#### Solution\n\n[最短路]\n\n把一条边拆成两条有向边，再把有向边视为点，然后按题意建图\n\n直接建图边数是$O(m^2)$的，考虑优化\n\n对于一个原图中的点而言，设新图中连进它的边集为$S$，从它连出去的边集为$T$\n\n不难发现，这里的$S$和$T$是一一对应的（有向边是由无向边拆得）\n\n将$S, T$按边权从小到大排序，连边方法：$(S_i, T_i, w_{i}), (T_i, T_{i+1}, w_{i+1} - w_i), (T_{i + 1}, T_{i}, 0)$\n\n正确性显然，是一个经典套路\n\n\n\n### [GZOI2019 旅行者](https://hk-cnyali.com/2019/05/22/「Problems」各省省选乱做/#「GXOI-GZOI2019」旅行者)\n\n\n\n### [BZOJ4061 Farm and factory](https://www.lydsy.com/JudgeOnline/problem.php?id=4061)\n\n#### Description\n\n给定一个$n$个点$m$条边的无向图。现要新加入一个点，这个点与$n$点分别连了一条边。需要设定这$n$条边的边权（可为实数），满足$n$个点到$1, 2$号点的最短路不一定经过这个新点，并且这$n$条边的边权平均值最小\n\n$n, m\\le 10^5$\n\n#### Solution\n\n[曼哈顿与切比雪夫距离] [最短路]\n\n很奥妙重重的一道题\n\n设$a_i$表示未加边前$1$到$i$的最短路，$b_i$表示$2$到$i$的最短路，$d_i$表示$i$和新加点之间的边权\n\n> 以下内容画图可能会更加清楚\n\n首先，为了保证合法，必须要满足\n$$\n\\begin{aligned}\nd_1 + d_i \\ge a_i\\\\\nd_2 + d_i \\ge b_i\n\\end{aligned}\n$$\n此时这个界并不紧，因为到$i$的最短路还有可能先经过另外一个点$j$，再经过新加点，再到$i$\n\n换句话来说，还有可能$a_j + d_j + d_i < a_i$\n\n但是，我们只需要满足$a_j + d_j \\ge d_1$即可，因为$d_1 + d_i$就已经比$a_i$大了（自认为讲得比较清楚），即\n$$\n\\begin{aligned}\nd_i + a_i \\ge d_1\\\\\nd_i + b_i \\ge d_2\n\\end{aligned}\n$$\n综上，需要满足\n$$\nd_i\\ge \\max\\{|d_1 - a_i|, |d_2 - b_i|\\}\n$$\n因为要求$\\sum d_i$尽量小，所以当$d_1, d_2$确定时，取等号最优\n\n问题转化为：确定$d_1, d_2$，使$\\displaystyle \\sum_{i=1}^{n}\\{|d_1 - a_i|, |d_2 - b_i|\\}$最小\n\n发现是个切比雪夫，可以转成曼哈顿，然后分别对$x, y$坐标取中位数即可\n\n\n\n## 生成树\n\n### CF125E\n\n直接wqs二分即可\n\n### CF888G\n\n最小异或生成树，在[这里](https://hk-cnyali.com/2019/02/24/「模拟赛」2-24模拟赛-Summary/)已经写得很清楚了\n\n上次是抄的代码。。。这次自己写了下\n\n之前的代码还没有类似启发式合并地查找，就是每次用元素少的集合丢到元素多的集合里查\n\n\n\n## 分层图\n\n### [BJWC2012 冻结](https://www.luogu.org/problem/P4822)\n\nsbt，$f[i][j]$表示到$i$，用了$j$次，直接跑最短路\n\n### CF1137C Museums Tour\n\n#### Description\n\n一张$n$个点$m$条边的有向图，定义周期为 $d$ 天，从第一个周期的第 $1$ 天开始从 $1$ 号点出发，一条边耗时一天。\n\n点在每个周期中会有部分时间有 $1$ 的点权，同一点不能重复获得点权，问能够得到的最大价值。\n\n$n, m\\le10^5, d\\le 50$\n\n#### Solution\n\n[强连通分量] [缩点]\n\n注意到$d$很小，于是可以往分层图上想\n\n按天分层，对于原图中$x\\rightarrow y$的边，连$(x, k) \\rightarrow (y, k + 1)$的边（注意不用真的连出来）\n\n缩点后求最长路即可\n\n> 这里缩完点后每个新点的$size$并不是直接把它包含的所有点的权值加起来，因为可能有点重复的情况，要用个`vis`搞下\n\n为什么每个点只会被算一次贡献？\n\n即若$(x, k)$能走到$(x, k')$，那么它们为什么一定在同一个强连通分量中？\n\n显然，考虑从$(x, k)$到$(x, k')$经过的路径序列，把它再重复$d-1$次后，一定能回到$(x, k)$\n\n\n\n## 强连通分量\n\n### [BZOJ2438 杀人游戏](https://www.lydsy.com/JudgeOnline/problem.php?id=2438) \n\n#### Description\n\n$n$ 个人，其中有一个杀手。有$m$条认识关系$(x, y)$，表示$x$能确定确定$y$是平民还是杀手\n\n警察需要选择一些人查证，选到杀手就会被杀掉，问确认杀手之前不被杀死的概率最大是多少\n\n$n, m\\le 3\\times10^5$\n\n#### Solution\n\n[强连通分量] [缩点]\n\n题意就是要确定每个人的身份。假设最优解中最少要查询$k$个人，那么答案就是$1 - \\frac{k}{n}$（这$k$个人每个人有$\\frac{1}{n}$的概率是杀手）\n\n缩点后求入度为$0$的点数即可\n\n若缩点后存在一个大小为$1$，入度为$0$的点，并且它所有指向的点均能被其他某些点到达，那么`ans--`\n\n>因为最后只剩这个点的话，就知道他是不是凶手了\n\n","categories":["Note"],"tags":["Summary","最短路","缩点","强连通分量","曼哈顿与切比雪夫距离"]},{"title":"「ARC083」F - Collecting Balls - 基环树 + 思维","url":"/2019/08/31/%E3%80%8CARC083%E3%80%8DF-Collecting-Balls-%E5%9F%BA%E7%8E%AF%E6%A0%91-%E6%80%9D%E7%BB%B4/","content":"\n有一个 $n\\times n$ 的矩阵，矩阵内有 $2n$ 个球。对于 $i \\in [1,n]$ ，$(0,i) (i,0)$ 的位置各有一个启动后往右走/往上走的机器人，机器人撞到球会和球一起消失。问启动机器人顺序的方案数，满足所有球最后都消失。\n\n$n \\le 10^{5}$ \n\n<!--more-->\n\n### Link\n\n[ARC083F](<https://arc083.contest.atcoder.jp/tasks/arc083_d>)\n\n### Solution\n\n把球看成点，机器人看成边。若存在一个$(x, y)$的球，则连$(x, y + n)$，权值为$x + y$的边\n\n这样连边后，每选择一个点就会拿掉它相邻剩下的边权最小的边；拿掉一条边就代表这个机器人撞没了\n\n并且必须要保证一个点对应一条边\n\n因为只有$n$个点$n$条边，所以一定是一个基环树森林（否则无解）。显然，基环树的每个子树的方案是确定的（从叶子往根推，只有一种方案），并且环上也只有两种方案（每条边属于左边的点或是右边的点）。可以枚举这两种情况算答案\n\n此时每个点已经分配了一个边权，但仍然有一些限制关系，即对于某个点分配到的那条边而言，所有与之相连且边权更小的边，必须要先选。显然，这样的限制又构成一棵森林\n\n问题便转化为，求一个选择序列使得所有点的祖先比它自己先选择，是一个经典问题\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n#define DEBUG(x) cout << #x << \" = \" << x << endl;\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int Maxn = 2e5 + 100;\nconst int Mod = 1e9 + 7;\n\n\nnamespace MATH\n{\n\tint fac[Maxn], ifac[Maxn];\n\n\tinline void Add (int &a, int b) { if ((a += b) >= Mod) a -= Mod; }\n\n\tinline int Pow (int a, int b)\n\t{\n\t\tint ans = 1;\n\t\tfor (int i = b; i; i >>= 1, a = (LL) a * a % Mod) if (i & 1) ans = (LL) ans * a % Mod;\n\t\treturn ans;\n\t}\n\n\tinline void init (int n = 2e5)\n\t{\n\t\tfac[0] = 1;\n\t\tfor (int i = 1; i <= n; ++i) fac[i] = (LL) fac[i - 1] * i % Mod;\n\t\tifac[n] = Pow (fac[n], Mod - 2);\n\t\tfor (int i = n - 1; i >= 0; --i) ifac[i] = (LL) ifac[i + 1] * (i + 1) % Mod;\n\t}\n\n\tinline int C (int n, int m) { if (n < m) return 0; return (LL) fac[n] * ifac[m] % Mod * ifac[n - m] % Mod; }\n}\n\nusing namespace MATH;\n\nint N;\nint e, Begin[Maxn], Next[Maxn << 1], To[Maxn << 1], W[Maxn << 1];\n\ninline void add_edge (int x, int y, int z) { To[++e] = y; Next[e] = Begin[x]; Begin[x] = e; W[e] = z; }\n\ninline int merge (int a, int b) { return C (a + b, b); }\n\nint Vis[Maxn], top, in_stk[Maxn];\npii stk[Maxn];\n\nint found;\nint circle[Maxn], in_circle[Maxn];\nint val_cir[Maxn];\n\ninline void dfs_circle (int x, int f, int w)\n{\n\tif (found) return ;\n\tstk[++top] = mp (x, w), in_stk[x] = 1;\n\n\tfor (int i = Begin[x]; i; i = Next[i])\n\t{\n\t\tint y = To[i];\n\t\tif (y == f) continue;\n\t\tif (!in_stk[y]) dfs_circle (y, x, W[i]);\n\t\telse\n\t\t{\n\t\t\tval_cir[++circle[0]] = W[i];\n\t\t\twhile (top)\n\t\t\t{\n\t\t\t\tint a = stk[top].x, b = stk[top].y; --top;\n\t\t\t\tcircle[circle[0]] = a;\n\t\t\t\tin_circle[a] = 1;\n\t\t\t\tval_cir[++circle[0]] = b;\n\t\t\t\tif (a == y) break;\n\t\t\t}\n\t\t\t--circle[0];\n\t\t\tfound = 1;\n\t\t\treturn ;\n\t\t}\n\t\tif (found) return ;\n\t}\n\n\t--top, in_stk[x] = 0;\n}\n\nint val[Maxn], tree[Maxn];\n\ninline void dfs_tree (int x, int f)\n{\n\ttree[++tree[0]] = x;\n\tVis[x] = 1;\n\tfor (int i = Begin[x]; i; i = Next[i])\n\t{\n\t\tint y = To[i];\n\t\tif (y == f || in_circle[y]) continue;\n\t\tval[y] = W[i];\n\t\tdfs_tree (y, x);\n\t}\n}\n\nint fa[Maxn], size[Maxn];\n\ninline int dfs_calc (int x)\n{\n\tint ans = 1;\n\tsize[x] = 0;\n\tfor (int i = Begin[x]; i; i = Next[i])\n\t{\n\t\tint y = To[i];\n\t\tif (x != fa[y]) continue;\n\t\tint now = dfs_calc (y);\n\t\tans = (LL) ans * now % Mod * merge (size[x], size[y]) % Mod;\n\t\tsize[x] += size[y];\n\t}\n\t++size[x];\n\treturn ans;\n}\n\ninline int Calc ()\n{\n\tfor (int t = 1; t <= tree[0]; ++t)\n\t{\n\t\tint x = tree[t];\n\t\tfa[x] = size[x] = 0;\n\t}\n\n\tfor (int t = 1; t <= tree[0]; ++t) \n\t{\n\t\tint x = tree[t];\n\t\tfor (int i = Begin[x]; i; i = Next[i])\n\t\t{\n\t\t\tint y = To[i];\n\t\t\tif (W[i] < val[x]) fa[y] = x;\n\t\t}\n\t}\n\n\tint ans = 1, sum_point = 0;\n\tfor (int t = 1; t <= tree[0]; ++t)\n\t{\n\t\tint x = tree[t];\n\t\tif (!fa[x])\n\t\t{\n\t\t\tint now = dfs_calc (x);\n\t\t\tans = (LL) ans * now % Mod * merge (sum_point, size[x]) % Mod;\n\t\t\tsum_point += size[x];\n\t\t}\n\t}\n\n\treturn ans;\n}\n\ninline int Process (int x)\n{\n\tfound = circle[0] = top = 0;\n\tdfs_circle (x, 0, 0);\n\ttree[0] = 0;\n\tfor (int i = 1; i <= circle[0]; ++i) dfs_tree (circle[i], 0);\n\n\tint ans = 0;\n\tfor (int i = 1; i <= circle[0]; ++i) val[circle[i]] = val_cir[i];\n\tAdd (ans, Calc ());\n\n\tval_cir[circle[0] + 1] = val_cir[1];\n\tfor (int i = 1; i <= circle[0]; ++i) val[circle[i]] = val_cir[i + 1];\n\tAdd (ans, Calc ());\n\n\treturn ans;\n}\n\nint Choose[Maxn];\n\ninline void Solve ()\n{\n\tint chosen = 0;\n\tfor (int i = 1; i <= 2 * N; ++i) if (Choose[i]) ++chosen;\n\tif (chosen != 2 * N) return void (puts(\"0\"));\n\n\tint ans = 1, sum_point = 0;\n\tfor (int i = 1; i <= 2 * N; ++i)\n\t\tif (!Vis[i])\n\t\t{\n\t\t\tint now = Process (i);\n\t\t\tans = (LL) ans * now % Mod * merge (sum_point, tree[0]) % Mod;\n\t\t\tsum_point += tree[0];\n\t\t}\n\n\tcout << ans << endl;\n}\n\ninline void Input ()\n{\n\tN = read<int>();\n\tfor (int i = 1; i <= 2 * N; ++i) \n\t{\n\t\tint x = read<int>(), y = read<int>();\n\t\tChoose[x] = Choose[y + N] = 1;\n\t\tadd_edge (x, y + N, x + y);\n\t\tadd_edge (y + N, x, x + y);\n\t}\n}\n\nint main()\n{\n\n#ifdef hk_cnyali\n\tfreopen(\"F.in\", \"r\", stdin);\n\tfreopen(\"F.out\", \"w\", stdout);\n#endif\n\n\tMATH :: init ();\n\tInput ();\n\tSolve ();\n\n\treturn 0;\n}\n\n```\n\n","categories":["Problem"],"tags":["基环树","思维"]},{"title":"「Summary」暑假总结","url":"/2019/08/30/%E3%80%8CSummary%E3%80%8D%E6%9A%91%E5%81%87%E6%80%BB%E7%BB%93/","content":"\n<!--more-->\n\n暑假前几天就只改了考试题，没有做什么自己的题目\n\n从8月份开始，就开始在刷一些不同题库，不同类型的题了（链接都在[这里](https://hk-cnyali.com/2019/07/31/Plan/)）\n\n通过这个暑假的训练和练习，我才逐渐对自己有了一定的认识，有了点底，知道自己的水平大概是什么层次，知道自己与别人的差距到底在哪里。并且，现在除了一些特别高级的知识点之外，知识点也都基本过了一遍了，不过还要通过模拟赛，以及网络比赛来加强、巩固。\n\n就目前来看，自己最大的问题还是思维不行，并且题目想得太慢，推得太慢（尤其是打非常规OI赛制的比赛，比如各种网络赛，以及今天参加的HNCPC之类），这都是题目做少了的原因，所以接下来还是要按自己的刷题计划一道道题地做。\n\n离联赛只有两个月了。\n\n或者说，还有两个月。\n\n继续 *or* 退役，一切的决定权目前还掌握在自己手中\n\n> 敌人一直都胜券在握，但我们依旧奋战如初，这就是我所知道的全部意义。  ——《权力的游戏》\n>\n> 2019.8.30 周五 壬申月 己亥日 宜背水一战","categories":["Summary"],"tags":["Summary"]},{"title":"「UR #5」怎样更有力气 - 并查集","url":"/2019/08/29/%E3%80%8CUR-5%E3%80%8D%E6%80%8E%E6%A0%B7%E6%9B%B4%E6%9C%89%E5%8A%9B%E6%B0%94-%E5%B9%B6%E6%9F%A5%E9%9B%86/","content":"\n给定一棵 $n$ 个节点的树，有 $m$ 天修路\n\n每一天修一条路的花费固定，为 $w _i(1 \\le i \\le m)$。第 $i$ 天会指定两个点 $u, v$，在第 $i$ 天时只可以在树中 $u$ 到 $v$ 的链上的任意两点之间修路。同时还有 $p$ 条限制 $(t, a, b)$，表示第 $t$ 天不能在 $a, b$ 之间修路\n\n问最小生成树的总花费。保证无自环重边，$a, b$ 在 $u _t, v _t$ 的路径上，且一定有一个合法生成树。\n\n<!--more-->\n\n### Link\n\n[UOJ61](http://uoj.ac/problem/61)\n\n### Solution\n\n> xhb写得很好，这里就直接搬过来了\n\n采用 Kruskal。把天数按 $w _i$ 从小到大排序，那么每天都是让**能连的边尽量连**。\n\n考虑优化这个连边的过程。\n\n有一个小 trick: 设 $k$ 为当天限制的个数，如果 $k <dis(u, v)$，那么 $u$ 到 $v$ 的这条链上的点一定会被连到一个联通块里去。\n\n> 证明显然\n\n所以当 $k < d$ 时可以直接链并，总复杂度 $\\cal O(n)$。\n\n考虑当 $k \\ge d$ 时怎么办。这时可以把 $u$ 到 $v$ 链上的点全部扒下来考虑，因为 $d \\le k$ 且 $\\sum k = p$，所以扒下来的总点数不超过 $p$，没有问题。\n\n这时把限制抽象成图，可以得到一张 $d + 1$ 个点 $k$ 条边的无向图。这是可连边的图的**补图**。\n\n有一个经典结论，一个无向图中最小的点的度数是 $\\cal O(\\sqrt m)$ 的。\n\n> 设其最小度数为 $d$，那么有 $d \\le \\frac {2m} n, d < n$。$\\therefore d ^2 < dn \\le 2m$。\n\n于是把这个限制图上的最小度数的点 $x$ 拿出来，与它连边的那些点记为集合 $T$，$T$ 的补集记为 $S$。\n\n$S$ 包含了 $x$ 以及没有与 $x$ 限制边相连的点，那些点直接与 $x$ 并成一个联通块就行了。\n\n现在考虑 $T$。显然只有两种连边方式：$T \\to T, S \\to T$。\n\n$T \\to T$：对于 $x$ 暴力枚举与其有限制边相连的两个点，并判断这两点是否有限制边。无则合并。\n\n$S \\to T$：对于 $T$ 中的每一个点枚举与其有限制边相连的点，并判断有多少个是 $S$ 集合中的点。如果 $S$ 中的点全部与其相连，无法连边；否则其一定能与 $S$ 中某个集合合并，且因为 $S$ 中所有点都与 $x$ 合并，故直接无视限制边与 $x$ 合并。\n\n时间复杂度分别是 $\\cal O(\\sum deg _y)$ 和 $\\cal O(deg _x ^2)$，易知这是 $\\cal O(k)$ 的。合并需要用到并查集，所以总复杂度大概是 $\\cal O((n + p) \\alpha(n))$\n\n### Code(6.1K)\n\n```cpp\n\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n#define DEBUG(x) cout << #x << \" = \" << x << endl;\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int Maxn = 3e5 + 100;\n\nLL ans;\nint N, M, P, Left;\nint e, Begin[Maxn], To[Maxn], Next[Maxn];\nstruct road\n{\n\tint x, y, z, id;\n\tinline int operator < (const road &rhs) const { return z < rhs.z; }\n} E[Maxn];\nvector <pii> Ban[Maxn];\n\ninline void add_edge (int x, int y) { To[++e] = y; Next[e] = Begin[x]; Begin[x] = e; }\n\nnamespace DSU\n{\n\tint fa[Maxn];\n\tinline void init () { for (int i = 1; i <= N; ++i) fa[i] = i; }\n\tinline int get_fa (int x) { return fa[x] == x ? x : fa[x] = get_fa (fa[x]); }\n\tinline void link (int x, int y, int w) \n\t{ \n\t\tx = get_fa (x), y = get_fa (y);\n\t\tif (x != y) fa[get_fa (x)] = get_fa (y), ans += w, ++Left; \n\t}\n\tinline int check (int x, int y) { return get_fa (x) == get_fa (y); }\n}\n\nnamespace HLD\n{\n\tint fa[Maxn], size[Maxn], dep[Maxn], son[Maxn], top[Maxn];\n\n\tinline void dfs (int x)\n\t{\n\t\tdep[x] = dep[fa[x]] + 1;\n\t\tsize[x] = 1;\n\t\tfor (int i = Begin[x]; i; i = Next[i])\n\t\t{\n\t\t\tint y = To[i];\n\t\t\tif (y == fa[x]) continue;\n\t\t\tfa[y] = x;\n\t\t\tdfs (y);\n\t\t\tif (size[y] > size[son[x]]) son[x] = y;\n\t\t\tsize[x] += size[y];\n\t\t}\n\t}\n\n\tinline void dfs (int x, int now)\n\t{\n\t\ttop[x] = now;\n\t\tif (son[x]) dfs (son[x], now);\n\t\tfor (int i = Begin[x]; i; i = Next[i])\n\t\t{\n\t\t\tint y = To[i];\n\t\t\tif (y == fa[x] || y == son[x]) continue;\n\t\t\tdfs (y, y);\n\t\t}\n\t}\n\n\tinline void init () { dfs (1), dfs (1, 1); }\n\n\tinline int get_lca (int x, int y)\n\t{\n\t\twhile (top[x] != top[y])\n\t\t{\n\t\t\tif (dep[top[x]] < dep[top[y]]) swap (x, y);\n\t\t\tx = fa[top[x]];\n\t\t}\n\t\tif (dep[x] > dep[y]) swap (x, y);\n\t\treturn x;\n\t}\n\n\tinline int get_dis (int x, int y) { return dep[x] + dep[y] - 2 * dep[get_lca (x, y)]; }\n}\n\nusing namespace HLD;\n\nnamespace TREE\n{\n\tnamespace DSU\n\t{\n\t\tint fa[Maxn];\n\t\tinline void init () { for (int i = 1; i <= N; ++i) fa[i] = i; }\n\t\tinline int get_fa (int x) { return fa[x] == x ? x : fa[x] = get_fa (fa[x]); }\n\t\tinline void link (int x, int y, int w) // 把x连到y上（y是x的父亲）\n\t\t{ \n\t\t\tx = get_fa (x), y = get_fa (y);\n\t\t\t:: DSU :: link (x, y, w);\n\t\t\tfa[x] = y;\n\t\t}\n\t\tinline int check (int x, int y) { return get_fa (x) == get_fa (y); }\n\t}\n\n\tinline void init () { HLD :: init (); DSU :: init (); }\n\n\tinline void solve (int x, int y, int w)\n\t{\n\t\tint lca = HLD :: get_lca (x, y);\n\t\twhile (!DSU :: check (x, lca))\n\t\t{\n\t\t\tDSU :: link (x, fa[x], w);\n\t\t\tx = DSU :: get_fa (x);\n\t\t}\n\t\twhile (!DSU :: check (y, lca))\n\t\t{\n\t\t\tDSU :: link (y, fa[y], w);\n\t\t\ty = DSU :: get_fa (y);\n\t\t}\n\t}\n}\n\nnamespace GRA\n{\n\tint e, Begin[Maxn], To[Maxn << 1], Next[Maxn << 1];\n\tint deg[Maxn];\n\tvector <int> A, S, T;\n\tint o, vis[Maxn];\n\tint is_S[Maxn], is_T[Maxn];\n\n\tinline void add_edge (int x, int y) { To[++e] = y; Next[e] = Begin[x]; Begin[x] = e; ++deg[x]; }\n\n\tinline void get_chain (int x, int y)\n\t{\n\t\tA.clear (), S.clear (), T.clear ();\n\t\tint lca = HLD :: get_lca (x, y);\n\t\twhile (x != lca) A.pb (x), x = fa[x];\n\t\twhile (y != lca) A.pb (y), y = fa[y];\n\t\tA.pb (lca);\n\t}\n\n\tinline void init (int id)\n\t{\n\t\te = 0;\n\t\tfor (int i = 0; i < A.size(); ++i) Begin[A[i]] = deg[A[i]] = 0;\n\n\t\tfor (int j = 0; j < Ban[id].size(); ++j)\n\t\t{\n\t\t\tint x = Ban[id][j].x, y = Ban[id][j].y;\n\t\t\tadd_edge (x, y);\n\t\t\tadd_edge (y, x);\n\t\t}\n\n\t\to = -1;\n\t\tfor (int i = 0; i < A.size(); ++i)\n\t\t{\n\t\t\tvis[A[i]] = 0;\n\t\t\tif (o < 0 || deg[A[i]] < deg[o]) \n\t\t\t\to = A[i];\n\t\t}\n\t}\n\n\tinline void get_set ()\n\t{\n\t\tfor (int i = Begin[o]; i; i = Next[i])\n\t\t{\n\t\t\tint x = To[i];\n\t\t\tif (!vis[x]) T.pb (x);\n\t\t\tvis[x] = 1;\n\t\t}\n\n\t\tfor (int i = 0; i < A.size(); ++i) if (!vis[A[i]]) S.pb (A[i]);\n\n\t\tfor (int i = 0; i < S.size(); ++i) is_S[S[i]] = 1, is_T[S[i]] = 0;\n\t\tfor (int i = 0; i < T.size(); ++i) is_T[T[i]] = 1, is_S[T[i]] = 0;\n\t}\n\n\tinline void solve_S (int w)\n\t{\n\t\tfor (int i = 0; i < S.size(); ++i)\n\t\t{\n\t\t\tint x = S[i];\n\t\t\tDSU :: link (x, o, w);\n\t\t}\n\t}\n\n\tinline void solve_T (int w)\n\t{\n\t\tfor (int i = 0; i < A.size(); ++i) vis[A[i]] = 0;\n\t\tfor (int t = 0; t < T.size(); ++t)\n\t\t{\n\t\t\tint x = T[t];\n\t\t\tint cnt = 0;\n\t\t\tfor (int i = Begin[x]; i; i = Next[i])\n\t\t\t{\n\t\t\t\tint y = To[i];\n\t\t\t\tif (is_S[y]) ++cnt;\n\t\t\t\tif (is_T[y]) vis[y] = 1;\n\t\t\t}\n\n\t\t\tif (cnt != S.size()) DSU :: link (o, x, w);\n\n\t\t\tfor (int j = t + 1; j < T.size(); ++j)\n\t\t\t{\n\t\t\t\tint y = T[j];\n\t\t\t\tif (!vis[y])\n\t\t\t\t\tDSU :: link (x, y, w);\n\t\t\t}\n\n\t\t\tfor (int i = Begin[x]; i; i = Next[i])\n\t\t\t{\n\t\t\t\tint y = To[i];\n\t\t\t\tvis[y] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tinline void solve (int x, int y, int w, int id)\n\t{\n\t\tget_chain (x, y), init (id);\n\t\tget_set ();\n\t\tsolve_S (w), solve_T (w);\n\t}\n}\n\ninline void Init ()\n{\n\tDSU :: init ();\n\tTREE :: init ();\n}\n\ninline void Solve ()\n{\n\tInit ();\n\n\tsort (E + 1, E + M + 1);\n\tfor (int i = 1; i <= M && Left < N - 1; ++i)\n\t{\n\t\tint x = E[i].x, y = E[i].y, w = E[i].z, id = E[i].id, k = Ban[id].size();\n\t\tint dis = get_dis (x, y);\n\t\tif (k < dis) TREE :: solve (x, y, w);\n\t\telse GRA :: solve (x, y, w, id);\n\t}\n\n\tcout << ans << endl;\n}\n\ninline void Input ()\n{\n\tN = read<int>(), M = read<int>(), P = read<int>();\n\tfor (int i = 2; i <= N; ++i) add_edge (read<int>(), i);\n\tfor (int i = 1; i <= M; ++i)\n\t{\n\t\tint x = read<int>(), y = read<int>(), z = read<int>();\n\t\tE[i] = (road){x, y, z, i};\n\t}\n\tfor (int i = 1; i <= P; ++i)\n\t{\n\t\tint t = read<int>(), a = read<int>(), b = read<int>();\n\t\tBan[t].pb (mp (a, b));\n\t}\n}\n\nint main()\n{\n\n#ifndef ONLINE_JUDGE\n\tfreopen(\"A.in\", \"r\", stdin);\n\tfreopen(\"A.out\", \"w\", stdout);\n#endif\n\n\tInput ();\n\tSolve ();\n\n\treturn 0;\n}\n\n```\n\n","categories":["Problem"],"tags":["并查集"]},{"title":"「BZOJ2138」stone - Hall定理 + 线段树","url":"/2019/08/27/%E3%80%8CBZOJ2138%E3%80%8Dstone-Hall%E5%AE%9A%E7%90%86-%E7%BA%BF%E6%AE%B5%E6%A0%91/","content":"\n有$n$堆石子，第$i$堆有$a_i$个\n\n$m$次操作$(l, r, k)$，每次你需要从$[l, r]$堆中取出尽量多石子，且总共不能超过$k$个，问每次最多能取多少个\n\n注意，第$i$次操作是建立在第$1$到$i-1$次都取到你回答的个数下，即询问**不是**相互独立的\n\n保证任意$[l, r]$不存在包含关系\n\n$n\\le 4\\times 10^4, a_i\\le 500$\n\n<!--more-->\n\n### Link\n\n[BZOJ2138](https://www.lydsy.com/JudgeOnline/problem.php?id=2138)\n\n### Solution\n\n如果暴力把每个点拆成$a_i$个，每个询问拆成$k_i$个，那么可以转化成二分图最大匹配的模型\n\n考虑`Hall定理`：枚举$X$的任意子集，看它在$Y$集合的相邻节点数量是否大于等于子集大小\n\n暴力考虑子集显然不行，但是由于$[l, r]$互不包含，所以只需要考虑所有连续的区间，而不必考虑集合\n\n> 若两个区间相交，那么显然没问题\n>\n> 若两个区间不交，那它们连到对面的边也不交，是完全独立的\n\n设$S[i, j]$表示$\\sum_{k=i}^{j}a_k$，$T[i,j]$表示所有被区间$[i, j]$包含的子区间需要的石子数之和\n\n> $S$就是一开始的$a$构成的，而$T$是随着操作而动态变化的\n\n那么若某个状态合法，则需要满足$\\forall i, j, S[i, j] \\ge T[i, j]$\n\n令$TL[i]$表示左端点$\\in [1, i]$的所有区间的石子数之和，$TR[i]$表示右端点$\\in[1, i]$的所有区间的石子数之和\n\n因为区间互不包含，所以$T[i, j] = TR[j] - TL[i - 1]$\n\n那么有$S[j] - S[i - 1] \\ge TR[j] - TL[i - 1]$\n\n即$S[j] - TR[j] \\ge S[i - 1] - TL[i - 1]$\n\n令$f[i] = S[i] - TR[i], g[i] = S[i] - TL[i]$，那么有$f[i] \\ge g[i]$\n\n考虑当前这次操作$[l, r]$，如果它要合法，则$\\forall i < l, j\\ge r$，都有$f[j] \\ge g[i]$。即$\\displaystyle \\min_{i=r}^{n}f_i \\ge \\max_{i=1}^{l-1}g_i$\n\n所以这个区间的答案就是$\\displaystyle \\min\\{k, \\min_{i=r}^{n}f_i - \\max_{i=1}^{l-1}g_i\\}$\n\n用线段树维护一下$\\min f, \\max g$即可\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n#define DEBUG(x) cout << #x << \" = \" << x << endl;\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int Maxn = 40000 + 100;\n\ninline LL sqr (LL x) { return x * x; }\n\nint N, M;\nint A[Maxn];\n\nnamespace SEG\n{\n#define mid ((l + r) >> 1)\n#define ls o << 1\n#define rs o << 1 | 1\n#define lson ls, l, mid\n#define rson rs, mid + 1, r\n\tstruct info\n\t{\n\t\tLL f, g, tag_f, tag_g;\n\t} node[Maxn << 2];\n\n\tinline void push_up (int o)\n\t{\n\t\tnode[o].f = min (node[ls].f, node[rs].f);\n\t\tnode[o].g = max (node[ls].g, node[rs].g);\n\t}\n\n\tinline void push_f (int o)\n\t{\n\t\tLL &t = node[o].tag_f;\n\t\tif (!t) return ;\n\t\tnode[ls].tag_f += t, node[rs].tag_f += t;\n\t\tnode[ls].f += t, node[rs].f += t;\n\t\tt = 0;\n\t}\n\n\tinline void push_g (int o)\n\t{\n\t\tLL &t = node[o].tag_g;\n\t\tif (!t) return ;\n\t\tnode[ls].tag_g += t, node[rs].tag_g += t;\n\t\tnode[ls].g += t, node[rs].g += t;\n\t\tt = 0;\n\t}\n\n\tinline void push_down (int o) { push_f (o), push_g (o); }\n\n\tinline void build (int o, int l, int r)\n\t{\n\t\tif (l == r) return void (node[o].f = node[o].g = A[l]);\n\t\tbuild (lson), build (rson);\n\t\tpush_up (o);\n\t}\n\n\tinline LL query_f (int o, int l, int r, int x, int y)\n\t{\n\t\tif (x <= l && r <= y) return node[o].f;\n\t\tpush_down (o);\n\t\tLL ans = LLONG_MAX;\n\t\tif (x <= mid) Chkmin (ans, query_f (lson, x, y));\n\t\tif (y > mid) Chkmin (ans, query_f (rson, x, y));\n\t\treturn ans;\n\t}\n\n\tinline LL query_g (int o, int l, int r, int x, int y)\n\t{\n\t\tif (x <= l && r <= y) return node[o].g;\n\t\tpush_down (o);\n\t\tLL ans = 0;\n\t\tif (x <= mid) Chkmax (ans, query_g (lson, x, y));\n\t\tif (y > mid) Chkmax (ans, query_g (rson, x, y));\n\t\treturn ans;\n\t}\n\t\n\tinline void update_f (int o, int l, int r, int x, int y, int val)\n\t{\n\t\tif (x <= l && r <= y) \n\t\t{\n\t\t\tnode[o].f += val, node[o].tag_f += val;\n\t\t\treturn ;\n\t\t}\n\t\tpush_down (o); \n\t\tif (x <= mid) update_f (lson, x, y, val);\n\t\tif (y > mid) update_f (rson, x, y, val);\n\t\tpush_up (o);\n\t}\n\n\tinline void update_g (int o, int l, int r, int x, int y, int val)\n\t{\n\t\tif (x <= l && r <= y) \n\t\t{\n\t\t\tnode[o].g += val, node[o].tag_g += val;\n\t\t\treturn ;\n\t\t}\n\t\tpush_down (o); \n\t\tif (x <= mid) update_g (lson, x, y, val);\n\t\tif (y > mid) update_g (rson, x, y, val);\n\t\tpush_up (o);\n\t}\n#undef mid\n}\n\nLL K[Maxn];\n\ninline void Solve ()\n{\n\tSEG :: build (1, 0, N);\n\tfor (int i = 1; i <= M; ++i)\n\t{\n\t\tint l = read<int>(), r = read<int>();\n\t\tLL now = max (0ll, min (K[i], SEG :: query_f (1, 0, N, r, N) - SEG :: query_g (1, 0, N, 1, l - 1)));\n\t\tprintf(\"%lld\\n\", now);\n\t\tSEG :: update_f (1, 0, N, r, N, - now);\n\t\tSEG :: update_g (1, 0, N, l, N, - now);\n\t}\n}\n\ninline void Input ()\n{\n\tN = read<int>();\n\tint x = read<int>(), y = read<int>(), z = read<int>(), P = read<int>();\n\tfor (int i = 1; i <= N; ++i) A[i] = A[i - 1] + (sqr (i - x) + sqr (i - y) + sqr (i - z)) % P;\n\tM = read<int>();\n\tK[1] = read<int>(), K[2] = read<int>(), x = read<int>(), y = read<int>(), z = read<int>(), P = read<int>();\n\tfor (int i = 3; i <= M; ++i) K[i] = (x * K[i - 1] + y * K[i - 2] + z) % P;\n}\n\nint main()\n{\n\n#ifdef hk_cnyali\n\tfreopen(\"A.in\", \"r\", stdin);\n\tfreopen(\"A.out\", \"w\", stdout);\n#endif\n\n\tInput ();\n\tSolve ();\n\n\treturn 0;\n}\n\n```\n\n","categories":["Problem"],"tags":["线段树","数据结构","Hall定理"]},{"title":"「UNR #1」火车管理 - 主席树","url":"/2019/08/27/%E3%80%8CUNR-1%E3%80%8D%E7%81%AB%E8%BD%A6%E7%AE%A1%E7%90%86-%E4%B8%BB%E5%B8%AD%E6%A0%91/","content":"\n有$n$个栈,$m$次操作\n\n区间压数,单点弹栈,求区间栈顶和\n\n强制在线\n\n$n, m\\le 5\\times10^5$\n\n<!--more-->\n\n### Link\n\n[UOJ218](http://uoj.ac/problem/218)\n\n### Solution\n\n![19-8-27-1](/images/19-8-27-1.png)\n\n本来想只用一个主席树维护的\n\n搞了一晚上不晓得怎么维护，网上的代码也看不懂\n\n就弃了\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n#define DEBUG(x) cout << #x << \" = \" << x << endl;\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int Maxn = 5e5 + 100;\n\nint N, M, type;\nint O[Maxn];\n\nnamespace CMT\n{\n#define mid ((l + r) >> 1)\n#define ls node[o].ch[0]\n#define rs node[o].ch[1]\n#define lson ls, l, mid\n#define rson rs, mid + 1, r\n\tstruct info\n\t{\n\t\tint ch[2];\n\t\tpii val;\n\t\tinfo () { val = mp (0, -1); }\n\t} node[Maxn * 80];\n\tint node_cnt;\n\n\tinline void build (int &o, int l, int r)\n\t{\n\t\to = ++node_cnt;\n\t\tif (l == r) return ;\n\t\tbuild (lson), build (rson);\n\t}\n\n\tinline void update (int pre, int &o, int l, int r, int x, int y, pii val)\n\t{\n\t\to = ++node_cnt; node[o] = node[pre];\n\t\tif (!pre) node[o].val = mp (0, -1);\n\t\tif (x <= l && r <= y) { node[o].val = val; ls = rs = 0; return ; }\n\t\tif (x <= mid) update (node[pre].ch[0], lson, x, y, val);\n\t\tif (y > mid) update (node[pre].ch[1], rson, x, y, val);\n\t}\n\n\tinline pii query (int o, int l, int r, int x)\n\t{\n\t\tif (!o) return mp (0, -1);\n\t\tif (l == r) return node[o].val;\n\t\tpii ans = mp (0, -1);\n\t\tif (x <= mid) ans = query (lson, x);\n\t\telse ans = query (rson, x);\n\t\tif (ans.y < 0) ans = node[o].val;\n\t\treturn ans;\n\t}\n\n#undef mid\n#undef ls\n#undef rs\n#undef lson\n#undef rson\n\n}\n\nnamespace SEG\n{\n#define mid ((l + r) >> 1)\n#define ls o << 1\n#define rs o << 1 | 1 \n#define lson ls, l, mid\n#define rson rs, mid + 1, r\n\n\tstruct info\n\t{\n\t\tint tag, sum;\n\t} node[Maxn << 2];\n\n\tinline void push_up (int o) { node[o].sum = node[ls].sum + node[rs].sum; }\n\n\tinline void push_down (int o, int l, int r)\n\t{\n\t\tint &t = node[o].tag;\n\t\tif (!t) return ;\n\t\tnode[ls].tag = node[rs].tag = t;\n\t\tnode[ls].sum = t * (mid - l + 1), node[rs].sum = t * (r - mid);\n\t\tt = 0;\n\t}\n\n\tinline int query (int o, int l, int r, int x, int y)\n\t{\n\t\tif (x <= l && r <= y) return node[o].sum;\n\t\tpush_down (o, l, r);\n\t\tint ans = 0;\n\t\tif (x <= mid) ans += query (lson, x, y);\n\t\tif (y > mid) ans += query (rson, x, y);\n\t\treturn ans;\n\t}\n\n\tinline void update (int o, int l, int r, int x, int y, int val)\n\t{\n\t\tif (x <= l && r <= y) { node[o].tag = val, node[o].sum = (r - l + 1) * val;  return ; }\n\t\tpush_down (o, l, r);\n\t\tif (x <= mid) update (lson, x, y, val);\n\t\tif (y > mid) update (rson, x, y, val);\n\t\tpush_up (o);\n\t}\n\n#undef mid\n#undef ls\n#undef rs\n#undef lson\n#undef rson\n\n}\n\n\ninline void Solve ()\n{\n\tCMT :: build (O[0], 1, N);\n\tint ans = 0;\n\tfor (int i = 1; i <= M; ++i)\n\t{\n\t\tint op = read<int>();\n\t\tif (op == 1)\n\t\t{\n\t\t\tint l = (read<int>() + ans * type) % N + 1, r = (read<int>() + ans * type) % N + 1;\n\t\t\tif (l > r) swap (l, r);\n\t\t\tO[i] = O[i - 1];\n\t\t\tprintf(\"%d\\n\", ans = SEG :: query (1, 1, N, l, r));\n\t\t}\n\t\telse if (op == 2)\n\t\t{\n\t\t\tint l = (read<int>() + ans * type) % N + 1;\n\t\t\tint x = CMT :: query (O[i - 1], 1, N, l).y;\n\t\t\tpii now = CMT :: query (O[x], 1, N, l);\n\t\t\tif (now.y < 0) now.y = 0;\n\t\t\tCMT :: update (O[i - 1], O[i], 1, N, l, l, now);\n\t\t\tSEG :: update (1, 1, N, l, l, now.x);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint l = (read<int>() + ans * type) % N + 1, r = (read<int>() + ans * type) % N + 1, x = read<int>();\n\t\t\tif (l > r) swap (l, r);\n\t\t\tSEG :: update (1, 1, N, l, r, x);\n\t\t\tCMT :: update (O[i - 1], O[i], 1, N, l, r, mp (x, i - 1));\n\t\t}\n\t}\n}\n\ninline void Input ()\n{\n\tN = read<int>(), M = read<int>(), type = read<int>();\n}\n\nint main()\n{\n\n#ifndef ONLINE_JUDGE\n\tfreopen(\"A.in\", \"r\", stdin);\n\tfreopen(\"A.out\", \"w\", stdout);\n#endif\n\n\tInput ();\n\tSolve ();\n\n\treturn 0;\n}\n\n```\n\n","categories":["Problem"],"tags":["线段树","数据结构","主席树"]},{"title":"「CF932F」Escape Through Leaf - 李超线段树合并","url":"/2019/08/25/%E3%80%8CCF932F%E3%80%8DEscape-Through-Leaf-%E6%9D%8E%E8%B6%85%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%90%88%E5%B9%B6/","content":"\n给你一颗 $n$ 个点的树 , 每个节点有两个权值 $a_i,b_i$\n\n从 $u$ 跳到 $v$ 的代价是 $a_u\\times b_v$你需要计算每个节点跳到叶子的最小代价.\n\n$n\\le 10^5;-10^5\\le a_i, b_i\\le 10^5$\n\n<!--more-->\n\n### Link\n\n[CF932F](https://codeforc.es/contest/932/problem/F)\n\n### Solution\n\n设$dp_i$为$i$跳到叶子的最小代价，枚举$u$的后代$v$，有：\n$$\n\\displaystyle dp_u = \\min_v \\{a[u] \\times b[v] + dp_v\\}\n$$\n这个斜率的形式很标准，直接上李超线段树即可\n\n并且很显然需要线段树合并\n\n李超线段树合并就是把另外一棵线段树的每个优势线段都插到当前的线段树中即可，是$O(n\\log^2n)$的复杂度\n\n这道题下标可能是负数，需要注意线段树的$mid$要向下取整（默认强转是向$0$取整）\n\n---\n\n第一次写李超线段树，按照自己想法写的\n\n没想到一遍就过了，没有任何精度问题，并且代码也很简洁\n\n在判断向线段树哪个儿子走的时候，直接算$l,r$这两个端点处哪个线段更优即可\n\n因为若两直线在某区间内有交，那么它们在两端点处的大小关系一定不同\n\n完全避免了计算交点的精度问题\n\n`insert`部分代码：\n\n```cpp\ninline void insert (int &o, int l, int r, line now)\n{\n\tif (!o) o = ++node_cnt;\n    if (node[o].get_val (mid) > now.get_val (mid)) swap (node[o].seg, now);\n\tif (l == r || !now.id) return ;\n\tif (node[o].get_val (l) > now.get_val (l)) insert (lson, now); \n\tif (node[o].get_val (r) > now.get_val (r)) insert (rson, now);\n}\n```\n\n\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n#define DEBUG(x) cout << #x << \" = \" << x << endl;\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int Maxn = 1e5 + 100;\nconst int LIM = 1e5 + 5;\nconst LL inf = 1e18;\n\nint N, A[Maxn], B[Maxn];\nint e, Begin[Maxn], To[Maxn << 1], Next[Maxn << 1];\n\ninline void add_edge (int x, int y) { To[++e] = y; Next[e] = Begin[x]; Begin[x] = e; }\n\nstruct line\n{\n\tint id;\n\tLL k, b;\n\tinline LL get_val (LL x) { if (!id) return inf; return k * x + b; }\n};\n\nnamespace SEG\n{\n#define mid (floor(1.0 * (l + r) / 2))\n#define ls node[o].ch[0]\n#define rs node[o].ch[1]\n#define lson ls, l, mid\n#define rson rs, mid + 1, r\n\n\tstruct info\n\t{\n\t\tint ch[2];\n\t\tline seg;\n\t\tinline LL get_val (LL x) { return seg.get_val (x); }\n\t} node[Maxn * 60];\n\tint node_cnt;\n\n\tinline void insert (int &o, int l, int r, line now)\n\t{\n\t\tif (!o) o = ++node_cnt;\n\t\tif (node[o].get_val (mid) > now.get_val (mid)) swap (node[o].seg, now);\n\n\t\tif (l == r || !now.id) return ;\n\n\t\tif (node[o].get_val (l) > now.get_val (l)) insert (lson, now); \n\t\tif (node[o].get_val (r) > now.get_val (r)) insert (rson, now);\n\t}\n\n\tinline void merge (int x, int &o, int l, int r)\n\t{\n\t\tif (!x || !o) return void(o = x | o);\n\t\tinsert (o, l, r, node[x].seg);\n\t\tmerge (node[x].ch[0], lson);\n\t\tmerge (node[x].ch[1], rson);\n\t}\n\n\tinline LL query (int o, int l, int r, int x)\n\t{\n\t\tif (!o) return inf;\n\t\tif (l == r) return node[o].seg.get_val (x);\n\t\tif (x <= mid) return min (query (lson, x), node[o].get_val (x));\n\t\treturn min (query (rson, x), node[o].get_val (x));\n\t}\n\n#undef mid\n}\n\nint O[Maxn];\nLL Dp[Maxn];\n\ninline void dfs (int x, int f)\n{\n\tint fl = 0;\n\tfor (int i = Begin[x]; i; i = Next[i])\n\t{\n\t\tint y = To[i];\n\t\tif (y == f) continue;\n\t\tfl = 1;\n\t\tdfs (y, x);\n\t\tSEG :: merge (O[y], O[x], -LIM, LIM);\n\t}\n\tif (fl) Dp[x] = SEG :: query (O[x], -LIM, LIM, A[x]);\n\tSEG :: insert (O[x], -LIM, LIM, (line){x, B[x], Dp[x]});\n}\n\ninline void Solve ()\n{\n\tdfs (1, 0);\n\tfor (int i = 1; i <= N; ++i) printf(\"%lld \", Dp[i]);\n}\n\ninline void Input ()\n{\n\tN = read<int>();\n\tfor (int i = 1; i <= N; ++i) A[i] = read<int>();\n\tfor (int i = 1; i <= N; ++i) B[i] = read<int>();\n\tfor (int i = 1; i < N; ++i)\n\t{\n\t\tint x = read<int>(), y = read<int>();\n\t\tadd_edge (x, y);\n\t\tadd_edge (y, x);\n\t}\n}\n\nint main()\n{\n\n#ifndef ONLINE_JUDGE\n\tfreopen(\"F.in\", \"r\", stdin);\n\tfreopen(\"F.out\", \"w\", stdout);\n#endif\n\n\tInput ();\n\tSolve ();\n\n\treturn 0;\n}\n\n```\n\n","categories":["Problem"],"tags":["Codeforces","线段树","数据结构","线段树合并","李超线段树"]},{"title":"「Algorithm」放球问题","url":"/2019/08/22/%E3%80%8CAlgorithm%E3%80%8D%E6%94%BE%E7%90%83%E9%97%AE%E9%A2%98/","content":"\n继续填小学没学好的坑\n\n都高二了还这么菜...\n\n<!--more-->\n\n## Content\n\n$n$个球，放到$m$个盒子里（$n\\ge m$），主要有下列八种情况：\n\n| 序号 | $n$个球是否有区别 | $m$个盒子是否有区别 | 是否允许空盒 |\n| :--: | :---------------: | :-----------------: | :----------: |\n|  1   |        否         |         否          |      否      |\n|  2   |        否         |         否          |      是      |\n|  3   |        否         |         是          |      否      |\n|  4   |        否         |         是          |      是      |\n|  5   |        是         |         否          |      否      |\n|  6   |        是         |         否          |      是      |\n|  7   |        是         |         是          |      否      |\n|  8   |        是         |         是          |      是      |\n\n### 一、球相同，盒子相同，不允许空盒\n\n要保证盒子大小非严格递减。每次把当前所有盒子里的球都$+1$；或者新增一个盒子，里面放一个球\n\n设$f[n][m]$表示答案，那么\n$$\nf[n][m] = f[n - 1][m - 1] + f[n - m][m]\n$$\n\n* 另外，也可以从允许空盒的方案（`情况2`）$g$推出：\n\n  每个盒子里都先铺一个球，即$f[n][m] = g[n - m][m]$\n\n### 二、球相同，盒子相同，允许空盒\n\n设$g[n][m]$表示答案，那么\n$$\ng[n][m] = g[n][m - 1] + g[n - m][m]\n$$\n（因为新增的盒子可以为空了）\n\n* 与$f$（`情况1`）的关系：\n\n  $\\displaystyle g[n][m] = \\sum_{i=1}^{m}f[n][i]$\n\n### 三、球相同，盒子不同，不允许空盒\n\n插板法，总共$n-1$个间隔，插$m-1$个板子\n\n答案即为$\\displaystyle \\binom{n-1}{m-1}$\n\n### 四、球相同，盒子不同，允许空盒\n\n可以看作，先在最后添上$m$个球，总共$n+m$个球，往里插$m-1$个板子，然后从这$m$部分中每部分拿掉一个球，就变成了这种情况\n\n答案是$\\displaystyle \\binom{n+m-1}{m-1}$\n\n>或者直接从代数角度\n>\n>答案等于$\\displaystyle \\sum_{i=1}^{m}\\binom{n-1}{i-1}$\n>\n>根据杨辉三角某一列的前缀和，就等于最下面那个位置右下角的值，即$\\displaystyle \\binom{n+m-1}{m-1}$\n\n* 如何从`情况4`推`情况3`？\n\n  允许空盒的方案是$n+m$个球插$m-1$个板子。在每个盒子里先铺一个球，那么只剩$n$个球了。插$m-1$个板子的方案数就是$\\displaystyle \\binom{n-1}{m-1}$\n\n### 五、球不同，盒子相同，不允许空盒\n\n第二类斯特林数\n\n考虑第$n$个球\n\n* 若前$n-1$个球形成了$m-1$个集合，那么第$n$个球必须新开一个集合。因为盒子没有顺序（或者说一开始已经固定了顺序），所以不用乘$n-m+1$\n* 若前$n-1$个球已经形成了$m$个集合，那第$n$个球可以插到其中任意一个中。因为第$n$个球是独一无二的，所以要乘$m$\n\n$$\n{n\\brace{m}} = {n-1\\brace{m-1}} + m{n-1\\brace m}\n$$\n\n\n\n### 六、球不同，盒子相同，允许空盒\n\n答案就是$\\displaystyle \\sum_{i=1}^{m}{n\\brace{i}}$\n\n\n\n### 七、球不同，盒子不同，不允许空盒\n\n答案就是$\\displaystyle m!{n\\brace m}$\n\n因为`情况5`中的每一种方案，任意两个集合交换后形成的方案一定与本身不同（若球都一样的话就不一定了，详见下文）\n\n### 八、球不同，盒子不同，允许空盒\n\n答案就是$m^n$\n\n* 与`情况7`关系：\n\n$$\n\\begin{aligned}\n\tm^n &= \\sum_{i = 0} ^ {m} \\binom{m}{i} {n \\brace m - i} (m - i)! \\\\\n\n\t&= \\sum_{i = 0} ^{m} \\binom{m}{i} {n \\brace i} i! \\\\\n\n\t&= \\sum_{i=0} ^m {n \\brace i} m^{\\underline{i}}\n\n\\end{aligned}\n$$\n\n枚举空盒数量，是个经典的式子\n\n## Summary\n\n* 什么东西是无标号的，那么就可以给它随便钦定一种顺序，形象地理解就是把它固定不动，再考虑另一个东西\n\n  例如：\n\n  * `情况1、2`相当于先把球固定，考虑盒子的过程中盒子的顺序也是固定的（保证非严格递减）\n  * `情况3、4`相当于把球固定，考虑盒子如何摆\n  * `情况5、6`相当于把盒子的顺序固定，依次考虑每个球放到哪个盒子里\n\n* Q. 为什么`5`到`7`可以直接乘$8!$，而`1`到`3`不行？\n\n  A. 因为盒子是否有区别，不仅取决于是否有标号，还与**集合大小**有关！\n\n  例如，在球不同，盒子不同的情况下，$\\{1, 2, 3\\},\\{4, 5, 6\\}$与$\\{4, 5, 6\\},\\{1, 2, 3\\}$是不同的。但若球不同，这两种情况都是$\\{3\\},\\{3\\}$，没有区别。这里需要注意\n\n","categories":["Algorithm"],"tags":["数学","斯特林数","组合数学"]},{"title":"「笔记」一些树题","url":"/2019/08/21/%E3%80%8C%E7%AC%94%E8%AE%B0%E3%80%8D%E4%B8%80%E4%BA%9B%E6%A0%91%E9%A2%98/","content":"\n来自xcy课件的一些树题\n\n<!--more-->\n\n## 杂题\n\n### [CF1109F](https://codeforces.com/contest/1109/problem/F)\n\n#### Description\n\n一个$n \\times m$的网格, 每个格子有一个数, 为$1$ ~ $n \\times m$的排列.\n\n一个值域区间$[l, r](1 \\le l \\le r \\le n \\times m)$是好的, 当且仅当数值在该区间内的格子, 构成一棵树(有公共边的格子连边).\n\n统计好区间数.\n\n$n, m\\le 2\\times10^3, n\\cdot m\\le 2\\times10^5$\n\n#### Soltuion\n\n[LCT] [数据结构] [线段树]\n\n![19-8-21-1](/images/19-8-21-1.png)\n\n\n\n### [CF1039D](https://codeforces.com/contest/1039/problem/D)\n\n#### Description\n\n有一棵$n$个点的树.\n\n一个简单路径的集合被称为”$k$合法”当且仅当: 树的每个点至多属于其中一条路径(可以不属于), 且每条路径恰好包含$k$个点.\n\n对于$k \\in [1, n]$, 求出”$k$合法”路径集合的最多路径数.\n\n$n \\le 10^5$\n\n#### Solution\n\n[分块]\n\n对于每个确定的$k$，显然可以直接$O(n)$从下往上贪心，尽量靠下方合并\n\n发现当$k > \\sqrt n$时答案$\\le \\sqrt n$，所以当$k\\in (\\sqrt n, n]$时，按答案分块，每块二分右端点\n\n$O(n\\sqrt n \\log n)$\n\nCF机子跑得快\n\n\n\n### [「SDOI2015」寻宝游戏](https://loj.ac/problem/2182)\n\n[set]\n\n本质上就是每次求树链的并\n\n树链的并就是按`dfn`排序后两两点的距离\n\nset维护一下即可\n\n\n\n## [Prüfer序](https://hk-cnyali.com/2019/01/12/树相关小结/)\n\n### [HNOI2008 明明的烦恼](https://www.luogu.org/problem/P2624)\n\n[prufer序列]\n\n设$\\displaystyle res = (n - 2)- \\sum_{i}(d_i - 1)$，表示剩下还有多少位置可以随便填，则\n\n$\\displaystyle ans = \\frac{(n - 2)!}{\\prod_{i}(d_i - 1)!\\times res!}\\times res^{n-k}$\n\n其中$k$表示钦定了度数的点的数量\n\n\n\n## 剖分\n\n### [「JSOI2016」轻重路径](https://loj.ac/problem/2079)\n\n#### Description\n\n一棵$n$个点的有根二叉树,对它跑一边重链剖分. 如果$u$两个儿子的大小一样, 认为左儿子为重儿子。\n\n$q$次操作, 每次删掉一个当前二叉树的叶子, 每次操作后输出重儿子的编号和.\n\n删除一个点之后, 如果以$u$两个儿子为根的子树大小一样, 重儿子保持不变.\n\n$n, q\\le 10^5$\n\n#### Solution\n\n[树链剖分]\n\n![19-8-21-2](/images/19-8-21-2.png)\n\n$size_u\\le \\frac12size_{rt}$是必要但不充分条件，但有了这个条件每次$size_{rt}$就会减半，十分巧妙\n\n我感觉这个复杂度其实是$O(n\\log^3n)$的。。。里面还有一层找祖先的$\\log$\n\n这道题还有个`Splay`维护的$O(n\\log n)$的做法，不过没看懂\n\n### [「十二省联考 2019」春节十二响](https://loj.ac/problem/3052)\n\n#### Description\n\n给定一棵$n$个点, 以$1$为根的树. 每个点有权值$w_i$ \n\n你需要把所有点划分到若干个集合中, 满足每个集合内不存在两点互为祖先/后代. \n\n每个集合的权值为其内点的权值的最大值. 一种划分的权值为划分出的所有集合的权值之和. \n\n求划分的权值的最小值.\n\n$n\\le 2*10^5$\n\n#### Solution\n\n[启发式合并] [贪心]\n\n对于任意一条到根的链或其子链, 其上的所有点一定分属不同的集合\n\n贪心，每个结点的子链上面一一向比自己大的配对，即对每个点的任意两条子链，按从大到小的顺序依次合并（最大的和最大的，次大的和次大的$\\dots k$大的和$k$的顺次合并）\n\n用个堆维护，启发式合并\n\n\n\n## 点分治\n\n### [LG P2664 树上游戏](https://www.luogu.org/problem/P2664)\n\n[点分治]\n\n点分治，先不考虑路径必须不在同一子树的限制，发现每个颜色在第一次出现时，会产生其子树大小的贡献\n\n对每个分治中心$x$, 先算出每个点到根的答案. \n\n进入每棵子树$k$时, 把子树内的点的贡献消去, 然后对于子树内的一个点, 首先把它到$x$(不包括$x$)的颜色所产生的贡献都消去(即这些颜色第一次出现时的子树大小之和)\n\n然后统计当前点到$x$(不包括$x$)的颜色数量$num$, 使答案加上$num \\times (size_{x} - size_{k})$\n\n---\n\n这道题差分做法：\n\n![19-8-27-2](/images/19-8-27-2.png)\n\n## 树分块\n\n![19-8-24-1](/images/19-8-24-1.png)\n\n### [「SCOI2005」王室联邦](https://loj.ac/problem/2152)\n\n这道题的做法可以用来分块\n\n讲做法还不如贴代码\n\n```cpp\ninline void dfs (int x, int f)\n{\n\tfor (int i = Begin[x]; i; i = Next[i])\n\t{\n\t\tint y = To[i];\n\t\tif (y == f) continue;\n\t\tdfs (y, x);\n\t\tvec[x].insert (vec[x].end(), vec[y].begin(), vec[y].end());\n\t\tif (vec[x].size() >= B)\n\t\t{\n\t\t\t++cnt;\n\t\t\tfor (int i = 0; i < vec[x].size(); ++i) \n\t\t\t\tbelong[vec[x][i]] = cnt;\n\t\t\tcap[cnt] = x;\n\t\t\tvec[x].clear();\n\t\t}\n\t}\n\tvec[x].pb (x);\n}\n```\n\n\n\n## Kruskal重构树\n\n可以处理出一个图中只经过边权$\\le k$的边所能到达的点集\n\n### [「IOI2018」狼人](https://loj.ac/problem/2865)\n\n[kruskal重构树]\n\n模板题\n\n建最小, 最大生成树的重构树, 边权分别为两端点编号的最大, 最小值. \n\n然后转化为两集合是否有交的问题了. \n\n主席树维护.\n\n","categories":["Note"],"tags":["分块","线段树","数据结构","贪心","set","树链剖分","启发式合并","kruskal重构树","LCT","点分治","prufer序列"]},{"title":"「PKUSC2018」星际穿越 - 主席树","url":"/2019/08/18/%E3%80%8CPKUSC2018%E3%80%8D%E6%98%9F%E9%99%85%E7%A9%BF%E8%B6%8A-%E4%B8%BB%E5%B8%AD%E6%A0%91/","content":"\n坐标轴上有 $n$ 个星球,第 $i$ 个星球坐标为 $i$ ,与星球 $[l_i , i - 1]$ 之间都有双向通道。其中,经过每个通道都需要 1 的单位时间。\n\n定义$dist(x, y)$为从星球$x$出发到达星球$y$的最短时间，求$\\displaystyle \\sum_{i=l}^{r}dist(x, i)$\n\n多组询问，保证$l < r < x$\n\n$n, q\\le 3\\times 10^5$\n\n<!--more-->\n\n### Link\n\n[LOJ6435](https://loj.ac/problem/6435)\n\n### Solution\n\n设$\\displaystyle L[i] = \\min_{j=i}^{n}l_j$，考虑从$x$走到$y$（$x > y$）的最短路，除了第一步外，后面的每一步都是沿着$L[i]$走\n\n> 若某一步不走$L[i]$更优，那么就说明$[i + 1, n]$内存在一个更小的$l_j$，矛盾\n\n先不管第一步，因为$(L[i], i)$形成了一个树型结构，显然可以用主席树维护答案\n\n> 每个点存它的最短路，再求和，因为要区间求和，所以要标记永久化\n>\n> 也可以离线，直接线段树维护\n\n再考虑第一步：\n\n* 若$y\\in[l_x, x - 1]$，则一步就能到\n* 否则，第一步肯定往$[l_x, n]$中$l_j$最小的$j$去跳，然后第二步就能跳到$L[l_x]$\n\n随便处理下就可以了\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n#define DEBUG(x) cout << #x << \" = \" << x << endl;\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int Maxn = 3e5 + 100;\n\nint N, Q;\nint l[Maxn], L[Maxn];\n\nnamespace SEG\n{\n#define mid ((l + r) >> 1)\n#define ls node[o].ch[0]\n#define rs node[o].ch[1] \n#define lson ls, l, mid\n#define rson rs, mid + 1, r\n\tstruct info\n\t{\n\t\tint ch[2], tag;\n\t\tLL sum;\n\t} node[Maxn * 80];\n\tint node_cnt;\n\n\tinline void push_up (int o) { node[o].sum = node[ls].sum + node[rs].sum; }\n\n\tinline void update (int pre, int &o, int l, int r, int x, int y)\n\t{\n\t\to = ++node_cnt; node[o] = node[pre];\n\t\tif (x <= l && r <= y) { node[o].sum += r - l + 1; ++node[o].tag; return ; }\n\t\tif (x <= mid) update (node[pre].ch[0], lson, x, y);\n\t\tif (y > mid) update (node[pre].ch[1], rson, x, y);\n\t\tpush_up (o);\n\t}\n\n\tinline LL query (int o, int l, int r, int x, int y)\n\t{\n\t\tif (x > y) return 0;\n\t\tif (x <= l && r <= y) return node[o].sum;\n/**/\tLL ans = (LL) node[o].tag * (min (y, r) - max (x, l) + 1);\n\t\tif (x <= mid) ans += query (lson, x, y);\n\t\tif (y > mid) ans += query (rson, x, y);\n\t\treturn ans;\n\t}\n\n#undef mid\n}\n\nint O[Maxn];\n\ninline void Init ()\n{\n\tL[N + 1] = 0x3f3f3f3f;\n\tfor (int i = N; i >= 2; --i) L[i] = min (L[i + 1], l[i]);\n\tfor (int i = 2; i <= N; ++i) SEG :: update (O[L[i]], O[i], 1, N, 1, i - 1);\n}\n\ninline void Solve ()\n{\n\tInit ();\n\tQ = read<int>();\n\twhile (Q--)\n\t{\n\t\tint nl = read<int>(), nr = read<int>(), x = read<int>();\n\t\tLL down = nr - nl + 1, up = nr - nl + 1;\n\t\tup += SEG :: query (O[l[x]], 1, N, nl, min (nr, l[x] - 1));\n\t\tLL g = __gcd (up, down);\n\t\tprintf(\"%lld/%lld\\n\", up / g, down / g);\n\t}\n}\n\ninline void Input ()\n{\n\tN = read<int>();\n\tfor (int i = 2; i <= N; ++i) l[i] = read<int>();\n}\n\nint main()\n{\n\n#ifndef ONLINE_JUDGE\n\tfreopen(\"A.in\", \"r\", stdin);\n\tfreopen(\"A.out\", \"w\", stdout);\n#endif\n\n\tInput ();\n\tSolve ();\n\n\treturn 0;\n}\n```\n\n","categories":["Problem"],"tags":["主席树"]},{"title":"「SCOI2016」萌萌哒 - 倍增 + 并查集","url":"/2019/08/17/%E3%80%8CSCOI2016%E3%80%8D%E8%90%8C%E8%90%8C%E5%93%92-%E5%80%8D%E5%A2%9E-%E5%B9%B6%E6%9F%A5%E9%9B%86/","content":"\n一个长度为 $n$ 的大数, 每次告诉你两个长度相同的区间数字完全对应相同, 问可能的数的个数。\n\n$n \\le 10^5$\n\n<!--more-->\n\n### Link\n\n[LOJ2014](https://loj.ac/problem/2014)\n\n### Solution\n\n暴力做法是用并查集维护，每次对两区间的对应点合并，答案即为$10^{cnt-1} \\times 9$（最高位不为$0$）\n\n考虑用倍增优化这个过程\n\n类似于ST表的做法，每次只对$[l, l + 2^{k} - 1]$，$[r - 2^k + 1, r]$这两个区间打上标记\n\n最后再从上往下扫一遍下传标记即可\n\n### Summary\n\n这个做法好巧妙\n\n有点类似于线段树优化建边的思想，只不过换成了并查集\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n#define DEBUG(x) cout << #x << \" = \" << x << endl;\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int Maxn = 1e5 + 100;\nconst int Mod = 1e9 + 7;\n\nint N, M;\n\ninline int Pow (int a, int b)\n{\n\tint ans = 1;\n\tfor (int i = b; i; i >>= 1, a = (LL) a * a % Mod) if (i & 1) ans = (LL) ans * a % Mod;\n\treturn ans;\n}\n\nnamespace ST\n{\n\tint Log[Maxn];\n\tstruct info\n\t{\n\t\tint ch[2];\n\t} node[Maxn * 20];\n\tint Id[20][Maxn];\n\tint node_cnt;\n\n\tnamespace DSU\n\t{\n\t\tint fa[Maxn * 20];\n\t\tinline void init (const int &n) { for (int i = 1; i <= n; ++i) fa[i] = i; }\n\t\tinline int get_fa (const int &x) { return fa[x] == x ? x : fa[x] = get_fa (fa[x]); }\n\t\tinline void link (const int &x, const int &y) { fa[get_fa (x)] = get_fa (y); }\n\t}\n\n\tinline void init ()\n\t{\n\t\tLog[1] = 0; for (int i = 2; i <= N; ++i) Log[i] = Log[i >> 1] + 1;\n\t\tfor (int i = 1; i <= N; ++i) Id[0][i] = ++node_cnt;\n\t\tfor (int i = 1; i <= Log[N]; ++i)\n\t\t\tfor (int j = 1; j + (1 << i) - 1 <= N; ++j)\n\t\t\t{\n\t\t\t\tId[i][j] = ++node_cnt;\n\t\t\t\tnode[Id[i][j]].ch[0] = Id[i - 1][j];\n\t\t\t\tnode[Id[i][j]].ch[1] = Id[i - 1][j + (1 << (i - 1))];\n\t\t\t}\n\n\t\tDSU :: init (node_cnt);\n\t}\n\n\tinline void merge (const int &l1, const int &r1, const int &l2, const int &r2)\n\t{\n\t\tint k = Log[r1 - l1 + 1];\n\t\tDSU :: link (Id[k][l1], Id[k][l2]);\n\t\tDSU :: link (Id[k][r1 - (1 << k) + 1], Id[k][r2 - (1 << k) + 1]);\n\t}\n\n\tinline void flush ()\n\t{\n\t\tfor (int i = Log[N]; i >= 1; --i)\n\t\t\tfor (int j = 1; j + (1 << i) - 1 <= N; ++j)\n\t\t\t{\n\t\t\t\tint f = DSU :: get_fa (Id[i][j]);\n\t\t\t\tDSU :: link (node[Id[i][j]].ch[0], node[f].ch[0]);\n\t\t\t\tDSU :: link (node[Id[i][j]].ch[1], node[f].ch[1]);\n\t\t\t}\n\n\t\tint ans = 0;\n\t\tfor (int i = 1; i <= N; ++i) if (DSU :: fa[i] == i) ++ans;\n\t\tcout << (LL) Pow (10, ans - 1) * 9 % Mod << endl;\n\t}\n}\n\ninline void Solve ()\n{\n\tST :: init ();\n\twhile (M--)\n\t{\n\t\tint l1 = read<int>(), r1 = read<int>(), l2 = read<int>(), r2 = read<int>();\n\t\tST :: merge (l1, r1, l2, r2);\n\t}\n\tST :: flush ();\n}\n\ninline void Input ()\n{\n\tN = read<int>(), M = read<int>();\n}\n\nint main()\n{\n\n#ifndef ONLINE_JUDGE\n\tfreopen(\"A.in\", \"r\", stdin);\n\tfreopen(\"A.out\", \"w\", stdout);\n#endif\n\n\tInput ();\n\tSolve ();\n\n\treturn 0;\n}\n\n```\n\n","categories":["Problem"],"tags":["并查集","倍增"]},{"title":"「笔记」一些贪心题","url":"/2019/08/17/%E3%80%8C%E7%AC%94%E8%AE%B0%E3%80%8D%E4%B8%80%E4%BA%9B%E8%B4%AA%E5%BF%83%E9%A2%98/","content":"\n\n来自gc课件的一些贪心题\n\n<!--more-->\n## 反悔型贪心\n\n> 似乎就是就是模拟费用流？\n\n\n### [CF867E](https://codeforces.com/contest/867/problem/E)\n\n#### Description\n\n你预言了每天的股票价格 $v_i$ , 从第 $1$ 天开始,你每天可以选择卖一支股票,买一支股票,或者什么也不做\n\n问直到第 $n$ 天结束你最多可以获得多少收益\n\n$n \\le 3 \\times 10^5$\n\n#### Solution\n\n> 定义一次`股票买卖(x, y)`为，把$x$买进，$y$卖出\n\n考虑贪心，维护一个小根堆，每次将当前股票价格扔进去\n\n对于当前股票$x$而言，看堆里最小的元素$y$是否比它小，如果是，则做一次股票买卖$(y, x)$，答案加上$x - y$\n\n显然，这样做会有问题，因为有可能$y$在后面的某个时刻卖出更优\n\n如何反悔？\n\n依旧是上面的做法，把$y$弹出堆后，将$x$扔进堆里两次即可\n\n这两次的意义是不一样的，分别是这两个意义：\n\n* 把$x$作为后面某一次股票买卖的`买进部分`\n* 把$x$看成中转站，可以理解为，$x$仍旧是后面某次股票买卖$(x, z)$的`买进部分`，不过在现在$x$已经被卖出了。一卖一买相互抵消，就相当于进行了一次$(y, z)$的买卖，答案会加上$x - y + z - x = z - y$\n\n这样就实现了贪心过程中的反悔\n\n\n\n### [CF3D](https://codeforces.com/contest/3/problem/D)\n\n#### Description\n\n给出一个由 ( ) ? 组成的序列,第 $i$ 个 ? 可以花费 $a_i$ 的代价变成 (,花费 $b_i$ 的代价变成 ),问将其变为合法括号序列的最小代价\n\n$n\\le 10^6$\n\n#### Solution\n\n感觉这道题好像不太算反悔型贪心\n\n先贪心把每个$?$看成$)$，尽量满足括号匹配的这个限制，并把$a_i - b_i$加入小根堆\n\n如果某个时刻发现$($数量不够了，再从堆里取出最小的一个元素，把它替换成$($\n\n\n\n### [LG P1484](https://www.luogu.org/problem/P1484)\n\n#### Description\n\n给出一个长度为$n$的序列$a_i$，你需要从中最多选出$k$个互不相邻的位置，使得这些位置的权值和最大\n\n$n\\le 5*10^5, k\\le \\frac{n}{2}$\n\n#### Solution\n\n对于任意三个相邻位置$i - 1, i, i + 1$，若$a_i > \\max\\{a_{i - 1}, a_{i + 1}\\}$，那么最优方案要么选$i$，要么选$i-1$和$i+1$\n\n> 若只选$i-1$，不选$i+1$，显然不如只选$i$\n\n把所有$a_i$丢进一个大根堆，每次从堆里取出一个下标$x$，答案加上$a_i$，再把$a_{l_i} + a_{r_i} - a_i$丢进堆中\n\n这就是反悔型贪心的基本操作了\n\n其中$l_i, r_i$用链表维护一下\n\n\n\n### [51nod 1053](https://www.51nod.com/Challenge/Problem.html#problemId=1053)\n\n先贪心选所有的正数段，再考虑把段数减少到$m$。操作方法有两种：\n\n* 不取一个正数段$i$\n* 多取一个负数段$i$\n\n它们都会多付出$|sum(i)|$的代价，将三个相邻的段合并，使总段数减少1\n\n然后就是和上一题一样的套路了\n\n\n\n## 位运算相关\n\n### [CF967E](http://codeforces.com/contest/967/problem/E)\n\n其实[之前写过](https://hk-cnyali.com/2018/05/01/Codeforces-Round-477-Div-2-E-Big-Secret-贪心/)，但是感觉写得不太清楚\n\n#### Description\n\n给你一个数列$A$，求是否存在它的一个排列使得前缀异或和单调递增。如果存在，则输出一种方案\n\n$n\\le 10^5, A_i\\le 2^{60}$\n\n#### Solution\n\n所有满足 $s \\oplus k > s$ 的 $k$ 必然满足, $k$的最高位在 $s$ 上为 0.\n\n于是把所有数按二进制最高位存起来, 每次对当前前缀和从低到高 chk 每个为 $0$ 的位，是否是某个未选数最高位的落点.\n\n如果有, 用它更新当前前缀和, 再去填下一个数, 重新找. 如果扫到最高位都没有, 就无解\n\n显然从低位往高位贪心更优，因为选择会更多。若从高到低最多只能放$60$个数\n\n另外，对于最高位相同的数，选择的先后顺序并没有影响\n\n\n\n### [CF1054D](https://codeforces.com/contest/1054/problem/D)\n\n#### Description\n\n你有一个由 $n$ 个 $k$ 位二进制数组成的序列。允许多次对任意数异或上 $2^k − 1$ \n\n最大化序列中异或和不为 0 的区间个数\n\n$n\\le 2*10^6, k\\le 30$\n\n#### Solution\n\n区间异或和相关可以想到转化为前缀异或和相关\n\n补集转化，题意转化为要序列前缀异或和相等的数尽量少\n\n因为每次只能对某个数异或上$2^k - 1$，所以对于每个数$a_i$，它只能变成$a_i \\oplus (2^k - 1)$\n\n按照$\\min\\{a_i, a_i\\oplus (2^k - 1)\\}$分类，显然将同类的数中的一半变成$a_i$，另一半变成$a_i \\oplus (2^k - 1)$\n\n\n\n## 其他\n\n### [LOJ2306](https://hk-cnyali.com/2019/08/13/「NOI2017」蔬菜/)\n\n\n\n### [51nod 1302](https://www.51nod.com/Challenge/Problem.html#problemId=1302)\n\n#### Description\n\n$n$ 个矩形,你要把它们分成两组,使得两组最大重叠面积之和最大。矩形可旋转, 可移动\n\n$n \\le 10^5$\n\n#### Solution\n\n显然最终答案长边对长边，短边对短边\n\n![19-8-16-2](/images/19-8-16-2.png)\n","categories":["Note"],"tags":["贪心"]},{"title":"「NOI2017」蔬菜","url":"/2019/08/13/%E3%80%8CNOI2017%E3%80%8D%E8%94%AC%E8%8F%9C/","content":"\n你的仓库里有 $n$ 种蔬菜,每天最多销售 $m$ 个单位的蔬菜\n\n第 $i$ 种蔬菜有 $c_i$ 单位的库存,每天固定会有 $x_i$ 个单位变质从而不能再用于销售\n\n这种蔬菜的单位收益为 $a_i$ ,同时,对其进行的第一次销售（卖出去的第一个单位）会产生 $s_i$ 的额外收益。\n\n你想知道销售 $p$ 天的最大收益。多组询问。\n\n$n\\le 10^5, m\\le 10, p\\le 10^5, a, c, x, s \\le 10^9$\n\n<!--more-->\n\n### Link\n\n[LOJ2306](https://loj.ac/problem/2306)\n\n### Solution\n\n好恶心的一道题\n\n如果我们知道了第$t$天最优策略卖出的蔬菜集合$S$，那么$t-1$天卖出的蔬菜就是把$S$中权值最小的$m$个元素去掉形成的集合\n\n那么只需要考虑最后一天的集合，然后倒退即可\t\n\n求最后一天的集合时有一些性质：\n\n- 贪心考虑，从权值大到小考虑\n- 倒着考虑，把腐烂看成新增，每个蔬菜尽量往后放，从腐烂的那天往前放\n- 每种蔬菜第一次卖出的那一单位可以看成一个新的蔬菜，并且可以视为最后腐烂的\n- 每次暴力找哪一天还有剩余，用并查集优化这个过程\n\n这题还有不少细节，就不一一列举了，不如直接看代码\n\n---\n\nUPD 19.8.16\n\n放一下网络流做法：\n\n总共四类点，从左往右一次为：$S$，天，蔬菜，$T$\n\n连这些边：\n\n1. $S$向每一天连边$(m,0)$, 以限制每种蔬菜可以卖多少个.\n\n2. 第$i$天向第$(i+1)$连边$(inf,0)$, 这意味着如果后面的天没有把它们的蔬菜卖完, 前面的天就可以到后面去继续后面的蔬菜.\n\n3. 把每种蔬菜拆成$\\frac{c-1}{x}+1$份，前$\\frac{c-1}{x}$份每份$x$，最后一份是$(c - 1)\\bmod x$\n\n   每天向这一天会腐烂的那份蔬菜连边$(inf, 0)$\n\n4. 每份蔬菜向$T$连边，容量为这份的数量，费用为$a$\n\n5. 每种蔬菜的最后一份向$T$多连一条$(1, a+s)$的边\n\n因为只有蔬菜向$T$有费用，所以不会退流\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n#define DEBUG(x) cout << #x << \" = \" << x << endl;\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int Maxn = 1e5 + 100;\n\nint N, M, K, Max = 1e5;\nstruct item\n{\n\tint p, v, t, x;\n};\nvector <item> A;\npriority_queue <pii, vector <pii>, greater <pii> > Q;\nLL Ans[Maxn];\n\nnamespace DSU\n{\n\tint fa[Maxn];\n\tinline void init (int n = 1e5) { for (int i = 1; i <= n; ++i) fa[i] = i; }\n\tinline int get_fa (int x) { return fa[x] == x ? x : fa[x] = get_fa (fa[x]); }\n}\n\nint Rest[Maxn];\n\ninline int cmp (item a, item b) { return a.p > b.p; }\n\ninline void Init ()\n{\n\tDSU :: init ();\n\tfor (int i = 1; i <= Max; ++i) Rest[i] = M;\n\tsort (A.begin(), A.end(), cmp);\n\n\tfor (int i = 0; i < A.size(); ++i)\n\t{\n\t\tint p = A[i].p, v = A[i].v, t = A[i].t, x = A[i].x;\n\t\tint res = 0, sum = 0;\n\t\twhile (1)\n\t\t{\n\t\t\tint to = DSU :: get_fa (t);\n\t\t\tif (!to) break;\n\t\t\tres = min (v, res + (t - to + 1) * x);\n\t\t\tint now = min (Rest[to], res);\n\t\t\tres -= now, Rest[to] -= now, v -= now, sum += now;\n\t\t\tif (!v) break;\n\t\t\tif (!Rest[to]) DSU :: fa[to] = DSU :: fa[to - 1];\n\t\t\tt = to - 1;\n\t\t\tif (!t) break;\n\t\t}\n\t\tAns[Max] += (LL) p * sum;\n\t\tif (sum) Q.push (mp (p, sum));\n\t}\n}\n\ninline void Solve ()\n{\n\tInit();\n\n\tint sum = 0;\n\tfor (int i = 1; i <= Max; ++i) sum += M - Rest[i], Rest[i] = 0;\n\tfor (int i = 1; i <= Max; ++i) Rest[i] = min (sum, M), sum = max (0, sum - M);\n\n\tfor (int i = Max - 1; i >= 1; --i)\n\t{\n\t\tAns[i] = Ans[i + 1];\n\n\t\twhile (!Q.empty() && Rest[i + 1])\n\t\t{\n\t\t\tpii now = Q.top(); Q.pop();\n\t\t\tint use = min (Rest[i + 1], now.y);\n\t\t\tAns[i] -= (LL) now.x * use;\n\t\t\tif (use == Rest[i + 1])\n\t\t\t{\n\t\t\t\tQ.push (mp (now.x, now.y - Rest[i + 1]));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tRest[i + 1] -= now.y;\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= K; ++i) printf(\"%lld\\n\", Ans[read<int>()]);\n}\n\ninline void Input ()\n{\n\tN = read<int>(), M = read<int>(), K = read<int>();\n\tfor (int i = 1; i <= N; ++i)\n\t{\n\t\tint p = read<int>(), a = read<int>(), v = read<int>(), x = read<int>();\n\t\tif (x)\n\t\t{\n\t\t\tint t = (v - 1 + x) / x;\n\t\t\tA.pb ((item){p, (t - 1) * x, t - 1, min (M, x)});\n\t\t\tA.pb ((item){p + a, 1, t, 1});\n\t\t\tA.pb ((item){p, (v - 1) % x, t, (v - 1) % x});\n\t\t}\n\t\telse\n\t\t{\n\t\t\tA.pb ((item){p, v - 1, Max, M});\n\t\t\tA.pb ((item){p + a, 1, Max, 1});\n\t\t}\n\t}\n}\n\nint main()\n{\n\n#ifndef ONLINE_JUDGE\n\tfreopen(\"A.in\", \"r\", stdin);\n\tfreopen(\"A.out\", \"w\", stdout);\n#endif\n\n\tInput ();\n\tSolve ();\n\n\treturn 0;\n}\n\n```\n\n","categories":["Problem"],"tags":["并查集","贪心"]},{"title":"「NOI2019」回家路线 - 斜率优化","url":"/2019/08/12/%E3%80%8CNOI2019%E3%80%8D%E5%9B%9E%E5%AE%B6%E8%B7%AF%E7%BA%BF-%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/","content":"\n有一张 $n$ 个点 $m$ 条边的有向图，边有两个权值 $p_i$ 和 $q_i$ $p_i < q_i$，表示若 $p_i$ 时刻在这条边的起点，则 $q_i$ 时刻能到达这条边的终点。\n\n你需要规划一条路线，使得从起点 $1$ 号点出发，沿着这条路线到达终点 $n$ 号点。\n\n假设路线依次经过的边为 ${a_1,a_2,...,a_k}$，则需要保证 $q_{a_{i−1}}\\le p_{a_i}$\n而这条路线的代价是 $\\displaystyle q_{a_k}+\\sum_{i=2}^{k}f(p_{a_i}-q_{a_{i-1}})+f(p_{a_1})$，其中$f(x)= Ax^2 + Bx + C$\n\n你需要使得你规划的路径的代价最小，输出这个最小代价。\n\n$n\\le 10^5, m\\le10^5$\n\n<!--more-->\n\n### Link\n\n[LOJ3156](https://loj.ac/problem/3156)\n\n### Solution\n\n设$f[i]$表示经过第$i$条边后的最小代价，那么\n$$\n\\begin{aligned}\nf[i]&=\\min_{y_j=x_i,q_j\\le p_i}\\{f[j]+A(p_i-q_j)^2+B(p_i-q_j)+C\\}\\\\\n&=\\min_{y_j=x_i,q_j\\le p_i}\\{f[j]+Aq_j^2-Bq_j-2Ap_iq_j\\}+Ap_i^2+Bp_i+C\n\\end{aligned}\n$$\n\n显然可以在每个点内部进行斜率优化，[方法见此](https://hk-cnyali.com/2019/01/17/斜率优化学习笔记/)\n\n设$j < k$，若$j$比$k$优，那么有\n$$\n\\begin{aligned}\n&f[j] + A(p_i - q_j)^2 + B(p_i - q_j) < dp[k] + A(p_i - q_k)^2 + B(p_i - q_k)\\\\\\\\\n\n\\Rightarrow &\\frac{(f[j] + Aq_j^2 - Bq_j) - (f[k] + Aq_k^2-Bq_k)}{q_j - q_k}>2Ap_i\n\\end{aligned}\n$$\n因为推出来是$<$，所以要把条件改成$k$比$j$优，即\n$$\n\\frac{(f[j] + Aq_j^2 - Bq_j) - (f[k] + Aq_k^2-Bq_k)}{q_j - q_k}<2Ap_i\n$$\n根据套路，把$p$和$q$一起排个序，单调队列维护下凸壳即可\n\n需要注意，在判断弹元素的时候，需要把分母乘过去，注意不等式符号的变化\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n#define DEBUG(x) cout << #x << \" = \" << x << endl;\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int Maxn = 1e5 + 100, Maxm = 2e5 + 100;\nconst int inf = 0x3f3f3f3f;\n\nint N, M, A, B, C;\nstruct edge\n{\n\tint x, y, p, q;\n} E[Maxm];\nvector <pii> Id;\n\ninline int cmp (pii a, pii b) { return (a.y ? E[a.x].q : E[a.x].p) < (b.y ? E[b.x].q : E[b.x].p); }\n\ninline int sqr (int x) { return x * x; }\n\nstruct Convex\n{\n\tstruct point { int up, down; };\n\n\tdeque <point> Q;\n\n\tinline void push (int up, int down)\n\t{\n\t\tif (Q.size() >= 2)\n\t\t{\n\t\t\tpoint now = *Q.rbegin(), pre = *(Q.rbegin() + 1);\n\t\t\t// 注意这里pre也是+1，而不是-1\n\t\t\twhile (Q.size() >= 2 && (LL) (pre.up - now.up) * (now.down - down) >= (LL) (now.up - up) * (pre.down - now.down))\n\t\t\t{\n\t\t\t\tQ.pop_back ();\n\t\t\t\tif (Q.size() >= 2) now = *Q.rbegin(), pre = *(Q.rbegin() + 1);\n\t\t\t}\n\t\t}\n\t\tQ.push_back ((point){up, down});\n\t}\n\n\tinline int get_dp (int t)\n\t{\n\t\tif (Q.empty()) return inf;\n\t\tif (Q.size() >= 2)\n\t\t{\n\t\t\tpoint now = *Q.begin(), nxt = *(Q.begin() + 1);\n\t\t\twhile (Q.size() >= 2 && nxt.up - now.up <= 2 * A * t * (nxt.down - now.down)) /**/\n\t\t\t{\n\t\t\t\tQ.pop_front ();\n\t\t\t\tif (Q.size() >= 2) now = *Q.begin(), nxt = *(Q.begin() + 1);\n\t\t\t}\n\t\t}\n\t\treturn Q.front().up + A * t * t - 2 * A * t * Q.front().down + B * t + C;\n\t}\n\n} P[Maxn];\n\nint Dp[Maxm];\n\ninline void Solve ()\n{\n\tsort (Id.begin(), Id.end(), cmp);\n\tfor (int i = 1; i <= M; ++i) Dp[i] = inf;\n\tP[1].push (0, 0);\n\n\tint ans = inf;\n\tfor (int i = 0; i < Id.size(); ++i)\n\t{\n\t\tint x = Id[i].x, op = Id[i].y, t = op ? E[x].q : E[x].p;\n\t\tif (!op) Dp[x] = P[E[x].x].get_dp (t);\n\t\telse\n\t\t{\n\t\t\tif (Dp[x] >= inf) continue;\n\t\t\tif (E[x].y == N) Chkmin (ans, Dp[x] + E[x].q);\n\t\t\telse P[E[x].y].push (Dp[x] + A * sqr (t) - B * t, t);\n\t\t}\n\t}\n\n\tcout << ans << endl;\n}\n\ninline void Input ()\n{\n\tN = read<int>(), M = read<int>(), A = read<int>(), B = read<int>(), C = read<int>();\n\tfor (int i = 1; i <= M; ++i)\n\t{\n\t\tint x = read<int>(), y = read<int>(), p = read<int>(), q = read<int>();\n\t\tE[i] = (edge){x, y, p, q};\n\t\tId.pb (mp (i, 0)), Id.pb (mp (i, 1));\n\t}\n}\n\nint main()\n{\n\n\tfreopen(\"route.in\", \"r\", stdin);\n\tfreopen(\"route.out\", \"w\", stdout);\n\n\tInput ();\n\tSolve ();\n\n\treturn 0;\n}\n\n```\n\n","categories":["Problem"],"tags":["动态规划","斜率优化"]},{"title":"某网站上的题","url":"/2019/08/10/%E6%9F%90%E7%BD%91%E7%AB%99%E4%B8%8A%E7%9A%84%E9%A2%98/","content":"","categories":["Problem"],"tags":["动态规划","二分答案","数据结构","线段树合并","并查集","三分","计数","概率和期望","高斯消元","最小生成树","二分图","树套树","线段树分治"]},{"title":"「CF438E」The Child and Binary Tree - 生成函数","url":"/2019/08/09/%E3%80%8CCF438E%E3%80%8DThe-Child-and-Binary-Tree-%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/","content":"\n一个含有 $n$ 个互异正整数的序列 $c$\n\n若一棵带点权的有根二叉树满足其所有顶点的权值都在集合 $c[1],c[2],...,c[n]$ 中, 就是好的二叉树，一棵带点权的树的权值,是其所有顶点权值的总和。\n\n给出一个整数 $m$,对于任意的 $s(1<=s<=m) $计算出权值为 $s$ 的好二叉树的个数。\n\n两个二叉树不同当他们点数不同或者结构不同，答案对 $998244353$ 取模\n\n$1 \\le n \\le 10^5 , 1 \\le m \\le 10^5 , C_i \\le 10^5$\n\n<!--more-->\n\n### Solution\n\n![19-8-9-1](/images/19-8-9-1.png)\n\n模板题，第一次写多项式求逆和开根\n\n* 求逆：$B(x) = 2B'(x) - A(x)B'(x)^2$\n* 开根：$B(x) = \\frac{A(x) + B'(x)^2}{2B'(x)}$，推导时构造完全平方数\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n#define DEBUG(x) cout << #x << \" = \" << x << endl;\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int Maxn = 1e6 + 100;\nconst int Mod = 998244353;\nconst int g = 3;\n\nint N, M;\nint C[Maxn];\n\ninline void Add (int &a, int b) { if ((a += b) >= Mod) a -= Mod; }\n\ninline int Pow (int a, int b)\n{\n\tint ans = 1;\n\tfor (int i = b; i; i >>= 1, a = (LL) a * a % Mod) if (i & 1) ans = (LL) ans * a % Mod;\n\treturn ans;\n}\n\nnamespace Poly\n{\n\tint n, rev[Maxn]; \n\tint _W[2][Maxn];\n\n\tinline void init (int maxn = 1e6)\n\t{\n\t\tfor (int mid = 1; mid <= maxn; mid <<= 1)\n\t\t{\n\t\t\t_W[0][mid] = Pow (g, (Mod - 1) / (mid << 1));\n\t\t\t_W[1][mid] = Pow (_W[0][mid], Mod - 2);\n\t\t}\n\t}\n\n\tinline void dft (int *A, int fl)\n\t{\n\t\tfor (int i = 0; i < n; ++i) if (rev[i] < i) swap (A[i], A[rev[i]]);\n\t\tfor (int mid = 1; mid < n; mid <<= 1)\n\t\t{\n\t\t\tint W = _W[0][mid];\n\t\t\tif (fl == -1) W = _W[1][mid];\n\t\t\tfor (int i = 0; i < n; i += (mid << 1))\n\t\t\t{\n\t\t\t\tint Wn = 1;\n\t\t\t\tfor (int j = i; j < i + mid; ++j, Wn = (LL) Wn * W % Mod)\n\t\t\t\t{\n\t\t\t\t\tint x = A[j], y = (LL) Wn * A[j + mid] % Mod;\n\t\t\t\t\tA[j] = (x + y) % Mod;\n\t\t\t\t\tA[j + mid] = (x - y + Mod) % Mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (fl == -1) {int inv = Pow (n, Mod - 2); for (int i = 0; i < n; ++i) A[i] = (LL) A[i] * inv % Mod; }\n\t}\n \n\tinline void mul (int *A, int N, int *B, int M, int *C)\n\t{\n\t\tstatic int F[Maxn], G[Maxn];\n\t\tn = 1; while (n <= N + M) n <<= 1;\n\t\tfor (int i = 0; i < n; ++i) rev[i] = (rev[i >> 1] >> 1) + ((i & 1) ? (n >> 1) : 0);\n\t\tfor (int i = 0; i < n; ++i) F[i] = (i <= N) ? A[i] : 0;\n\t\tfor (int i = 0; i < n; ++i) G[i] = (i <= M) ? B[i] : 0;\n\n\t\tdft (F, 1), dft (G, 1);\n\t\tfor (int i = 0; i < n; ++i) F[i] = (LL) F[i] * G[i] % Mod;\n\t\tdft (F, -1);\n\t\tfor (int i = 0; i < n; ++i) C[i] = (i <= N + M) ? C[i] : 0;\n\t}\n\n\tinline void get_inv (int *A, int *B, int N)\n\t{\n\t\tif (N == 1) { B[0] = Pow (A[0], Mod - 2); return ; }\n\t\tint len = (N + 1) >> 1;\n\t\tget_inv (A, B, len);\n\n\t\tstatic int F[Maxn], G[Maxn];\n\t\tn = 1; while (n <= 2 * N) n <<= 1;\n\t\tfor (int i = 0; i < n; ++i) rev[i] = (rev[i >> 1] >> 1) + ((i & 1) ? (n >> 1) : 0);\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tF[i] = (i < N) ? A[i] : 0;\n\t\t\tG[i] = (i < len) ? B[i] : 0;\n\t\t}\n\n\t\tdft (F, 1), dft (G, 1);\n\t\tfor (int i = 0; i < n; ++i) F[i] = (2ll * G[i] % Mod - (LL) F[i] * G[i] % Mod * G[i] % Mod + Mod) % Mod;\n\t\tdft (F, -1);\n\n\t\tfor (int i = 0; i < n; ++i) B[i] = (i < N) ? F[i] : 0;\n\t}\n\n\tinline void get_sqrt (int *A, int *B, int N)\n\t{\n\t\tif (N == 1) { B[0] = 1; return ; }\n\t\tint len = (N + 1) >> 1;\n\t\tget_sqrt (A, B, len);\n\n\t\tn = 1; while (n <= 2 * N) n <<= 1;\n\t\tfor (int i = 0; i < n; ++i) rev[i] = (rev[i >> 1] >> 1) + ((i & 1) ? (n >> 1) : 0);\n\n\t\tstatic int F[Maxn], G[Maxn], S[Maxn], H[Maxn];\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tF[i] = (i < N) ? A[i] : 0;\n\t\t\tG[i] = (i < len) ? B[i] : 0;\n\t\t\tS[i] = (i < len) ? 2ll * B[i] % Mod\t: 0;\n\t\t\tH[i] = 0;\n\t\t}\n\n\t\tdft (F, 1), dft (G, 1); \n\t\tget_inv (S, H, N), dft (H, 1);\n\t\tfor (int i = 0; i < n; ++i) F[i] = (LL) (F[i] + (LL) G[i] * G[i] % Mod) % Mod * H[i] % Mod;\n\t\tdft (F, -1);\n\n\t\tfor (int i = 0; i < n; ++i) B[i] = (i < N) ? F[i] : 0;\n\t}\n}\n\nint A[Maxn], B[Maxn];\n\ninline void Solve ()\n{\n\tC[0] = 1;\n\tfor (int i = 1; i <= M; ++i) C[i] = (- 4ll * C[i] % Mod + Mod) % Mod;\n\n\tPoly :: init ();\n\tPoly :: get_sqrt (C, B, M + 1);\n\t(++B[0]) %= Mod;\n\tPoly :: get_inv (B, A, M + 1);\n\tfor (int i = 0; i <= M; ++i) A[i] = 2ll * A[i] % Mod;\n\tfor (int i = 1; i <= M; ++i) printf(\"%d\\n\", A[i]);\n}\n\ninline void Input ()\n{\n\tN = read<int>(), M = read<int>();\n\tfor (int i = 1; i <= N; ++i) C[read<int>()] = 1;\n}\n\nint main()\n{\n\n#ifndef ONLINE_JUDGE\n\tfreopen(\"E.in\", \"r\", stdin);\n\tfreopen(\"E.out\", \"w\", stdout);\n#endif\n\n\tInput ();\n\tSolve ();\n\n\treturn 0;\n}\n\n//一定注意：所有的F和G都要开static !!!!!!\n```\n\n","categories":["Problem"],"tags":["Codeforces","生成函数","多项式"]},{"title":"「笔记」一些组合题","url":"/2019/08/05/%E3%80%8C%E7%AC%94%E8%AE%B0%E3%80%8D%E4%B8%80%E4%BA%9B%E7%BB%84%E5%90%88%E9%A2%98/","content":"\n来自qrsikno的课件\n\n<!--more-->\n\n## AGC002F Leftmost Ball\n\n### Description\n\n给定 $n$ 种颜色, 每种颜色有 $k$ 个球.\n\n现在把他们排列成一行, 再把每种颜色第一个染成 0 号颜色 (之前未出现).\n\n求经过操作之后能有多少种不同的序列.\n\n两个序列不同被认为是长度不同或某个位置颜色不同.\n\n$n \\le 2000, k \\le 2000$\n\n### Solution\n\n[动态规划] [计数] [组合数学]\n\n因为颜色等价，可以忽略颜色的排列顺序，最后乘上$k!$\n\n$0$和其他颜色放一起填，需要保证任意前缀都有$num_0 \\ge num_{color}$\n\n$dp[i][j]$表示当前填了$i$个$0$，$j$种颜色的方案数，每次把一种颜色全部加进来\n$$\ndp[i][j] = dp[i - 1][j] + dp[i][j - 1]\\times \\binom{nk - i - (j - 1)(k - 1) - 1}{k - 2}\n$$\n$dp[i - 1][j]$的系数为$1$是因为必须钦定$0$放在当前第一个空位，否则会算重\n\n组合数上面最后一项$-1$同理，钦定第一个数填在第一个空位上\n\n下面$-2$是要减去$0$和当前颜色的第一个数\n\n## Luogu P1758 管道取珠\n\n### Solution\n\n[计数]\n\n$\\sum a_i ^ 2$可以看成两个完全一样的游戏同时进行，它们得到了相同的串的方案数\n\n设$dp[i][j][k][l]$表示第一个游戏进行到$(i, j)$，第二个进行到$(k, l)$的方案数\n\n显然$l = i + j - k$，复杂度$O(n^3)$\n\n\n\n## CF1111D Destory the Colony\n\n### Description\n\n给定一个偶数长度 $n(n \\le 10^5 )$ 的字符串, 只包含大小写字母.\n\n有 $q(q \\le 10^5 )$ 次询问, 每次指定两个位置, 要求通过交换字符, 使这两个位置上的类型的字符在字符串中线同一边(要么全在左半边，要么全在右半边).\n\n并且对于其他类型的字符, 不能跨过串的中线 (也就是说必须在一边, 但是可以不跟指定的字符一边).\n\n询问之间独立, 求方案数模 $10^9 + 7$ 的值\n\n### Solution\n\n[动态规划] [退背包]\n\n先不考虑指定的两个位置的限制\n\n枚举$S$表示放在左半边的字符的集合\n\n根据可重排列计数，$S$的答案就是：\n$$\n\\frac{(\\frac{n}{2}!)^2}{\\prod_{i\\in {S}}cnt_i * \\prod_{i\\notin {S}}cnt_i} = \\frac{(\\frac{n}{2}!)^2}{\\prod_i cnt_i}\n$$\n发现与$S$具体是什么无关\n\n因为有$|S| = \\frac{n}{2}$，所以需要做一次背包求出方案数，再乘上面那个东西就是答案\n\n---\n\n然后考虑指定了位置$(i, j)$怎么做\n\n> 可能的$(i, j)$很少，可以把答案都预处理\n\n显然，只需要把$i$和$j$在背包中挖掉即可\n\n```cpp\nfor (int k = Cnt[i]; k <= N / 2; ++k)\n    Add (f[k], Mod - f[k - Cnt[i]]); \n```\n\n并且答案要乘$2$，因为$i$和$j$可以同时在左半边或者右半边\n\n\n\n## CF785D Anton and School 2\n\n### Description\n\n[范德蒙德卷积]\n\n![19-8-6-1](/images/19-8-6-1.png)\n\n### Solution\n\n![19-8-6-2](/images/19-8-6-2.png)a\n\n","categories":["Note"],"tags":["动态规划","计数","组合数学","范德蒙德卷积","退背包"]},{"title":"2019年8月","url":"/2019/08/03/2019%E5%B9%B48%E6%9C%88/","content":"\n搞颓记录\n\n<!--more-->\n\n## 8-1\n\n考了自己的题，结果T1锅了\n\nT1 CF原题数据太水，导致我的假做法也能过\n\n不过问题不太大，修改了一下就过了\n\n\n\n## 8-2\n\n### Process\n\nT1搞了一个小时，后面在想T2的20分怎么做，以及T3的正解做法，均无果\n\n### Score\n\n`100 + 10 + 30 = 140`\n\n### T1\n\n[数据结构] [线段树]\n\n每个点维护一个二进制标记，如果第$i$位为$1$，则表示它子树内深度为$i$的点需要翻转左右儿子\n\n修改的时候，因为至多只有首尾两层是不满的段，其他中间的段都是满的，因此中间的每次都是$O(1)$的，于是总复杂度是$O(n\\log n)$的\n\n修改不满的段的时候的做法比较巧妙，但也不难想，以后如果忘了看看代码就懂了。。。\n\n\n\n### T2\n\n还没改，不知道会不会改\n\n\n\n### T3\n\n[动态规划]\n\n一个经典套路：忽略题意中的走的顺序，从左往右依次加点进行dp\n\n那么原序列就会被分成若干个联通块(实际上是若干条链，这里暂且称作联通块)，设$dp[i][j]$为考虑到第$i$个点，有$j$个联通块的方案数，具体转移见代码\n\n<details>\n<summary>Code</summary>\n\n```cpp\n\ninline int left (int x) { if (A[x] != 'R') return 1; return 0; }\ninline int right (int x) { if (A[x] != 'L') return 1; return 0; }\n\n// 这里的联通块是指一条链(方向不定，反正展开就是一条链)\n// 需要保证每个联通块的末尾为R(因为前面的已经考虑过了，如果还剩了L就连不起来了)\n// 普通联通块： 除了S所在联通块和T所在联通块，其他的联通块\n\n// 每种点的作用：\n// 能往左走： 连接前面两个联通块的桥梁; 作为某个联通块的开头\n// 能往右走： 单独作为一个联通块; 作为某个联通块的结尾\n\ninline void Solve ()\n{\n\tmemset(Dp, 0, sizeof Dp);\n\tif (A[N] == 'R' && T != N) { puts(\"0\"); return ; }\n\tDp[N][0] = 1;\n\tfor (int x = N - 1; x >= 1; --x)\n\t{\n\t\tfor (int k = 0; k <= N; ++k)\n\t\t{\n\t\t\tint &ans = Dp[x][k];\n\t\t\tif (x == S)\n\t\t\t{\n\t\t\t\tif (k && left (x)) Add (ans, (LL) k * Dp[x + 1][k - 1] % Mod);\n\t\t\t\tif (right (x)) Add (ans, Dp[x + 1][k]);\n\t\t\t}\n\t\t\telse if (x == T)\n\t\t\t{\n\t\t\t\tif (k) Add (ans, (LL) k * Dp[x + 1][k - 1] % Mod);\n\t\t\t\tAdd (ans, Dp[x + 1][k]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (left (x))\n\t\t\t\t{\n\t\t\t\t\tif (k >= 2) Add (ans, (LL) k * (k - 1) % Mod * Dp[x + 1][k - 1] % Mod); // 连接两个普通联通块\n\t\t\t\t\tif (k && x > S) Add (ans, (LL) k * Dp[x + 1][k - 1] % Mod); // 连接普通联通块和首联通块\n\t\t\t\t\tif (x > T)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (k) Add (ans, (LL) k * Dp[x + 1][k - 1] % Mod); // 连接普通联通块和尾联通块\n\t\t\t\t\t\tAdd (ans, Dp[x + 1][k]); // 放在尾联通块的开头\n\t\t\t\t\t}\n\n\t\t\t\t\tAdd (ans, (LL) k * Dp[x + 1][k] % Mod); // 放在普通联通块的开头\n\t\t\t\t}\n\t\t\t\tif (right (x))\n\t\t\t\t{\n\t\t\t\t\tAdd (ans, Dp[x + 1][k + 1]); // 单独作为一个联通块\n\t\t\t\t\tif (x > S) Add (ans, Dp[x + 1][k]); // 放在首联通块的末尾\n\t\t\t\t\tAdd (ans, (LL) k * Dp[x + 1][k] % Mod); // 放在普通联通块的末尾\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprintf(\"%d\\n\", Dp[1][0]);\n}\n```\n</details>\n\n## 8-3\n\n上午听zjm讲组合，生成函数，多项式；下午听zqc讲容斥反演\n\n似乎迷迷糊糊听懂了一点，可是理解还是不够\n\n\n\n## 8-4\n\n### Process\n\ncxr的题，T1傻逼题居然没想到，自闭了自闭了\n\n就写了T1 T3两个暴力，根本没开T2，后来改题的时候看T2发现好像也不太难\n\n`60 + 0 + 60 = 120`\n\n### T1\n\n真的是sb题\n\n考虑把答案设为根，此时会有一些限制不满足，又因为一定在根的子树中，那么设$d_i$表示第$i$个限制至少需要深度$d_i$才满足限制，找到最大的$d_i$，以及其对应的点$x$，判断$x$是否合法即可\n\n### T2\n\n[强连通分量] [缩点] [组合数学] [范德蒙德卷积]\n\n题解很清楚\n\n第二部分中，我们假设所有在$A$集合中的数都取到了最大值，显然它们还在$A$集合中，但相对位置可能会变化，不过对统计方案数并没有影响。\n\n第二部分中$x$实际上还与$A$有关，即$cnt1 + x + 1 \\le A$，因此不能直接把$\\sum_{x}\\binom{cnt2}{x}\\binom{cnt1}{B-1-x}$利用范德蒙德卷积变成$\\binom{cnt1 + cnt2}{B-1}$\n\n### T3\n\n没改\n\n\n\n## 8-5\n\n### Process\n\nT3模板题， T1花了点时间推式子，T2傻逼dp居然都没想到（最后时间不太够，有点急）\n\n`100 + 30 + 100 = 230`\n\n### T1\n\n[数学]\n\n设$a, b, c, d$分别为$(0, 0), (0, 1), (1, 0), (1, 1)$的数量\n\n设$a_1, b_1, c_1, d_1$分别为这些状态在答案的左边的数量，$a_2, b_2, c_2, d_2$为右边\n\n可以列出一些方程，手解一下就行\n\n最后化出来一步$b_1 + c_1 = t$，那么取$b_1 = \\min\\{b, t\\}$，看$c_1$是否合法即可\n\n### T2\n\n[动态规划] [数据结构] [线段树] [单调栈]\n\n设$dp[i]$表示取到第$i$个物品的答案，把与第几个箱子有关那个部分的贡献拆到后面去，即有转移：\n$$\ndp[i] = \\min_{j}\\{dp[j] + \\max_{k=j + 1}^{i}\\} + \\sum_{j=i + 1}^{n}w_j\n$$\n单调栈 + 线段树维护一下$\\max$部分即可\n\n类似于[19-6-22 T1](https://hk-cnyali.com/2019/06/03/2019年6月/)\n\n### T3\n\n[图论] [网络流] [欧拉回路]\n\n混合图欧拉回路模板题\n\n![19-8-5-1](/images/19-8-5-1.png)\n\n---\n\n今天晚上想搞一点zjm课件的题\n\n\n\n## 8-6\n\n讲课，拖堂了1个小时\n\n讲得有点累，幸好把话筒修好了，不然可能会当场去世\n\n晚上把zjm的组合题搞完了\n\n\n\n## 8-7\n\n### Process\n\n今天整个不在状态。一个sbT2还想了一两个小时。\n\nT1想了个乱搞，没搞出来。T3没怎么仔细想，结果爆零了\n\n最后T2还因为没卡常爆成40\n\n`10 + 40 +0 = 50 `\n\n### T1\n\n[动态规划] [搜索]\n\n枚举每个点作为起点搜索 , 设 $dp[i][j][k]$ 为到 $(i,j)$ 吃到豆子的状态为 $k$ 的最大得分 .\n\n> 如何记录是否吃到了某个豆子呢 ? \n>\n> 当蛇在豆子的右边穿过奇数次时就能包围住 , 穿过偶数次就没有包围住. \n\n预处理一下经过某个点后，豆子`是否被选中`这个状态如何改变即可\n\n### T2\\\n\n[二分答案]\n\n二分答案，差分check\n\n这里必须要加一个优化：不要每次都从1到mid去算答案，而是类似于一个指针在上面移动，维护上次check到这次check中间的变化量\n\n### T3\n\n[动态规划] [组合数学] [容斥]\n\n不难发现，每行填的数都是**一个排列去掉一个数**\n\n枚举这个断点即可得到$O(n^3)$的暴力，稍微优化一下就变成$O(n^2)$\n\n设$dp[i][j]$表示第$i$行，断点在$j$的答案，则：\n$$\ndp[i][j] = dp[i - 1][j + 1] + dp[i][j - 1]\n$$\n结合[这里](https://www.cnblogs.com/xzyxzy/p/9812585.html)的图可以发现，答案就是从原点出发，只能向右或向上走，不接触直线A,B，到达点$(n+m+1,n)$的路径条数\n\n考虑容斥，先算从原点到$(n + m + 1, n)$的总方案数，减去碰到$A, B$的方案数\n\n考虑将终点$p$关于$A$对称得到$p'$，发现从原点到$p'$的方案数就是`碰到A至少一次`的方案数\n\n同理，关于$B$对称后的答案是`碰到B至少一次`的方案数\n\n显然这样又会算重，算重的情况是`先碰到A，然后碰到B`，或者`先碰到B，然后碰到A`\n\n也就是碰到边界的序列中存在`AB`或`BA`子序列的方案\n\n于是又可以继续对称，把终点先关于$B$对称，再关于$A$对称，即算出了存在子序列`AB`的方案\n\n以此类推\n\n不难发现容斥系数为$(-1)^{cnt}$，$cnt$表示对称的次数\n\n---\n\n模拟求解即可，对称到不在第一象限时就停止。最多对称$\\log$次\n\n>  19.10.6 UPD\n>\n> 之前可能还是没太搞清楚\n>\n> 显然，总方案去掉经过$A$**或**$B$的方案就是答案\n>\n> 如何保证一种经过$A$？\n>\n> 把终点$p$关于$A$对称得到$p'$，起点到$p'$的方案数就是**至少经过一次**$A$的方案数。B同理\n>\n> 但这样算是错的，因为子序列$AB$会被$A$减一次，被$B$减一次，减了两次；$BA$同理\n>\n> 所以要加上经过子序列$AB、BA$的情况（终点依次关于$A、B$对称\n>\n> 但子序列$ABA$就没算了（被$A、B$减一次，被$AB、BA$加一次），必须要再减一次；$BAB$同理\n>\n> 注意，此时$ABB$并不会多算（被$A、B$减一次，被$AB$加一次，刚好是$-1$）\n>\n> 以此类推\n\n## 8-8\n\n### Process\n\nT1花了半个小时，然后一直在搞T2。T2完全没有想到分治，一直在往扫描线的方向去想，始终无果\n\n### T1\n\n见[GC's Blog](https://gongchen618.gitee.io/blog/2019/07/17/贪心选做/#51nod-1563-坐标轴上的最大团)\n\n### T2\n\n[分治]\n\n统计序列中点对的问题要往分治上想！！！\n\n考虑跨区间的贡献！！！\n\n想到分治后不难\n\n题解写得还可以\n\n### T3\n\n[动态规划]\n\n最后需要找到一个$t$，使得$\\sum_{i=1}^{n}\\_\\_builtin\\_popcount(t + mx - a[i])$最小\n\n可以考虑$t$在每一位上的取值(0/1)，然后dp\n\n暴力dp需要知道当前位往下一位有哪些数进了位\n\n但是不难发现，若一个数前$i-1$位对应的数越大，它在第$i$位越容易进位\n\n那么根据这个性质每次将数排序后，进位的数就是一段前缀了\n\n具体细节可见Sol/Code\n\n## 8-9\n\n上午xz讲数据结构，下午jwb讲线段树\n\n今天有点晕，不想接受新的东西。。。就水过去了\n\n有时间搞下jwb的课件\n\n## 8-10\n\n### Process\n\n开场想了下T1，无果。然后发现T2很sb，写完之后去看T3，发现一个很直观很暴力的线段树合并做法。\n\nT3调到考试结束前半个小时，最后慌慌张张写T1暴力，结果部分分写挂了\n\n最后T2也挂了20分。。。\n\n`35 + 80 + 100 = 215`\n\n### T1\n\n[图论] [边双]\n\n转化为求多少点对之间存在至少$d$条不相交路径\n\n* 若联通：至少1条\n* 若在同一个边双中：至少2条\n* 若把图中任意一条边删除后，它们仍在同一边双中：3条\n\n第三种情况枚举删哪条边即可\n\n### T2\n\n转化为求$x\\times 10^{yl} + y \\equiv 0\\pmod{k}$的$(x, y)$对数，其中$yl$表示$y$的位数\n\n枚举$x$，再枚举$yl$，用个$map$随便数下有多少个$y$即可\n\n### T3\n\n[数据结构] [线段树] [线段树合并]\n\n我的暴力线段树合并做法：\n\n对于一个询问$x, k$来说，它要找$x$子树内，边权前缀$\\max\\le k$的点的个数（这里的前缀意思是它到$x$的这一段路径）\n\n维护一个权值线段树，下标是边权离散化之后的值，权值是每个边权对应的答案和\n\n显然子树的限制可以通过线段树合并来解决\n\n而对于一条权值为$d$的边来说，它子树内所有$\\le d$的边都要变成$d$（因为是前缀$\\max$）\n\n直接在线段树上区间查，区间置$0$（把点直接删掉）即可\n\n---\n\n晚上搞了TJOI2015旅游和xsy1599A\n\n## 8-11\n\n### Process\n\n倒序做题，T1写了个斜率优化（差不多又快忘光了。。。）\n\n`50 + 100 + 100 = 250`\n\n### T1\n\n[动态规划] [斜率优化]\n\n有一个性质没挖掘出来：\n\n* 若钦定某个点在最优策略里被选，那么策略与它的值没有关系\n\n剩下的看sol吧\n\n用分治优化dp，同时用上斜率优化\n\n### T2\n\n[贪心] [最小生成树]\n\n贪心最小生成树\n\n每个点只往它当前这一列的相邻点，以及另一列离它最近的两个点连边即可\n\n### T3\n\n随便dp一下，处理出每个点到根的最短路\n\n---\n\n晚上把AGC028D搞完了，然后发现斜率优化学得狗屎样的，重新学了下\n\n## 8-12\n\n上午的贪心好神啊。。。\n\n下午图论听了一部分\n\n今天的课件都要找时间搞了\n\n晚上搞了NOI2019D1T1和「LNOI2014」LCA\n\n## 8-13\n\n### Process\n\n前两题搞完的时候是10:40，太慢了。。。T2写了半天\n\nT3写了个暴力，搞链的分但是做法有点问题\n\n### T1\n\n题解很清楚\n\n我直接找的规律，规律很好找\n\n### T2\n\n[数据结构]\n\n我的做法和$k$有关，对每个点直接枚举其对应的$k$的具体的值，剩下的条件随便维护下即可\n\n也可以CDQ分治，做到与$k$无关\n\n### T3\n\n[动态规划] [组合数学]\n\n在$a$到$b$的链上dp，设$dp[i][j]$表示考虑到链上第$i$个点，它在操作序列中位于第$j$个位置\n\n每次把点往前面的方案里插即可\n\n对组合数的理解的应用还要再深一点\n\n\n\n## 8-14\n\n### Process\n\n想了一上午T1，不会做，期间想了一个假做法，以及推了下T2的式子，太麻烦就弃了\n\n于是爆零了\n\n`0 + 0 + 0 = 0`\n\n### T1\n\n离散化之后就可以考虑**每个单位格子**对答案的贡献！！！\n\n怎么这么sb都想不到\n\n我想的做法是$n^2$枚举两个点，以它们形成的矩形去算贡献，但是会有细节问题\n\n考虑单位格子的话就不存在各种奇奇怪怪的问题了！！！\n\n### T2\n\n[概率和期望] [线段树]\n\n> 做法来自xcy\n\n考虑$[L, R]$中的每个点对答案的贡献，发现是$w_i * E(i)$，$E(i)$表示$i$这个点期望要走多少次\n\n设$\\displaystyle a = \\prod_{j=i}^{R}p_j$，那么有\n$$\n\\begin{aligned}\nE(i) &= a + 2 \\times(1-a)\\cdot a + 3\\times (1-a)^2 \\cdot a + ...\\\\\n&=\\sum_{k=0}^{\\infty}(k + 1)(1-a)^ka\\\\\n&=\\frac{1}{a}\n\\end{aligned}\n$$\n于是答案就是$\\displaystyle \\sum_{i=L}^{R}\\frac{w_i}{\\prod_{j=i}^{R}p_j}$\n\n线段树每个结点维护一下$\\displaystyle \\frac{w_i}{\\prod_{j=i}^{R}p_j}$和$\\displaystyle {\\prod_{j=i}^{R}p_j}$即可\n\n最后把$n$开到2的幂次，预处理出修改需要的值即可\n\n### T3\n\n[LCT]\n\n思路：\n\n对每种权值维护一棵树，每个结点有黑白两种颜色，白色表示这个点是当前这种权值，黑色表示不是\n\n那么答案就是所有操作之后，每个黑色联通块的$size^2$的和\n\n用`LCT`维护即可\n\n计算答案的时候先初始化一个全是黑点的树，离线处理每个颜色，处理完一个颜色反着改回去\n\n> 类似于CDQ分治时清空BIT的方法\n\n具体实现见[此](https://www.luogu.org/problemnew/solution/CF1172E)，或出题人sol\n\n\n\n## 8-15\n\n神仙讲课\n\n晚上搞了两道gc的课件\n\n\n\n## 8-16\n\n### Process\n\n刚了一上午的T2\n\n`60 + 100 + 20 = 180`\n\n### T1\n\n[动态规划] [计数]\n\n求整数分拆的方案数\n\n先考虑两种dp\n\n$f[i][j]$ : 大小为$i$的数，用不超过$j$的数拆分的方案数\n\n> 转移考虑是否加上一个权值为$j$的数\n\n$g[i][j]$ : 大小为$i$的数，用$j$个数拆分的方案数\n\n> 转移考虑把当前所有数$+1$，或者新加一个值为$1$的数\n\n注意到，$f$的第二维只与权值大小有关，$g$的第二维只与个数有关\n\n又因为权值大于$\\sqrt n$的数不会超过$\\sqrt n$个，于是可以考虑把$f$和$g$的第二维都只枚举到$\\sqrt n$\n\n这里要把$g$的定义稍微改一下，要保证这$j$个数都$> \\sqrt n$\n\n令$m = \\sqrt n$，则答案长这样\n$$\nans = \\sum_{i=0}^{n}\\Big(\\sum_{j=0}^{m}g[i][j]\\Big) \\times f[n - i][m]\n$$\n\n\n### T2\n\n> 定义`计算括号序列`为将$($看成$+1$，$)$看成$-1$，求前缀和\n\n我的做法比较暴力\n\n首先考虑把所有$?$先看成$($，计算括号序列的值，设其为$a$数组\n\n若某个合法的括号序列以$i$为左端点，则右端点$j$需要满足，从$i$开始走到$j$的过程中，括号序列的值非负\n\n形式化地说，需要满足$\\displaystyle \\min_{k = i}^{j}a_j - a_{i - 1} \\ge 0$\n\n显然，这个式子具有单调性，即合法的右端点一定在区间$[i, R_i]$中，可以二分求出$R_i$\n\n---\n\n同理，把$?$看成$)$，计算后缀括号序列后，也能类似地求出$L_i$，表示以$i$为右端点时，左端点一定在区间$[L_i, i]$中\n\n> 一个小结论：只要满足$[i, R_i]$和$[L_i, i]$这两个限制，就一定能构造出合法地括号序列\n\n考虑枚举右端点$i$，那么就是要找有多少个左端点$j\\in[L_i, i]$，满足$R_j \\ge i$\n\n这个随便用个数据结构维护一下即可\n\n\n\n### T3\n\n[线段树] [树链剖分]\n\n![19-8-16-1](/images/19-8-16-1.png)\n\n\n\n## 8-17\n\ngc的题，我验的题\n\n### T1\n\n[组合数学]\n\n补集转化，然后用插板法算下方案数即可\n\n### T2\n\n[单调栈] [线段树]\n\n先处理出关于$c_i$递减的单调栈\n\n按$v_i$排序，从小到大考虑，在单调栈上二分找到恰好能卖的那个位置\n\n从那个位置开始把一段前缀减掉，用线段树维护即可\n\n### T3\n\n把点权拆到边权上，每次考虑一个点把之前的哪个点作为父亲最优\n\n显然只要考虑它到原树的根的那条链上的点即可，因为其他点都不会更优\n\n---\n\n晚上打了百度之星初赛\n\nT2贪心没搞出来，没进250。。。\n\n\n\n## 8-18\n\n上午csy讲字符串，有一两道题断了\n\n下午xcy讲树，基本还在线\n\n晚上打了百度之星初赛第二场\n\n抄了GC的T4，最后排名77\n\n\n\n## 8-19\n\n### Process\n\n似乎现在在考的是去年纪中的题了\n\nT1还没想清楚细节就开始码，导致浪费了很多时间，最后只能交个$\\log^2$的暴力草草收场\n\nT2考过很多次了，结果遇到的时候还话了不少时间才看出来是那个模型。。。\n\nT3没时间了，暴力没调出来（实际上是看漏了个条件）\n\n### Summary\n\n现在开始的模考一定要认真对待！！！\n\n每道题先写好暴力，想正解/码正解的题一定要掐好时间，不能出现暴力分没写完，甚至是有题爆零的情况！！！\n\n### T1\n\n改了个好多细节的做法\n\n二分某一个数组的下标，那么可以计算出另外一个数组期望的下标\n\n再通过判断两个数组某些位置上的值的大小关系判断往左还是往右走\n\n### T2\n\n$$\ndp[i] = \\max_{j=0}^{i-1}dp[j] + f(\\min _{k=j+1}^{i}a_k)\n$$\n\n和[这天](https://hk-cnyali.com/2019/08/03/2019年8月/#T2-2)一模一样\n\n### T3\n\n[概率和期望] \n\n首先有一个式子：对于一个随机变量$x$，其期望值为$\\displaystyle E(x)= \\sum_{i=1}^{\\infty}P(x\\ge i)$\n\n> 根据期望的线性性把式子拆开，考虑每个比$x$小的$i$对答案的贡献\n\n接下来对每个询问$[l, r]$，考虑每个$x$的贡献：\n\n![19-8-19-1](/images/19-8-19-1.png)\n\n也就是说，我们只需要求出$[l, r]$内每个位置的最小值$\\ge x$的概率$\\big(P(v_i\\ge x)\\big)$\n\n它就是小于$x$的数不选的概率的乘积，减去所有数都不选的概率\n\n---\n\n然后考虑$x$在变化的时候，答案如何变化（假设从$y$变为$x$）\n\n显然，最外面的`1-`可以最后计算，于是可以只考虑$\\displaystyle \\prod_{i=l}^{r}1 - P(v_i\\ge x)$的变化，那么直接除掉$1 - P(v_i\\ge y)$，再乘上$1 - P(v_i\\ge x)$即可\n\n但是这样做当$P(v_i\\ge x) = 1$时会有问题，不过因为$P(v_i \\ge x)$是随$x$的变大而递减的\n\n即若$\\exists x> y, P(v_i\\ge x) = 1$，那么$P(v_i\\ge y) = 1$\n\n所以从大到小枚举$x$就行了\n\n---\n\n最后考虑多组询问如何处理\n\n因为所给区间互不包含，所以每个点被包含的区间也是一个区间\n\n只需要把答案的这段区间直接乘上当前的贡献，线段树维护即可\n\n看代码可能更好理解。。。\n\n<details>\n<summary>Code</summary>\n\n```cpp\n\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n#define DEBUG(x) cout << #x << \" = \" << x << endl;\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int Maxn = 2e5 + 100;\nconst int Mod = 1e9 + 7;\n\nnamespace MATH\n{\n\tinline void Add (int &a, int b) { if ((a += b) >= Mod) a -= Mod; }\n\n\tinline int Pow (int a, int b)\n\t{\n\t\tint ans = 1;\n\t\tfor (int i = b; i; i >>= 1, a = (LL) a * a % Mod) if (i & 1) ans = (LL) ans * a % Mod;\n\t\treturn ans;\n\t}\n}\n\nusing namespace MATH;\n\nint N, M, Q;\nstruct info\n{\n\tint x, y, p;\n} A[Maxn];\npii B[Maxn];\n\nstack <int> stk[Maxn];\nint base[Maxn];\nint L[Maxn], R[Maxn];\n\ninline int cmp (info a, info b) { return a.y < b.y; }\n\ninline int cmp_x (pii a, pii b) { return a.x < b.x; }\n\ninline int cmp_y (pii a, pii b) { return a.y < b.y; }\n\nnamespace SEG\n{\n#define mid ((l + r) >> 1)\n#define ls o << 1\n#define rs o << 1 | 1\n#define lson ls, l, mid\n#define rson rs, mid + 1, r\n\tstruct info\n\t{\n\t\tint sum, tag;\n\t\tinfo () { sum = 0, tag = 1; }\n\t} node[Maxn << 2];\n\n\tinline void push_up (int o) { node[o].sum = (node[ls].sum + node[rs].sum) % Mod; }\n\t\n\tinline void push_down (int o)\n\t{\n\t\tif (node[o].tag == 1) return ;\n\t\tnode[ls].sum = (LL) node[ls].sum * node[o].tag % Mod;\n\t\tnode[rs].sum = (LL) node[rs].sum * node[o].tag % Mod;\n\t\tnode[ls].tag = (LL) node[ls].tag * node[o].tag % Mod;\n\t\tnode[rs].tag = (LL) node[rs].tag * node[o].tag % Mod;\n\t\tnode[o].tag = 1;\n\t}\n\t\n\tinline void build (int o, int l, int r)\n\t{\n\t\tif (l == r) return void (node[o].sum = 1);\n\t\tbuild (lson), build (rson);\n\t\tpush_up (o);\n\t}\n\t\n\tinline void update (int o, int l, int r, int x, int y, int val)\n\t{\n\t\tif (x > y) return ;\n\t\tif (x <= l && r <= y)\n\t\t{\n\t\t\tnode[o].sum = (LL) node[o].sum * val % Mod;\n\t\t\tnode[o].tag = (LL) node[o].tag * val % Mod;\n\t\t\treturn ;\n\t\t}\n\t\tpush_down (o);\n\t\tif (x <= mid) update (lson, x, y, val);\n\t\tif (y > mid) update (rson, x, y, val);\n\t\tpush_up (o);\n\t}\n\t\n\tinline int query () { return node[1].sum; }\n#undef mid\n}\n\ninline void Calc (int x)\n{\n\tint pre = 1 - (stk[x].top() - base[x]) % Mod + Mod;\n\tstk[x].pop();\n\tint now = 1 - (stk[x].top() - base[x]) % Mod + Mod;\n\tSEG :: update (1, 1, Q, L[x], R[x], (LL) now * Pow (pre, Mod - 2) % Mod);\n}\n\ninline void Init ()\n{\n\tsort (A + 1, A + M + 1, cmp);\n\tfor (int i = 1; i <= N; ++i) stk[i].push (1);\n\tfor (int i = 1; i <= M; ++i)\n\t{\n\t\tint res = stk[A[i].x].top();\n\t\tstk[A[i].x].push ((LL) res * (1 - A[i].p + Mod) % Mod);\n\t}\n\tfor (int i = 1; i <= N; ++i) base[i] = stk[i].top();\n\n\tsort (B + 1, B + Q + 1);\n\tfor (int i = 1; i <= N; ++i)\n\t{\n\t\tL[i] = lower_bound (B + 1, B + Q + 1, mp (0, i), cmp_y) - B;\n\t\tR[i] = upper_bound (B + 1, B + Q + 1, mp (i, 0), cmp_x) - B - 1;\n\t}\n\t\n\tSEG :: build (1, 1, Q);\n}\n\ninline void Solve ()\n{\n\tInit ();\n\n\tint ans = 0, i = M;\n\twhile (i)\n\t{\n\t\tint j = i;\n\t\twhile (A[j].y == A[i].y && j >= 1) Calc (A[j].x), --j;\n\t\tAdd (ans, (LL) SEG :: query () * (A[i].y - A[j].y) % Mod);\n\t\ti = j;\n\t}\n\t\n\tans = ((LL) Q * A[M].y % Mod - ans + Mod) % Mod;\n\tcout << ans << endl;\n}\n\ninline void Input ()\n{\n\tN = read<int>(), M = read<int>(), Q = read<int>();\n\tfor (int i = 1; i <= M; ++i)\n\t\tA[i].x = read<int>(), A[i].y = read<int>(), A[i].p = read<int>();\n\tfor (int i = 1; i <= Q; ++i) B[i].x = read<int>(), B[i].y = read<int>();\n}\n\nint main()\n{\n\n\tfreopen(\"max.in\", \"r\", stdin);\n\tfreopen(\"max.out\", \"w\", stdout);\n\t\n\tInput ();\n\tSolve ();\n\t\n\treturn 0;\n}\n\n```\n\n</details>\n\n\n\n## 8-20\n\n### Process\n\n又看错题。。。T2算方案数的时候看成当且仅当$a_i$不同，死活不会算\n\nT1想错了一个地方，以为$m$只会到$10^6$。。。\n\nT3比较简单，直接矩阵快速幂即可\n\n### T1\n\n[贪心] [动态规划]\n\n显然对于相同体积的物品只用留权值最大的\n\n暴力是$O(100m)$，考虑$m$比较大的时候直接取性价比最高的，当$m$到$10^6$左右的时候再dp\n\n### T2\n\n[卡特兰数]\n\n第一问用后半部分减去前半部分\n\n第二问奇偶部分相减\n\n第三问括号序列，直接卡特兰数\n\n### T3\n\n[容斥] [矩阵快速幂]\n\n暴力容斥，然后矩阵快速幂算方案数\n\n\n\n## 8-21\n\n上午sxy讲课，又复习了下往年联赛题\n\n下午自己在搞xcy课件\n\n\n\n## 8-22\n\n### Process\n\n刚了一上午T2，就没时间了\n\n### T1\n\n[组合数学] [容斥]\n\n把$n$拆成两部分，一部分是若干个$m$，另一部分是用$k$个$[1, m-1]$的数凑出剩下的部分\n\n设第一部分为$im$，那么剩下的就是$n-im$\n\n因为$k$个$[1, m-1]$能凑出的数在$[k, k(m-1)]$范围内，因此$n-im\\in[k, k(m-1)]$，这个范围是很小的\n\n于是就可以枚举所有$i$了\n\n第一部分可以直接插板法算，是$\\displaystyle \\binom{i + k - 1}{k - 1}$\n\n第二部分需要容斥，枚举有多少个数不合法（大于$m-1$），是$\\displaystyle \\sum_{i=0}^{k}(-1)^i\\binom{k}{i}\\binom{(n-im)-i(m-1)-1}{k-1}$\n\n### T2\n\n[点分治]\n\n点分治，然后数点\n\n看上去需要二维数点，但是可以通过把某一维排序后降到一维\n\n排序后不一定保证数出来的点分属两个不同的子树，于是需要把每个子树的答案减去\n\n这应该是点分治的一个经典技巧，大概是这个意思：\n\n```cpp\n\nAdd (ans, process (x, A[x], A[x]));\n\nfor (int i = Begin[x]; i; i = Next[i])\n{\n    int y = To[i];\n    if (Vis[y]) continue;\n    Add (ans, Mod - process (y, A[x], A[x]));\n    divide (y);\n}\n\n```\n\n\n\n### T3\n\n[毒瘤]\n\n不是sol的做法\n\n考虑询问的$x$和$y$的中点$mid$（假设$mid$在$x$到$lca$的链上）\n\n答案由几部分取max构成：\n\n* $lca$子树外的最长链\n\n* $lca$子树内除了$x$和$y$所在子树，剩下部分的最长链\n\n* $x, y$子树最长链\n\n* > 设$lack[i]$表示$fa[i]$的所有子链中，除了$i$所在的链外，最长的子链\n\n  $x$到$mid$路径上，找到一个最大的$i$，满足$lack[i] + dis(fa[i], x)$最大\n  \n  $y$到$lca$路径上，找到一个最大的$i$，满足$lack[i] + dis(fa[i], y)$最大\n  \n* $mid$到$lca$路径上，找到一个最大的$i$，满足$lack[i] + dis(fa[i], y)$最大\n\n前面三种情况随便处理\n\n第四种情况把$dis$拆开，就是要使$lack[i] - dep[fa[i]]$最大，倍增即可\n\n第五种情况同理\n\n剩下就是一些细节\n\n\n\n## 8-23\n\n### Process\n\nT1写了一早上，结果看错题了，是个分块模板题\n\n后面又没时间搞了\n\n### T1\n\n[分块]\n\n直接分块，暴力维护答案，搞个tag就可以了\n\n### T2\n\n$f$是个积性函数，然后直接按题解那个式子筛就可以了\n\n### T3\n\n[概率和期望] [动态规划] [矩阵快速幂]\n\n好神仙的概率期望\n\n![19-8-23-1](/images/19-8-23-1.png)\n\n* 为什么要处理一个$b$数组？\n\n  因为当当前格子填$1$的话，它右边的那个格子就只能填$2$，否则会合并\n\n最难理解的地方是dp转移分母那里\n\n![19-8-23-2](/images/19-8-23-2.png)\n\n和贝叶斯长得很像，但是感觉还是没完全理解。。。\n\n\n\n## 8-25\n\n### Process\n\nT1就是暴力，随便写了下\n\nT2猜结论，推了下性质搞出来了\n\n后面由于某些特殊原因没怎么搞了\n\n### T1\n\n暴力\n\n### T2\n\nsol写得挺好\n\n观察性质，猜结论，转化成坐标系中的经典问题\n\n### T3\n\nsol写得挺好，看subtask3和subtask6\n\n\n\n## 8-26\n\n### Process\n\n搞了一上午T3，搞出来了，T2暴力写挂了\n\n### T1\n\n若后手存在两个王，则先手胜，否则后手胜\n\n### T2\n\n[分治]\n\n因为操作可逆，显然可以把$A, B$排序\n\n考虑归并排序，然后考虑如何把两个已经排好序的区间合并\n\n假设考虑到$[l, mid]$和$[mid + 1, r]$\n\n那么从$mid$开始往左找到一个最大的$x$，满足$A[mid - x + 1] > A[mid + x]$\n\n然后把$[mid - x + 1, mid],[mid + 1, mid + x],[mid - x + 1, mid + x]$依次翻转，因为它们都是有序的\n\n那么此时$[l, mid]$都比$[mid + 1, r]$小了，递归处理$[l, mid]$以及$[mid + 1, r]$即可\n\n### T3\n\n[动态规划] [计数]\n\n考虑一个个往后填颜色，设$f[i][j][k]$表示到第$i$位，前面已经出现了$j$种颜色，这$j$种颜色中有$k$种颜色在后面还可以\n\n>这是类似于一个栈一样的东西\n>\n>比如如果填了1 2 3 4 3，那后面就不能填4了\n\n可以先钦定一个排列顺序，最后乘上排列数\n\n$f[i][j][k]\\rightarrow f[i + 1][j + 1][k + 1]$\n\n$f[i][j][k] \\rightarrow f[i + 1][j][l], l\\in [0, k]$\n\n填表法，那么第二个转移就是一段后缀了\n\n这是$O(nm^2)$的做法，考虑优化\n\n发现$n$比$m$大了很多，会出现很多相邻的，颜色相同的点，考虑把这些点缩成一块考虑\n\n按题意的方法刷颜色的话，每次最多只会增加两块，也就是块的个数最多为$2m-1$\n\n于是第一维只要枚举到$2m-1$，再用插板法算下方案数即可\n\n\n\n## 8-27\n\n听了一些神仙题\n\n要抓紧时间写完\n\n## 8-28\n\n### Process\n\n先搞了T2，然后写了T1，最后T3没调出来交了一个错的优化，结果获得了90分的好成绩\n\n### T1\n\n[动态规划]\n\n$f[x][i]$表示从$x$开始走，走$i$步，不一定回到自己的答案\n\n$g[x][i]$表示从$x$开始走，走$i$步，一定回到自己的答案\n\n树上背包转移\n\n\n\n### T2\n\n[分块]\n\n以$k$为块大小分块，每个询问区间只会落在相邻的两个块中\n\n\n\n### T3\n\n[two pointers] [set]\n\n固定左端点$i$时，右端点$j$是单峰的。即若$\\min_{x, y\\in [i, j]}|a_x - b_y| > j - i + 1$，往右移右端点会更优，否则往左移\n\n会更优\n\n`two pointers`即可\n\n需要用`set`维护那个`min`，一个维护当前状态，一个维护差值。这是个很经典的套路\n\n一开始加入左右`inf`，可以简化代码细节\n\n\n\n## 8-29\n\n### Process\n\nT1开场写了，T3想了个超级复杂的做法，搞了一上午搞出来了，T2暴力\n\n### T1\n\n参见noip2018D1T1\n\n### T2\n\n[动态规划] [计数]\n\n发现$< n^m$和$>n^m$的方案数是相同的，因为任意一个$<n^m$的方案，把每个数用$n$除掉之后，一定都能得到一个合法的，$>n^m$的方案\n\n于是只需要计算$=n^m$的方案\n\n$n$的每个因子独立，拆开分别dp算一下再乘起来即可\n\n具体转移看sol\n\n### T3\n\n[概率和期望] [高斯消元] [换根DP]\n\n我的做法：\n\n考虑一个类似PKUWC随机游走的做法，设$f[i]$表示$i$的答案，根据树上高消的套路可以表示成$f[x] = A[x]\\cdot f[fa[x]] + B[x]$的形式\n\n容易想到可以直接用线段树维护这个东西\n\n但是对于不同的询问，每次$A[x] = B[x] = 0$的点不一样\n\n于是把询问离线，把询问挂在$y$上。一边`dfs`整棵树，一边处理询问\n\n这样的话每次换根就只会有两个点的系数发生改变\n\n---\n\n正解：\n\n考虑每条边的贡献（即这条边产生贡献的期望时间）\n\n设$f[i]$表示$i\\rightarrow fa[i]$这条边的贡献，$g[i]$表示$fa[i] \\rightarrow i$这条边产生的贡献\n\n显然，$f[i] = \\frac{1}{deg_i} + \\frac{1}{deg_i}\\sum_{j}(1 + f[j] + f[i])$\n\n化简得到，$f[i] = 2\\cdot size_i - 1$，$g[i]$同理\n\n然后随便搞下就可以了\n\n","categories":["Summary"],"tags":["数学","容斥","Summary","分块","动态规划","缩点","二分答案","单调栈","线段树","数据结构","线段树合并","贪心","计数","set","概率和期望","分治","图论","搜索","毒瘤","树链剖分","组合数学","高斯消元","最小生成树","矩阵快速幂","LCT","边双","换根DP","点分治","网络流","卡特兰数","斜率优化","欧拉回路","two pointers","强连通分量","范德蒙德卷积"]},{"title":"Plan","url":"/2019/07/31/Plan/","content":"\n一些传送门\n\n## Atcoder\n\n### [ARC](https://hk-cnyali.com/2019/07/31/Atcoder/#ARC)\n\n### [AGC](https://hk-cnyali.com/2019/07/31/Atcoder/#AGC)\n\n## [数据结构](https://hk-cnyali.com/2019/07/31/数据结构/)\n\n## [某个OJ](https://hk-cnyali.com/2019/08/10/某网站上的题/)\n\n密码是我的机位号\n\n## 课件的题\n\n### [zjm的组合题](https://hk-cnyali.com/2019/08/05/「笔记」一些组合题/)\n\n### [gc的贪心题](https://hk-cnyali.com/2019/08/17/「笔记」一些贪心题)\n\n### [xcy的树题](https://hk-cnyali.com/2019/08/21/「笔记」一些树题/)\n\n","categories":["Summary"]},{"title":"数据结构","url":"/2019/07/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","content":"\n[数据结构]\n\nsb题\n\n<!--more-->\n\n### [「SHOI2015」脑洞治疗仪](https://loj.ac/problem/2037)\n\n[线段树]\n\n线段树维护最大子段和模板题\n\n$1$操作求出$[l_0, r_0]$内$1$的个数，然后在$[l_1, r_1]$上二分求出右端点，转化为区间置$1$\n\n\n\n### [「SDOI2017」树点涂色](https://loj.ac/problem/2001)\n\n[LCT]\n\n看到操作1很容易想到LCT，然后考虑路径的权值和LCT有什么关系\n\n发现点$x$到根路径的权值就是$x$到根路径上经过的轻边个数+1，并且这个东西也有可减性\n\n> 每条重链可以看成一个联通块，经过轻边就相当于跨过联通块，使权值+1\n\n注意到，只有在`access`的时候会改变轻重边，那么用一棵dfn序线段树维护信息即可\n\n> 例如，把当前$x$的重儿子$y$变成轻儿子，就相当于把$y$所在`splay`中深度最浅的点的子树权值$+1$\n\n\n\n### [「TJOI2015」旅游](https://loj.ac/problem/2103)\n\n#### Description\n\n题面太屎，记录一下\n\n给你一棵点权树(权值为$val$)\n\n每次询问两个点$(x, y)$，你要在$x$到$y$的这条链上**依次**找出两个点$a, b$，使得$val[a] - val[b]$最大\n\n并且要支持点权链加\n\n#### Solution\n\n[线段树] [树链剖分]\n\n考虑序列上怎么做\n\n直接线段树，维护$min, max$，以及当前区间的答案（左右儿子答案与当前点的$max_{rs} - min_{ls}$取最大值）\n\n在树上的话，套层树剖即可，注意不仅需要维护$max_{rs} - min_{ls}$，还要维护$max_{ls} - min{rs}$，因为树剖在跳的时后，一边是正的一边是反的\n\n\n\n### [「LNOI2014」LCA](https://loj.ac/problem/2558)\n\n很经典的一个套路了，不过这道题一直没写\n\n今天拿到这道题的时候居然还想了半天才想出来。。。\n\n询问$[l, r]$显然可以拆成$[1, l-1]$和$[1, r]$，然后考虑离线求出前缀的答案\n\n按$1$到$n$的顺序，每次把$i$到根路径上所有点权值+1\n\n若询问$x$，只要求$x$到根路径权值和即可\n\n\n\n### [「SDOI2010」捉迷藏](https://www.luogu.org/problem/P2479)\n\n[曼哈顿与切比雪夫距离]\n\n[k-d tree]\n\n两个模板\n\n最小值直接`k-d tree`\n\n最大值转化成切比雪夫距离，直接求就行了\n\n\n\n### [「JXOI2017」颜色](https://loj.ac/problem/2275)\n\n[扫描线] [线段树]\n\n枚举剩下的那一段区间\n\n对于每种颜色$i$处理出$L[i], R[i]$分别表示该颜色出现的最靠左，最靠右的位置\n\n若一个区间$[l, r]$合法，则$\\displaystyle \\max_{i=l}^{r}\\{R[A_i]\\} \\le r$，且$\\displaystyle \\min_{i=l}^{r}\\{L[A_i]\\} \\ge l$\n\n显然，对于一个确定的右端点，左端点的范围是一段连续的区间；左端点确定时同理\n\n就和[这个题](https://hk-cnyali.com/2019/08/03/2019年8月/#T2-9)一模一样了\n\n这里我~~看的题解~~的做法是，枚举右端点$i$扫描线，$\\displaystyle \\max_{i=l}^{r}\\{R[A_i]\\} \\le r$这个限制直接二分找到最靠左的左端点；$\\displaystyle \\min_{i=l}^{r}\\{L[A_i]\\} \\ge l$这个限制在扫描线的过程中搞个线段树，区间置$0$\n\n\n\n### [「BZOJ3439」 Kpm的MC密码](https://www.lydsy.com/JudgeOnline/problem.php?id=3439)\n\n[trie] [可持久化]\n\n倒着建可持久化`trie`，模板题\n\n不知道为什么`bzoj`上一直会t，交到`dark bzoj`上能过","categories":["Problem"],"tags":["线段树","数据结构","k-d tree","扫描线","树链剖分","LCT","曼哈顿与切比雪夫距离","可持久化","trie"]},{"title":"Atcoder","url":"/2019/07/31/Atcoder/","content":"\n[Atcoder]\n\nsb题\n\n<!--more-->\n\n# ARC\n\n## [090](https://atcoder.jp/contests/arc090/tasks)\n\n### F\n\n#### Solution\n\n[暴力]\n\n分类讨论\n\n1. $f(l) \\le 7$：暴力\n\n2. $f(l) \\ge 8$：显然$f(r) - f(l) \\le 1$，且区间长度一定会$\\le \\lfloor \\frac{S}{8}\\rfloor $，于是考虑枚举区间长度$len$\n\n   - $f(r) - f(l) = 0$：方案数为$10^{\\frac{S}{len}} - 10^{\\frac{S}{len} - 1}- len + 1$\n\n   - $f(r) - f(l) = 1$:\n\n     设有$x$个数长度为$f(l)$，$y$个数长度为$f(r)$，那么有\n     $$\n     \\begin{aligned}\n     &\\begin{cases}\n     x + y = len\\\\\n     xf(l) + yf(r) = S\n     \\end{cases}\\\\\n     \\\\\n     \\Rightarrow& f(l)\\cdot len + y = S\\\\\n     \\\\\n     \\Rightarrow& \n     \\begin{cases}\n     y = S\\mod t\\\\\n     x = len - (S\\mod t)\n     \\end{cases}\n     \\end{aligned}\n     $$\n     于是对于每个$len$，都能解出唯一确定的解\n\n     需要注意当$f(l) | S$时答案在前一种情况中计算过了\n\n[Code](https://atcoder.jp/contests/arc090/submissions/6197848)\n\n#### Summary\n\n- 小范围暴力，缩紧条件以方便计数\n\n## [091](https://atcoder.jp/contests/arc091/tasks)\n\n### E\n\n[Dilworth定理]\n\n猜了个结论，贪心构造方案，没想到就A了\n\n根据Dilworth定理：最小链覆盖等于最长反链，即最长下降子序列的长度等于极长上升子序列的个数\n\n那么可以类似这样去构造：$(7, 8, 9 , 10), (5, 6), (3, 4), (2), (1)$\n\n这个例子中，$LIS = 4,LCS = 5$ \n\n## [092](https://atcoder.jp/contests/arc092/tasks)\n\n### E\n\n为什么sb题又做不出\n\n~~可能一定程度上是被这数据范围误导了吧，明明是线性做法~~\n\n首先观察到对答案有贡献的位置的奇偶性是相同的\n\n那么答案要么是所有奇数位上大于零的数之和，要么是所有偶数位上大于零的数之和\n\n选一个较大的即可\n\n### F\n\n[强连通分量]\n\n考虑一条边$(a, b)$\n\n* 若$a, b$在同一个强连通分量中：\n\n  那么$b$能到达$a$\n\n  若$a$能只通过这条边到$b$，则反向后答案改变，否则不改变\n\n* 若$a,b$不在同一个强连通分量中：\n\n  那么$b$不能到达$a$\n\n  若$a$还有另一条路径能到达$b$，则答案改变，否则不改变\n\n考虑如何判断是否存在另外一条路径能到达$b$\n\n枚举$a$，考虑$a$的所有出边指向的节点$b_1, b_2, \\dots b_k$\n\n按$b_1, b_2, \\dots b_k$的顺序dfs一次\n\n假设从$b_i$开始dfs，访问到某个节点的时候，如果它没有标记，则标记上$i$，否则退出\n\n再按同样的方法$b_k, \\dots,b_2, b_1$的顺序dfs一次\n\n这样就能对每个点求出，经过它所需的编号最小的出边，以及编号最大的出边了\n\n若二者相等，则只有这一条出边能到达这个点\n\n复杂度是$O(nm)$的，能跑过\n\n## [093](https://atcoder.jp/contests/arc093/tasks)\n\n### E\n\n[最小生成树] [计数]\n\n> 这道题居然自己做出来了！！！\n>\n> 好开心！\n\n容易发现一个结论\n\n* 最终答案的`MST`方案，与原图的任意一一种`MST`方案相比，最多只能有一条边的差别\n\n> 若有两条有差别的话，那么一条染白，一条染黑，一定合法且更优\n\n然后就基本做出来了\n\n设$sum$表示原图的`MST`答案，讨论一下三种情况：\n\n* $sum > X$：无解\n\n* $sum = X$：\n\n  一开始答案是$2 ^ m - 2 * 2^{m - (n - 1)}$\n\n  > 至少一条边颜色不一样，就是总数减全黑或全白\n\n  枚举其他的每条边，强制其在`MST`中，然后做最小生成树。\n\n  若有$k$条边$=X$，则答案要加上$2 * \\Big(2^{m - (n - 1) }- 2^{m - (n - 1) - k}\\Big)$\n\n  > 先确定原图`MST`方案那些边的颜色$p$，然后从$k$条边中至少选一条与$p$颜色不同，剩下的随便选的方案数\n\n* $sum < X$：\n\n  设有$prob$条边，满足答案为$X$，有$ban$条边，满足答案$< X$\n\n  与上一种情况考虑类似，先确定原图`MST`方案那些边的颜色$p$，然后从$prob$条边中至少选一条与$p$颜色不同，且剩下的边中有$ban$条边也要与$p$颜色相同的方案数\n\n  即$2 * \\Big(2^{m - (n - 1) - ban} - 2 ^ {m - (n - 1) - ban - prob}\\Big)$\n  \n\n### F\n\n #### Description\n\n有 $2^n$ 名选手，编号为 $1$ 至 $2^n$ 。现在这 $2^n$名选手将进行 $n$ 轮淘汰赛，决出胜者。若 $x<y$，则 $x$ 能够战胜 $y$ 。但有 $m$ 个例外，$1$ 号选手会输给这 $m$ 个选手。问有多少中排列方式使得 $1$ 号选手取得胜利。\n\n$n, m\\le 16$\n\n#### Solution\n\n[容斥] [动态规划]\n\n算是这几天学习容斥的小练习题，但是还是看了题解。。。\n\n记 $m$ 个例外形成的集合为 $A$ 集合\n\n首先可以固定$1$号选手在$1$的位置（最后乘$2^n$），那么题目就转化为，使得$\\{p_2\\},\\{p_3,p_4\\},\\{p_5, p_6, p_7, p_8\\}\\cdots$这$n$个区间的最小值不能在$A$集合中\n\n显然可以容斥，因为$n$很小，可以对这$n$个区间的限制，枚举所有情况暴力容斥\n\n$\\displaystyle ans = \\sum_{S}(-1)^{S}f_S$，其中$f_S$表示强制$S$集合的区间的最小值在$A$集合中的方案数\n\n> 因为这里枚举了所有情况，所以不需要乘组合数。。。\n\n然后考虑求$f_S$\n\n与[这道题](https://hk-cnyali.com/2019/09/03/2019年9月/#T3-3)类似的套路，把$A$集合从大到小排序，设$dp[i][S]$表示考虑到$A$集合中的第$i$个元素，强制$S$集合的区间的最小值在$A$集合中的方案数\n\n转移就是枚举第$i$个数出现在第$j$个区间中（也可以不出现），再从剩下可选的数中挑$2^j - 1$个数出来\n\n因为是从大到小考虑的，所以剩下可选的数很好计算\n\n<details>\n<summary>Code</summary>\n```cpp\nint ALL = (1 << N) - 1;\nDp[0][0] = 1;\nfor (int i = 0; i < M; ++i)\n\tfor (int S = 0; S <= ALL; ++S)\n\t{\n\t\tif (!Dp[i][S]) continue;\n\t\tAdd (Dp[i + 1][S], Dp[i][S]);\n\t\tfor (int j = 0; j < N; ++j)\n\t\t{\n\t\t\tif (S & pw[j]) continue;\n\t\t\tint coef = (LL) C (pw[N] - S - A[i + 1], pw[j] - 1) * fac[pw[j]] % Mod;\n\t\t\tAdd (Dp[i + 1][S | pw[j]], (LL) Dp[i][S] * coef % Mod);\n\t\t}\n\t}\n```\n</details>\n\n> * 为什么阶乘要乘在里面，而不能最后乘？\n>\n>   因为你挑了某一些数之后，它们就只能在内部排列了\n\n\n\n# AGC\n\n## [028](https://atcoder.jp/contests/agc028/tasks)\n\n### A\n\n答案要么是$-1$，要么是$\\mathrm{lcm}(n, m)$\n\n### B\n\n[概率和期望]\n\n连个B都做不出来。。。\n\n先把答案转化为总方案数乘每个数贡献的期望\n\n对于第$i$个数，它产生贡献的概率是$\\sum_{j=1}^{n}\\frac{1}{|i - j| + 1}$\n\n这个概率的套路和[这道题]([https://hk-cnyali.com/2019/03/01/%E3%80%8CFJWC2019%E3%80%8D%E5%90%83-%E6%A6%82%E7%8E%87%E5%92%8C%E6%9C%9F%E6%9C%9B-%E7%82%B9%E5%88%86%E6%B2%BB-NTT-CDQ%E5%88%86%E6%B2%BB/](https://hk-cnyali.com/2019/03/01/「FJWC2019」吃-概率和期望-点分治-NTT-CDQ分治/))几乎一模一样。。。\n\n处理下逆元的前缀和即可\n\n#### Summary\n\n- 对整体算所有情况的答案时可以转化为求概率期望\n\n### C\n\n[构造]\n\n其实大体自己都想到了。一个小细节上想歪了，一直卡在那个细节那里就去看了题解。看了题解之后发现我是sb\n\n发现一个合法方案中总共可能有这四类点：00, 01, 10, 11 （左边为$A_i$，右边$B_i$，$1$表示答案中有这个权值）\n\n通过手玩发现，合法方案中00的个数与11的个数相等。并且只要满足$num_{00} = num_{11} > 0$，方案就一定合法\n\n可以通过画图的方法来证明，并构造出方案\n\n![19-7-31-1](/images/19-7-31-1.png)\n\n其中红色边为$A_i$，蓝色边为$B_i$\n\n显然，红蓝两色分界处对应00和11，只要它们数量相等，那么其他类型的点分配在每条相同颜色边构成的链上即可\n\n> 到这里其实都想到了。。。\n>\n> 当时感觉这样构造出来的方案有可能不可行，不过没关系，如果不可行那答案一定会比它更优\n>\n> 这样做只要能保证答案的情况能被算进来就行了\n\n------\n\n接下来就很简单了，把$A_i, B_i$混在一起排序，枚举00类的点是哪个（至少要一个），剩下的贪心选即可\n\n记得考虑全是01或者全是10的情况\n\n### D\n\n[计数] [动态规划]\n\n~~转化一下~~\n\n~~数轴上有一些点，已经存在的$K$条线段把数轴分成了一些部分~~\n\n~~可以求出如果在任意两个部分之间连一条边，答案会增加多少~~\n\n狗屎\n\n看错题了，题目联通是指两个点通过某些线段联通，我以为把圆分成了多少个部分。。。\n\n好难的计数题。。。\n\n题解看了好久才懂\n\n考虑最终状态，一定是某些编号连续的**块**（不一定是联通块）构成的\n\n![19-8-11-1](/images/19-8-11-1.png)\n\n> 注：如图中的蓝色部分，它不是一个联通块，但这并不影响\n\n考虑枚举所有这样的块，设$dp[i][j]$表示这样的块编号最小的点为$i$，最大的点为$j$，那么答案就是所有$dp[i][j]$乘上剩下点随便连的方案数\n\n> 这样的块本质上就是满足$i$和$j$联通，且$i$到$j$之间的点只在内部互相配对\n\n设$g[i]$表示$i$个点随便连边的方案数，若$i$为奇数，则$g[i] = 0$；否则$g[i] = (i-1) \\times (i-3) \\times \\cdots \\times 1$\n\n如何计算$dp[i][j]$呢？\n\n直接算并不好算，因为有图中蓝色块的情况，于是考虑简单容斥（补集转化），用所有方案减去$i$和$j$不联通的方案（枚举断点位置，相当于区间dp）\n$$\ndp[i][j] = g[cnt_{i, j}] - \\sum_{k=i}^{j-1}dp[i][k]\\times g[cnt_{k+1, j}]\n$$\n其中$cnt_{i, j}$表示$i$到$j$中没被钦定的点的个数\n\n答案就是\n$$\n\\sum_{i, j} dp[i][j]\\times g[cnt_{1, i-1} + cnt_{i + 1, n}]\n$$\n\n## [029](https://atcoder.jp/contests/agc029/tasks)\n\n### A\n\n显然答案就是每个$W$前面$B$的个数\n\n### B\n\n贪心题。。。\n\n不会做。。。\n\n没脑子。。。\n\n从大到小考虑，对于一个数$x$，找到它在剩下的数中能与它配对的数$y$，那么$y$是唯一确定的\n\n>设$y$是最小的满足$x + y = 2^k$的数，那么显然找不到一个$z > y$，满足 $x + z = 2^{k'}$\n>\n>因为剩下的数中没有比$x$大的数，而这里的$z$肯定要比$x$大\n\n于是可以直接将$x, y$配对\n\n### C\n\n二分答案，判断的时候若$a_i > a_{i - 1}$就填0，否则把大于$a_i$位的部分删掉，再+1，用map暴力维护这个过程即可\n\n### D\n\n这个D比较简单。。。\n\n* 先手每次都必须往下走，不能停在原地\n* 最后一定是停在某个障碍的上方，或地图最底下\n* 后手在第$i$行时若最右能走到$p$的位置，那么第$i +1$行的$1$至$p$列若有障碍，则结束\n\n## [030](https://atcoder.jp/contests/agc030/tasks)\n\n### A\n\nsbt\n\n### B\n\n手玩一下发现最优解是从$0$开始，先往左/右走一段距离，然后再反复横跳\n\n枚举断点，预处理前后缀和计算答案","categories":["Problem"],"tags":["容斥","动态规划","构造","计数","概率和期望","暴力","最小生成树","强连通分量","Dilworth定理"]},{"title":"2019年7月","url":"/2019/07/19/2019%E5%B9%B47%E6%9C%88/","content":"\n搞颓记录\n\n<!--more-->\n\n## 7-12\n\n三道题都不难。。。\n\nT2小细节挂了20分\n\nT3考场上居然不会十进制下的矩阵快速幂。。。\n\n`100 + 80 + 80 = 260`\n\n### T1\n\n完全背包\n\n### T2\n\n[换根DP]\n\n换根DP，处理下每个点上去和下去的最长链即可\n\n### T3\n\n[矩阵快速幂]\n\n递推式可以通过爆搜/找规律等方法求出，但是直接高精度+矩阵快速幂会T\n\n考虑十进制下的矩阵快速幂\n\n假设需要求$A^{1283}$，那么显然可以拆成$(A^1 * A^{1000}) * (A^2 * A^{100}) * (A^8 * A^{10}) * (A^3 * A^1)$\n\n但显然$A^{10^{40000}}$不能快速求出，于是考虑优化。\n\n$$\n\\Bigg(\\Big(\\big((A^1)^{10}*A^2\\big)^{10} * A^8\\Big)^{10} * A^{3}\\Bigg)^{10}\n$$\n\n和读入优化类似的技巧：\n\n```\nsum = (sum << 3) + (sum << 1) + ch - '0';\n```\n\n把运算法则都升一级后显然也成立，也就是$A^{10} = \\Big(\\big(A^2\\big)^2\\Big)^2 * A^2$\n\n复杂度就降下来了\n\n\n\n## 7-13\n\n今天崩了，11:20才做出来T1，后面两题都没看\n\n正解想不出来的时候考虑暴力做法，一步步往下推就能推出来了 \n\n`100 + 0 + 0 = 100`\n\n### Process\n\n>### T1\n>\n>$dp[i]$表示从合成出$i$级武器开始，到合成出$n$级武器所需的期望花费\n>\n>好像不能这么设。。。\n>\n>$dp[i]$表示合成出$i$级武器的期望花费\n>\n>令$\\displaystyle a_i = \\frac{\\min\\{c_i, b_{max\\{0, i - 1\\}}\\}}{c_i}$\n>\n>>以下是错误思路。。。\n>>\n>>$(dp[i - 2] + dp[i - 1])$有$a_{i-1}$的概率转移到$dp[i]$\n>>\n>>$(dp[i] + dp[i + 1])$有$(1-a_{i+1})$的概率转移到$dp[i]$\n>>$$\n>>dp[i] = \\frac{a_{i-1}}{a_{i-1} - a_{i+1} + 1}\\times(dp[i - 2] + dp[i - 1]) + \\frac{1 - a_{i+1}}{a_{i-1} - a_{i + 1} + 1}\\times (dp[i] + dp[i + 1])\n>>$$\n>>边界：\n>>\n>>$dp[0] = a$\n>>\n>>$dp[1] = $\n>\n>现在是10:47，我还一分都不会写。。。\n>\n>状态设得可能有点问题，应该是第一次合成出$i$级武器的期望花费\n>\n>考虑$dp[1]$，显然只要没合成出$1$级武器，就一直在$0$级不断合成，好像实际上不需要考虑$dp[2]$对它的影响\n>$$\n>\\begin{aligned}\n>dp[1] &= \\sum_{i=0}^{\\infty}(1-a_0)^ia_0\\times (i+2)dp[0]\\\\\n>(1-a_0)dp[1] &= \\sum_{i=1}^{\\infty}(1-a_0)^ia_0\\times(i+1)dp[0]\\\\\n>a_0\\times dp[1] &= 2a_0\\times dp[0] + \\sum_{i=1}^{\\infty}(1-a_0)^ia_0\\times dp[0]\\\\\n>a_0\\times dp[1] &= 2a_0\\times dp[0] + (1-a_0)\\Big(1-(1-a_0)^{\\infty}\\Big)dp[0]\\\\\n>a_0\\times dp[1] &= 2a_0\\times dp[0] + (1-a_0)\\times dp[0]\\\\\n>dp[1] &= (1 + \\frac{1}{a_0}) dp[0]\n>\n>\\end{aligned}\n>$$\n>好像这样就过了样例了...\n>\n>那么对于后面的dp值同理，应该也只需要考虑从前推过去的情况\n>$$\n>\\begin{aligned}\n>dp[n] &= \\sum_{i=0}^{\\infty}(1-a_{n-1})^ia_{n-1}\\times \\Big((i+1)dp[n-1] + dp[n - 2]\\Big)\\\\\n>dp[n] &= \\frac{1}{a_{n-1}}dp[n - 1] + dp[n - 2]\n>\\end{aligned}\n>$$\n>写的时候把$\\frac{1}{a_n}$变成$a_n$\n>\n>11:18终于签上到了。。。\n>\n>\n>\n>### T3\n>\n>启发式合并维护倍增数组，$O(n\\log^2(n))$\n>\n>写不完了。。。\n\n### T1\n\n[概率和期望]\n\nprocess里讲完了\n\n### T2\n\n数论，没碰\n\n### T3\n\n[启发式合并] [倍增]\n\n考虑**启发式合并维护倍增数组**\n\n既然要启发式合并，那么树就必须要是一棵无根树，但原题因为要判断祖孙关系，必须要是一棵有根树\n\n为了解决这个问题，只需要倍增时多维护一下边的方向即可，查询的时候要保证$x\\rightarrow y$的路径上边的方向都相同且朝向$y$\n\n\n\n## 7-14\n\n### Process\n\nT1搞了好久，后面两道题没什么思路\n\n`100 + 20 + 52 = 172`\n\n>### T1\n>\n>操作顺序对答案无影响\n>\n>先全部操作列，考虑列对行的贡献，再操作行\n>\n>### T2\n>\n>倍增？\n>\n>复杂度太高了。。。\n>\n>\n>\n>### T3\n>\n>$[l, r]$的答案：左端点$\\in[1, l]$，右端点$\\in[r, n]$的长度最小的合法区间\n>\n>类似于二维数点？\n\n### T1\n\n略\n\n### T2\n\n[分块] [神仙题]\n\n神仙题\n\n首先显然会有循环，循环节是$m$的倍数，且大小$\\le n * m$\n\n暴力做法是每次$O(n*m)$找循环节，考虑一个**类似于分块的优化**：\n\n记$jump[i]$表示第一列第$i$行走$m$步到达的位置，即每$m$步一大步，一大步一大步地走\n\n再考虑修改操作：\n\n假设修改$(x, y)$，那么只有可能$(x - 1, y - 1), (x, y - 1)(x + 1, y - 1)$这三个格子的决策发生变化，然后对第一列的某些格子的$jump$值产生影响\n\n即我们需要考虑，第一列有哪些格子能走到当前格子\n\n不难发现，它一定是连续的一段\n\n>因为上下两条曲线会将中间一块区域围起来，只要碰到边界就会走向目标格子\n\n于是直接每次暴力往前找出连续区间的上下边界，修改其$jump$值\n\n>这个地方有不少细节，具体见代码。最主要的一个性质：\n>\n>* 在往前推区间范围时，合法的上下界每次最多会往里缩小$1$\n\n### T3\n\n#### Description\n\n给定一个排列 P ，定义区间 [l, r] 是优美的当且仅当其中的数字在从小到大排列后是连续的，m 次询问，每次给定 [l, r] ，求包含它的最短优美区间。\n\n$n, m \\le 10^{5}$\n\n#### Solution\n\n[扫描线] [堆] [数据结构] [线段树] \n\n**扫描线 + 堆 + 线段树**\n\n其中线段树维护的部分非常厉害\n\n**一开始在线段树中对不同的节点赋不同的初值**，巧妙地解决了，在扫描线移动时，后缀的长度同时发生变化的问题。即通过这种方法使得所有位置平等：离扫描线越远，初始赋上的权值越大\n\n下面是具体做法\n\n------\n\n性质 1 ：定义 $p_{i}$ 为 i 在序列中的下标，$k_{i}$ 初始值为 i ，令指针 i 从前往后扫，每走一步，如果 $p_{v_{i}+1} < i$ ，就把 $[1,p_{v_{i}+1}]$ 的 k 值加上 1 ；如果 $p_{v_{i}-1}<i$ ，就把 $[1, p_{v_{i}-1}]$ 的 k 值加上 1 。这样操作之后，区间 [x, i] 是优美的当且仅当 $k_{x} = i$ 。   \n\n证明：若区间 [x, i] 是优美区间，设区间内元素排序后为 l...r ，那么对于 $i\\in[l,r)$ 的每一对 i 和  i + 1 ，两者之中 p 较大的那一个都会让 $k_{x}$ 加 1 ，共加 i - x - 1 次，最终使 $k_{x}=i$ 。若区间 [x, i] 不是优美区间，$k_{x}$ 不可能加到 i - x - 1 次。 \n\n性质 2 ：包含某区间的最短优美区间一定是所有包含它的区间中右端点最左的一个。\n\n反证：令 A 为一个这样的区间，如果 A 不最短，则 A 与答案区间 B 有相交部分，而且相交部分 C 必然是优美的，因为不可能有一个使 C 变优美所必需的数同时出现在 A, B 的非交部分内。那么这个 C 显然会更优，而且 C 的右端点同样最左。\n\n综上，把询问挂在区间右端点上，扫描线 i 从前往后扫，每扫到一个询问就把它丢进优先队列里，队列内按左端点从右到左排序。同时用一棵线段树对 $r\\in[1,i]$ 维护区间 [1, r] 中 k 的最大值，对于队首的询问区间 [l, r] 而言，若 $k_{j}, j \\in [1,l]$ 最大为 i ，直接计算答案并永久弹出队列，然后继续 check 队首，如果不是，停止弹出。因为剩下的区间左端点 l 越来越小，一定不可能在 [1, l] 中出现 $k_{j}=i$ 的存在。\n\n\n\n## 7-15\n\n### Process\n\nT1开场切了，T2搞了好久，T3没时间搞了\n\n`100 + 100 + 25 = 225`\n\n### T1\n\n显然答案一定是某个位置与其目标位置之间的区间\n\n随便统计下答案就行了\n\n### T2\n\n[最短路]\n\n在某个点$(x, y)$，只有两种决策方式\n\n1. 往四个方向走一步\n2. 往四个方向中的两个方向扔传送门，然后往其中一个传送门走，从另一个传送门出来\n\n跑最短路即可\n\n### T3\n\n[三分] [树状数组]\n\n考虑枚举最大值位置，然后确定其高度。显然代价随高度是一个单峰函数，可以三分。于是要快速计算三分出的最大值$val$在位置$i$时的代价\n\n>注：以下的$i$表示枚举出的最大值位置\n\n题目的限制$h_j= h_i - |i - j|$可以转化成\n$$\n\\begin{cases}\nh_j - j = h_i - i~~~(j < i)\\\\\nh_j + j = h_i + i~~~(j > i)\n\\end{cases}\n$$\n设初始的高度为$v_j$，最终方案的高度为$h_j$，那么我们就是要求$\\sum{|v_j - h_j|}$\n\n同样的，它可以化成\n$$\n\\begin{aligned}\n&\\begin{cases}\n|(v_j - j) - (h_j - j)|~~~(j < i)\\\\\n|(v_j + j) - (h_j + j)|~~~(j > i)\n\\end{cases}\n\\\\\\\\\n\\Rightarrow\n&\\begin{cases}\n|(v_j - j) - (h_i - i)|~~~(j < i)\\\\\n|(v_j + j) - (h_i + i)|~~~(j > i)\n\\end{cases}\n\\\\\\\\\n\\Rightarrow\n&\\begin{cases}\n\\begin{cases}\n(v_j - j) - (h_i - i)~~~\\Big((v_j - j) > (h_i - i)\\Big)\\\\\n(h_i - i) - (v_j - j)~~~\\Big((v_j - j) < (h_i - i)\\Big)\n\\end{cases}~~~(j < i)\\\\\n\\begin{cases}\n(v_j + j) - (h_i + i)~~~\\Big((v_j + j) > (h_i + i)\\Big)\\\\\n(h_i + i) - (v_j + j)~~~\\Big((v_j + j) < (h_i + i)\\Big)\n\\end{cases}~~~(j > i)\n\\end{cases}\n\n\\end{aligned}\n$$\n两个树状数组，一个维护前缀信息，以$v_j - j$为下标；一个维护后缀信息，以$v_j + j$为下标\n\n## 7-16\n\nNOI Day1 网络同步赛\n\nT1写了70分暴力挂成65，T2 T3都是裸暴力\n\n## 7-18\n\nNOI Day2 网络同步赛\n\n搞了一上午T1的`K-D Tree`，T3写了暴力，T2暴力dp没写完\n\n晚上把T2 40分暴力写了\n\n## 7-19\n\n### Process\n\n开场写了T2，然后想了很久的T1。T3暴力一个小细节写挂。。。\n\n`95 + 100 + 0 = 195`\n\n### T1\n\n[容斥] [二分图] [动态规划]\n\n题目要求没有不合法位置的排列个数，考虑容斥，转化求至少有$i$个位置不合法的方案数\n$$\nans = \\sum_{i=0}^{n}(-1)^i(n - i)!\\times f[i]\n$$\n其中$f[i]$表示钦定$i$个位置不合法的方案数\n\n通过观察发现，不合法的情况中，每个位置和权值的对应关系如下图：\n\n![19-7-19-1](/images/19-7-19-1.png)\n\n显然，钦定$i$个位置不合法就是从图中选出$i$条边，且这个边集必须是一个匹配\n\n由于这个二分图是由若干条链构成的，于是可以把链一一提出来，排成一排做dp\n\n>因为最多只可能相邻的两个点之间有连边\n>\n>$dp[i][j][0/1]$表示到第$i$个点，选出了$j$条边，当前这个点和它前面的点之间是否有连边的方案数\n\n### T2\n\n[树状数组]\n\n我的做法和标程稍微有点不一样\n\n类似于共价大爷游长沙的做法，给每条非树边连接的两个点一个权值，树状数组维护，求子树权值异或和即可\n\n### T3\n\n本以为是一道披着多项式外衣的斗地主题,最后才知道其实是一道披着斗地主外衣的多项式题\n\n---\n\n晚上把自己T2的std和题面写了。myy的题是真的仙\n\n打算多搞一点T2的部分分\n\n## 7-20\n\n### Process\n\n早上去搞了牙齿，到机房已经9:00了。先花了40分钟左右写完了T1（还是有点慢），然后写了T3的$O(n\\log^2n)$的做法，卡了下常就没时间了。T2只写了个暴力\n\n### T1\n\n考虑在旋转的时候答案会如何变化\n\n显然，有些位置上的答案会$+1$，有些会$-1$，但是我们并不需要知道这些位置到底是什么\n\n直接用两个变量动态维护需要$+1$的位置的数量，和需要$-1$的位置的数量即可\n\n因为每个数最多只会改变一次贡献的正/负，随便存起来搞下就行了\n\n### T2\n\n[线段树] [数据结构]\n\n线段树维护矩阵\n\n线段树的$[l, r]$上维护$f[i][j]$表示从$(i, l)$走到$(j, r)$的最少步数，随便合并\n\n### T3\n\n$O(n\\log^2n)$的暴力\n\n枚举答案区间中的最小值，分别往左右二分扩展即可\n\n---\n\n~~想今天把自己的题搞完，不知道搞不搞得完~~\n\n显然搞不完啊。。。\n\n\n\n## 7-21 ~ 7-28\n\n去海南浪\n\n期间把自己的题数据造完了\n\n课件开了个头，基础知识点基本写完了\n\n\n\n## 7-29\n\n调`beamer`样式调了好久\n\n课件搞了一点点\n\n\n\n## 7-30\n\n上午把课件写了$\\frac{3}{4}$\n\n下午又调了好久`beamer`样式\n\n晚上大体把课件搞完了\n\n\n\n## 7-31\n\n上午看了哪吒\n\n下午调整了下课件的一些小细节，正式收工\n\n","categories":["Summary"],"tags":["容斥","Summary","分块","动态规划","最短路","线段树","数据结构","堆","树状数组","三分","倍增","概率和期望","扫描线","神仙题","启发式合并","矩阵快速幂","换根DP","集训","二分图"]},{"title":"2019年6月","url":"/2019/06/03/2019%E5%B9%B46%E6%9C%88/","content":"\n[Summary]\n\n搞颓记录\n\n<!--more-->\n\n## 6-2\n\n难得一次能AK，以后这种比较简单的考试也要多想正解/高分部分分\n\n`100 + 100 + 100 = 300`\n\n### T1\n\n[数论] [gcd] [欧拉函数]\n\n先考虑**枚举gcd**，把**限制缩紧**，有$(a', b')=1$，然后再化式子\n\n一个比较有用的结论：\n\n满足$\\begin{cases}a+b=n\\\\ (a, b)=1\\end{cases}$的$a, b$的对数就是$\\varphi(n)$\n\n>$$\n>\\begin{aligned}\n>&(a, b) = 1\\\\\n>\\Rightarrow &(a, a+b)=1\\\\\n>\\Rightarrow &(a, n)=1\n>\\end{aligned}\n>$$\n\n### T2\n\n[树状数组] [计数]\n\n最长上升子序列计数\n\n用线段树/树状数组求`LIS`的时候顺便记一下方案数即可\n\n### T3\n\n[动态规划] [前缀和]\n\n分情况讨论，**前缀和优化dp**\n\n<details>\n<summary>Solution</summary>\n很容易得到一个$O(n^3)$的做法（枚举`lca`深度， 分别枚举左右两侧链长）。写出这个暴力后可以发现，在枚举两侧链长之后，`lca`深度范围就确定了，于是可以用前缀和直接算\n</details>\n\n\n\n## 6-6\n\n花了很长时间在想T1正解，结果部分分都没写完。T2比较简单，[之前做过](https://hk-cnyali.com/2018/02/04/AGC004-C-AND-Grid-构造/)。T3想了一会儿，离正解已经很近了，但是最后一步没有想清楚：中间某一部分的机器人是一定能被选出来的\n\n`40 + 100 + 60 = 200`\n\n### T1\n\n[概率和期望]\n\n考虑题目式子的**具体意义**，然后转化成一个概率模型（虽然正向推几乎不可能想到。。。\n\n要大胆猜结论。。。\n\n\n### T2\n\n[构造]\n\n比较巧妙的构造，主要难在四联通条件的处理\n\n<details>\n<summary>Solution</summary>\n![19-6-6-1](/images/19-6-6-1.png)\n</details>\n\n\n### T3\n\n[动态规划]\n\n通过一些特殊的状态进行dp\n\n<details>\n    <summary>Solution</summary>\n\n因为所有机器人是一起移动，相对位置不变，那么可以看成只移动出口，并且``存活的机器人的范围``跟着出口在一起变化<br />\n\n任意时刻`存活的机器人的范围`一定是一个矩形，于是可以以这个矩形作为状态进行dp<br />\n\n要发现一个性质：当前状态下有一部分区域是`一定能获救的`（即救这个区域内的机器人不会改变`存活的机器人`的范围）<br />\n\n需要注意的是，`已经获救的机器人`$\\ne$`当前状态下一定能获救的机器人`$\\ne$`当前状态下存活的机器人`\n\n</details>\n\n\n\n## 6-16\n\n题目比较迷，尤其是T3。T2挂了分\n\n`100 + 80 + 100 = 280`\n\n### T1\n\n[prufer序列] [计数]\n\n方案对应无根树形态，根据**prufer序**，答案为$n^{n-2}*(n-1)!$\n\n### T2\n\n[数论] [欧拉函数] [Pollard Rho]\n\n答案为$\\varphi(n)$，根据[这里的知识](https://hk-cnyali.com/2018/12/16/数论函数初探/#线性筛)直接计算即可， 需要`Pollard Rho`大数质因数分解\n\n### T3\n\n没有奇环没有偶环的连通图就是树。。。\n\n\n\n## 6-17\n\n题面垃圾，题解垃圾，自己太菜了\n\n`60 + 50 + 30  = 140`\n\n### T1\n\n数学题，没看懂\n\n### T2\n\n[树状数组] [动态规划]\n\n傻逼题不会做\n\n\n<details>\n    <summary>Solution</summary>\n很容易想到一个做法：从左往右移动长度为$L$的区间，预处理右边部分的dp数组，左边的动态处理，动态更新答案<br />\n\n需要注意到一个性质：假设当前删除区间为$[x, x + L]$，那么只需要看$a_{x+L+1}$是否对答案产生贡献，因为再后面的数显然此时不会更优\n\n</details>\n\n### T3\n\n狗屎分块，std有`300L`\n\n\n\n## 6-20\n\n### Process\n\n>#### T1\n>\n>点分治？\n>\n>对于每种不同的深度，它们对答案贡献的增量不同，如何解决这个问题？\n>\n>必须要支持把深度数组平移的操作\n>\n>\n>\n>#### T2\n>\n>$dp[i][j]$表示长度为$i$的排列中，有$j$个逆序对的方案。枚举下一个数填什么转移，$O(n^3)$\n>\n>优化一下可以到$O(nk)$，常数是$2$，好像能跑过。。。\n>\n>容斥？\n>\n>不会。。。\n\nT1无限接近正解，还是差了点\n\n然后T1暴力也挂了。。。\n\n`39 + 57 + 33 = 129`\n\n### T1\n\n[点分治] [FFT]\n\n不必考虑增量，显然把**深度数组平移这个操作可以用`FFT`来实现**。。。\n\n考试的时候还忽略了一个问题，这个点分治并不能像平时一样，必须先算分治中心整棵子树的答案，再分别对应减去各个儿子对应子树的答案\n\n\n\n### T2\n\n[容斥] [动态规划] [组合数学]\n\n把$k$拆分成在每一位对答案的贡献，然后容斥dp\n\n因为第$i$位对逆序对总数的贡献范围在$[0, i)$间，于是可以转化为，选出$n$个数$a_i$，满足\n$$\n\\begin{cases}\n\\sum{a_i} = k\\\\\n\\forall i, 0\\le a_i < i\n\\end{cases}\n$$\n\n先不考虑下面的限制，如果只有上面的限制的话显然答案就是插板法$\\binom{n + k -1}{n-1}$ \n\n下面的限制可以通过容斥来满足，暴力容斥的话是枚举至少有多少个数不满足条件\n\n$\\displaystyle \\sum_{i=0}^{k}(-1)^{i}\\sum_{S, |S| = i}\\binom{n-1+k-\\sum{S}}{n-1}$ \n\n显然只关心$|S|$和$\\sum{S}$\n\n即$\\displaystyle \\sum_{S}(-1)^{|S|}*\\binom{n -1 + k - \\sum{S}}{n - 1}$\n\n再变换一下，考虑对于相同的$\\sum{S}$，统计出$\\sum{(-1)^{|S|}}$ \n\n设$f_{i,, j}$表示$|S| = i, \\sum{S} = j$的方案（方案即为$\\sum{(-1)^{S}}$的系数，这里考不考虑符号都无所谓，如果考虑的话最后统计答案的时候就不需要考虑了）\n\n这个dp很巧妙，首先因为每个数互不相等，那么可以强制状态中每个数是按照从大到小严格单调的来保证。\n\n$$\nf_{i, j} = f_{i, j - i} + f_{i - 1, j - i} - f_{i - 1, j - n - 1}\n$$\n\n>考虑要么把当前所有的数全部+1，要么在这个基础上在后面新加一个1\n>\n>但是这样第一个数可能会等于$n+1$，所以要把第一个数为$n+1$的情况减掉\n\n发现$|S|$是$O(\\sqrt k)$级别的，所以dp是$O(k\\sqrt k)$的\n\n总复杂度$O(n + k\\sqrt k)$\n\n\n\n## 6-22\n\n### Process\n\n>### T1\n>\n>作差分？\n>\n>倍增？\n>\n>显然，只有某一段的差分均为$d$的倍数，才有可能有值\n>\n>离线？\n>$$\n>\\frac{\\max - \\min}{d} - r + l\n>$$\n>假设从$l$到$r$的所有差分均为$d$的倍数，那么这一段的答案为\n>$$\n>\\frac{\\sum{\\max} - \\sum{\\min}}{d} - \\sum{r} + \\sum{l}\n>$$\n>差分不为$d$的部分把原序列划分成了若干个连续段，预处理出这些连续段的答案，然后在每次端点处单独讨论一下即可\n>\n>能快速求出$\\sum\\max,\\sum\\min$吗？\n>\n>~~单调栈？离线？~~\n>\n>HNOI2016 序列。。。\n>\n\n一整场考试在T1，开场30mins左右想到了一个似乎是正解的做法，写到考试结束前1个多小时才发现是假的，`区间内数不能重复`这个条件没想到，于是光荣爆炸，后面两题看都没看\n\n`35 + 16 + 0 = 51`\n\n### T1\n\n[扫描线] [单调栈] [线段树] [数据结构]\n\n只有满足以下条件的区间$[l, r]$才合法：\n\n- 没有重复元素\n- 所有元素模$d$同余\n\n其贡献为\n$$\n\\frac{\\max - \\min}{d} - (r - l)\n$$\n\n于是需要维护所有可行区间的$\\frac{\\max}{d}、\\frac{\\min}{d}、(r-l)$，并且求和\n\n转化成一个经典套路：**扫描线 + 单调栈 + 线段树维护历史版本和**\n\n具体来说，按右端点排序，对于所有左端点，用一棵线段树维护以当前扫到的位置为右端点的答案\n\n对于$\\frac{\\max}{d}、\\frac{\\min}{d}$，需要用单调栈维护，在线段树上区间加减\n\n同时，因为右端点在移动的过程中，会有一段连续的左端点变成不合法，于是需要支持线段树上置0操作\n\n最后，因为对于每个左端点，要维护扫过的所有右端点的答案和，所以需要线段树维护历史版本和\n\n> 形象理解一下：\n>\n> ![19-6-25-1](/images/19-6-25-1.png)\n>\n> 一开始答案是蓝色矩形的面积，即$C * (T-1)$\n>\n> 假设在$T$时刻该点权值变为$K$，那么答案就是蓝色和红色矩形的面积并，也就是$T*K + (C-K)*(T-1)$\n>\n> 因为权值变化量$\\Delta = K-C$，那么化简一下，对于之后的某个时间$i$，其答案即为$i*K - \\Delta(T-1)$\n>\n> 维护$K$和$\\sum{\\Delta(T-1)}$即可\n\n\n\n### T2\n\n神题。。。不想写sol了。。。\n\n看谁写了直接蒯过来吧\n\n>UPD\n>gc写了sol，已经放在文件目录下了\n\n### T3\n\n题解写得很清楚，观察性质一个个部分分往上做就行\n\n\n\n## 6-23\n\n### Process\n\nT1一开始想打表，发现最多才只能卡到68K左右，懒得搞了，观察了一下，发现当$n > \\log(m)$时答案就是$\\log(m)$（仔细想想发现也是），剩下的跑暴力就能过了\n\nT3写了好久暴力，最后情况还是没考虑全，爆零\n\n`100 + 40 + 0 = 140`\n\n### T1\n\n[动态规划]\n\n随便搞\n\n### T2\n\n[交互]\n\n这里链的情况保证了根为链的端点。。。直接`stable_sort`\n\n二叉树的情况：\n\n先随便找个点，遍历每个点，如果有祖先就跳到过去，这样就能$O(n)$求出根了。同理，用这个方法就能求出根的两个儿子，递归处理即可\n\n### T3\n\n[计算几何] [扫描线]\n\n树剖 + 扫描线 + 计算几何\n\n尝试了用解析几何的方法写计算几何，感觉还行，这道题也就调了一上午\n\n\n\n## 6-24\n\n### Process\n\nT1想了好久，T3考过原题，T2没时间看了\n\n`100 + 44 + 100 = 244`\n\n### T1\n\n[贪心] [长链剖分]\n\n类似于长剖的过程，贪心地把树划分成若干条链，取前$k$大的链即可\n\n### T2\n\n权值$\\le 75$\n\n线段树暴力维护信息\n\n### T3\n\n[最短路] [状态压缩] [动态规划]\n\n差分，转化成求$2k$个起点，$nm$条边的最短路，最后状压dp\n\n\n\n","categories":["Summary"],"tags":["数论","gcd","欧拉函数","容斥","Summary","动态规划","最短路","构造","单调栈","线段树","数据结构","贪心","树状数组","计数","状态压缩","概率和期望","前缀和","扫描线","组合数学","长链剖分","点分治","FFT","交互","Pollard Rho","计算几何","prufer序列"]},{"title":"「hexo」实现折叠文字/代码块","url":"/2019/05/23/%E3%80%8Chexo%E3%80%8D%E5%AE%9E%E7%8E%B0%E6%8A%98%E5%8F%A0%E6%96%87%E5%AD%97-%E4%BB%A3%E7%A0%81%E5%9D%97/","content":"\nhexo折叠文字/代码块的方法\n\n<!--more-->\n\nfrom [省队爷](<https://huhaoo.github.io/2019/05/17/%E5%AE%9E%E7%8E%B0%E6%8A%98%E5%8F%A0%E6%96%87%E5%AD%97%E5%9D%97/>)\n\n```html\n<details>\n<summary>Code</summary>\n\nblablabla\n\n</details>\n```\n\ndemo:\n\n<details>\n<summary>Code</summary>\n\n```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main ()\n{\n\tputs(\"fuck you\");\n\treturn 0;\n}\n```\n</details>\n","categories":["hexo"],"tags":["hexo"]},{"title":"「Problems」各省省选乱做","url":"/2019/05/22/%E3%80%8CProblems%E3%80%8D%E5%90%84%E7%9C%81%E7%9C%81%E9%80%89%E4%B9%B1%E5%81%9A/","content":"挑了一些简单点的题乱做。。。\n\n<!--more-->\n\n题目链接：[传送门](<https://loj.ac/problems/search?keyword=HNOi2015>)\n\n\n\n\n## [HNOI2019](<https://loj.ac/problems/search?keyword=HNOI2019>)\n\n### [「HNOI2019」多边形](https://loj.ac/problem/3056)\n\n[这里](<https://hk-cnyali.com/2019/05/08/%E3%80%8CHNOI2019%E3%80%8D%E5%A4%9A%E8%BE%B9%E5%BD%A2-%E7%BB%93%E8%AE%BA-%E7%BB%84%E5%90%88%E8%AE%A1%E6%95%B0-%E6%A8%A1%E6%8B%9F/>)\n\n\n\n### [「HNOI2019」校园旅行](https://loj.ac/problem/3057)\n\n[myy的题解](<http://matthew99.blog.uoj.ac/blog/4968>)\n\n[更详细的题解](<https://www.cnblogs.com/luoshuitianyi/p/10679665.html>)\n\n稍微提一下，考虑优化暴力。暴力每次是往两边扩展一个点，那么我们就每次扩展一堆点。事实上，我们也并不需要知道每次往两边加多少个，只需要考虑奇偶性即可，于是就有了这个做法。\n\n\n## [GXOI/GZOI2019](<https://loj.ac/problems/search?keyword=GZOI2019>) \n\n### [「GXOI / GZOI2019」与或和](https://loj.ac/problem/3083)\n\n[单调栈]\n\n按位拆分，转化为求有多少个子矩阵全为$1$，以及总方案数减去有多少个子矩阵全为$0$\n\n以全为$1$为例，预处理出$len[i][j]$表示从$(i, j)$这个位置往右最长连续为$1$的长度。考虑每一列，我们即要求出这一列上所有区间$len$的最小值之和\n\n问题转化为，有一个数列，你需要求其中每个区间的最小值之和\n\n显然考虑贡献，用单调栈维护左边第一个小于等于它的位置，右边第一个小于它的位置即可\n\n\n### [「GXOI / GZOI2019」逼死强迫症](https://loj.ac/problem/3086)\n\n[矩阵快速幂]\n\n设$n$列的答案为$f_n$，斐波那契数列为$g_n$，其前缀和为$h_n$，那么\n$$\n\\begin{aligned}\n\\displaystyle f_n &= f_{n - 1} + f_{n - 2} + 2\\sum_{i=1}^{n-3}g_i\\\\\n &= f_{n - 1} + f_{n-2} + 2*h_{n - 3}\\\\\n &= f_{n-1} + f_{n-2} + 2*(g_{n-1} - 1)\n\\end{aligned}\n$$\n\n考虑枚举两个$1\\times 1$的砖块中**更靠右**的那个放在哪里.\n\n若它放在第 $n-1$ 列，则答案是$f_{n - 1}$，若在前 $n-2$ 个中的某一列上，则答案是$f_{n - 2}$\n\n若放在第$n$列，设左边那个砖块放在第$i$列，那么从第$i$列到第$n$列的方案其实是固定的，剩下的部分就是斐波那契数列\n\n>关于$h_{n} = g_{n + 2} - 1$那里的证明：\n>$$\n>\\begin{aligned}\n>h_n &= \\sum_{i=1}^{n}g_i\\\\\n>&= \\sum_{i=1}^{n}g_{i + 1} - g_{i - 1}\\\\\n>&= \\Big(\\sum_{i=2}^{n + 1}g_{i}\\Big) - \\Big(\\sum_{i=0}^{n - 1}g_{i}\\Big)\\\\\n>&= g_{n + 1} + g_{n} - 1\\\\\n>&= g_{n + 2} - 1\n>\\end{aligned}\n>$$\n\n然后矩阵快速幂优化即可\n\n---\n\n这里顺便记录一下矩阵快速幂优化线性齐次常系数递推的套路\n\n假设dp转移方程是从$f_{1}, f_{2} ... f_{n}$转移成$(a_{1, 1}f_1 + a_{2, 1}f_2 + ...+a_{n, 1}f_n), ... ,(a_{1, n}f_{1} + a_{2, n}f_2 + ... + a_{n, n}f_n)$\n\n那么矩阵就是\n$$\n\\begin{bmatrix}\nf_{1}&f_{2}&f_{3}&\\dots& f_{n}\n\\end{bmatrix}\n\\times\n\\begin{bmatrix}\na_{1, 1} & a_{1, 2} & a_{1,3} &\\dots&a_{1, n}\\\\\na_{2, 1} & a_{2, 2} & a_{2,3} &\\dots&a_{2, n}\\\\\n&&\\vdots\\\\\na_{n, 1} & a_{n, 2} & a_{n,3} &\\dots&a_{n, n}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nf'_{1}&f'_{2}&f'_{3}&\\dots& f'_{n}\n\\end{bmatrix}\n$$\n简单来说，$a_{i, j}$表示从$f_i$转移到$f'_{j}$需要乘的系数\n\n这个东西我现在才会。。。\n\n---\n\n<details>\n<summary>Code</summary>\n\n```cpp\n\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int Mod = 1e9 + 7;\nconst int Maxn = 5;\n\nint N;\n\ninline void Add (int &a, int b) { if ((a += b) >= Mod) a -= Mod; }\n\nstruct Matrix\n{\n\tint A[Maxn][Maxn];\n\n\tMatrix () { memset (A, 0, sizeof A); }\n\t\n\tinline Matrix operator * (const Matrix &rhs) const &\n\t{\n\t\tMatrix ans;\n\t\tfor (int i = 0; i < Maxn; ++i)\n\t\t\tfor (int k = 0; k < Maxn; ++k)\n\t\t\t{\n\t\t\t\tif (!A[i][k]) continue;\n\t\t\t\tfor (int j = 0; j < Maxn; ++j)\n\t\t\t\t\tAdd (ans.A[i][j], (LL) A[i][k] * rhs.A[k][j] % Mod);\n\t\t\t}\n\t\treturn ans;\n\t}\n\t\n\tinline Matrix operator ^ (const int b) const &\n\t{\n\t\tMatrix a = *this, ans;\n\t\tfor (int i = 0; i < Maxn; ++i) for (int j = 0; j < Maxn; ++j) ans.A[i][j] = (i == j);\n\t\tfor (int i = b; i; i >>= 1, a = a * a) if (i & 1) ans = ans * a;\n\t\treturn ans;\n\t}\n};\n\ninline void Solve ()\n{\n\tif (N == 1 || N == 2) { puts(\"0\"); return ; }\n\tMatrix sum;\n\tsum.A[0][0] = sum.A[0][1] = 1;\n\tsum.A[1][0] = 1;\n\tsum.A[2][2] = sum.A[2][3] = 1, sum.A[2][0] = 2;\n\tsum.A[3][2] = 1;\n\tsum.A[4][0] = sum.A[4][4] = 1;\n\n\tMatrix ans;\n\tans.A[0][2] = 2, ans.A[0][3] = 1, ans.A[0][4] = Mod - 2;\n\t\n\tans = ans * (sum ^ (N - 2));\n\t\n\tprintf(\"%d\\n\", ans.A[0][0]);\n}\n\ninline void Input ()\n{\n\tN = read<int>();\n}\n\nint main()\n{\n\n#ifndef ONLINE_JUDGE\n\tfreopen(\"A.in\", \"r\", stdin);\n\tfreopen(\"A.out\", \"w\", stdout);\n#endif\n\n\tint T = read<int>();\n\twhile (T--)\n\t{\n\t\tInput ();\n\t\tSolve ();\n\t}\n\t\n\treturn 0;\n}\n\n```\n\n</details>\n\n\n\n\n\n\n\n### [「GXOI / GZOI2019」旅行者](https://loj.ac/problem/3087)\n\n[最短路] [二进制分组]\n\n考虑每条边的贡献。处理出$f_i$表示到$i$点最近的关键点，$g_i$表示从$i$出发能到达的最近的关键点。如果$f_i\\ne g_i$就能用这条边贡献答案\n\n此外，还能直接二进制分组做。即枚举二进制下每一位，把关键点按这一位为$0/1$划分成两个集合，跑两个集合之间的最短路即可。因为原问题起点终点集合有交，于是不能直接跑最短路。而通过二进制分组分成两个不交的集合后就能直接跑了\n\n<details>\n<summary>Code</summary>\n\n```cpp\n\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar(); \n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/sefl/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int Maxn = 1e5 + 100;\nconst int Maxm = 5e5 + 100;\n\nint N, M, K;\nint A[Maxn];\n\nstruct edge\n{\n\tint x, y, z;\n} E[Maxm];\n\nstruct Graph\n{\n\tconst LL inf = 1e18;\n\tint e, Begin[Maxn], To[Maxm << 1], Next[Maxm << 1], W[Maxm << 1];\n\tinline void init ()\n\t{\n\t\te = 0;\n\t\tmemset (Begin, 0, sizeof Begin);\n\t}\n\n\tinline void add_edge (int x, int y, int z) { To[++e] = y; Next[e] = Begin[x]; Begin[x] = e; W[e] = z; }\n\t\n\tLL Dis[Maxn];\n\tint from[Maxn];\n\t\n\tinline void dijkstra ()\n\t{\n\t\tstatic priority_queue <pii, vector <pii>, greater <pii> > Q; \n\t\tfor (int i = 1; i <= N; ++i) Dis[i] = inf, from[i] = 0;\n\t\tfor (int i = 1; i <= K; ++i) Dis[A[i]] = 0, from[A[i]] = A[i], Q.push (mp (0, A[i]));\n\t\n\t\twhile (!Q.empty())\n\t\t{\n\t\t\tint x = Q.top ().y; Q.pop ();\n\t\t\tfor (int i = Begin[x]; i; i = Next[i])\n\t\t\t{\n\t\t\t\tint y = To[i];\n\t\t\t\tif (Chkmin (Dis[y], Dis[x] + W[i]))\n\t\t\t\t{\n\t\t\t\t\tfrom[y] = from[x];\n\t\t\t\t\tQ.push (mp (Dis[y], y));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n} G[2];\n\ninline void Solve ()\n{\n\tG[0].dijkstra ();\n\tG[1].dijkstra ();\n\t\n\tLL ans = 1e18;\n\t\n\tfor (int i = 1; i <= M; ++i)\n\t{\n\t\tint x = E[i].x, y = E[i].y, z = E[i].z;\n\t\tif (G[0].from[x] != G[1].from[y])\n\t\t\tChkmin (ans, G[0].Dis[x] + G[1].Dis[y] + z);\n\t}\n\t\n\tcout << ans << endl;\n}\n\ninline void Input ()\n{\n\tN = read<int>(), M = read<int>(), K = read<int>();\n\tfor (int i = 1; i <= M; ++i)\n\t{\n\t\tE[i].x = read<int>(), E[i].y = read<int>(), E[i].z = read<int>();\n\t\tG[0].add_edge (E[i].x, E[i].y, E[i].z);\n\t\tG[1].add_edge (E[i].y, E[i].x, E[i].z);\n\t}\n\tfor (int i = 1; i <= K; ++i) A[i] = read<int>();\n}\n\ninline void Init ()\n{\n\tG[0].init ();\n\tG[1].init ();\n}\n\nint main ()\n{\n\t\n#ifndef ONLINE_JUDGE\n\tfreopen (\"A.in\", \"r\", stdin);\n\tfreopen (\"A.out\", \"w\", stdout);\n#endif\n\n\tint Testcase = read<int>();\n\t\n\twhile (Testcase--)\n\t{\n\t\tInit ();\n\t\tInput ();\n\t\tSolve ();\n\t}\n\t\n\treturn 0;\n}\n\n```\n\n</details>\n\n\n\n\n\n\n\n### [「GXOI / GZOI2019」旧词](https://loj.ac/problem/3088)\n\n[数据结构]\n\n一个很简单的套路。没有$k$次方的话就是把可选点到根的路径全部$+1$，然后求所求点到根路径上的权值和\n\n$+1$的本质其实是$\\displaystyle +dep_i - dep_{fa_{i}}$，那么这道题变成$\\displaystyle +(dep_i^k) -(dep_{fa_{i}}^k) $即可\n\n<details>\n<summary>Code</summary>\n\n```cpp\n\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int Maxn = 5e4 + 100;\nconst int Mod = 998244353;\n\ninline void Add (int &a, int b) { if ((a += b) >= Mod) a -= Mod; }\n\ninline int Pow (int a, int b)\n{\n\tint ans = 1;\n\tfor (int i = b; i; i >>= 1, a = (LL) a * a % Mod) if (i & 1) ans = (LL) ans * a % Mod;\n\treturn ans;\n}\n\nint N, M, K;\nint e, Begin[Maxn], To[Maxn << 1], Next[Maxn << 1];\nint fa[Maxn], dep[Maxn], dfn[Maxn], idfn[Maxn], son[Maxn], size[Maxn], top[Maxn], dfs_clock;\nint Sum[Maxn];\n\nstruct info\n{\n\tint x, y, id;\n} Q[Maxn];\n\ninline int cmp (info a, info b) { return a.x < b.x; }\n\ninline void add_edge (int x, int y) { To[++e] = y; Next[e] = Begin[x]; Begin[x] = e; }\n\ninline void dfs (int x)\n{\n\tdep[x] = dep[fa[x]] + 1, size[x] = 1;\n\tfor (int i = Begin[x]; i; i = Next[i])\n\t{\n\t\tint y = To[i];\n\t\tdfs (y);\n\t\tsize[x] += size[y];\n\t\tif (size[y] > size[son[x]]) son[x] = y;\n\t}\n}\n\ninline void dfs (int x, int now)\n{\n\tidfn[dfn[x] = ++dfs_clock] = x, top[x] = now;\n\tif (son[x]) dfs (son[x], now);\n\tfor (int i = Begin[x]; i; i = Next[i])\n\t{\n\t\tint y = To[i];\n\t\tif (y == son[x]) continue;\n\t\tdfs (y, y);\n\t}\n}\n\nnamespace SEG\n{\n#define mid ((l + r) >> 1)\n#define ls root << 1\n#define rs root << 1 | 1\n#define lson ls, l, mid\n#define rson rs, mid + 1, r\n\tstruct info\n\t{\n\t\tint sum, tag;\n\t} node[Maxn << 2];\n\n\tinline int get_val (int l, int r) { return (Sum[r] - Sum[l - 1] + Mod) % Mod; }\n\t\n\tinline void push_up (int root) { node[root].sum = (node[ls].sum + node[rs].sum) % Mod; }\n\t\n\tinline void push_down (int root, int l, int r)\n\t{\n\t\tif (!node[root].tag) return ;\n\t\tAdd (node[ls].sum, (LL) node[root].tag * get_val (l, mid) % Mod);\n\t\tAdd (node[ls].tag, node[root].tag);\n\t\tAdd (node[rs].sum, (LL) node[root].tag * get_val (mid + 1, r) % Mod);\n\t\tAdd (node[rs].tag, node[root].tag);\n\t\tnode[root].tag = 0;\n\t}\n\t\n\tinline void update (int root, int l, int r, int x, int y)\n\t{\n\t\tif (x <= l && r <= y)\n\t\t{\n\t\t\tAdd (node[root].sum, get_val (l, r));\n\t\t\tAdd (node[root].tag, 1);\n\t\t\treturn ;\n\t\t}\n\t\tpush_down (root, l, r);\n\t\tif (x <= mid) update (lson, x, y);\n\t\tif (y > mid)  update (rson, x, y);\n\t\tpush_up (root);\n\t}\n\t\n\tinline int query (int root, int l, int r, int x, int y)\n\t{\n\t\tif (x <= l && r <= y) return node[root].sum;\n\t\telse\n\t\t{\n\t\t\tpush_down (root, l, r);\n\t\t\tint ans = 0;\n\t\t\tif (x <= mid) Add (ans, query (lson, x, y));\n\t\t\tif (y > mid) Add (ans, query (rson, x, y));\n\t\t\treturn ans;\n\t\t}\n\t}\n\n#undef mid\n#undef ls\n#undef rs\n#undef lson\n#undef rson\n}\n\ninline void Update (int x)\n{\n\twhile (x)\n\t{\n\t\tSEG :: update (1, 1, N, dfn[top[x]], dfn[x]);\n\t\tx = fa[top[x]];\n\t}\n}\n\ninline int Query (int x)\n{\n\tint ans = 0;\n\twhile (x)\n\t{\n\t\tAdd (ans, SEG :: query (1, 1, N, dfn[top[x]], dfn[x]));\n\t\tx = fa[top[x]];\n\t}\n\treturn ans;\n}\n\nint Ans[Maxn];\n\ninline void Pre ()\n{\n\tdfs (1);\n\tdfs (1, 1);\n//\tfor (int i = 1; i <= N; ++i) cout << idfn[i] << ' ' << dep[idfn[i]] << endl;\n\tfor (int i = 1; i <= N; ++i)\n\t\tSum[i] = ((LL) Sum[i - 1] + Pow (dep[idfn[i]], K) - Pow (dep[idfn[i]] - 1, K) + Mod) % Mod;\n}\n\ninline void Solve ()\n{\n\tPre ();\n\n\tfor (int i = 1; i <= M; ++i) Q[i].x = read<int>(), Q[i].y = read<int>(), Q[i].id = i;\n\tsort (Q + 1, Q + M + 1, cmp);\n\t\n\tint j = 1;\n\tfor (int i = 1; i <= M; ++i)\n\t{\n\t\twhile (j <= Q[i].x) Update (j++);\n\t\tAns[Q[i].id] = Query (Q[i].y);\n\t}\n\t\n\tfor (int i = 1; i <= M; ++i) printf(\"%d\\n\", Ans[i]);\n}\n\ninline void Input ()\n{\n\tN = read<int>(), M = read<int>(), K = read<int>();\n\tfor (int i = 2; i <= N; ++i) add_edge (fa[i] = read<int>(), i);\n}\n\nint main()\n{\n\n#ifndef ONLINE_JUDGE\n\tfreopen(\"A.in\", \"r\", stdin);\n\tfreopen(\"A.out\", \"w\", stdout);\n#endif\n\n\tInput ();\n\tSolve ();\n\t\n\treturn 0;\n}\n\n```\n\n</details>\n\n\n\n\n\n\n## TJOI2019\n\n### [「TJOI2019」甲苯先生的字符串](https://loj.ac/problem/3104)\n\n[矩阵快速幂]\n\n矩阵快速幂随便搞下\n\n<details>\n<summary>Code</summary>\n\n```cpp\n\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int Maxn = 1e5 + 100;\nconst int Mod = 1e9 + 7;\n\nLL N;\nchar S[Maxn];\n\ninline void Add (int &a, int b) { if ((a += b) >= Mod) a -= Mod; }\n\ninline int Pow (int a, int b)\n{\n\tint ans = 1;\n\tfor (int i = b; i; i >>= 1, a = (LL) a * a % Mod) if (i & 1) ans = (LL) ans * a % Mod;\n\treturn ans;\n}\n\nstruct Matrix\n{\n\tint A[30][30];\n\tinline Matrix () { memset (A, 0, sizeof A); }\n\tinline Matrix operator * (const Matrix &rhs) const &\n\t{\n\t\tMatrix ans;\n\t\tfor (int i = 0; i < 26; ++i)\n\t\t\tfor (int k = 0; k < 26; ++k)\n\t\t\t{\n\t\t\t\tif (!A[i][k]) continue;\n\t\t\t\tfor (int j = 0; j < 26; ++j)\n\t\t\t\t\tAdd (ans.A[i][j], (LL) A[i][k] * rhs.A[k][j] % Mod);\n\t\t\t}\n\t\treturn ans;\n\t}\n\n\tinline Matrix operator ^ (const LL &n) const &\n\t{\n\t\tMatrix a = *this, ans;\n\t\tfor (int i = 0; i < 26; ++i) ans.A[i][i] = 1;\n\t\tfor (LL i = n; i; i >>= 1, a = a * a) if (i & 1) ans = ans * a;\n\t\treturn ans;\n\t}\n} trans;\n\ninline void Solve ()\n{\n\tMatrix Ans;\n\tfor (int i = 0; i < 26; ++i) Ans.A[0][i] = 1;\n\tAns = Ans * (trans ^ (N - 1));\n\n\tint ans = 0;\n\tfor (int i = 0; i < 26; ++i) Add (ans, Ans.A[0][i]);\n\tcout << ans << endl;\n}\n\ninline void Input ()\n{\n\tN = read<LL>();\n\tscanf(\"%s\", S);\n\tfor (int i = 0; i < 26; ++i) for (int j = 0; j < 26; ++j) trans.A[i][j] = 1;\n\tfor (int i = 1, len = strlen (S); i < len; ++i)\n\t\ttrans.A[S[i - 1] - 'a'][S[i] - 'a'] = 0;\n}\n\nint main()\n{\n\n#ifndef ONLINE_JUDGE\n\tfreopen(\"A.in\", \"r\", stdin);\n\tfreopen(\"A.out\", \"w\", stdout);\n#endif\n\n\tInput ();\n\tSolve ();\n\t\n\treturn 0;\n}\n\n```\n\n</details>\n\n\n\n\n\n### [「TJOI2019」甲苯先生的滚榜](https://loj.ac/problem/3105)\n\n[数据结构]\n\n无脑上`pb_ds`，当然也可以权值线段树维护\n\n\n### [「TJOI2019」唱、跳、rap 和篮球](https://loj.ac/problem/3106)\n\n[容斥] [生成函数] [多项式] [NTT]\n\n考虑容斥。设$m = \\min\\{a, b, c, d, \\frac{n}{4}\\}$，枚举至少有$i$个`cxk`，则\n$$\nans = \\sum_{i=0}^{m} (-1)^{i}\\binom{n - 3i}{i}f_{n-4i}\n$$\n其中$f_{n-4i}$表示剩下的$n-4i$个人的排列方案\n\n前面那个$\\binom{n-3i}{i}$是因为`cxk`不能拆开，于是把每个`cxk`看成一个整体，所以总共有$n-3i$个元素，要从中选出$i$个元素\n\n后面的部分，设四种同学分别有$a_j$个，那么就是$\\displaystyle \\frac{(n-4i)!}{\\prod_{j=1}^{4} a_j!}$\n\n分母部分就直接把四个指数型生成函数的多项式卷起来即可\n\n<details>\n<summary>Code</summary>\n\n```cpp\n\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int Maxn = 1000 + 100;\nconst int Mod = 998244353;\n\nint N, Num[4], M;\n\nnamespace MATH\n{\n\tint fac[Maxn], ifac[Maxn];\n\tinline void Add (int &a, int b) { if ((a += b) >= Mod) a -= Mod; }\n\tinline int Pow (int a, int b)\n\t{\n\t\tint ans = 1;\n\t\tfor (int i = b; i; i >>= 1, a = (LL) a * a % Mod) if (i & 1) ans = (LL) ans * a % Mod;\n\t\treturn ans;\n\t}\n\tinline int C (int n, int m)\n\t{\n\t\tif (n < m) return 0;\n\t\treturn (LL) fac[n] * ifac[m] % Mod * ifac[n - m] % Mod;\n\t}\n}\n\nusing namespace MATH;\n\nnamespace Poly\n{\n\tconst int Maxn = 1e4 + 10;\n\tconst int g = 3;\n\tint n, rev[Maxn];\n\tint F[4][Maxn];\n\n\tinline void init (int k)\n\t{\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < 4; ++i) sum += Num[i] - k;\n\t\n\t\tn = 1; while (n <= sum) n <<= 1;\n\t\tfor (int i = 0; i < n; ++i) rev[i] = (rev[i >> 1] >> 1) + (i & 1 ? (n >> 1) : 0);\n\t\n\t\tfor (int i = 0; i < 4; ++i)\n\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\tF[i][j] = (j <= Num[i] - k) ? ifac[j] : 0;\n\t}\n\t\n\tinline void dft (int *A, int fl)\n\t{\n\t\tfor (int i = 0; i < n; ++i) if (rev[i] < i) swap (A[rev[i]], A[i]);\n\t\tfor (int mid = 1; mid < n; mid <<= 1)\n\t\t{\n\t\t\tint Wn = Pow (g, (Mod - 1) / mid / 2);\n\t\t\tif (fl) Wn = Pow (Wn, Mod - 2);\n\t\t\tfor (int i = 0; i < n; i += (mid << 1))\n\t\t\t{\n\t\t\t\tint W = 1;\n\t\t\t\tfor (int j = i; j < i + mid; ++j, W = (LL)W * Wn % Mod)\n\t\t\t\t{\n\t\t\t\t\tint x = A[j], y = (LL) W * A[j + mid] % Mod;\n\t\t\t\t\tA[j] = (x + y) % Mod, A[j + mid] = (x - y + Mod) % Mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tint inv = Pow (n, Mod - 2);\n\t\tif (fl) for (int i = 0; i < n; ++i) A[i] = (LL) A[i] * inv % Mod;\n\t}\n\t\n\tinline int calc (int k)\n\t{\n\t\tinit (k);\n\t\tfor (int i = 0; i < 4; ++i) dft (F[i], 0);\n\t\tfor (int i = 1; i < 4; ++i)\n\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\tF[0][j] = (LL) F[0][j] * F[i][j] % Mod;\n\t\tdft (F[0], 1);\n\t\treturn F[0][N - 4 * k];\n\t}\n}\n\ninline void Solve ()\n{\n\tint ans = 0;\n\tfor (int i = 0; i <= M; ++i)\n\t{\n\t\tint now = (LL) C (N - 3 * i, i) * Poly :: calc (i) % Mod * fac[N - 4 * i] % Mod;\n\t\tif (i & 1) Add (ans, Mod - now);\n\t\telse Add (ans, now);\n\t}\n\n\tcout << ans << endl;\n}\n\ninline void Input ()\n{\n\tN = read<int>(), M = N / 4;\n\tfor (int i = 0; i < 4; ++i) Chkmin (M, Num[i] = read<int>());\n}\n\ninline void Init (int maxn = 1000)\n{\n\tfac[0] = 1;\n\tfor (int i = 1; i <= maxn; ++i) fac[i] = (LL) fac[i - 1] * i % Mod;\n\tifac[maxn] = Pow (fac[maxn], Mod - 2);\n\tfor (int i= maxn - 1; i >= 0; --i) ifac[i] = (LL) ifac[i + 1] * (i + 1) % Mod;\n}\n\nint main()\n{\n\n#ifndef ONLINE_JUDGE\n\tfreopen(\"A.in\", \"r\", stdin);\n\tfreopen(\"A.out\", \"w\", stdout);\n#endif\n\n\tInit ();\n\tInput ();\n\tSolve ();\n\t\n\treturn 0;\n}\n\n```\n\n</details>\n\n\n\n\n\n\n### [「TJOI2019」大中锋的游乐场](https://loj.ac/problem/3107)\n\n因为$k$很小，直接把所有状态拿出来跑最短路\n\n\n### [「TJOI2019」甲苯先生和大中锋的字符串](https://loj.ac/problem/3108)\n\n[后缀自动机] [字符串]\n\n建`SAM`随便搞 \n\n<details>\n<summary>Code</summary>\n\n```cpp\n\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\nconst int Maxn = 1e5 + 100;\n\nint N, K;\nchar S[Maxn];\n\nnamespace BIT\n{\n#define lowbit(x) (x & (-x))\n\tLL sum[Maxn];\n\tinline void init () { memset (sum, 0, sizeof sum); }\n\tinline void add (int x, int val) { for (; x < Maxn - 5; x += lowbit(x)) sum[x] += val; }\n\tinline void add (int x, int y, int val) { add (x, val), add (y + 1,-val); }\n\tinline LL query (int x) { LL ans = 0; for (; x; x -= lowbit(x)) ans += sum[x]; return ans; }\n}\n\nnamespace SAM\n{\n\tint node_cnt = 1, last = 1;\n\tstruct info\n\t{\n\t\tint ch[30], fa, maxlen, cnt;\n\t} node[Maxn << 2];\n\t\n\tinline int new_node (int pre)\n\t{\n\t\t++node_cnt;\n\t\tnode[node_cnt].maxlen = node[pre].maxlen + 1;\n\t\tnode[node_cnt].cnt = 1;\n\t\treturn node_cnt;\n\t}\n\t\n\tinline void extend (int c)\n\t{\n\t\tint now = new_node (last), pre = last; last = now;\n\t\tfor (; pre && !node[pre].ch[c]; pre = node[pre].fa) node[pre].ch[c] = now;\n\t\tif (!pre) node[now].fa = 1;\n\t\telse\n\t\t{\n\t\t\tint x = node[pre].ch[c];\n\t\t\tif (node[x].maxlen == node[pre].maxlen + 1) node[now].fa = x;\n\t\t\telse\n\t\t\t{\n\t\t\t\tint y = ++node_cnt; node[y] = node[x];\n\t\t\t\tnode[y].cnt = 0, node[y].maxlen = node[pre].maxlen + 1;\n\t\t\t\tnode[now].fa = node[x].fa = y;\n\t\t\t\tfor (; node[pre].ch[c] == x; pre = node[pre].fa) node[pre].ch[c] = y;  \n\t\t\t}\n\t\t}\n\t}\n\t\n\tinline void build (char *s, int n)\n\t{\n\t\tfor (int i = 1; i <= n; ++i) extend (s[i] - 'a');\n\t}\n\t\n\tvector <int> G[Maxn << 2];\n\t\n\tinline void dfs (int x)\n\t{\n\t\tfor (int y : G[x])\n\t\t{\n\t\t\tdfs (y);\n\t\t\tnode[x].cnt += node[y].cnt;\n\t\t}\n\t}\n\t\n\tinline void solve ()\n\t{\n\t\tfor (int i = 1; i <= node_cnt; ++i) G[node[i].fa].pb (i);\n\t\tdfs (1);\n\t\n\t\tfor (int i = 1; i <= node_cnt; ++i)\n\t\t{\n\t\t\tif (node[i].cnt == K)\n\t\t\t\tBIT :: add (node[node[i].fa].maxlen + 1, node[i].maxlen, 1);\n\t\t}\n\t\n\t\tint ans = -1;\n\t\tLL times = 0;\n\t\tfor (int i = N; i >= 1; --i)\n\t\t{\n//\t\t\tcout << i << ' ' << BIT :: query (i) << endl;\n\t\t\tif (Chkmax (times, BIT :: query (i))) ans = i;\n\t\t}\n\t\t\n\t\tcout << ans << endl;\n\t}\n\t\n\tinline void init ()\n\t{\n\t\tfor (int i = 1; i <= node_cnt; ++i) G[i].clear (), memset (node[i].ch, 0, sizeof node[i].ch), node[i].fa = node[i].cnt = node[i].maxlen = 0;\n\t\tnode_cnt = last = 1;\n\t}\n}\n\ninline void Solve ()\n{\n\tBIT :: init ();\n\tSAM :: init ();\n\tSAM :: build (S, N);\n\tSAM :: solve ();\n}\n\ninline void Input ()\n{\n\tscanf(\"%s\", S + 1);\n\tN = strlen (S + 1);\n\tK = read<int>();\n}\n\nint main ()\n{\n\n#ifndef ONLINE_JUDGE\n\tfreopen(\"A.in\", \"r\", stdin);\t\n\tfreopen(\"A.out\", \"w\", stdout);\n#endif\n\n\tint Testcase = read<int>();\n\t\n\twhile (Testcase--)\n\t{\n\t\tInput ();\n\t\tSolve ();\n\t}\n\treturn 0;\n}\n\n```\n\n</details>\n\n\n","categories":["Problem"],"tags":["容斥","最短路","单调栈","数据结构","NTT","字符串","矩阵快速幂","生成函数","后缀自动机","省选","多项式","二进制分组"]},{"title":"「Algorithm」对子集和DP/高维前缀和的一些理解","url":"/2019/05/19/%E3%80%8CAlgorithm%E3%80%8D%E5%AF%B9%E5%AD%90%E9%9B%86%E5%92%8C%E5%8F%98%E6%8D%A2-%E9%AB%98%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/","content":"\n太菜了，想半天才想清楚\n\n<!--more-->\n\n### Description\n\n每个集合有个权值，对于每个集合求它所有子集的权值和\n\n\n### Solution\n\n暴力枚举子集是$O(3^n)$的，但是我们可以通过高维前缀和做到$O(2^nn)$\n\n先放代码\n\n```cpp\nfor (int i = 1; i <= N; ++i)\n    for (int state = 0; state <= ALL; ++state)\n        if (state & (1 << (i - 1)))\n            Add(Ans[state], Ans[state ^ (1 << (i - 1))]);\n```\n\n为什么要外层循环枚举新加的元素，内层枚举状态呢？\n\n为什么这样能做到不重复计算呢？\n\n考虑下图这样的转移\n\n![19-5-20-1](/images/19-5-20-1.png)\n\n显然，因为先枚举的转移哪一位，所以标①的两个一起转移，标②的两个一起转移\n\n假设①比②先转移，那么$0001001$只会从$0101001$转移到$1101001$，而不会从$1001001$转移过去（因为从$1001001$转移的时候，$0001001$还没转移到$1001001$上）\n\n这样相当于给转移的每一位钦定了顺序，必须把某一位全部转移完再考虑下一位。而且外层按任意顺序枚举都可以\n\n同理，因为对于某一位而言，只可能是从$0$转移到$1$，所以内层的状态也可以按任意顺序枚举\n\n只要保证外面枚举哪一位，里面枚举状态就行\n","categories":["Algorithm"],"tags":["前缀和","子集和DP"]},{"title":"「Codeforces」一些傻逼题","url":"/2019/05/17/%E3%80%8CCodeforces%E3%80%8D%E4%B8%80%E4%BA%9B%E5%82%BB%E9%80%BC%E9%A2%98/","content":"\n都是傻逼题\n\n<!--more-->\n\n## [#1167](<https://codeforces.com/contest/1167>)\n\n### D\n\n直接贪心。如果要填左括号，就看当前剩下没配对的左括号哪种颜色少；右括号同理\n\n<details>\n<summary>Code</summary>\n    ```cpp\n    for (int i = 1; i <= N; ++i)\n\t{\n\t\tif (S[i] == '(')\n\t\t{\n\t\t\tif (sum0 < sum1) Ans[i] = 0, ++sum0;\n\t\t\telse Ans[i] = 1, ++sum1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (sum0 > sum1) Ans[i] = 0, --sum0;\n\t\t\telse Ans[i] = 1, --sum1;\n\t\t}\n\t}\n    ```\n</details>\n\n### E\n\n固定左端点，假设可行的右端点的范围为$[p, m]$，显然从大到小枚举左端点后，$p$是单调不升的\n\n记录每种数字位置的最大/最小值，前缀最大值，`two pointers`扫一下即可\n\n`two pointers`的细节需要注意，**务必想清楚再动键盘**\n\n<details>\n<summary>Code</summary>\n```cpp\n// Max[i] 所有为i的数的最右位置\n// Min[i] 所有为i的数的最左位置\n// sum_max[] Max的前缀最大值\n\tint MIN = 1e7, r = M;\n\tfor (int l = p; l >= 1; --l)\n\t{\n\t\twhile (r >= l && Max[r + 1] <= MIN && Min[r + 1] >= sum_max[l - 1])\n\t\t{\n\t\t\tChkmin (MIN, Min[r + 1]);\n\t\t\t--r;\n\t\t}\n\n\t\tans += (M - r);\n\t}\n```\n</details>\n\n### F\n\n考虑贡献，计算每个数对答案的贡献，即对于每个数考虑`所有包含它的区间中`小于它的数的个数\n\n显然，对于一个位置，因为往左右分别延伸的区间互不影响，所以可以拆成左边和右边分别计算答案\n\n再拆一次贡献，对于每个小于它的数分别算对它的贡献，搞一左一右两棵树状数组统计答案\n\n<details>\n<summary>Code</summary>\n​```cpp\n\tfor (int i = 1; i <= N; ++i) T[1].add (A[i], N - i + 1);\n\tint ans = 0;\n\tfor (int i = 1; i <= N; ++i)\n\t{\n\t\tint sum0 = (LL) T[0].query (A[i]) * (N - i + 1) % Mod;\n\t\tint sum1 = (LL) T[1].query (A[i]) * i % Mod;\n\t\tAdd (ans, (LL) (sum0 + sum1) % Mod * Hash[A[i]] % Mod);\n\t\tT[0].add (A[i], i);\n\t\tT[1].add (A[i], Mod - (N - i + 1));\n\t}\n```\n</details>\n\n\n## [#1166](<https://codeforces.com/contest/1166>)\n\n### C\n\n枚举$x$，计算可能的$y$的范围\n\n根据条件$|x - y| \\le |x|, |y| \\le |x + y|$（实际上这里还需要讨论符号）\n\n分类讨论一下可以得到合法的$y$的区间\n\n* $x\\le 0$时：$y\\in [2x, \\frac{x}{2}]\\cup [-\\frac{x}{2}, -2x]$\n* $x > 0$时：$y\\in [\\frac{x}{2}, 2x]\\cup [-2x,-\\frac{x}{2}]$\n\n注意减掉$x=y$的情况\n\n<details>\n<summary>Code</summary>\n```cpp\n\tsort (A + 1, A + N + 1);\n\tLL ans = 0;\n\tfor (int i = 1; i <= N; ++i)\n\t{\n\t\tint x = A[i], l, r;\n\t\tif (x <= 0)\n\t\t{\n\t\t\tl = lower_bound (A + 1, A + N + 1, 2 * x) - A;\n\t\t\tr = upper_bound (A + 1, A + N + 1, x / 2.0) - A - 1;\n\t\t\tans += r - l + 1;\n\t\t\tl = lower_bound (A + 1, A + N + 1, - x / 2.0) - A;\n\t\t\tr = upper_bound (A + 1, A + N + 1, - 2 * x) - A - 1;\n\t\t\tans += r - l + 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tl = lower_bound (A + 1, A + N + 1, x / 2.0) - A;\n\t\t\tr = upper_bound (A + 1, A + N + 1, x * 2) - A - 1;\n\t\t\tans += r - l + 1;\n\t\t\tl = lower_bound (A + 1, A + N + 1, - x * 2) - A;\n\t\t\tr = upper_bound (A + 1, A + N + 1, - x / 2.0) - A - 1;\n\t\t\tans += r - l + 1;\n\t\t}\n\t\t--ans;\n\t}\n\tcout << ans / 2 << endl;\n```\n</details>\n\n\n### D\n\n贪心构造，先构造一个初始局面，再不断调整这个局面\n\n考虑先构造一个形如$a, a + 1, 2 a + 2, 4a + 3, \\dots ,b$的局面，因为$\\log(10^{14}) < 50$，所以长度肯定不会超过限制\n\n这样构造出来后，$\\Delta = b - sum_{k-1}$有可能$> m$，于是需要调整，把前面多凑一点\n\n从小到大考虑每个位置$i$，假设给它加上$x$，那么$i+1$就需要加上$x$，$i+2$加上$2x$，$i+3$加上$4x$，以此类推\n\n可以发现这样做了之后，$sum_{k-1}$会加上$2^{n-i}x$\n\n又因为$2^{n-i}x\\le \\Delta$，且$x\\le m - 1$\n\n所以贪心地考虑，$x = \\min\\{\\lfloor\\frac{\\Delta}{2^{n-i}}\\rfloor, m - 1\\}$\n\n最后看剩下的$\\Delta$是否$\\ge m$即可\n\n还有一些小细节，比较恶心\n\n<details>\n<summary>Code</summary>\n```cpp\n\tif (a == b)\n\t{\n\t\tcout << 1 << ' ' << a << endl;\n\t\treturn ;\n\t}\n\n\tmemset(A, 0, sizeof A); N = 0;\n\tA[++N] = a;\n\tLL sum = a;\n\twhile (1)\n\t{\n\t\tif (sum <= b && b <= sum * 2 + 1) { A[++N] = b; break; }\n\t\tA[++N] = sum + 1;\n\t\tsum = sum * 2 + 1;\n\t}\n\t\n\tLL delta = A[N] - sum - 1;\n\tfor (int i = 2; i < N; ++i)\n\t{\n\t\tLL now = min (M - 1, (LL) (delta / pow(2ll, N - i - 1)));\n\t\tdelta -= Calc (now, i);\n\t\n\t\tLL res = now;\n\t\tA[i] += now;\n\t\tfor (int j = i + 1; j < N; ++j)\n\t\t{\n\t\t\tA[j] += res;\n\t\t\tres += res;\n\t\t}\n\t}\n\tif (delta >= M) puts(\"-1\");\n\telse\n\t{\n\t\tcout << N << ' ' ;\n\t\tfor (int i = 1; i <= N; ++i) cout << A[i] << ' '; puts(\"\");\n\t}\n```\n</details>\n\n\n### E\n\n设$A_i, B_i$表示第$i$天的两个集合，其中$A_i$是题目给出的那个\n\n不难发现存在合法方案的必要条件是所有$A$集合之间两两有交\n\n> 如果存在$i, j$使得$A_i \\cap A_j = \\emptyset$，则$\\mathrm{lcm}\\{B_j\\} \\ge \\mathrm{lcm}\\{A_i\\} > \\mathrm{lcm}\\{B_i\\} > \\mathrm{lcm}\\{A_j\\}$，矛盾\n\n然后考虑它的充分性，即只利用这个限制去构造合法解\n\n考虑如下构造：选取$m$个互不相同的质数$p_1,p_2\\dots p_m$，对于第$i$天的集合$A_i$，把其中所有商店的权值乘上$p_i$\n\n显然，因为$A_i$两两有交，所以$\\displaystyle \\forall i, \\mathrm{lcm}\\{A_i\\} = \\prod_{j=1}^{m} p_j$\n\n那么$\\displaystyle \\mathrm{lcm}\\{B_i\\} \\le \\frac{\\prod_{j=1}^{m}p_j}{p_i} < \\mathrm{lcm}\\{A_i\\}$\n\n<details>\n<summary>Code</summary>\n​```cpp\n\tfor (int i = 1; i <= M; ++i)\n\t{\n\t\tint k = read<int>();\n\t\twhile (k--) A[i][read<int>()] = 1;\n\t\tfor (int j = 1; j < i; ++j)\n\t\t{\n\t\t\tif (!(A[i] & A[j]).any())\n\t\t\t{\n\t\t\t\tputs(\"impossible\");\n\t\t\t\treturn ;\n\t\t\t}\n\t\t}\n\t}\n\tputs(\"possible\");\n```\n</details>\n\n\n### F\n\n#### Description\n\n给你一张$n$个点$m$条边的无向图，每条边有一个$\\in[1, c]$的颜色，另外有$q$次操作：\n\n* `+ x y z` 连一条$x$到$y$，颜色为$z$的边\n\n* `? x y`询问从$x$到$y$是否存在一条这样的路径：从经过的第一条边开始，每经过的两条边颜色相同\n\n  比如，有一条经过了$5$条边的路径，那么就需要满足第$1、2$条边颜色相同，$3、4$条边颜色相同，而第$5$条边颜色任意\n\n$n,m, c, q\\le 10^5$\n\n#### Solution\n\n一个暴力的想法是，建一个新图，如果$(u, w)$和$(w, v)$颜色相同，则在新图中连$(u, v)$，但是最后一条边不需要走颜色相同的边，不太好处理\n\n考虑用并查集来维护连通性，且每个连通块用一个`set`来维护这个连通块能到达的点的集合，显然`set`可以启发式合并\n\n> 这里能到达点的集合并不就是这个连通块\n>\n> 因为每个点还能再多往后走一步，即还要加上这些点在原图中的邻居\n\n最后还需要考虑一个经典的问题，因为新图中的边可能很多，所以我们不能把它们直接建出来。于是可以对于每个点，每种颜色只保留一条边。如果再加一条这种颜色的边的话，直接把它与之前保留边的信息合并即可\n\n<details>\n<summary>Code</summary>\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int Maxn = 1e5 + 100;\n\nint N, M, C, Q;\nset <int> S[Maxn];\nmap <pii, int> Map;\n\nnamespace DSU\n{\n\tint fa[Maxn];\n\n\tinline void init (int maxn) { for (int i = 1; i <= maxn; ++i) fa[i] = i, S[i].insert (i); }\n\tinline int get_fa (int x) { return x == fa[x] ? x : fa[x] = get_fa (fa[x]); }\n\tinline void link (int x, int y)\n\t{\n\t\tx = get_fa (x), y = get_fa (y);\n\t\tif (x == y) return ;\n\t\tif (S[x].size() > S[y].size()) swap (x, y);\n\t\tfa[x] = y;\n\t\tS[y].insert (S[x].begin(), S[x].end());\n\t\tS[x].clear ();\n\t}\n\tinline int query (int x, int y) \n\t{ \n\t\tx = get_fa (x); \n\t\tif (*S[x].lower_bound (y) != y) return 0;\n\t\treturn 1;\n\t}\n}\n\ninline void add_edge (int x, int y, int z)\n{\n\tif (Map[mp (x, z)]) DSU :: link (Map[mp (x, z)], y);\n\telse Map[mp (x, z)] = y;\n\tS[DSU :: get_fa (y)].insert (x);\n}\n\ninline void Solve ()\n{\n\tDSU :: init (N);\n\tfor (int i = 1; i <= M; ++i)\n\t{\n\t\tint x = read<int>(), y = read<int>(), z = read<int>();\n\t\tadd_edge (x, y, z), add_edge (y, x, z);\n\t}\n\n\twhile (Q--)\n\t{\n\t\tchar S[10]; scanf(\"%s\", S);\n\t\tif (S[0] == '?')\n\t\t{\n\t\t\tint x = read<int>(), y = read<int>();\n\t\t\tprintf(\"%s\\n\", DSU :: query (x, y) ? \"Yes\" : \"No\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint x = read<int>(), y = read<int>(), z = read<int>();\n\t\t\tadd_edge (x, y, z);\n\t\t\tadd_edge (y, x, z);\n\t\t}\n\t}\n}\n\ninline void Input ()\n{\n\tN = read<int>(), M = read<int>(), C = read<int>(), Q = read<int>();\n}\n\nint main()\n{\n\n#ifndef ONLINE_JUDGE\n\tfreopen(\"F.in\", \"r\", stdin);\n\tfreopen(\"F.out\", \"w\", stdout);\n#endif\n\n\tInput ();\n\tSolve ();\n\t\n\treturn 0;\n}\n\n```\n</details>\n```","categories":["Problem"],"tags":["Codeforces","树状数组","启发式合并","two pointers"]},{"title":"「HNOI2019」多边形 - 结论 + 组合计数 + 模拟","url":"/2019/05/08/%E3%80%8CHNOI2019%E3%80%8D%E5%A4%9A%E8%BE%B9%E5%BD%A2-%E7%BB%93%E8%AE%BA-%E7%BB%84%E5%90%88%E8%AE%A1%E6%95%B0-%E6%A8%A1%E6%8B%9F/","content":"\n给出一个三角剖分的$n$边形\n\n定义一次操作$(a, c)$：若存在$1\\le a < b < c <  d \\le n$，满足$(a, b), (b, c), (c, d), (a, d), (a, c)$有边，则可以删掉边$(a, c)$，连上边$(b, d)$\n\n定义目标状态为不能进行任何操作的多边形，问至少需要多少次操作才能到达目标状态，并求出方案数对$10^9 + 7$取模的值\n\n另外，还有$m$次询问\n\n每次给出一个合法的操作$(a, c)$，求在初始状态先操作$(a, c)$后得到的多边形的答案，询问之间互不影响\n\n$n, m\\le 10^5$\n\n<!--more-->\n\n### Link\n\n[LOJ 3056](<https://loj.ac/problem/3056>)\n\n### Solution\n\n显然，最优策略每次的$d=n$，目标状态就是全都连到$n$号点上，长这样子：\n\n![19-5-8-1](/images/19-5-8-1.png)\n\n因此第一问的答案就是除了边界外，两个端点均没有与$n$相连的边数\n\n考虑一开始所有与$n$相连的点，将它们排序后，对于任意一对相邻的点$(l, r)$，一定存在边$(l, r)$\n\n且若$l + 1 \\ne r$，则在$l$到$r$中必然**存在且仅存在一个**点$p$，满足$(l, p)$有边，$(p, r)$有边\n\n那么操作$(l, r)$的话，就能连上$(p, n)$，且接下来$(l, r)$就被拆分成$(l, p)$和$(p, r)$两个独立的部分，递归处理\n\n![19-5-8-2](/images/19-5-8-2.png)\n\n不难发现，这形成了一棵树形结构，**且以初始局面下所有$l+1<r$的边$(l,r)$作为树根，即可得到一片二叉树森林。**（考场上没时间了，没想到是二叉树，以为每一层都和第一层一样可能有多个儿子）其中每个点必须在它父亲之后操作。\n\n这样的方案数可以树形dp，通过直接计算合并两棵子树的方案数来得到\n\n具体来说，考虑隔板法，把右子树中的点插到左子树点的序列中。这并不需要考虑左右子树内部的顺序，因为在递归到左右子树的时候已经考虑过了\n\n---\n\n对于任意一次询问，因为**操作需要满足$1\\le a < b < c < d \\le n$**，发现只有两种合法情况：\n\n* 最优策略下操作了一步使得最优步数减1\n\n  即将这个点（在森里中一定是根）删去，其左右儿子分别作为两棵新的二叉树的根\n\n* 对某个点（一定是左儿子）进行了一次$rotate$操作，不改变最优步数\n\n这两种情况本质都是把原来的某些边断掉，并连上新的边。用组合数和逆元算一下即可\n\n\n\n### Summary\n\n* 挖掘题目中隐含的更深的性质\n* 运用dp的思想来计数，把原问题拆分成若干个子问题，计算每个子问题对答案的贡献，再利用乘法原理合并\n\n\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1; \n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int Maxn = 1e5 + 100;\nconst int Mod = 1e9 + 7;\n\nint OP, N, M, ans_cnt;\n\nvector <int> G[Maxn];\n\ninline void add_edge (int x, int y) { G[x].pb (y), G[y].pb (x); }\n\nnamespace MATH\n{\n\tint fac[Maxn], ifac[Maxn];\n\n\tinline int fpm (int a, int b)\n\t{\n\t\tint ans = 1;\n\t\tfor (int i = b; i; i >>= 1, a = (LL) a * a % Mod) if (i & 1) ans = (LL) ans * a % Mod;\n\t\treturn ans;\n\t}\n\tinline int C (int n, int m) { return (LL) fac[n] * ifac[m] % Mod * ifac[n - m] % Mod; }\n\tinline int InvC (int n, int m) { return (LL) ifac[n] * fac[m] % Mod * fac[n - m] % Mod; }\n\tinline void init (int n)\n\t{\n\t\tfac[0] = 1;\n\t\tfor (int i = 1; i <= n; ++i) fac[i] = (LL) fac[i - 1] * i % Mod;\n\t\tifac[n] = fpm (fac[n], Mod - 2);\n\t\tfor (int i = n - 1; i >= 0; --i) ifac[i] = (LL) ifac[i + 1] * (i + 1) % Mod;\n\t}\n}\n\nusing MATH :: C;\nusing MATH :: InvC;\n\ninline int Calc (int l, int r)\n{\n\tif (l + 1 == r) return 1;\n\tint mid = *lower_bound (G[r].begin(), G[r].end(), l + 1);\n\treturn (LL) C (r - l - 2, mid - l - 1) * Calc (l, mid) % Mod * Calc (mid, r) % Mod;\n}\n\ninline void Solve ()\n{\n\tint step = 0, ans = 1;\n\n\tfor (int i = 1; i < G[N].size(); ++i)\n\t{\n\t\tint x = G[N][i - 1], y = G[N][i], sum = y - x - 1;\n\t\tans = (LL) ans * C (step + sum, sum) % Mod;\n\t\tans = (LL) ans * Calc (x, y) % Mod;\n\t\tstep += sum;\n\t}\n\n\tif (!OP) cout << step << endl;\n\telse cout << step << ' ' << ans << endl;\n\n\tM = read<int>();\n\n\twhile (M--)\n\t{\n\t\tint x = read<int>(), y = read<int>(), step_now = step, ans_now = ans;\n\n\t\tint l = *lower_bound (G[y].begin(), G[y].end(), x + 1);\n\t\tint r = *lower_bound (G[x].begin(), G[x].end(), y + 1);\n\t\tint sum_all = y - x - 1, lsum = l - x - 1, rsum = y - l - 1;\n\n\t\tif (r == N)\n\t\t{\n\t\t\t--step_now;\n\t\t\tans_now = (LL) ans_now * InvC (step, sum_all) % Mod;\n\t\t\tans_now = (LL) ans_now * InvC (lsum + rsum, lsum) % Mod;\n\t\t\tans_now = (LL) ans_now * C (step_now - rsum, lsum) % Mod;\n\t\t\tans_now = (LL) ans_now * C (step_now, rsum) % Mod;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint lsum_f = y - x - 1, rsum_f = r - y - 1;\n\t\t\tint rsum_new = r - l - 1;\n\t\t\tans_now = (LL) ans_now * InvC (lsum + rsum, lsum) % Mod;\n\t\t\tans_now = (LL) ans_now * InvC (lsum_f + rsum_f, lsum_f) % Mod;\n\t\t\tans_now = (LL) ans_now * C (rsum + rsum_f, rsum) % Mod;\n\t\t\tans_now = (LL) ans_now * C (lsum + rsum_new, lsum) % Mod;\n\t\t}\n\n\t\tif (OP) printf(\"%d %d\\n\", step_now, ans_now);\n\t\telse printf(\"%d\\n\", step_now);\n\t}\n}\n\ninline void Input ()\n{\n\tOP = read<int>();\n\tMATH :: init (N = read<int>());\n\n\tfor (int i = 1; i <= N - 3; ++i)\n\t{\n\t\tint x = read<int>(), y = read<int>();\n\t\tadd_edge (x, y);\n\t}\n\tfor (int i = 1; i <= N; ++i) add_edge (i, i % N + 1);\n\n\tfor (int i = 1; i <= N; ++i) sort (G[i].begin (), G[i].end ());\n}\n\nint main ()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"polygon.in\", \"r\", stdin);\n\tfreopen(\"polygon.out\", \"w\", stdout);\n#endif\n\n\tInput ();\n\tSolve ();\n\n\treturn 0;\n}\n\n```\n\n","categories":["Problem"],"tags":["计数","组合数学","模拟","省选"]},{"title":"「Summary」HNOI2019总结","url":"/2019/04/24/%E3%80%8CSummary%E3%80%8DHNOI2019%E6%80%BB%E7%BB%93/","content":"\n挂得好惨。\n\n<!--more-->\n\n## 得分\n\n`10 + 20 + 40 + 0 + 40 + 10 = 120`\n\n`Rank 37`\n\n\n\n## 失误\n\n### 完全不应该的失误\n\n1. 考试时好高骛远，想多拿部分分而没有进行对拍（Day1 T1）\n\n   这里丢了30分\n\n2. 考场上比较急躁，Day1 T2直接`dfs树`上暴力撤销匹配的假算法写了半天没调出来就放弃了\n\n   这里丢了30分，实测这个暴力还能多拿20分\n\n   也就是丢了50分\n\n3. 本来写了乱搞，想出部分分之后把乱搞删掉了，结果乱搞得到的分还更多\n\n   这里丢了10分\n\n加起来总共丢了90分，比两天任意一天的分都高\n\n这些分加上就能稳进队了\n\n\n\n### 一些还有可能拿到的分数\n\n1. Day1 T3我的做法离比较高的部分分以及正解已经不远了，稍微再多花点时间就能拿到更多的分\n2. Day2 T1再**冷静**地想一下不难想出$O(m^2)$的暴力做法\n3. Day2 T3再仔细分析下性质，大胆猜下结论，或是考前做过类似的套路也能多拿至少`20~40`分\n\n\n\n## 问题\n\n1. 考场上太急躁，没调整好心态，导致思路混乱，浪费大量时间\n2. 考场上对自己过于自信，计算几何题都不对拍\n3. 平时搞竞赛（学知识点/刷题）的方法还是有问题，下面再具体分析\n\n\n\n## 改进\n\n通过这次省选，以及滚回去十几天搞文化的经历，发现自己搞OI的方法还是有问题\n\n其实，对于我这种菜鸡而言，不管是文化还是竞赛都是一样\n\n真正在考场上再去一层层分析题目，找思路是很难的。平时必须要多做题，多见套路（不只是口胡）。在学每个知识点/每一种题型的时候，哪怕只是比较模板的东西，也一定要多写几遍，多自己推几遍，多用几遍类似的套路\n\n要做到看一眼就知道这道题/这个部分分怎么写，并且有自信能比较快地些出来\n\n只有这样，在考场上才能更快地把该拿的分拿到；才能更稳地对拍；才有时间，有可能拿到更多的分\n\n对于我而言，一些所谓的口胡是毫无意义的。真正的口胡应该是： 这道题我知道怎么做，并且我**确定**能很快地写出来**并写对**。而不是，这道题我**好像**见过/**好像**会做。\n\n---\n\n当然，与此同时，也要多锻炼思维，继续打CF等各种比赛\n\n\n\n## 最后\n\n挺可笑的，上天给了我一次这么好的机会，题目难，区分度不大，写满暴力就能进队\n\n可是又有什么用呢。\n\n似乎就像一场模拟赛，那些平时很稳的选手还是很稳\n\nresult发下来，又有各种奇奇怪怪的地方挂了分\n\n只不过这一次，所有该挂的不该挂的分全都挂了。\n\n不过也好，给洋洋自得的自己当头一棒\n\n机会一次次减少，OI生涯已经过半\n\n高一的OI生涯其实也只剩几天后的CTS和可能存在，或许去不了的夏令营了\n\n紧接着是联赛，然后是冬令营，然后又到了省选\n\n明年的这个时候，坐在理工大的银杏树下痛哭的也许就轮到我了\n\n提高点效率，别再浑浑噩噩地混日子了\n\n加油吧。","categories":["Summary"],"tags":["Summary","省选"]},{"title":"「Codeforces」4.1~4.2","url":"/2019/04/04/%E3%80%8CCodeforces%E3%80%8D4-1-4-2/","content":"\n最近做的一点点CF上的题\n\n<!--more-->\n\n## [1142A - The Beatles](https://codeforces.com/contest/1142/problem/A)\n\n环形数轴上有间隔为$k$的$n$个点，下标为$1,k+1,2k+1,\\dots,(n−1)k+1$。首尾相接\n\n你在数轴上走，设起点为$s$，步长为$L$，而现在只知道和$s$距离最近的点的距离为$a$，和$(s+L)$距离最近的点的距离为$b$。问从$s$出发，第一次回到$s$走的最多和最少的步数\n\n$n, k\\le 100000;a, b\\le \\frac{k}{2}$\n\n### Solution\n\n显然答案和$s$没什么关系，只和$L$有关系\n\n考虑枚举所有可能的$L$，先考虑$L < k$的情况，然后不断再$+k$\n\n$L < k$时，通过画图发现只有四种情况：\n\n* $L = k + a  - b$\n* $L = k - a - b$\n* $L = a + b$\n* $L = k + b - a$\n\n枚举出了$L$之后，答案即为$\\displaystyle \\frac{n*k}{\\gcd(n*k, L)}$\n\n\n\n## [1142B - Lynyrd Skynyrd](https://codeforces.com/contest/1142/problem/B)\n\n一个长度为$n$的**排列**$a_i$，一个长度为$m$的**序列**$b_i$，满足$b_i\\in [1, n]$\n\n有$q$次询问$[l, r]$，你需要回答是否能从序列$b_i$的区间$[l, r]$中，选出一个长度为$n$的子序列，满足它和排列$a_i$循环同构\n\n$n, m, q\\le 2*10^5$\n\n### Solution\n\n题目可以转化为，把排列$a_i$倍长之后，能否找到$a$的一个长度为$n$的子段，跟$b$在$[l, r]$范围内的一个子序列匹配上\n\n也就是说，我们判断，把$b$在$[l, r]$范围内的子序列去跟$a$匹配，看最长匹配长度是否$\\ge n$\n\n因为$a$是一个排列，因此对于$b_i$而言，它肯定只会匹配对应$a$中后面的那一个位置，这个关系在$b$序列上构成了一棵树\n\n问题转化为，我们只能选区间$[l,r]$内的点，问能否选出一条长度$\\ge n$的链\n\n显然，每个点的$n-1$级祖先是固定的，能预处理出来。\n\n用`ST表`维护一下区间最小的那个$n-1$级祖先，看它是否属于$[l, r]$即可\n\n\n\n## [1142C - U2](https://codeforces.com/contest/1142/problem/C)\n\n给你二维平面上的$n$个点，对于任意两个$x$坐标不同的点，连一条形如$y=x^2+bx+c$的抛物线\n\n问有多少条抛物线满足在它内部没有点\n\n$n\\le 10^5$\n\n### Solution\n\n把每个点$(x, y)$转化成$(x, y - x^2)$之后求上凸壳即可\n\n\n\n## [1144G - Two Merged Sequences](https://codeforces.com/contest/1144/problem/G)\n\n一个长度为$n$的序列$a_i$，问能否把它划分成一个严格上升子序列和一个严格下降子序列，并输出方案\n\n$n\\le 2*10^5$\n\n### Solution\n\n考虑当前这个数是分到上升序列还是下降序列\n\n$dp[i][0/1]$表示第$i$个数作为下降/上升序列末尾时，上升/下降序列末尾的最小/最大值\n\n顺便再记一下最小/最大值的位置，用`pair`实现\n\n\n\n\n\n","categories":["Problem"],"tags":["数学","动态规划","数据结构","ST表","凸包"]},{"title":"「HNOI2015」Brief Solution","url":"/2019/04/03/%E3%80%8CHNOI2015%E3%80%8DSolution/","content":"\n并不全\n\n<!--more-->\n\n题目链接：[传送门](<https://loj.ac/problems/search?keyword=HNOi2015>)\n\n\n\n## 接水果\n\n一棵$n$个点的树，有$P$条路径，每条路径有权值$c_i$\n\n$Q$次询问$(x, y, k)$，每次询问在所有包含于路径$(x, y)$的路径中，第$k$小的权值\n\n$n, P, Q\\le 40000$\n\n\n\n### Solution\n\n显然可以直接二分答案，但是直接在线`check`需要二维线段树维护，不好搞，于是离线整体二分\n\n整体二分里面套了一个二维数点，随便扫一下就可以了\n\n\n\n## 菜肴制作\n\n一张$n$个点，$m$条边的`DAG`，求它的一个拓扑排序，满足编号越小的尽量排在越前面（不是字典序最小）\n\n$n, m\\le 10^5$\n\n\n\n### Solution\n\n显然越靠后面的位置放越大的数会更优，建反图跑拓扑排序，使得字典序尽量大，再倒着输出即可\n\n>稍微证明一下为什么是这样的\n>\n>考虑当前可以放在最后一个的最大的数，如果它不放在最后，那真正放过去的那个数会比它小，显然不会更优\n\n\n\n## 落忆枫音\n\n一张$n$个点，$m$条边的`DAG`，再往上加一条边$(S, T)$，求得到的图外向生成树的个数\n\n答案对$10^9+7$取模\n\n$n\\le 10^5, m\\le 2*10^5$\n\n\n\n### Solution\n\n记$deg[i]$表示$i$的入边个数，考虑每个点的父亲是谁，那么一个`DAG`的方案数为$\\displaystyle \\prod_{i=2}^{n}deg[i]$\n\n加上一条新边之后，如果还这么算的话，可能会出现环，考虑把所有环的方案减掉\n\n假设有一个$a_1, a_2\\dots,a_k$的环，那么不合法（要减掉）的方案数为$\\displaystyle \\frac{\\prod_{i=2}^{n}deg[i]}{\\prod_{i=1}^{k}deg[a_i]}$\n\n> 环上的点都钦定了父亲，剩下所有点的父亲随便选\n\n问题变成，计算从$T$到$S$所有可能的路径，上面那个式子的和\n\n因为原图是个`DAG`，直接拓扑排序dp即可\n\n\n\n## 开店\n\n一棵$n$个点，带边权的树，且每个点有权值$x_i$\n\n$Q$次询问$(x, l, r)$，每次询问从$x$出发，到所有点权$\\in [l, r]$的点的路径长度和\n\n$n, Q\\le 2*10^5$\n\n### Solution\n\n> 只口胡，不想写\n\n点权$\\in [l, r]$的这个限制显然可以用主席树搞掉\n\n问题变成，你有一个点集，每次询问一个点到`所有点集中的点`的距离和\n\n直接算不好算，根据树上问题的套路，显然$x$到$y$的路径长度可以转化为$\\mathrm{dis}(x) + \\mathrm{dis}(y) - 2*\\mathrm{dis}(lca_{x, y})$\n\n那么就是要求$\\mathrm{dis}(lca_{x, y})$，显然这个东西就是$x$到根的路径和$y$到根的路径的交\n\n树剖，一开始把每个点到根的路径全部加一下，查询就直接查那个点的权值即可。也就是区间加，单点查询\n\n\n\n## 亚瑟王\n\n不太会，咕咕咕\n\n\n\n## 实验比较\n\n没看题，咕咕咕\n","categories":["Problem"],"tags":["动态规划","线段树","数据结构","拓扑排序","省选","整体二分"]},{"title":"「ZJOI2019」线段树 - 线段树","url":"/2019/04/02/%E3%80%8CZJOI2019%E3%80%8D%E7%BA%BF%E6%AE%B5%E6%A0%91-%E7%BA%BF%E6%AE%B5%E6%A0%91/","content":"\n一开始，你有序列$[1, n]$的一棵线段树，有$m$次操作/询问\n\n* `1 l r`：在操作队列里加上`l, r`这个操作。\n* `2`：询问当前操作队列，每个操作是否执行，总共$2^{k}$（$k$为操作数）种方案中， 线段树上`tag`为$1$ 的节点个数的总和。答案对$998244353$取模\n\n在线段树上的一次操作$[l, r]$，就是把线段树上所有被$[l, r]$完全覆盖的极大区间的`tag`设为$1$\n\n$n, m\\le 10^5$\n\n<!--more-->\n\n### Links\n\n[LOJ 3043](<https://loj.ac/problem/3043>)\n\n### Solution\n\n4.5UPD\n\n一个更妙，更简洁的概率做法：[这里](<https://www.cnblogs.com/cjyyb/p/10645169.html>)\n\n---\n\n考虑在线段树上模拟这个过程，统计每个节点在$2^k$种方案中，`tag`为$1$的次数分别是多少\n\n显然每次只需要考虑新加进来一个操作后，对当前节点答案产生的影响\n\n不难注意到，对于第$k$个操作$[x, y]$，造成不同影响的节点$[l, r]$一共有$4$类：\n\n![19-4-2-1](/images/19-4-2-1.png)\n\n1. $x\\le l, r\\le y$，且该结点被访问过\n\n   也就是线段树访问到的最底层的那一类节点\n\n   无论之前的操作是什么样，这一次它的`tag`一定为$1$，即答案加上$2^{k-1}$\n\n2. 除第$1$类之外，剩下被访问过的节点\n\n   这些节点的`tag`都会在这一次操作中被下放，即答案没变\n\n3. 第$2$类节点除了第$1$类节点之外的儿子\n\n   这些节点不会被访问，但是标记会被下放到这里。那么这些点的答案会加上`从根节点到该点的路径上，存在tag=1的节点`的方案数，设它为$f_i$，先不管怎么求\n\n4. 剩下的所有节点\n\n   无论当前操作执不执行都对它们没影响。所以它们的答案要乘$2$\n\n123类节点可以通过线段树上遍历打标记去维护，但显然第$4$类节点的答案不能直接遍历去算\n\n可以先把答案减掉`当前操作123类节点之前对答案的贡献`，把答案乘$2$，再加上`当前操作123类节点对答案的贡献`\n\n---\n\n然后考虑如何求$f_i​$，依旧分类讨论\n\n* 所有满足$x\\le l, r\\le y$的节点（不要求被访问）。也就是$1$类节点以及它们的所有后代\n\n  显然这些节点当前到根的路径上存在`tag=1`的节点\n\n  这些点的$f$ 加上$2^{k-1}$\n\n* 上面的第$2​$类节点\n\n  显然所有根到它路径上的`tag`在这一次之后都被下放，$f$值不变\n\n* 其他所有节点\n\n  这次操作对它们没有影响，$f$值乘$2​$\n\n求$f​$的部分依旧是线段树上打加法乘法标记来维护\n\n---\n\n代码也许(?)比较清晰\n\n\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int Maxn = 1e5 + 100;\nconst int Mod = 998244353;\n\ninline void Add (int &a, int b) { if ((a += b) >= Mod) a -= Mod; }\ninline void Mul (int &a, int b) { a = (LL) a * b % Mod; }\n\nint N, M, ans;\n\nnamespace SEG\n{\n#define mid ((l + r) >> 1)\n#define ls root << 1\n#define rs root << 1 | 1\n#define lson ls, l, mid\n#define rson rs, mid + 1, r\n\n\tstruct info\n\t{\n\t\tint val, val_mul;\n\t\tint f, f_add, f_mul;\n\t} node[Maxn << 2];\n\n\tinline void build (int root, int l, int r)\n\t{\n\t\tnode[root].val_mul = node[root].f_mul = 1;\n\t\tif (l == r) return ;\n\t\telse build (lson), build (rson);\n\t}\n\n\tinline void push_val_mul (int root, int x)\n\t{\n\t\tMul (node[root].val, x);\n\t\tMul (node[root].val_mul, x);\n\t}\n\n\tinline void push_f_add (int root, int x)\n\t{\n\t\tAdd (node[root].f, x);\n\t\tAdd (node[root].f_add, x);\n\t}\n\n\tinline void push_f_mul (int root, int x)\n\t{\n\t\tMul (node[root].f, x);\n\t\tMul (node[root].f_mul, x);\n\t\tMul (node[root].f_add, x);\n\t}\n\n\tinline void push_down (int root)\n\t{\n\t\tif (node[root].val_mul != 1)\n\t\t{\n\t\t\tpush_val_mul (ls, node[root].val_mul),\n\t\t\tpush_val_mul (rs, node[root].val_mul);\n\t\t\tnode[root].val_mul = 1;\n\t\t}\n\n\t\tif (node[root].f_mul != 1)\n\t\t{\n\t\t\tpush_f_mul (ls, node[root].f_mul),\n\t\t\tpush_f_mul (rs, node[root].f_mul);\n\t\t\tnode[root].f_mul = 1;\n\t\t}\n\n\t\tif (node[root].f_add)\n\t\t{\n\t\t\tpush_f_add (ls, node[root].f_add),\n\t\t\tpush_f_add (rs, node[root].f_add);\n\t\t\tnode[root].f_add = 0;\n\t\t}\n\t}\n\n\tinline int update (int root, int l, int r, int x, int y, int pow2)\n\t{\n\t\tif (r < x || y < l)\n\t\t{\n\t\t\tAdd (ans, Mod - node[root].val);\n\t\t\t\n\t\t\tAdd (node[root].val, node[root].f);\n\t\t\tpush_f_mul (root, 2);\n\t\t\tMul (node[root].val_mul, 2);\n\n\t\t\treturn node[root].val;\n\t\t}\n\n\t\tif (x <= l && r <= y)\n\t\t{\n\t\t\tAdd (ans, Mod - node[root].val);\n\n\t\t\tAdd (node[root].val, pow2);\n\t\t\tpush_f_add (root, pow2);\n\t\t\tMul (node[root].val_mul, 2);\n\n\t\t\treturn node[root].val;\n\t\t}\n\n\t\tpush_down (root);\n\t\tint sum = node[root].val; Add (ans, Mod - node[root].val);\n\t\t\n\t\tAdd (sum, update (lson, x, y, pow2));\n\t\tAdd (sum, update (rson, x, y, pow2));\n\t\t\n\t\treturn sum;\n\t}\n\n#undef mid \n#undef ls \n#undef rs\n#undef lson\n#undef rson\n}\n\ninline void Solve ()\n{\n\tSEG :: build (1, 1, N);\n\tint sum = 1;\n\twhile (M--)\n\t{\n\t\tint op = read<int>();\n\t\tif (op == 1)\n\t\t{\n\t\t\tint l = read<int>(), r = read<int>();\n\n\t\t\tint now_ans = SEG :: update (1, 1, N, l, r, sum);\n\n\t\t\tans = (2ll * ans % Mod + now_ans) % Mod;\n\t\t\tsum = (LL) sum * 2 % Mod;\n\t\t}\n\t\telse printf(\"%d\\n\", ans);\n\t}\n}\n\ninline void Input ()\n{\n\tN = read<int>(), M = read<int>();\n}\n\nint main()\n{\n\n#ifndef ONLINE_JUDGE\n\tfreopen(\"A.in\", \"r\", stdin);\n\tfreopen(\"A.out\", \"w\", stdout);\n#endif\n\n\tInput ();\n\tSolve ();\n\n\treturn 0;\n}\n\n```\n\n","categories":["Problem"],"tags":["线段树","数据结构"]},{"title":"「CF1137F」Matches Are Not a Child's Play - LCT + 树状数组","url":"/2019/03/31/%E3%80%8CCF1137F%E3%80%8DMatches-Are-Not-a-Child%E2%80%99s-Play-LCT-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/","content":"\n一棵 $n$ 个点的树，点权最初为 $1 \\sim n$ 的排列。\n\n定义一个删点过程: 每次找到权值最小的叶子,删去它以及连接的边，重复这个过程直到剩下一个点，然后删去最后的点。\n\n处理 $q$ 个询问:\n\n* 将一个点$x $ 的权值赋为当前最大权值 $+1$\n* 查询在删点过程中，$x$ 会是第几个被删除的\n\n$n, q \\le 2 *10^5$\n\n<!--more-->\n\n### Links\n\n[CF 1137F](<https://codeforces.com/contest/1137/problem/F>)\n\n### Solution\n\n观察到删除序列的一些性质:\n\n* 权值最大的点最后一个被删。\n* 权值最大的点为$x$，次大的为 $y$，那么序列最后一段就是 $y$ 到 $x$ 的简单路径。\n\n不难分析，一次赋值操作，不会影响非 $y \\rightarrow x$ 路径上的点的变叶子过程\n\n所以造成的影响就是将 $y \\rightarrow x$ 路径提到序列最后，其他点的顺序不变\n\n---\n\n考虑用`LCT`来维护这个过程，强制每次`LCT`的根结点都是当前全局权值最大的节点\n\n具体实现上，`LCT`维护每条实链上的所有点权值相同；用一个树状数组（下标为权值，值为这个权值的点数）来维护一个关于权值的前缀和\n\n修改操作就是`LCT`的`make_root`\n\n查询就是所有权值小于它的点数，加上它在`LCT`上的右子树大小\n\n有一点点小细节。。。\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int Maxn = 2e5 + 100;\n\nint N, Q, M, color_cnt;\nint e, Begin[Maxn], To[Maxn << 1], Next[Maxn << 1];\n\nnamespace BIT\n{\n#define lowbit(x) (x & (-x))\n\tint sum[Maxn << 1];\n\tinline void add (int x, int val) { for (; x <= M; x += lowbit(x)) sum[x] += val; }\n\tinline int query (int x) { int ans = 0; for (; x; x -= lowbit(x)) ans += sum[x]; return ans; }\n}\n\nnamespace LCT\n{\n#define fa(x) (node[x].fa)\n#define ls(x) (node[x].ch[0])\n#define rs(x) (node[x].ch[1])\n\n\tstruct info\n\t{\n\t\tint fa, ch[2], size, rev, col, tag;\n\t} node[Maxn];\n\n\tinline int is_root (int x) { return ls (fa (x)) != x && rs (fa (x)) != x; }\n\n\tinline int judge_dir (int x) { return rs (fa (x)) == x; }\n\n\tinline void connect (int x, int f, int dir) { node[f].ch[dir] = x, fa (x) = f; }\n\n\tinline void push_up (int root) { node[root].size = node[ls (root)].size + node[rs (root)].size + 1; }\n\n\tinline void push_down (int x)\n\t{\n\t\tif (node[x].rev)\n\t\t{\n\t\t\tswap (ls (x), rs (x));\n\t\t\tnode[ls (x)].rev ^= 1, node[rs (x)].rev ^= 1;\n\t\t\tnode[x].rev = 0;\n\t\t}\n\t\tif (node[x].tag)\n\t\t{\n\t\t\tnode[ls (x)].tag = node[ls (x)].col = node[x].tag;\n\t\t\tnode[rs (x)].tag = node[rs (x)].col = node[x].tag;\n\t\t\tnode[x].tag = 0;\n\t\t}\n\t}\n\n\tinline void build (int x, int f)\n\t{\n\t\tfa (x) = f, node[x].col = x;\n\n\t\tfor (int i = Begin[x]; i; i = Next[i])\n\t\t{\n\t\t\tint y = To[i];\n\t\t\tif (y == f) continue ;\n\t\t\tbuild (y, x);\n\t\t\tif (Chkmax (node[x].col, node[y].col)) rs (x) = y;\n\t\t}\n\n\t\tpush_up (x), BIT :: add (node[x].col, 1);\n\t}\n\n\tinline void rotate (int x)\n\t{\n\t\tint f = fa (x), anc = fa (f), dir_x = judge_dir (x), dir_f = judge_dir (f);\n\t\tif (!is_root (f)) node[anc].ch[dir_f] = x; fa (x) = anc;\n\t\tconnect (node[x].ch[dir_x ^ 1], f, dir_x);\n\t\tconnect (f, x, dir_x ^ 1);\n\t\tpush_up (f), push_up (x);\n\t}\n\n\tinline void splay (int x)\n\t{\n\t\tstatic int Stack[Maxn], top;\n\t\tStack[top = 1] = x;\n\t\tfor (int y = x; !is_root (y); y = fa (y)) Stack[++top] = fa (y);\n\t\twhile (top) push_down (Stack[top--]);\n\n\t\tfor (; !is_root (x); rotate (x))\n\t\t\tif (!is_root (fa (x)))\n\t\t\t\trotate (judge_dir (x) == judge_dir (fa (x)) ? fa (x) : x);\n\t}\n\n\tinline void access (int x, int col)\n\t{\n\t\tfor (int y = 0; x; y = x, x = fa (x))\n\t\t{\n\t\t\tsplay (x);\n\t\t\tBIT :: add (node[x].col, - (node[ls (x)].size + 1));\n\t\t\tBIT :: add (col, node[ls (x)].size + 1);\n\t\t\trs (x) = y, push_up (x);\n\t\t}\n\t}\n\n\tinline void make_root (int x, int col)\n\t{\n\t\taccess (x, col), splay (x);\n\t\tnode[x].tag = node[x].col = col;\n\t\tnode[x].rev ^= 1;\n\t}\n\n\tinline int query (int x) { splay (x); return BIT :: query (node[x].col - 1) + node[rs (x)].size + 1; }\n\n#undef fa\n#undef ls\n#undef rs\n}\n\ninline void add_edge (int x, int y) { To[++e] = y, Next[e] = Begin[x], Begin[x] = e; }\n\ninline void Solve ()\n{\n\tLCT :: build (N, 0);\n\n\twhile (Q--)\n\t{\n\t\tchar S[10]; scanf(\"%s\", S); int x = read<int>();\n\t\tif (S[0] == 'u') LCT :: make_root (x, ++color_cnt);\n\t\telse if (S[0] == 'w') printf(\"%d\\n\", LCT :: query (x));\n\t\telse\n\t\t{\n\t\t\tint y = read<int>();\n\t\t\tprintf(\"%d\\n\", LCT :: query (x) < LCT :: query (y) ? x : y);\n\t\t}\n\t}\n}\n\ninline void Input ()\n{\n\tN = color_cnt = read<int>(), Q = read<int>(), M = N + Q + 1;\n\tfor (int i = 1; i < N; ++i)\n\t{\n\t\tint x = read<int>(), y = read<int>();\n\t\tadd_edge (x, y), add_edge (y, x);\n\t}\n}\n\nint main()\n{\n\n#ifndef ONLINE_JUDGE\n\tfreopen(\"F.in\", \"r\", stdin);\n\tfreopen(\"F.out\", \"w\", stdout);\n#endif\n\n\tInput ();\n\tSolve ();\n\n\treturn 0;\n}\n\n```\n\n","categories":["Problem"],"tags":["Codeforces","数据结构","树状数组","LCT"]},{"title":"「CF1054F」Electric Scheme - 二分图匹配 + 网络流","url":"/2019/03/31/%E3%80%8CCF1054F%E3%80%8DElectric-Scheme-%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D-%E7%BD%91%E7%BB%9C%E6%B5%81/","content":"\n平面上有若干条线段，有红蓝两种颜色。红色线段与$X$轴平行，蓝色线段与$Y$ 轴平行，同色线段均不相交\n\n已知这些线段之间形成了$n$个交点（在端点相交也算相交）\n\n给出这些交点，求平面上至少有多少条线段，并输出任意一种方案。线段长度允许为$0$\n\n$n \\le 10^3 , x_i , y_i \\le 10^9$\n\n<!--more-->\n\n### Links\n\n[CF 1054F](<https://codeforces.com/contest/1054/problem/F>)\n\n### Solution\n\n一开始在每个交点处放两条长度为$0$的异色线段，这显然合法\n\n考虑通过连接相邻两个点来合并线段，每连接两个相邻点线段总数就减少$1$，但是显然两条异色线段可能有交\n\n于是问题转化为，保留尽量多线段，使得它们不在除端点外相交\n\n将线段视为点，冲突视为边，求出这个[二分图的最大独立集](<https://hk-cnyali.com/2019/03/29/%E3%80%8CAlgorithm%E3%80%8D%E5%9B%BE%E5%8C%B9%E9%85%8D%E7%9B%B8%E5%85%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#%E6%9C%80%E5%A4%A7%E7%8B%AC%E7%AB%8B%E9%9B%86>)即可\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int Maxn = 1000 + 100;\nconst int inf = 0x3f3f3f3f;\n\nint N;\npii A[Maxn];\n\nstruct line\n{\n\tint x1, y1, x2, y2;\n} X[Maxn], Y[Maxn];\nint cntX, cntY, ansX, ansY;\n\ninline int cmpX (pii a, pii b) { return a.x == b.x ? (a.y < b.y) : (a.x < b.x); }\ninline int cmpY (pii a, pii b) { return a.y == b.y ? (a.x < b.x) : (a.y < b.y); }\n\nint VisX[Maxn], VisY[Maxn];\n\nnamespace Dinic\n{\n\tconst int Maxn = (1000 << 1) + 100, Maxm = Maxn * Maxn + 100;\n\n\tint e = 1, Begin[Maxn], To[Maxm << 1], Next[Maxm << 1], W[Maxm << 1];\n\tint Now[Maxn], Dis[Maxn];\n\tint S, T;\n\n\tinline void add_edge (int x, int y, int z) { To[++e] = y; Next[e] = Begin[x]; Begin[x] = e; W[e] = z; }\n\n\tinline void add (int x, int y, int z) { add_edge (x, y, z), add_edge (y, x, 0); }\n\n\tqueue <int> Q;\n\n\tinline int bfs ()\n\t{\n\t\tfor (int i = S; i <= T; ++i) Dis[i] = -1;\n\t\tDis[S] = 0, Q.push (S);\n\n\t\twhile (!Q.empty())\n\t\t{\n\t\t\tint x = Q.front (); Q.pop ();\n\t\t\tfor (int i = Begin[x]; i; i = Next[i])\n\t\t\t{\n\t\t\t\tint y = To[i];\n\t\t\t\tif (W[i] <= 0 || Dis[y] != -1) continue;\n\t\t\t\tDis[y] = Dis[x] + 1;\n\t\t\t\tQ.push (y);\n\t\t\t}\n\t\t}\n\n\t\treturn Dis[T] != -1;\n\t}\n\n\tinline int dfs (int x, int now)\n\t{\n\t\tif (!now || x == T) return now;\n\n\t\tint tot = 0;\n\t\tfor (int &i = Now[x]; i; i = Next[i])\n\t\t{\n\t\t\tint y = To[i], sum = 0;\n\t\t\tif (Dis[y] == Dis[x] + 1 && W[i] > 0 && (sum = dfs (y, min (W[i], now))))\n\t\t\t{\n\t\t\t\tW[i] -= sum, now -= sum;\n\t\t\t\tW[i ^ 1] += sum, tot += sum;\n\t\t\t\tif (!now) break;\n\t\t\t}\n\t\t}\n\n\t\treturn tot;\n\t}\n\n\tinline void work ()\n\t{\n\t\tint ans = 0;\n\n\t\twhile (bfs ())\n\t\t{\n\t\t\tfor (int i = S; i <= T; ++i) Now[i] = Begin[i];\n\t\t\tans += dfs (S, inf);\n\t\t}\n\n\t\tansX = ansY = N;\n\n\t\tfor (int i = 1; i <= cntX; ++i) if (Dis[i] != -1) VisX[i] = 1, --ansX; \n\t\tfor (int i = 1; i <= cntY; ++i) if (Dis[i + cntX] == -1) VisY[i] = 1, --ansY; \n\t}\n\n\tinline void init (int _S, int _T)\n\t{\n\t\tS = _S, T = _T;\n\t\tfor (int i = 1; i <= cntX; ++i) add (S, i, 1);\n\t\tfor (int i = 1; i <= cntY; ++i) add (i + cntX, T, 1);\n\t}\n}\n\ninline void Init ()\n{\n\tsort (A + 1, A + N + 1, cmpX);\n\tfor (int i = 2; i <= N; ++i)\n\t\tif (A[i].x == A[i - 1].x)\n\t\t\tX[++cntX] = (line) {A[i - 1].x, A[i - 1].y, A[i].x, A[i].y};\n\n\tsort (A + 1, A + N + 1, cmpY);\n\tfor (int i = 2; i <= N; ++i)\n\t\tif (A[i].y == A[i - 1].y)\n\t\t\tY[++cntY] = (line) {A[i - 1].x, A[i - 1].y, A[i].x, A[i].y};\n\n\tDinic :: init (0, cntX + cntY + 1);\n\n\tfor (int i = 1; i <= cntX; ++i)\n\t\tfor (int j = 1; j <= cntY; ++j)\n\t\t\tif (Y[j].x1 < X[i].x1 && X[i].x1 < Y[j].x2 && X[i].y1 < Y[j].y1 && Y[j].y1 < X[i].y2)\n\t\t\t\tDinic :: add (i, j + cntX, 1);\n}\n\ninline void Solve ()\n{\n\tInit ();\n\tDinic :: work ();\n\n\tcout << ansY << endl;\n\tsort (A + 1, A + N + 1, cmpY);\n\tint nowY = 0, i = 1;\n\twhile (i <= N)\n\t{\n\t\tint pos = i;\n\t\twhile (A[pos + 1].y == A[pos].y && VisY[++nowY]) ++pos;\n\t\tprintf (\"%d %d %d %d\\n\", A[i].x, A[i].y, A[pos].x, A[pos].y);\n\t\ti = pos + 1;\n\t}\n\n\tcout << ansX << endl;\n\tsort (A + 1, A + N + 1, cmpX);\n\tint nowX = 0; i = 1;\n\twhile (i <= N)\n\t{\n\t\tint pos = i;\n\t\twhile (A[pos + 1].x == A[pos].x && VisX[++nowX]) ++pos;\n\t\tprintf (\"%d %d %d %d\\n\", A[i].x, A[i].y, A[pos].x, A[pos].y);\n\t\ti = pos + 1;\n\t}\n}\n\ninline void Input ()\n{\n\tN = read<int>();\n\tfor (int i = 1; i <= N; ++i) A[i].x = read<int>(), A[i].y = read<int>();\n}\n\nint main()\n{\n\n#ifndef ONLINE_JUDGE\n\tfreopen(\"F.in\", \"r\", stdin);\n\tfreopen(\"F.out\", \"w\", stdout);\n#endif\n\n\tInput ();\n\tSolve ();\n\n\treturn 0;\n}\n\n```\n\n","categories":["Problem"],"tags":["Codeforces","二分图匹配","网络流"]},{"title":"「LOJ 6401」yww与字符串 - 后缀自动机","url":"/2019/03/31/%E3%80%8CLOJ-6401%E3%80%8Dyww%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2-%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/","content":"\n有一个只包含小写字母，长度为$n$ 的字符串$S$。有一些字母是好的，剩下的是坏的。\n\n定义一个子串$S_{l..r}$是好的，当且仅当这个子串包含不超过$k$个坏的字母。\n\n求有多少个不同的满足以下要求的字符串$T$：\n\n* $T$作为$S$的子串出现过。\n* 存在一个$T$出现的位置$[l, r]$，满足$S_{l..r}$是好的\n\n$n, k\\le 10^5$\n\n<!--more-->\n\n### Links\n\n[LOJ6401](https://loj.ac/problem/6401)\n\n### Solution\n\n傻逼题，用来在考前稍微复习一下`SAM`\n\n考虑和`统计本质不同子串个数`类似的做法\n\n设$pos_i$表示以$i$为右端点，满足子串包含不超过$k$个坏字母的左端点的最小值，$len_i = i - pos_i + 1$\n\n显然对于`SAM`的每个节点，它`right集合`中所有右端点的$len$的最大值，就是这个节点所代表的子串中最长满足条件的长度，与$[minlen, maxlen]$取交集即为这个节点的答案\n\n感觉没写太清楚，反正这题比较水随便想想就会了。。。\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int Maxn = 1e5 + 100;\n\nint N, K, A[Maxn];\nchar S[Maxn], SS[Maxn];\n\nint Root[Maxn << 1], Sum[Maxn], Len[Maxn];\n\nnamespace SAM\n{\n\tint node_cnt = 1, last = 1;\n\n\tstruct info\n\t{\n\t\tint ch[27], fa, maxlen, max;\n\t} node[Maxn << 1];\n\tvector <int> G[Maxn << 1];\n\n\tinline int new_node (int pos)\n\t{\n\t\tnode[++node_cnt].maxlen = node[last].maxlen + 1;\n\t\tnode[node_cnt].max = Len[pos];\n\t\treturn node_cnt;\n\t}\n\n\tinline int extend (int c, int pos)\n\t{\n\t\tint now = new_node (pos), pre = last; last = now;\n\n\t\tfor (; pre && !node[pre].ch[c]; pre = node[pre].fa) node[pre].ch[c] = now;\n\n\t\tif (!pre) node[now].fa = 1;\n\t\telse\n\t\t{\n\t\t\tint x = node[pre].ch[c];\n\t\t\tif (node[x].maxlen == node[pre].maxlen + 1) node[now].fa = x;\n\t\t\telse\n\t\t\t{\n\t\t\t\tint y = ++node_cnt; node[y] = node[x];\n\t\t\t\tnode[y].maxlen = node[pre].maxlen + 1, node[x].fa = node[now].fa = y;\n\t\t\t\tfor (; node[pre].ch[c] == x; pre = node[pre].fa) node[pre].ch[c] = y;\n\t\t\t}\n\t\t}\n\n\t\treturn now;\n\t}\n\n\tinline void dfs (int x)\n\t{\n\t\tfor (int i = 0; i < G[x].size(); ++i)\n\t\t{\n\t\t\tint y = G[x][i];\n\t\t\tdfs (y);\n\t\t\tChkmax (node[x].max, node[y].max);\n\t\t}\n\t}\n\n\tinline void build (char *s, int n)\n\t{\n\t\tfor (int i = 1; i <= n; ++i) extend (s[i] - 'a', i);\n\t\tfor (int i = 1; i <= node_cnt; ++i) G[node[i].fa].pb (i);\n\t\tdfs (1);\n\t}\n\n\tinline int calc (int l1, int r1, int l2, int r2)\n\t{\n\t\tChkmax (l1, l2), Chkmin (r1, r2);\n\t\treturn r1 - l1 + 1;\n\t}\n\n\tinline void solve ()\n\t{\n\t\tLL ans = 0;\n\t\tfor (int i = 1; i <= node_cnt; ++i)\n\t\t{\n\t\t\tint sum = max(0, calc (node[node[i].fa].maxlen + 1, node[i].maxlen, 1, node[i].max));\n\t\t\tans += sum;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\ninline void Solve ()\n{\n\tint pos = 1;\n\tfor (int i = 1; i <= N; ++i)\n\t{\n\t\twhile (Sum[i] - Sum[pos - 1] > K) ++pos;\n\t\tLen[i] = i - pos + 1;\n\t}\n\n\tSAM :: build (S, N);\n\n\tSAM :: solve ();\n}\n\ninline void Input ()\n{\n\tscanf(\"%s\", S + 1), N = strlen (S + 1);\n\tscanf(\"%s\", SS + 1); \n\tfor (int i = 1; i <= N; ++i) A[i] = !(SS[i] - '0'), Sum[i] = Sum[i - 1] + A[i];\n\tK = read<int>();\n}\n\nint main()\n{\n\n#ifndef ONLINE_JUDGE\n\tfreopen(\"A.in\", \"r\", stdin);\n\tfreopen(\"A.out\", \"w\", stdout);\n#endif\n\n\tInput ();\n\tSolve ();\n\n\treturn 0;\n}\n```\n\n","categories":["Problem"],"tags":["后缀自动机"]},{"title":"「Algorithm」图匹配相关学习笔记","url":"/2019/03/29/%E3%80%8CAlgorithm%E3%80%8D%E5%9B%BE%E5%8C%B9%E9%85%8D%E7%9B%B8%E5%85%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"\n二分图的最大匹配，最小点覆盖，最小边覆盖，最大独立集\n\nDAG的最小路径覆盖，最小链覆盖（可相交路径覆盖），最大独立集，最长反链\n\n<!--more-->\n\n## 二分图\n\n注：此部分中$n$表示图中总点数（两部分点数的总和），$P$表示最大匹配数\n\n### 最大匹配\n\n> 选出尽量多的边，使得每个点至多是其中一条边的端点\n\n建源点汇点，从$S$向左边每个点连流量为$1$的边，右边每个点向$T$连流量为$1$的边，原图中的边流量为$1$，跑最大流\n\n显然中间部分每条边最多流量为$1$，每个点最多被一条边包含，且选出来的边最多\n\n### 最小点覆盖\n\n> 选出尽量少的点，使得每条边至少有一个端点被选出\n\n最小点覆盖$=P​$，就是最大流\n\n---\n\n不难发现上面建图的最小割就是最小点覆盖\n\n显然割掉中间的边不会比割两侧的边优，割两侧的边就代表选择相应的点\n\n同一张网络流的图中，最大匹配是利用了中间流的情况，最小点覆盖是利用了两侧割的情况，但是本质是一样的\n\n### 最小边覆盖\n\n> 选出尽量少的边，使得每个点至少是一条选出的边的端点\n\n最小边覆盖$= n-P$，就是最小割\n\n---\n\n要尽量使得选出的边贡献最大，也就是先做最大匹配\n\n匹配边每条边都会产生$2$的贡献（连接的两个点都不重复），那么这里就已经选出$P$条边，$2P​$个点了\n\n还剩下$n-2P$个点不能和其他点匹配，那么会有$n-2P​$条边\n\n总边数为$P + (n-2P) = n - P$\n\n### 最大独立集\n\n> 选出尽量多的点，使得点两两之间没有边连接\n\n最大独立集$=n-P$\n\n推论：最大点权独立集 $=$ 总权值 $-$ 最小点权覆盖集（[NOIp2018 保卫王国](<https://www.luogu.org/problemnew/show/P5024>)）\n\n---\n\n最大匹配没有选出来的所有点，它们两两之间没有连边，这里有$n-2P$个点\n\n显然，最大匹配的两个点不可能同时还向另外一侧有连边（否则最大匹配数能+1），因此最大匹配的两个点能任意再选一个，这里有$P​$个点\n\n总点数为$(n-2P) + P = n-P$\n\n---\n\nUPD另外一种理解方法\n\n最大独立集 + 最小点覆盖 = 所有点\n\n这是因为最小点覆盖把所有边都包含了，所以对于每个在最大独立集中的点，它连向的点都在最小点覆盖中\n\n这样理解的话便于输出方案，只要用最小点覆盖的做法，跑网络流的时候把两侧没有被割的点输出即可\n\n\n\n## 有向无环图(DAG)\n\n### 最小路径覆盖\n\n> 用最少的不相交路径，覆盖所有点恰好一次\n\n* 把每个点$x$拆成$x_1, x_2$，对于原图边$(x, y)$，连边$(x_1, y_2)$\n* 求最大匹配$P$，最小路径覆盖就是$n-P$\n\n---\n\n一开始每个点都独立为一条路径，在二分图中匹配就是将路径合并（即匹配的这两个点在同一条路径上）\n\n因为二分图的匹配中不能有公共点，显然这样做出来路径没有交\n\n ### 最小链覆盖（可相交路径覆盖）\n\n> 用最少的可以相交的路径，覆盖所有点至少一次\n\n先跑一遍传递闭包，然后就转化成了最小路径覆盖\n\n---\n\n这个很显然，因为在原图中两条相交的路径都能在新图中转化成不相交的\n\n### Dilworth定理\n\n> 反链：DAG中的一个点集，链上任意两个点$x$, $y$，满足 $x$ 不能到达 $y$，且 $y$ 也不能到达 $x$\n\n最长反链长度$=$最小链覆盖\n\n最长链长度$=$最小反链覆盖\n\n---\n\n证明真心没看懂\n\n","categories":["Algorithm"],"tags":["二分图匹配","网络流"]},{"title":"「九省联考 2018」林克卡特树 - 树形dp + 凸优化","url":"/2019/03/29/%E3%80%8C%E4%B9%9D%E7%9C%81%E8%81%94%E8%80%83-2018%E3%80%8D%E6%9E%97%E5%85%8B%E5%8D%A1%E7%89%B9%E6%A0%91-%E6%A0%91%E5%BD%A2dp-%E5%87%B8%E4%BC%98%E5%8C%96/","content":"\n一棵$n$个节点带边权的树，边权可能为负\n\n你可以割掉树上**恰好**$k$条边，然后任意连上边权为$0$的边\n\n求链上边权最大和\n\n$k < n\\le 3*10^5$\n\n<!--more-->\n\n### Links\n\n[LOJ 2478](<https://loj.ac/problem/2478>)\n\n\n\n### Solution\n\n不难发现题目可以转化成，选出树上恰好$k+1$条不相交路径，使得边权和最大\n\n以下用$k$代替原题中的$k+1$\n\n考虑树形dp，$f[x][i][0/1/2]$表示$x$子树中，选出$i$条链，且$x$的度数为$0/1/2$的答案\n\n显然可以凸优化，把$i$这一维去掉，在dp时多记录一个当前最优答案下选出的链的数量（用`pair`比较方便）\n\n需要注意，可能存在对于连续几个答案都相同的情况\n\n在二分的时候，只要当前选出来链的数量$\\ge k$就更新答案即可\n\n\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\ntypedef pair <LL, int> pli;\ninline pli operator + (const pli &a, const pli &b) { return mp (a.x + b.x, a.y + b.y); }\n\nconst int Maxn = 3e5 + 100;\nconst LL inf = 2e18;\n\nint N, K;\nint e, Begin[Maxn], To[Maxn << 1], Next[Maxn << 1], W[Maxn << 1];\npli Dp[3][Maxn];\n\ninline void add_edge (int x, int y, int z) { To[++e] = y; Next[e] = Begin[x]; Begin[x] = e; W[e] = z; }\n\ninline void dfs (int x, int f, LL now_ans)\n{\n\tDp[0][x] = mp (0, 0);\n\tDp[1][x] = mp (-now_ans, 1);\n\tDp[2][x] = mp (-inf, 0);\n\n\tfor (int i = Begin[x]; i; i = Next[i])\n\t{\n\t\tint y = To[i];\n\t\tif (y == f) continue ;\n\t\tdfs (y, x, now_ans);\n\n\t\tpli Max = max (Dp[0][y], max (Dp[1][y], Dp[2][y]));\n\n\t\tChkmax (Dp[2][x], Dp[2][x] + Max);\n\t\tChkmax (Dp[2][x], Dp[1][x] + Dp[1][y] + mp (W[i] + now_ans, -1));\n\n\t\tChkmax (Dp[1][x], Dp[1][x] + Max);\n\t\tChkmax (Dp[1][x], Dp[0][x] + Dp[1][y] + mp (W[i], 0));\n\n\t\tChkmax (Dp[0][x], Dp[0][x] + Max);\n\t}\n}\n\ninline pli Check (LL now_ans)\n{\n\tdfs (1, 0, now_ans);\n\tpli ans = mp (-inf, 0);\n\tfor (int i = 0; i <= 2; ++i) Chkmax (ans, Dp[i][1]);\n\treturn mp (ans.x + (LL) K * now_ans, ans.y);\n}\n\ninline void Solve ()\n{\n\tLL l = -1e6, r = 1e8, ans;\n\n\twhile (l <= r)\n\t{\n\t\tLL mid = (l + r) >> 1;\n\t\tpli now = Check (mid);\n\t\tif (now.y >= K) ans = mid, l = mid + 1;\n\t\telse r = mid - 1;\n\t}\n\n\tprintf(\"%lld\\n\", Check (ans).x);\n}\n\ninline void Input ()\n{\n\tN = read<int>(), K = read<int>() + 1;\n\tfor (int i = 1; i < N; ++i)\n\t{\n\t\tint x = read<int>(), y = read<int>(), z = read<int>();\n\t\tadd_edge (x, y, z);\n\t\tadd_edge (y, x, z);\n\t}\n}\n\nint main()\n{\n\n#ifndef ONLINE_JUDGE\n\tfreopen(\"A.in\", \"r\", stdin);\n\tfreopen(\"A.out\", \"w\", stdout);\n#endif\n\n\tInput ();\n\tSolve ();\n\n\treturn 0;\n}\n```\n\n","categories":["Problem"],"tags":["动态规划","凸优化"]},{"title":"「Summary」review","url":"/2019/03/29/%E3%80%8CSummary%E3%80%8Dreview/","content":"","categories":["Summary"],"tags":["Summary"]},{"title":"「Algorithm」凸优化/带权二分学习笔记","url":"/2019/03/25/%E3%80%8CAlgorithm%E3%80%8D%E5%87%B8%E4%BC%98%E5%8C%96-%E5%B8%A6%E6%9D%83%E4%BA%8C%E5%88%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"\n理解图像意义理解了大半天\n\n<!--more-->\n\n## Brief Introduction\n\ndp凸优化和带权二分实际上是一个东西，它用来解决一类**恰好选k个某种物品**的最优化问题\n\n这个`最优解`与`选择的物品数量`之间的关系如果用一个函数图像表示，那么这个图像是凸的。换句话说，选的物品越多时，每多选一个物品，最优解增长的速度就越慢\n\n一般而言，在具体题目中这$k​$个物品并不好直接选出（可能的状态太多或限制不好满足），但我们可以比较快速地求出**没有选择物品数量的限制**下的最优解\n\n\n\n## Algorithm\n\n考虑这样一个模型：有$n​$个物品，每个物品有一个权值（可以为负），你需要从中选出恰好$m​$个，使得选出来的物品权值和尽量大\n\n> 显然可以直接排序，但是这只是一个模型，真正题目中物品并不好直接选出。这里我们考虑一种另外的做法\n\n假设没有选择物品的限制，当每个物品的价值越大时，最优情况下选出的物品就越多；每个物品价值越小时，最优情况下选出的物品越少\n\n换句话说，把每个物品的权值都加上一个$k$，那么$k$越大，选出的物品就会越多；$k$越小，选出的物品就越少\n\n考虑这样一个做法：\n\n* 二分$k$，计算出此时无个数限制下的答案，以及得到这个答案选择了多少个物品\n\n* 用此时选出来的物品数与实际需要的物品数做比较，调整二分的边界\n\n---\n\n以上基本把凸优化的做法讲完了，感性理解一下很有道理\n\n但是，如果把问题抽象化，仅仅给出原函数是凸的这个条件，我们并不能严谨证明出`当每个物品价值越大时，最优情况下选出的物品就越多`这一重要性质\n\n其实单从这个角度考虑只能感性理解，严谨证明这个能够二分还需要从几何角度入手\n\n\n\n## 几何意义\n\n首先注意到一个显然的事情：把每个物品减去$k​$之后，在选择物品数目相同的情况下（假设为$x​$）的最优策略与原来的策略是一样的\n\n![19-3-25-1](/images/19-3-25-1.png)\n\n> 在这个图像中，横坐标表示选出的物品个数，纵坐标表示最优策略下选出来的物品价值\n>\n> 绿色的函数是原函数，紫色的函数是原函数每个点减去$kx​$之后的函数（即原函数减去一个正比例函数）\n>\n> 图中给出的是随便一个$k$的情况\n\n从图像上来看，$C$点就是当前最优策略，也就是说$y_C + k\\times x_C = y_A$\n\n设$B(0, y_C)$，那么$k_{AB} = \\frac{AC}{BC} = \\frac{k\\times x_C}{x_C} = k$，即**直线$AB$的斜率就等于$k$！**(注：这是一个语气助词，不是阶乘)\n\n此外，还有一个特别妙的性质\n\n考虑在$A, B, C$不断移动时，直线$AB$的斜率都为$k$，它是不会改变的\n\n由前面的结论我们知道，当前策略最优时，$C$是紫色函数的最高点，即$B$点的纵坐标最大\n\n整理一下信息，我们知道，最优策略下直线$AB$的斜率为$k$，截距最大，且直线与原函数有交点\n\n不难发现，**直线$AB$就是过原函数$A$点的切线斜率！**\n\n---\n\n又因为原函数是凸的，所以我们可以**二分$k$！**(注：这依旧不是阶乘)\n\n直到这里，我们才严谨证明出前面的内容，这也就是原函数需要是凸的的原因\n\n\n\n## Problem & Code\n\n咕咕咕\n\n[dis本来打算出在模拟赛中的简单上手模板题](http://172.45.33.100/demo/problem.php?id=1026)\n\n","categories":["Algorithm"],"tags":["凸优化","带权二分"]},{"title":"「Algorithm」k-d tree","url":"/2019/03/24/%E3%80%8CAlgorithm%E3%80%8Dk-d-tree/","content":"\n这个东西比较简单，复杂度又不会证（好像是假的），那就随便写一点吧\n\n<!--more-->\n\n## Brief Introduction\n\n`k-d tree`是用来解决高维空间内一些操作的数据结构，OI中一般只用二维，下面都默认指二维\n\n它大概长这样子：\n\n![19-3-24-1](/images/19-3-24-1.png)\n\n简单来说，它是一棵二叉树的结构，每个节点代表了平面上的某一个部分\n\n每次分叉的时候按照水平或竖直把当前部分分割成两半，直到平面内只剩一个点\n\n\n\n## 构建\n\n* 确定当前平面内所有点极差最大的那一维\n* 按照这一维把所有点排序，找到中点，这一步可以用`nth_element`函数实现\n* 从中点把平面分割成两部分，递归处理\n\n如果需要动态插入的话，还需要像替罪羊树一样动态拍扁重建\n\n\n\n## 应用\n\n### 最邻近查询\n\n> 这一部分好像复杂度有问题，相当于是暴力加上了一些减枝\n\n* 模拟插入的过程，找到待查点在树上哪个节点所包含的部分，用经过的点与待查点的距离更新答案\n* 回溯的时候，如果当前点的另一个儿子有可能使答案更优，则访问另一个儿子\n\n\n\n### 二维区间操作\n\n> 我感觉这个复杂度应该是对的。。。\n\n相当于把线段树扩展到二维，支持二维区间的一些操作。某些时候可以代替树套树/二维线段树，空间是$O(n)$的，更加优秀\n\n这个很好理解，与线段树几乎一模一样\n\n[代码见此](http://hk-cnyali.com/2019/03/24/%E3%80%8C%E6%A8%A1%E6%8B%9F%E8%B5%9B%E3%80%8D19-3-24%E6%A8%A1%E6%8B%9F%E8%B5%9B-Summary/)\n\n---\n\n19-9-29 UPD\n\n`KDT`的复杂度显然是错的。。。\n\n因为在递归的时候走到的节点**不一定有用**，即有可能一开始走到某个节点的时候，发现它**可能**可行，但递归到很深的地方的时候才发现不可行。这样就会浪费很多时间。所以并不是$\\log$的\n\n正因为这个原因，`KDT`在实现的时候不能这么写：\n\n```cpp\ninline void update (int o, int l, int r, pii x, pii y)\n{\n    ++node[o].sum;\n\tif (blabla) return ;\n    update (lson), update (rson);\n}\n```\n\n而应该这么写：\n\n```cpp\ninline void update (int o, int l, int r, pii x, pii y)\n{\n    if (blabla) return ;\n    if (balbla) return void (++node[o].sum);\n    update (lson), update (rson);\n    push_up (o);\n}\n```\n\n\n\n","categories":["Algorithm"],"tags":["数据结构","k-d tree"]},{"title":"「模拟赛」19.3.24模拟赛 - Summary","url":"/2019/03/24/%E3%80%8C%E6%A8%A1%E6%8B%9F%E8%B5%9B%E3%80%8D19-3-24%E6%A8%A1%E6%8B%9F%E8%B5%9B-Summary/","content":"","categories":["Summary"],"tags":["Summary","线段树","数据结构","线段树合并","bitset","k-d tree"]},{"title":"「模拟赛」19.3.23模拟赛 - Summary","url":"/2019/03/24/%E3%80%8C%E6%A8%A1%E6%8B%9F%E8%B5%9B%E3%80%8D19-3-23%E6%A8%A1%E6%8B%9F%E8%B5%9B-Summary/","content":""},{"title":"「模拟赛」19.3.21模拟赛 - Summary","url":"/2019/03/22/%E3%80%8C%E6%A8%A1%E6%8B%9F%E8%B5%9B%E3%80%8D19-3-21%E6%A8%A1%E6%8B%9F%E8%B5%9B-Summary/","content":"","categories":["Summary"],"tags":["Summary","单调栈","线段树","毒瘤","扫描线","交互","分类讨论"]},{"title":"「模拟赛」19.3.20模拟赛 - Summary","url":"/2019/03/20/%E3%80%8C%E6%A8%A1%E6%8B%9F%E8%B5%9B%E3%80%8D19-3-20%E6%A8%A1%E6%8B%9F%E8%B5%9B-Summary/","content":"","categories":["Summary"],"tags":["构造","线段树","数据结构","并查集","扫描线","ST表","找规律"]},{"title":"「Codeforces」一些题","url":"/2019/03/19/%E3%80%8CCodeforces%E3%80%8D%E4%B8%80%E4%BA%9B%E9%A2%98/","content":"\n最近做的一些别人都一眼秒掉的题\n\n近几场CF里一些别人都一眼秒掉的题\n\n里面没有代码，代码可以见CF提交记录\n\n<!--more-->\n\n### [CF1137A Skyscrapers](https://codeforces.com/contest/1137/problem/A)\n\n#### Description\n\n给定一个$n*m$的网格，每个格子里都有一个数，对于任意一行和任意一列\n\n要求把这$n+m-1$个数重新用正整数编号，并且对于这一行，数与数之间的大小关系不变，对于这一列同理\n\n求出任意一行和任意一列编号使用的最大编号的最小值。\n\n$n, m\\le 1000$\n\n#### Solution\n\n每一行每一列分别离散，并记录离散之后的值，每次看是选行的值作为最终的值还是列的值作为最终的值，分别算一下即可\n\n\n\n### [CF1137B Camp Schedule](https://codeforces.com/contest/1137/problem/B)\n\n#### Description\n\n给出两个01串$S$和$T$\n\n把$S$打乱顺序，使得$T$在$S$中出现的次数最多\n\n$|S|, |T|\\le 500000$\n\n#### Solution\n\n$S$没有什么用，只要记录下01的个数。对于$T$跑一下`KMP`，每次跳`fail`贪心放就行了\n\n\n\n### [CF1137D Cooperative Game](https://codeforces.com/contest/1137/problem/D)\n\n#### Description\n\n交互题\n\n有一张图是由一个长度为$t$的链和一个大小为$c$的环中间连上一条边组成的\n\n假设环与链交界的位置为$T$，链的左端点为$S$\n\n现在在$S$处有$10$个棋子，编号$0-9$，每次你可以让任意数量的棋子向出边方向走一步，交互库会返回若干个集合，每一个集合内的棋子都在同一个位置上，并且这个位置上的所有棋子都在这个集合中\n\n现在你既不知道$t$也不知道$c$。你需要使用不超过$3(t+c)$次操作使得所有棋子都移动到$T$位置上并且返回交互库`done`。\n\n![19-3-19-2](/images/19-3-19-2.png)\n\n#### Solution\n\n好妙的一道题\n\n首先考虑类似`floyd判圈`的做法，移动两个棋子，分别以`1步/轮`和`1步/2轮`的速度往前走，一直走到两个棋子相遇为止\n\n注意到，当第二个棋子走了$2t$轮到达$T$点时，那么第一个棋子肯定会走到环上`从T开始逆时针标号的`$t$位置\n\n所以第一个棋子还需要走$c-t$步才能追上第二个棋子，追上的位置为$c-t$\n\n那么追上之后，这两个点距离$T$点还有$t$步，剩下的点距离$T$点也还有$t$步，把所有棋子都移动$t$步即可\n\n\n\n### [CF1137E Train Car Selection](https://codeforces.com/contest/1137/problem/E)\n\n#### Descrption\n\n你有一列有$n$个车厢的火车，从车头开始$1-n$编号，一开始所有车厢的价值都是$0$(包括中途加入的车厢)\n\n有$m$次操作，分为$3$种：\n\n* 在车头位置加入$k$节车厢\n* 在车尾位置加入$k$节车厢\n* 修改每节车厢的价值：每次修改会给定$s,b$，如果当前车厢是从车头开始数的第$i$节，那么它的价值就会加上$(i-1)*s+b$\n\n在每次操作结束之后回答价值最小的车厢的编号以及其价值。如果有多个输出编号最小的那个\n\n$n\\le10^9, m\\le 300000$\n\n#### Solution\n\n首先发现每次加进来的一段车厢只有最左边的那个可能成为答案；且如果在前端插入一段，那么后面全部都没用了，可以直接丢掉\n\n接下来考虑每次往后面加一个点的情况\n\n显然，如果$a$在$b$的左下方（$x_a < x_b, y_a < y_b$），那么无论什么时候$a$一定比$b​$优\n\n那么**可能**成为最优解的点的坐标一定是单调下降的\n\n考虑横坐标位于$A$和$C$之间的$B$，它如果要成为最优解要满足什么条件\n\n![19-3-19-1](/images/19-3-19-1.png)\n\n假设当前加上的是一条$y=kx+b$的直线\n\n那么$\\Delta y_B  - \\Delta y_A = k(x_B - x_A)$，也就说明$B$比$A$多增加了$k(x_B - x_A)$。它必须小于$y_A - y_B$，$B$点才会更优\n\n于是$\\displaystyle k(x_B - x_A) < y_A - y_B \\Rightarrow k < -k_{AB}$\n\n类似地，若$B$比$C$优的话就要满足$k > -k_{BC}$\n\n注意到，若$B$不在左下凸壳上的话（图中所示情况），则$k_{AB}> k_{BC}$，此时$k$无解\n\n因此，只有左下凸壳上的点才**有可能**成为最优解，单调栈维护一下即可\n\n\n\n### [CF1120A Diana and Liana](https://codeforces.com/contest/1120/problem/A)\n\n#### Description\n\n给定一个长度为$m$的序列，你可以从中删去不超过$m-n*k$个元素，剩下的元素从左往右每$k$个一组，最后一组可以不满\n\n给定你一个大小为$|S|$的可重集，要求你分出的组中至少有一组构成的可重集包含了给定的可重集。\n\n构造一种符合条件的删数方案。\n\n$n,m,k,|S|\\le5*10^5$\n\n#### Solution\n\n考虑对于每一个右端点求出一个最大的左端点恰好包含集合$S$，显然可以用`two pointers`做到$O(n)$，然后判断这个区间$[l, r]$是否合法\n\n这里调了我一年，最后看了yyb博客，强制$r-l+1\\ge k$之后就过了。。。\n\n\n\n### [CF1120C Compress String](https://codeforces.com/contest/1120/problem/C)\n\n#### Description\n\n给出一个串$S$，你需要把它进行划分\n\n有两种划分方式：要么是一个字符成一组，代价是$a$；要么是$[l,r]$划分一组，要求$[l,r]$是$[1,l−1]$的一个子串，代价是$b$。\n\n求最小代价。\n\n$|S|\\le 5000$\n\n#### Solution\n\n建`SAM`直接刷表dp即可\n\n\n\n### [CF1136E Nastya Hasn't Written a Legend](https://codeforces.com/contest/1136/problem/E)\n\n#### Description\n\n给你一个长度为$n$的序列$a_1\\sim a_n$和一个长度为$n-1$的序列$k_{1}\\sim k_{n-1}$\n\n有$q$次操作，分为两种\n\n* 给第$x$个数$+y$ 然后对于$i \\ge x$执行一段连续操作：$a_{i+1} = max\\{a_{i+1}, a_i + k_i\\}$  \n* 查询区间和\n\n#### Solution\n\n显然每次有效的`Chkmax`操作只会是从$x$开始的一段连续区间，区间的右端点可以二分得到，接下来考虑如何维护这个东西\n\n发现题目的限制可以转化为这样：\n$$\na_1\\le a_2 - k_1\\le a_3 - k_1 - k_2 \\le \\dots\\le a_n - \\sum_{i=1}^{n-1}k_i\n$$\n于是对于每个$i$，直接用线段树维护这个$a_i - \\sum_{j=1}^{i-1}k_j$即可，每次修改都是`区间set(赋值)`操作\n\n","categories":["Problem"],"tags":["动态规划","单调栈","线段树","数据结构","KMP","字符串","two pointers","交互","后缀自动机"]},{"title":"「Algorithm」Hall定理","url":"/2019/03/18/%E3%80%8CAlgorithm%E3%80%8DHall%E5%AE%9A%E7%90%86/","content":"\n`Hall定理`学习笔记\n\n<!--more-->\n\n## Brief Introdutcion\n\n`Hall 定理`是二分图匹配的一个定理，用于判断二分图是否存在完美匹配\n\n似乎它通常会作为一个工具和其他算法相结合，但是目前网络流水平还太差，没做过什么题。。。\n\n## Definition\n\n设二分图$G = (V_1, V_2, E )​$中$|V_1| = m \\le |V_2| = n​$，设$M(S)​$表示与$S​$中的点相邻（有边相连）的点集\n\n$G$中存在完美匹配当且仅当对于任意点集$S\\subset V_1$，都有$|M(S)|\\ge |S|$\n\n换句话来说，在左边任选$k$个点，在右边与它们相邻的点至少有$k$个\n\n## Proof\n\n### 必要性\n\n连出去的边数都不足点数，显然匹配不了\n\n### 充分性\n\n考虑反证\n\n假设存在一个满足`Hall定理`的二分图，且不存在完美匹配\n\n那么左边肯定存在一个未匹配的点$x$。根据`Hall定理`，它至少和右边的一个点$y$有连边\n\n* 若$y$ 没匹配过，那显然$x$和$y$可以匹配，矛盾\n* 若$y$匹配了，设$y$和左边的$z$点匹配，根据`Hall`定理，点集$\\{x, y\\}$与右边至少有两个点有连边，假设除了$y$之外的那个点为$p$\n  * 若$p$没匹配过， $\\dots\\dots$\n  * 若$p$匹配了，$\\dots\\dots$\n\n如此反复，就能找到一条增广路了，于是矛盾\n\n","categories":["Algorithm"],"tags":["二分图匹配","网络流","Hall定理"]},{"title":"「Algorithm」欧拉回路","url":"/2019/03/18/%E3%80%8CAlgorithm%E3%80%8D%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF/","content":"\n欧拉回路学习笔记\n\n<!--more-->\n\n## 一些定义\n\n### 欧拉路径\n\n图中的某一条路径经过每条**边**恰好一次，则该路径称为欧拉路径\n\n> 注：哈密顿路径：图中的某一条路径经过每个**点**恰好一次\n\n### 欧拉回路\n\n一条闭合的欧拉路径\n\n不难发现，欧拉回路一定是形如若干个环套在一起\n\n![19-3-18-2](/images/19-3-18-2.png)\n\n当然，还可以再多两个“线头“出来\n\n\n\n## 判定\n\n### 欧拉路径\n\n1. 图连通\n2. * 无向图：奇点数为0或2，并且这两个奇点其中一个为起点另外一个为终点\n   * 有向图：可以存在两个点，其入度不等于出度，其中一个入度比出度大1，为路径的起点；另外一个出度比入度大1，为路径的终点\n\n### 欧拉回路\n\n1. 图连通\n2. * 无向图：奇点数为0\n   * 有向图：每个点的入度等于出度\n\n\n\n## 求出一条欧拉回路\n\n上面的图已经很形象地展示了，欧拉回路是形如若干个环套一起的\n\n那么考虑用一个栈在dfs过程中来存这个欧拉回路，具体流程如下（直接上代码了）：\n\n``` cpp\ninline void dfs (int x)\n{\n\tfor (int &i = Begin[x]; i; i = Next[i])\n\t{\n\t\tint y = To[i];\n\t\tif (Vis[i >> 1]) continue;\n\t\tVis[i >> 1] = 1;\n\t\tdfs (y);\n\t}\n\tidfn[++dfs_clock] = x;\n}\n```\n\n每走过一条边的时候把这条边标记一下，一直走到不能走为止（即走到了某个环的终点），最后取dfs后序遍历\n\n注意要加当前弧优化，否则可能会被卡\n\n","categories":["Algorithm"],"tags":["欧拉回路"]},{"title":"「模拟赛」19.3.18模拟赛 - Summary","url":"/2019/03/18/%E3%80%8C%E6%A8%A1%E6%8B%9F%E8%B5%9B%E3%80%8D19-3-18%E6%A8%A1%E6%8B%9F%E8%B5%9B-Summary/","content":"","categories":["Summary"],"tags":["二分图匹配","网络流","欧拉回路","交互","Hall定理"]},{"title":"「模拟赛」19.3.17模拟赛 - Summary","url":"/2019/03/17/%E3%80%8C%E6%A8%A1%E6%8B%9F%E8%B5%9B%E3%80%8D19-3-17%E6%A8%A1%E6%8B%9F%E8%B5%9B-Summary/","content":"","categories":["Summary"],"tags":["Summary","KMP","字符串","高斯消元","后缀自动机","广义后缀自动机"]},{"title":"「模拟赛」19.3.15模拟赛 - Summary","url":"/2019/03/15/%E3%80%8C%E6%A8%A1%E6%8B%9F%E8%B5%9B%E3%80%8D19-3-15%E6%A8%A1%E6%8B%9F%E8%B5%9B-Summary/","content":"","categories":["Summary"],"tags":["Summary","tarjan","线段树","set","概率和期望","矩阵快速幂","FFT"]},{"title":"「HNOI2016」大数 - 莫队","url":"/2019/03/13/%E3%80%8CHNOI2016%E3%80%8D%E5%A4%A7%E6%95%B0-%E8%8E%AB%E9%98%9F/","content":"\n给出一个长度为$n$，只由数字构成的字符串$S$，给出一个质数$P$\n\n有$m$次询问，每次询问区间$[l, r]$中有多少个子串是$P$的倍数（包括$0$）\n\n$n, m\\le 10^5$\n\n<!--more-->\n\n## Links\n\n[LOJ 2053](https://loj.ac/problem/2053)\n\n## Solution\n\n考虑莫队，先考虑把条件转化成只和$l, r$有关的东西\n\n设$num_i$表示$S$串中以第$i$位开始的后缀所对应的数字\n\n那么条件可以转化成：$\\displaystyle \\frac{num_l - num_{r + 1}}{10^{r - l + 1}} \\equiv 0 \\pmod {P}$\n\n* 若$P$不为$2$或$5$：\n  $$\n  num_l - num_{r+1} \\equiv 0\\pmod P\\\\\n  \\Rightarrow num_l \\equiv num_{r+1}\\pmod P\n  $$\n  预处理下$num_i$在模$P$意义下的值，莫队随便搞搞就可以了\n\n* 若$P$为$2$或$5$：\n\n  只需要判末位数是否为$P$的倍数，莫队再随便搞搞就行了\n\n## Code\n\n```cpp\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/hash_policy.hpp>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int Maxn = 1e5 + 100;\n\nint BLOCK;\nint N, M, P, Belong[Maxn], A[Maxn];\nchar S[Maxn];\n\nstruct query\n{\n\tint l, r, id;\n} Q[Maxn];\n\n\ninline int cmp (query a, query b)\n{\n\tif (Belong[a.l] == Belong[b.l]) return (Belong[a.l] & 1) ? (a.r < b.r) : (a.r > b.r);\n\treturn Belong[a.l] < Belong[b.l];\n}\n\ninline void Init ()\n{\n\tBLOCK = sqrt (N);\n\tfor (int i = 1; i <= N; ++i) Belong[i] = (i - 1) / BLOCK + 1;\n\tsort (Q + 1, Q + M + 1, cmp);\n}\n\nnamespace Sub1\n{\n\tinline void init ()\n\t{\n\t\tint sum = 0, pow10 = 1;\n\t\tfor (int i = N; i >= 1; --i)\n\t\t{\n\t\t\tsum = (sum + (LL) pow10 * (S[i] - '0') % P) % P;\n\t\t\tA[i] = sum;\n\t\t\tpow10 = (LL) pow10 * 10 % P;\n\t\t}\n\t}\n\n\t__gnu_pbds :: gp_hash_table <int, LL> Map;\n\tLL ans;\n\tint Vis[Maxn];\n\n\tinline void Update (int l, int r, int op)\n\t{\n\t\tif (op)\n\t\t{\n\t\t\tif (!Vis[r]) ++Map[A[r]], ans += Map[A[r + 1]];\n\t\t\telse ans -= Map[A[r + 1]], --Map[A[r]];\n\t\t\tVis[r] ^= 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (!Vis[l]) ans += Map[A[l]] + (A[l] == A[r + 1]), ++Map[A[l]];\n\t\t\telse --Map[A[l]], ans -= Map[A[l]] + (A[l] == A[r + 1]);\n\t\t\tVis[l] ^= 1;\n\t\t}\n\t}\n\n\tLL Ans[Maxn];\n\n\tinline void solve ()\n\t{\n\t\tinit ();\n\n\t\tint l = 1, r = 0;\n\t\tfor (int i = 1; i <= M; ++i)\n\t\t{\n\t\t\twhile (r < Q[i].r) Update (l, ++r, 1);\n\t\t\twhile (l > Q[i].l) Update (--l, r, 0);\n\t\t\twhile (r > Q[i].r) Update (l, r--, 1);\n\t\t\twhile (l < Q[i].l) Update (l++, r, 0);\n\t\t\tAns[Q[i].id] = ans;\n\t\t}\n\n\t\tfor (int i = 1; i <= M; ++i) printf(\"%lld\\n\", Ans[i]);\n\t}\n}\n\nnamespace Sub2\n{\n\tinline void init ()\n\t{\n\t\tfor (int i = 1; i <= N; ++i) A[i] = S[i] - '0';\n\t}\n\n\tLL ans, cnt;\n\tint Vis[Maxn];\n\n\tinline void Update (int l, int r, int op)\n\t{\n\t\tif (op)\n\t\t{\n\t\t\tif (!Vis[r]) { if (!(A[r] % P)) ans += r - l + 1, ++cnt; }\n\t\t\telse { if (!(A[r] % P)) ans -= r - l + 1, --cnt; }\n\t\t\tVis[r] ^= 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (!Vis[l]) cnt += !(A[l] % P), ans += cnt;\n\t\t\telse ans -= cnt, cnt -= !(A[l] % P);\n\t\t\tVis[l] ^= 1;\n\t\t}\n\t}\n\n\tLL Ans[Maxn];\n\n\tinline void solve ()\n\t{\n\t\tinit ();\n\n\t\tint l = 1, r = 0;\n\t\tfor (int i = 1; i <= M; ++i)\n\t\t{\n\t\t\twhile (r < Q[i].r) Update (l, ++r, 1);\n\t\t\twhile (l > Q[i].l) Update (--l, r, 0);\n\t\t\twhile (r > Q[i].r) Update (l, r--, 1);\n\t\t\twhile (l < Q[i].l) Update (l++, r, 0);\n\t\t\tAns[Q[i].id] = ans;\n\t\t}\n\n\t\tfor (int i = 1; i <= M; ++i) printf(\"%lld\\n\", Ans[i]);\n\t}\n}\n\ninline void Solve ()\n{\n\tInit ();\n\tif (P != 2 && P != 5) Sub1 :: solve ();\n\telse Sub2 :: solve ();\n}\n\ninline void Input ()\n{\n\tP = read<int>();\n\tscanf(\"%s\", S + 1); N = strlen(S + 1);\n\tM = read<int>();\n\tfor (int i = 1; i <= M; ++i) Q[i].l = read<int>(), Q[i].r = read<int>(), Q[i].id = i;\n}\n\nint main()\n{\n\n#ifndef ONLINE_JUDGE\n\tfreopen(\"A.in\", \"r\", stdin);\n\tfreopen(\"A.out\", \"w\", stdout);\n#endif\n\n\tInput ();\n\tSolve ();\n\n\treturn 0;\n}\n\n```\n\n","categories":["Problem"],"tags":["莫队","省选"]},{"title":"「HNOI2016」序列 - 莫队 + ST表 + 单调栈","url":"/2019/03/13/%E3%80%8CHNOI2016%E3%80%8D%E5%BA%8F%E5%88%97-%E8%8E%AB%E9%98%9F-ST%E8%A1%A8-%E5%8D%95%E8%B0%83%E6%A0%88/","content":"\n给出一个长度为$n$的序列$a_i$\n\n有$q$次询问，每次给出$[l, r]$，求$\\displaystyle \\sum_{i=l}^{r}\\sum_{j=i}^{r}\\min_{k=i}^{j}a_k$\n\n$n, q\\le 10^5, |a_i|\\le 10^9$\n\n<!--more-->\n\n## Links\n\n[LOJ 2051](https://loj.ac/problem/2051)\n\n## Solution\n\n考虑莫队，考虑从$[l, r-1]$转移到$[l, r]$答案的变化\n\n新加进来的子串肯定都是以$r​$结尾的子串，那么新加的答案就是$\\displaystyle \\sum_{i=l}^{r}\\min_{j=i}^{r}a_j​$\n\n也就是要求区间$[l, r], [l + 1, r], [l + 2, r] \\dots ,[r, r]​$的最小值的和\n\n考虑区间中每个值对答案的贡献，假设下标为$i​$的数左边第一个比它小的数为$x_i​$，右边第一个比它小的数为$y_i​$，那么区间$[\\max\\{x_i, l\\}, \\min\\{y_i, r\\}]​$的最小值都是它\n\n先用单调栈求出$x_i, y_i$，设$sumL_i$表示以$1$为左端点，$1, 2, \\dots ,i$为右端点区间最小值的和\n\n显然这个贡献是一段一段的，因此可以用前缀和优化\n\n最后算答案的时候先用`ST表`求出区间$[l, r]$的最小值的位置$p$，那么新加的答案就是$a_p * (p - l + 1) + sumL_{r} - sumL_{p}$\n\n## Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int Maxn = 100000 + 100;\n\nint BLOCK;\n\nint N, M;\nint A[Maxn], Belong[Maxn];\npair <pii, int> Q[Maxn];\n\nnamespace ST\n{\n\tint Log[Maxn];\n\tpii Min[20][Maxn];\n\n\tinline void init ()\n\t{\n\t\tfor (int i = 2; i <= N; ++i) Log[i] = Log[i >> 1] + 1;\n\t\tfor (int i = 1; i <= N; ++i) Min[0][i] = mp (A[i], i); \n\t\tfor (int j = 1; j <= Log[N]; ++j)\n\t\t\tfor (int i = 1; i <= N - (1 << j) + 1; ++i)\n\t\t\t\tMin[j][i] = min (Min[j - 1][i], Min[j - 1][i + (1 << (j - 1))]);\n\t}\n\n\tinline int query (int l, int r)\n\t{\n\t\tint k = Log[r - l + 1];\n\t\treturn min (Min[k][l], Min[k][r - (1 << k) + 1]).y;\n\t}\n}\n\ninline int cmp (pair <pii, int> a, pair <pii, int> b)\n{\n\tif (Belong[a.x.x] == Belong[b.x.x]) return (Belong[a.x.x] & 1) ? (a.x.y < b.x.y) : (a.x.y > b.x.y);\n\treturn Belong[a.x.x] < Belong[b.x.x];\n}\n\nint L[Maxn], R[Maxn], Stack[Maxn], top;\nLL SumL[Maxn], SumR[Maxn];\n\ninline void Init ()\n{\n\tST :: init ();\n\n\tfor (int i = 1; i <= N; ++i) Belong[i] = (i - 1) / BLOCK + 1;\n\tsort (Q + 1, Q + M + 1, cmp);\n\n\tA[0] = -0x3f3f3f3f, Stack[++top] = 0;\n\tfor (int i = 1; i <= N; ++i)\n\t{\n\t\twhile (top && A[Stack[top]] >= A[i]) --top;\n\t\tL[i] = Stack[top];\n\t\tStack[++top] = i;\n\t}\n\n\ttop = 0;\n\tA[N + 1] = -0x3f3f3f3f, Stack[++top] = N + 1;\n\tfor (int i = N; i >= 1; --i)\n\t{\n\t\twhile (top && A[Stack[top]] >= A[i]) --top;\n\t\tR[i] = Stack[top];\n\t\tStack[++top] = i;\n\t}\n\n\tfor (int i = 1; i <= N; ++i) SumL[i] = SumL[L[i]] + (LL) A[i] * (i - L[i]);\n\tfor (int i = N; i >= 1; --i) SumR[i] = SumR[R[i]] + (LL) A[i] * (R[i] - i);\n}\n\nLL ans;\nint Vis[Maxn];\n\ninline void Update (int l, int r, int op)\n{\n\tint pos = ST :: query (l, r);\n//\tcout << l << ' ' << r << ' ' << pos << endl;\n\tif (op)\n\t{\n\t\tLL sum = (LL) A[pos] * (pos - l + 1) + SumL[r] - SumL[pos];\n\t\tif (!Vis[r]) ans += sum;\n\t\telse ans -= sum;\n\t\tVis[r] ^= 1;\n\t}\n\telse\n\t{\n\t\tLL sum = (LL) A[pos] * (r - pos + 1) + SumR[l] - SumR[pos];\n\t\tif (!Vis[l]) ans += sum;\n\t\telse ans -= sum;\n\t\tVis[l] ^= 1;\n\t}\n\n}\n\nLL Ans[Maxn];\n\ninline void Solve ()\n{\n\tInit ();\n\n\tint l = 1, r = 0;\n\tfor (int i = 1; i <= M; ++i)\n\t{\n\t\twhile (r < Q[i].x.y) Update (l, ++r, 1);\n\t\twhile (l > Q[i].x.x) Update (--l, r, 0);\n\t\twhile (r > Q[i].x.y) Update (l, r--, 1);\n\t\twhile (l < Q[i].x.x) Update (l++, r, 0);\n\t\tAns[Q[i].y] = ans;\n\t}\n\n\tfor (int i = 1; i <= M; ++i) printf(\"%lld\\n\", Ans[i]);\n}\n\ninline void Input ()\n{\n\tN = read<int>(), M = read<int>(), BLOCK = sqrt(N);\n\n\tfor (int i = 1; i <= N; ++i) A[i] = read<int>();\n\tfor (int i = 1; i <= M; ++i) Q[i].x.x = read<int>(), Q[i].x.y = read<int>(), Q[i].y = i;\n}\n\nint main()\n{\n\n#ifndef ONLINE_JUDGE\n\tfreopen(\"A.in\", \"r\", stdin);\n\tfreopen(\"A.out\", \"w\", stdout);\n#endif\n\n\tInput ();\n\tSolve ();\n\n\treturn 0;\n}\n\n```\n\n","categories":["Problem"],"tags":["单调栈","莫队","ST表","省选"]},{"title":"「模拟赛」19.3.12模拟赛 - Summary","url":"/2019/03/13/%E3%80%8C%E6%A8%A1%E6%8B%9F%E8%B5%9B%E3%80%8D19-3-12%E6%A8%A1%E6%8B%9F%E8%B5%9B-Summary/","content":"","categories":["Summary"],"tags":["容斥","概率和期望","整除分块","杜教筛","ex_Lucas"]},{"title":"「Algorithm」关于tarjan & 点双 & 边双","url":"/2019/03/13/%E3%80%8CAlgorithm%E3%80%8D%E5%85%B3%E4%BA%8Etarjan-%E7%82%B9%E5%8F%8C-%E8%BE%B9%E5%8F%8C/","content":"\n一个连tarjan都想不清楚的菜鸡\n\n<!--more-->\n\n## Tarjan\n\n`low[x]`表示$x$子树中的点`通过非树边`能到达的，仍在栈中的，`dfs序最靠前的点`的编号\n\n是用来求强连通分量/点双/边双最重要的一个东西\n\n下面的东西都放到`dfs树`上就很好理解了\n\n## 强连通分量\n\n有向图\n\n强连通图：任意两点互相可达\n\n强连通分量：图中的一个极大强连通子图\n\n---\n\n显然，任何一个强连通分量，必定是对原图的`dfs树`的子树。那么我们只要确定每个强连通分量的子树的根，然后根据这些根从树的最低层开始，一个一个拿出强连通分量即可\n\n```cpp\ninline void tarjan (int x)\n{\n\tStack[++top] = x, In[x] = 1;\n\tdfn[x] = low[x] = ++dfs_clock;\n    \n\tfor (int i = Begin[x]; i; i = Next[i])\n\t{\n\t\tint y = To[i];\n\t\tif (!dfn[y]) tarjan (y), Chkmin (low[x], low[y]);\n\t\telse if (In[y]) Chkmin (low[x], dfn[y]);\n\t}\n\t\n\tif (dfn[x] == low[x])\n\t{\n\t\t++scc_cnt;\n\t\twhile (1)\n\t\t{\n\t\t\tint a = Stack[top--];\n\t\t\tBelong[a] = scc_cnt, In[a] = 0;\t\t\t\t\n\t\t\tif (a == x) break;\n\t\t}\n\t}\n}\n```\n\n## 点双\n\n无向图 \n\n割点：去掉这个点后原图改变了原图的连通性\n\n点双连通图：没有割点的图\n\n点双连通分量：极大的点双连通子图\n\n* 每存在一个割点就会把图分成若干个点双，每个割点至少属于两个点双\n* 点双内的任意两点至少有两条`不经过重复点（除起点和终点）`的路径\n\n---\n\n显然，如果一个点的子树中`能返回到的最早的节点`的`dfs序`**大于等于**当前点的`dfs序`，则子树中的点走到外面去一定会经过这个点，所以去掉这个点后原图就不连通了，于是它是一个割点\n\n注意需要记录`dfs树`中的父亲节点，显然`low`值不能通过父亲节点去更新\n\n```cpp\ninline void tarjan (int x, int f)\n{\n\tdfn[x] = low[x] = ++dfs_clock, Stack[++top] = x;\n\n\tfor (int i = Begin[x]; i; i = Next[i])\n\t{\n\t\tint y = To[i];\n\t\tif (y == f) continue;\n\t\tif (!dfn[y]) tarjan(y, x), Chkmin (low[x], low[y]);\n\t\telse Chkmin (low[x], dfn[y]);\n\t}\n\n\tif (low[x] >= dfn[f])\n\t{\n\t\twhile (1)\n\t\t{\n\t\t\tint a = Stack[top--];\n\t\t\tIn[a] = 0;\n\t\t\tif (a == x) break;\n\t\t}\n\t}\n}\n```\n\n如果需要求割点的话还要特判一下根结点的情况\n\n> 左图根不是割点，右图根是割点\n\n![19-3-13-1](/images/19-3-13-1.png)\n\n处理方法：求出一个割点$x$时令`cnt[f]++`，最后看`cnt[root]`是否大于$1$即可\n\n\n\n## 边双\n\n与点双定义类似\n\n无向图 \n\n割边（桥）：去掉这条边后原图改变了原图的连通性\n\n边双连通图：没有桥的图\n\n边双连通分量：极大的边双连通子图\n\n* 每存在一个桥就会把图分成若干个边双，桥不属于任何一个边双\n* 边双可以看作原图把所有桥都去掉分成的若干个连通块\n* 边双内的任意两点至少有两条`不经过重复边`的路径\n\n------\n\n显然，边双的范围比点双要小，限制更严。只有一个点子树中`能返回到的最早的节点`的`dfs序`**大于**当前点的`dfs序`，这个点与它父亲的那条边才是桥\n\n注意需要记录父亲到它的那条**边**的编号，因为如果存在重边的话就能通过重边走到父亲节点，这是合法的。只需要保证接下来走的边不是来的那条边即可\n\n代码和点双类似，把`low[x] >= dfn[f]`改成`low[x] > dfn[f]`即可\n\n\n\n## 写法上的细节\n\n点双判断`low[x] >= dfn[f]`那里写里面外面都可以；边双只能写外面。所以干脆都写外面就好了\n\n> 因为边双如果不写外面就不能判断根节点所在的边双了，根结点那里实际上还是有一条父亲边\n\n\n\n## 应用\n\n点双和边双在应用时，往往是利用到了`任意两个点之间有两条（不经过重复点/边的）路径`这个性质\n\n* 求仙人掌中的环是缩点双（任何一条边不属于两个环中，那么一定都是简单环，但一个点可能属于两个环中）\n\n* 求仙人球（任意一个点不属于两个环中）的环是缩边双\n* 圆方树\n\n\n\n好像差不多了吧","categories":["Algorithm"],"tags":["tarjan","点双","边双","割点","桥"]},{"title":"「Algorithm」扩展Lucas学习笔记","url":"/2019/03/12/%E3%80%8CAlgorithm%E3%80%8D%E6%89%A9%E5%B1%95Lucas%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"\n本来没打算学的，既然模拟赛考到了就还是学一下吧\n\n<!--more-->\n\n## Pre-Knowledge\n\n* [ex_gcd](http://hk-cnyali.com/2019/03/12/「Algorithm」关于ex-gcd以及求解不定方程/)\n* `CRT` or [ex_CRT(合并模线性方程组)](https://hk-cnyali.com/2018/11/06/求解模线性方程组-ex-gcd/)\n* ~~A strong will~~\n\n## Brief Introduction\n\n我们都知道，`Lucas定理`是当$n,m$比较大（大于$P$）时，用来求$\\binom{n}{m}\\pmod P $，其中$P$为质数的一个工具。它长这样：\n$$\n\\binom{n}{m}\\equiv \\binom{\\lfloor{\\frac{n}{P}}\\rfloor}{\\lfloor{\\frac{m}{P}}\\rfloor}*\\binom{n\\%P}{m\\%P}\\pmod P\n$$\n\n> 把 $n$ 和 $m$ 表示成 $P$ 进制数，对 $P$进制下的每一位分别计算组合数，最后乘起来。这样递归计算的话就能保证需要求的$n,m$在$P$的范围内了\n\n但是当$P​$不为质数的时候就需要用到`扩展Lucas`了，但其实它和`Lucas`没有半毛钱关系\n\n## Analysis\n\n1. 把$p$质因数分解，即分解成$P = \\prod p_i^{k_i}$的形式，那么只需要分别求出$\\binom{n}{m} \\bmod p_i^{k_i}$，利用`CRT`或`ex_CRT`就能合并答案\n\n2. 把组合数展开：\n\n   $$\n   \\binom{n}{m} \\equiv  \\frac{n!}{m!(n-m)!} \\pmod {p_i^{k_i}}\n   $$\n   考虑把$n!,m!,(n-m)!$这三项中含$p_i$的因子提出来，变形得到\n   $$\n   \\binom{n}{m} = \\frac{\\frac{n!}{p^{a1}}}{\\frac{m!}{p^{a2}}* \\frac{(n-m)!}{p^{a3}}}* p^{a1-a2-a3}\\pmod {p_i^{k_i}}\n   $$\n   其中$a1, a2, a3$分别表示$n!,m!,(n-m)!$含$p_i$的次数\n\n3. 解决$\\frac{n!}{p^{a1}}\\pmod{p_i^{k_i}}$这个子问题，注意在计算上式的分母时需要用`ex_gcd`求逆元\n\n最后一步步往上推就行了\n\n## Process\n\n重点在于如何求$\\frac{n!}{p^{a}}\\pmod{p^{k}}​$\n\n先举一个例子吧，假设$n = 19, p = 3, k = 2$\n\n> 这里真的随便手玩一下就懂了\n\n$$\n19!=1\\times 2\\times 3\\times 4\\times 5\\times 6\\times 7\\times 8\\times 9\\times 10 \\times 11\\times 12\\times 13\\times 14\\times 15\\times 16\\times 17\\times 18\\times 19\n$$\n\n把所有$p$的倍数的项提出来：\n$$\n19!=3^6 \\times (1\\times 2\\times 3\\times 4\\times 5\\times 6)\\times(1\\times 2\\times 4\\times 5\\times 7\\times 8\\times 10 \\times 11\\times 13\\times 14\\times 16\\times 17\\times 19)\n$$\n不难注意到最后一个括号里的数在模$p^k$意义下是不断循环的，即\n$$\n19!=3^6 \\times (1\\times 2\\times 3\\times 4\\times 5\\times 6)\\times(1\\times 2\\times 4\\times 5\\times 7\\times 8)\\times (10 \\times 11\\times 13\\times 14\\times 16\\times 17)\\times 19\n$$\n很显然，$(1\\times 2\\times 4\\times 5\\times 7\\times 8)$和$(10 \\times 11\\times 13\\times 14\\times 16\\times 17)$在模$p^k$意义下相等\n\n那么\n$$\n19!=3^6 \\times 6!\\times(1\\times 2\\times 4\\times 5\\times 7\\times 8)^2\\times 19\n$$\n\n---\n\n通过上面这个例子，我们可以形式化地得出以下式子：\n$$\nn!\\equiv p^{\\lfloor \\frac{n}{p} \\rfloor}\\times \\lfloor \\frac{n}{p} \\rfloor!\\times(\\prod_{i=1}^{p^k}num_i)^{\\lfloor \\frac{n}{p^k} \\rfloor}\\times(\\prod_{i=1}^{n\\bmod {p^k}}num_i)\\pmod {p^k}\n$$\n其中$num_i$表示不含$p$因子的数字\n\n考虑每一项的意义以及如何求：\n\n* $ p^{\\lfloor \\frac{n}{p} \\rfloor}$ ：因为最后我们要求$\\frac{n!}{p^a}\\pmod{p^k}$，需要除掉$p^a$，因此可以在这里直接不乘这一项\n* $\\lfloor \\frac{n}{p} \\rfloor!$ ：直接递归求解，边界条件是$n=0$答案为$1$\n* $(\\prod_\\limits{i=1}^{p^k}num_i)^{\\lfloor \\frac{n}{p^k} \\rfloor}​$：也就是小于$p^k​$的部分循环了$\\lfloor\\frac{n}{p^k}\\rfloor​$次。可以直接暴力求出$(\\prod_{i=1}^{p^k}num_i)​$，然后做一遍快速幂\n* $(\\prod_\\limits{i=1}^{n\\bmod {p^k}}num_i)$：循环最后会剩下一部分多的，直接暴力乘起来即可\n\n\n\n## Complexity\n\n**瞎分析一波**\n\n首先分析一下求解$\\frac{n!}{p^{a}}\\pmod{p^{k}}$的复杂度\n$$\nT(n) = T(\\frac{n}{p}) + O(p^k)\n$$\n根据主定理容易得到$T(n) = O(p^k )$\n\n另外，`ex_gcd`求逆元那里还有一个$O(\\log P)​$的复杂度\n\n总复杂度为\n$$\nO\\Big(\\sum (p_i^{k_i} + \\log P)\\Big)\n$$\n\n\n## Code\n\n还没写\n\n","categories":["Algorithm"],"tags":["数学","数论","ex_gcd","ex_Lucas"]},{"title":"「Algorithm」关于ex_gcd以及求解不定方程","url":"/2019/03/12/%E3%80%8CAlgorithm%E3%80%8D%E5%85%B3%E4%BA%8Eex-gcd%E4%BB%A5%E5%8F%8A%E6%B1%82%E8%A7%A3%E4%B8%8D%E5%AE%9A%E6%96%B9%E7%A8%8B/","content":"\n`ex_gcd`这个东西从搞`OI`开始到现在好像就从来没有彻底搞清楚过，一直是迷迷糊糊背的代码，平均每几个月就要忘一次\n\n希望这一次搞了之后以后都能想清楚了吧\n\n<!--more-->\n\n## Ex_Gcd\n\n**注：为了方便，以下均用$g​$代替$\\gcd(a, b)​$**\n\n### 辗转相除法\n\n$$\n\\gcd(a, b) = \\gcd(b, a~\\mathrm{mod}~b)\n$$\n\n感性理解：$\\gcd(a, b) = \\gcd(b, a - b) = \\gcd(b, a - 2b) = \\cdots = \\gcd(b, a~\\mathrm{mod}~b)$\n\n### 求任意一组特解\n\n给出$a、b​$，求$ax + by = g​$的解\n\n由辗转相除法$\\gcd(a, b) = \\gcd(b, a~\\mathrm{mod}~b)​$，易知\n$$\nax + by = g = bx' + (a~\\mathrm{mod}~b)y'\n$$\n那么\n$$\nax + by = ay' + b(x' - \\lfloor\\frac{a}{b}\\rfloor y')\n$$\n\n\n于是\n$$\n\\begin{cases}\nx = y'\\\\\ny = x' - \\lfloor\\frac{a}{b}\\rfloor y'\n\\end{cases}\n$$\n递归求解即可，每次回溯的时候更新$x, y​$，这样就能求出一组特解\n\n\n\n### 解系扩展\n\n**这一部分一直没搞清楚**\n\n假设$x_0, x_1, y_0, y_1$均为合法解，则\n$$\na(x_0 - x_1) + b(y_0 - y_1) = 0\n$$\n于是\n$$\n(\\frac{a}{g})(x_0 - x_1) = (\\frac{b}{g})(y_0 - y_1)\n$$\n\n因为$\\gcd(\\frac{a}{g}, \\frac{b}{g}) = 1$，所以$x_0 - x_1$是$\\frac{b}{g}$的倍数。也就是说，任意两个解$x_0, x_1$都满足它们的差是$\\frac{b}{g}$的倍数。$y$的部分同理\n\n因此方程的通解$x, y$可以通过任意一组特解$x_0, y_0$表示为\n$$\n\\begin{cases}\nx = x_0 + (\\frac{b}{g})\\cdot k\\\\\\\\\ny = y_0 - (\\frac{a}{g})\\cdot k\n\\end{cases}\n~, ~k\\in R\n$$\n**因此，在求最小非负整数解时，需要$(x + (\\frac{b}{g})~\\mathrm{mod}~ (\\frac{b}{g})​$，而非$b​$！！！**\n\n也就是说，在求最小非负整数解时，直接`a /= g, b /= g`，转化成求$(\\frac{a}{g})x + (\\frac{b}{g})y = 1$的解，最后加$b$模$b$即可，不需要考虑其他问题了\n\n**或者说，在用`ex_gcd`求解最小非负整数解时，需要保证$\\gcd(a, b) = 1$，然后就能直接模$b$加$b$了**\n\n\n## Ex_Gcd求解不定方程\n\n求解$ax+by=c$的最小非负整数解\n\n---\n\n首先，$c$必须为$g$的倍数，若不是$g$的倍数则无解\n\n> $c = ax + by$，而$ax + by$显然为$g$的倍数\n\n求这个东西有两个本质相同的做法，以前一直没搞清：\n\n### Sol 1\n\n$$\n\\begin{aligned}\nax + by &= c \\\\\n\\Leftrightarrow ~~(\\frac{a}{g})x~ + (\\frac{b}{g})y~ &= (\\frac{c}{g})\\\\\n\\Rightarrow ~~(\\frac{a}{g})x' + (\\frac{b}{g})y' &= 1\\\\\n\\end{aligned}\n$$\n\n利用`ex_gcd`解出$x'$的最小非负整数解，那么$x = x' \\times (\\frac{c}{g})$\n\n### Sol2\n\n$$\n\\begin{aligned}\nax + by &= c \\\\\n\\Rightarrow ~~~~~~~~~ax'~ + by'~ &= g\\\\\n\\Leftrightarrow ~~(\\frac{a}{g})x' + (\\frac{b}{g})y' &= 1\\\\\n\\end{aligned}\n$$\n\n利用`ex_gcd`解出$x'$的最小非负整数解，那么$x = x' \\times (\\frac{c}{g})$\n\n---\n\n写出来就发现这两个做法本质相同\n\n以前没搞清楚就是因为不知道解系扩展的时候需要保证$\\gcd(a, b) = 1$，或者说乘的是$(\\frac{b}{g})$。就导致了想不清楚应该在什么时候加模取模，不知道应该加模取模哪个数，到底是$b$还是$(\\frac{b}{g})$\n\n---\n\n实际写代码的时候一般写第一种方法，拿到方程之后就把$a, b, c$除$g$变成新的$a, b, c$，然后进行`ex_gcd`，假设求出来的解为$x'$，那么原方程最小非负整数解$x = (x' \\times (\\frac{c}{g}) + b)~\\mathrm{mod}~b$即可。因为现在已经保证了$\\gcd(a, b) = 1$\n\n如果原来的方程还要用的话最后还是乘回去吧。。。","categories":["Algorithm"],"tags":["数学","数论","ex_gcd"]},{"title":"「HNOI2008」GT 考试 - KMP + 矩阵快速幂","url":"/2019/03/12/%E3%80%8CHNOI2008%E3%80%8DGT-%E8%80%83%E8%AF%95-KMP-%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/","content":"\n阿申准备报名参加 GT 考试，准考证号为 $n$位数 $X_1X_2\\cdots X_n(0\\le X_i\\le 9)$，他不希望准考证号上出现不吉利的数字。\n\n他的不吉利数字 $A_1A_2\\cdots A_m(0\\le A_i\\le 9)$有 $m$位，不出现是指 $X_1X_2\\cdots X_n$中没有恰好一段等于$A_1A_2\\cdots A_m$\n\n给出$A$，求$X$可能的方案数\n\n$n\\le10^9, m\\le20, K\\le 1000$\n\n<!--more-->\n\n### Links\n\n[LOJ 10224](https://loj.ac/problem/10224)\n\n### Solution\n\n设$f[i][j]$表示长度为$i$的串，最后$j$个可以匹配模板串前$j$位的方案数，答案为$\\sum_{i=0}^{m-1}f[n][i]$\n\n转移$f$的话可以考虑设$g[i][j]$表示模板串从前缀$i$失配后转移到前缀$j$的方案数，这个可以通过枚举下一个字符，然后用`kmp`的$next$直接暴力算\n\n那么$f[i + 1][k] = \\sum_{j=1}^{m}f[i][j]* g[j][k]$，矩阵快速幂优化即可\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int Maxn = 20 + 5;\n\nint N, M, Mod;\nint Next[Maxn];\nint A[Maxn];\n\ninline void Add (int &a, int b) { if ((a += b) >= Mod) a -= Mod; }\n\nstruct Matrix\n{\n\tint A[Maxn][Maxn];\n\tinline int* operator [] (const int &x) { return A[x]; }\n\n\tinline void init ()\n\t{\n\t\tfor (int i = 0; i < M; ++i)\n\t\t\tfor (int j = 0; j < M; ++j) \n\t\t\t{\n\t\t\t\tA[i][j] = 0;\n\t\t\t\tif (i == j) A[i][j] = 1;\n\t\t\t}\n\t}\n\n\tinline Matrix operator * (const Matrix &rhs) const\n\t{\n\t\tMatrix ans;\n\t\tfor (int i = 0; i < M; ++i)\n\t\t\tfor (int j = 0; j < M; ++j)\n\t\t\t{\n\t\t\t\tans[i][j] = 0;\n\t\t\t\tfor (int k = 0;  k < M; ++k)\n\t\t\t\t\tAdd (ans[i][j], (LL)A[i][k] * rhs.A[k][j] % Mod);\n\t\t\t}\n\t\treturn ans;\n\t}\n\n} trans;\n\ninline Matrix Pow (Matrix a, int b)\n{\n\tMatrix ans; ans.init();\n\tfor (int i = b; i; i >>= 1, a = a * a) if (i & 1) ans = ans * a;\n\treturn ans;\n}\n\ninline void Init ()\n{\n\tint j = 0;\n\tfor (int i = 2; i <= M; ++i)\n\t{\n\t\twhile (j && A[j + 1] != A[i]) j = Next[j];\n\t\tif (A[j + 1] == A[i]) ++j;\n\t\tNext[i] = j;\n\t}\n\n\tfor (int i = 0; i < M; ++i)\n\t{\n\t\tfor (int j = 0; j <= 9; ++j)\n\t\t{\n\t\t\tint k = i;\n\t\t\twhile (k && A[k + 1] != j) k = Next[k];\n\t\t\tif (A[k + 1] == j) ++k;\n\t\t\t++trans[i][k];\n\t\t}\n\t}\n}\n\ninline void Solve ()\n{\n\tInit ();\n\tMatrix res = Pow (trans, N);\n\n\tint ans = 0;\n\tfor (int i = 0; i < M; ++i) Add (ans, res[0][i]);\n\tcout << ans << endl;\n}\n\ninline void Input ()\n{\n\tN = read<int>(), M = read<int>(), Mod = read<int>();\n\tchar S[Maxn];\n\tscanf(\"%s\", S + 1);\n\tfor (int i = 1; i <= M; ++i) A[i] = S[i] - '0';\n\tA[0] = 2003;\n\tA[M + 1] = 216;\n}\n\nint main()\n{\n\n#ifndef ONLINE_JUDGE\n\tfreopen(\"A.in\", \"r\", stdin);\n\tfreopen(\"A.out\", \"w\", stdout);\n#endif\n\n\tInput ();\n\tSolve ();\n\n\treturn 0;\n}\n\n```\n\n","categories":["Problem"],"tags":["KMP","字符串","矩阵快速幂"]},{"title":"「模拟赛」19.3.11模拟赛 - Summary","url":"/2019/03/11/%E3%80%8C%E6%A8%A1%E6%8B%9F%E8%B5%9B%E3%80%8D19-3-11%E6%A8%A1%E6%8B%9F%E8%B5%9B-Summary/","content":"","categories":["Summary"],"tags":["数学","分块","动态规划","概率和期望","暴力","二分","二项式定理"]},{"title":"「NOI2017」游戏 - 2-SAT","url":"/2019/03/10/%E3%80%8CNOI2017%E3%80%8D%E6%B8%B8%E6%88%8F-2-SAT/","content":"\n有三种数，$n$个位置，每个位置只能填一种数。有$d\\in[0,8]$个位置有三种选择，其他位置只有两种选择\n\n给你一些限制$(x, a, y, b)$，表示第$x$个位置选了$a$，那么第$y$个位置就必须选$b$\n\n输出一组合法的选数方案，无解输出$-1$\n\n<!--more-->\n\n### Links\n\n[LOJ 2305](https://loj.ac/problem/2305)\n\n### Solution\n\n`2-SAT`模板题\n\n先$2^d$枚举那$d$个位置**不选**哪个数，任意枚举两个即可，这样就能包括所有的三种情况\n\n每次跑一遍`2-SAT`即可\n\n 代码写的比较丑，我是一开始先把和那$d$个位置无关的边加好，每`dfs`一次加入剩下的边\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int MAXN = 50000 + 100, MAXM = 100000 + 100;\n\nint N, d, M;\nchar S[MAXN];\nint A[2][MAXN], Ban[MAXN], Buc[10];\n\nstruct edge\n{\n\tint x, a, y, b;\n} E[MAXM];\n\nint e, Begin[MAXN << 1], Next[MAXM << 2], To[MAXM << 2];\npii Save_E[MAXM << 2];\nint save_cnt;\n\ninline void add_edge (int x, int y) { Save_E[++save_cnt] = mp(x, y); To[++e] = y; Next[e] = Begin[x]; Begin[x] = e; }\n\nnamespace GRAPH\n{\n\tconst int maxn = MAXN << 1;\n\n\tint dfn[maxn], dfs_clock, low[maxn], Belong[maxn], scc_cnt;\n\tint Stack[maxn], top, In[maxn];\n\n\tinline void tarjan (int x)\n\t{\n\t\tStack[++top] = x, In[x] = 1;\n\t\tdfn[x] = low[x] = ++dfs_clock;\n\n\t\tfor (int i = Begin[x]; i; i = Next[i])\n\t\t{\n\t\t\tint y = To[i];\n\t\t\tif (!dfn[y]) tarjan (y), Chkmin (low[x], low[y]);\n\t\t\telse if (In[y]) Chkmin (low[x], dfn[y]);\n\t\t}\n\t\t\n\t\tif (dfn[x] == low[x])\n\t\t{\n\t\t\t++scc_cnt;\n\t\t\twhile (1)\n\t\t\t{\n\t\t\t\tint a = Stack[top--];\n\t\t\t\tBelong[a] = scc_cnt, In[a] = 0;\n\t\t\t\tif (a == x) break;\n\t\t\t}\n\t\t}\n\t}\n\n\tint Ans[maxn];\n\n\tinline void init ()\n\t{\n\t\tdfs_clock = scc_cnt = top = 0;\n\t\tfor (int i = 1; i <= 2 * N; ++i) dfn[i] = low[i] = Belong[i] = In[i] = 0;\n\t}\n\n\tinline void solve ()\n\t{\n\t\tinit ();\n\t\tfor (int i = 1; i <= 2 * N; ++i) if (!dfn[i]) tarjan (i);\n\n\t\tfor (int i = 1; i <= N; ++i)\n\t\t{\n\t\t\tif (Belong[i] == Belong[i + N]) return ;\n\t\t\tif (Belong[i] < Belong[i + N]) Ans[i] = A[0][i];\n\t\t\telse Ans[i] = A[1][i];\n\t\t}\n\n\t\tfor (int i = 1; i <= N; ++i)\n\t\t{\n\t\t\t//cout << A[0][i] << ' ' << A[1][i] << endl;\n\t\t\tprintf(\"%c\", Ans[i] + 'A' - 1);\n\t\t\t//cout << Ans[i] << endl;\n\t\t}\n\t\texit(0);\n\t}\n}\n\ninline void Add (int x, int a, int y, int b)\n{\n\tif (Ban[x] == a) return ;\n\n\tint dx = (a == A[0][x]) ? x : (x + N), ox = (dx <= N) ? (dx + N) : (dx - N);\n\tint dy = (b == A[0][y]) ? y : (y + N), oy = (dy <= N) ? (dy + N) : (dy - N);\n\n//\tcout << x << ' ' << dx << ' ' << ox << endl;\n//\tcout << y << ' ' << dy << ' ' << oy << endl;\n\n\tif (Ban[y] == b) add_edge (dx, ox);\n\telse add_edge (dx, dy), add_edge (oy, ox);\n}\n\ninline void Pop (int now)\n{\n\twhile (save_cnt != now)\n\t{\n\t\tint x = Save_E[save_cnt].x, y = Save_E[save_cnt].y; --save_cnt, --e;\n\t\tBegin[x] = Next[Begin[x]];\n\t}\n}\n\ninline void Check ()\n{\n\tint save_now = save_cnt;\n\tfor (int i = 1; i <= M; ++i)\n\t{\n\t\tint x = E[i].x, a = E[i].a, y = E[i].y, b = E[i].b;\n\t\tAdd (x, a, y, b);\n\t}\n\n\tGRAPH :: solve ();\n\n\tPop (save_now);\n}\n\ninline void dfs (int step)\n{\n    if (clock() > 0.9 * CLOCKS_PER_SEC) { cout << -1; exit(0); }\n\tif (step == d + 1) { Check (); return ; }\n\n\tBan[Buc[step]] = 1, A[0][Buc[step]] = 2, A[1][Buc[step]] = 3;\n\tif (rand() & 1) swap(A[0][Buc[step]], A[1][Buc[step]]);\n\tdfs (step + 1);\n\n\tBan[Buc[step]] = 2, A[0][Buc[step]] = 1, A[1][Buc[step]] = 3;\n\tif (rand() & 1) swap(A[0][Buc[step]], A[1][Buc[step]]);\n\tdfs (step + 1);\n}\n\ninline void Solve ()\n{\n\tdfs (1);\n\tcout << \"-1\";\n}\n\ninline void Input ()\n{\n\tsrand(20030216);\n\tN = read<int>(), d = read<int>();\n\tscanf(\"%s\", S + 1);\n\tint buc_cnt = 0;\n\n\tfor (int i = 1; i <= N; ++i)\n\t{\n\t\tif (S[i] != 'x') \n\t\t{\n\t\t\tBan[i] = S[i] - 'a' + 1;\n\t\t\tif (S[i] == 'a') A[0][i] = 2, A[1][i] = 3;\n\t\t\telse if (S[i] == 'b') A[0][i] = 1, A[1][i] = 3;\n\t\t\telse A[0][i] = 1, A[1][i] = 2;\n\t\t\tif (rand() & 1) swap(A[0][i], A[1][i]);\n\t\t}\n\t\telse A[0][i] = -1, Buc[++buc_cnt] = i;\n\t}\n\n\tint MM;\n\tM = MM = read<int>(), M = 0;\n\twhile (MM--)\n\t{\n\t\tchar str[3];\n\t\tint x = read<int>(), a; scanf(\"%s\", str), a = str[0] - 'A' + 1;\n\t\tint y = read<int>(), b; scanf(\"%s\", str), b = str[0] - 'A' + 1;\n\n\t\tif (!Ban[x] || !Ban[y]) E[++M] = (edge){x, a, y, b};\n\t\telse Add (x, a, y, b);\n\t}\n}\n\nint main()\n{\n\n#ifndef ONLINE_JUDGE\n\tfreopen(\"A.in\", \"r\", stdin);\n\tfreopen(\"A.out\", \"w\", stdout);\n#endif\n\n\tInput ();\n\tSolve ();\n\n\treturn 0;\n}\n\n```\n\n","categories":["Problem"],"tags":["tarjan","2-SAT"]},{"title":"「模拟赛」19.3.9模拟赛 - Summary","url":"/2019/03/10/%E3%80%8C%E6%A8%A1%E6%8B%9F%E8%B5%9B%E3%80%8D19-3-9%E6%A8%A1%E6%8B%9F%E8%B5%9B-Summary/","content":"","categories":["Summary"],"tags":["Summary","单调栈","数据结构","树状数组","三分"]},{"title":"「Algorithm」2-SAT","url":"/2019/03/10/%E3%80%8CAlgorithm%E3%80%8D2-SAT/","content":"\n一个比较简单的图论问题，总算是填了这个小坑\n\n<!--more-->\n\n## Problem\n\n有一些集合，每个集合中有且仅有两个元素，且不能同时选取两个元素，集合间的元素存在一定的选择关系，求解可行性及可行方案\n\n## Algorithm\n\n其实这也不算是一个算法，就是一个很简单的图论模型，特别详细的过程可以看[这里](https://www.luogu.org/problemnew/solution/P4782)\n\n把每个点拆成两种状态$a$和$a'$，状态之间互相连形如`如果选a则必须选b`的有向边，通过`tarjan`求强连通分量来判断可行性\n\n算法流程如下：\n\n* 连边\n\n* 跑tarjan\n\n* 判可行性：判断一个点的两种状态是否同属一个强连通分量\n\n* 输出方案：输出两种状态中较先被缩成强连通分量的那个状态即可\n\n  > 这个本质是对强连通分量进行缩点，缩完后形成的树（或者说是`DAG`也行）上显然如果状态$x$被选，那么$x$的子树的所有状态都要选。于是对于同一个点的两种状态而言，肯定只能选深度较深的那种状态，这种状态显然在用`tarjan`缩点时会先被缩起来\n\n## Connection\n\n关于连边，主要思想就一个：`选了a必选b`对应连边$a\\rightarrow b$和$b' \\rightarrow a'$（**逆否命题**，必须也要连），然后根据相应的逻辑关系进行连边\n\n常见的逻辑关系有：\n\n* $a$、$b$不能同时选：选了$a$就要选$b'$，选了$b$就要选$a'$\n* $a$、$b$至少选一个：选了$a‘$就要选$b$，选了$b‘$就要选$a$\n* $a$、$b$必须同时选：选了$a$就要选$b$，选了$b$就要选$a$，选了$a'$就要选$b'$，选了$b'$就要选$a'$\n* $a$、$b$必须选一个：选了$a$就要选$b'$，选了$b$就要选$a'$，选了$a'$就要选$b$，选了$b'$就要选$a$\n* $a$必须选：$a'\\rightarrow a$\n* $a$必须不选：$a\\rightarrow a'$\n\n## Example\n\n懒的放了\n\n","categories":["Algorithm"],"tags":["tarjan","2-SAT"]},{"title":"「CF700E」 Cool Slogans - 后缀自动机 + 线段树合并 + 贪心","url":"/2019/03/08/%E3%80%8CCF700E%E3%80%8D-Cool-Slogans-%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA-%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%90%88%E5%B9%B6-%E8%B4%AA%E5%BF%83/","content":"\n给出一个长度为$n$的字符串$s_1$，由小写字母组成\n\n定义一个字符串序列$s_{1 \\sim k}$，满足性质：$s_i$在$s_{i-1} (i\\ge2)$中出现至少两次（位置可重叠）\n\n求最大的$k$是多少，使得从$s_1$开始到$s_k$都满足这样一个性质\n\n$n\\le 2\\times 10^5$\n\n<!--more-->\n\n### Links\n\n[CF 700E](https://codeforces.com/contest/700/problem/E)\n\n### Solution\n\n倒着考虑，考虑每次多选出来一个子串使得它包含了当前子串至少两次\n\n注意到一个性质，假设我们已经选出了$i-1$个串，那么一定存在一种最优方案使得第$i$个串的右端点与第$i-1$个串的右端点相同\n\n> 假设存在一个方案使得右端点不同，那么肯定可以通过割掉当前这个串右边的那一段多余部分使得它们的右端点相同，且这样割掉只会使得后面的转移更优\n\n那么选出来的就是一些右端点相同的后缀（本来这里是想贴几张图的，结果写题解的时候机房网烂了，就算了。。。）\n\n发现这个东西实际上就是`SAM`中`parent树`上的一条链，于是可以在`parent树`上贪心地选：只要当前状态能使得答案更优就选它，否则继承父亲的状态\n\n设$f[i]$表示`SAM`上从根到节点$i$最多能选出来的子串数，$g[i]$表示这个最优方案最后一个选的状态是什么\n\n在`parent树`上贪心，对于一个节点$x$每次判断一下$g[fa[x]]$的`right集合`中是否存在两个位置$p$满足$pos[x] - maxlen[x] + 1\\le p - minlen[g[fa[x]] + 1$且$p\\le pos[x]​$\n\n其中$pos[x]$表示状态$x$的`right集合`中任意一个右端点的位置，线段树合并维护一下`right集合`即可，这个小技巧和[「NOI2018」你的名字](https://hk-cnyali.com/2019/03/06/%E3%80%8CNOI2018%E3%80%8D%E4%BD%A0%E7%9A%84%E5%90%8D%E5%AD%97-%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA-%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%90%88%E5%B9%B6/)差不多\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int MAX_N = 200000 + 100;\n\nint N;\nchar S[MAX_N];\n\nnamespace SEG\n{\n#define mid (l + r >> 1)\n#define ls node[root].ch[0]\n#define rs node[root].ch[1]\n#define lson ls, l, mid\n#define rson rs, mid + 1, r\n\n\tconst int MAX_NODE = MAX_N * 40;\n\n\tint node_cnt;\n\n\tstruct info\n\t{\n\t\tint cnt, ch[2];\n\t} node[MAX_NODE];\n\n\tinline void push_up (int root) { node[root].cnt = node[ls].cnt + node[rs].cnt; }\n\n\tinline void insert (int &root, int l, int r, int x)\n\t{\n\t\t++node[root = ++node_cnt].cnt;\n\t\tif (l == r) return ;\n\t\tif (x <= mid) insert (lson, x);\n\t\telse insert (rson, x);\n\t}\n\n\tinline int merge (int x, int y, int l, int r)\n\t{\n\t\tif (!x || !y) return x | y;\n\t\tint root = ++node_cnt;\n\t\tls = merge (node[x].ch[0], node[y].ch[0], l, mid);\n\t\trs = merge (node[x].ch[1], node[y].ch[1], mid + 1, r);\n\t\tpush_up (root);\n\t\treturn root;\n\t}\n\n\tinline int query (int root, int l, int r, int x, int y)\n\t{\n\t\tif (x > y) return 0;\n\t\tif (x <= l && r <= y) return node[root].cnt;\n\n\t\tint ans = 0;\n\t\tif (x <= mid) ans += query (lson, x, y);\n\t\tif (y > mid) ans += query (rson, x, y);\n\t\treturn ans;\n\t}\n\n#undef mid \n#undef ls \n#undef rs \n#undef lson\n#undef rson\n}\n\nnamespace SAM\n{\n\tconst int MAX_NODE  = MAX_N << 1;\n\n\tint node_cnt, last;\n\tint Root[MAX_NODE];\n\n\tstruct info\n\t{\n\t\tint ch[27], maxlen, fa, pos;\n\t} node[MAX_NODE];\n\n\tvector <int> G[MAX_NODE];\n\n\tint f[MAX_NODE], g[MAX_NODE]; // f : 最大值, g : 最大值产生的状态\n\tint State[MAX_NODE];\n\n\tinline int new_node (int pre)\n\t{\n\t\tnode[++node_cnt].maxlen = node[pre].maxlen + 1;\n\t\treturn node_cnt;\n\t}\n\n\tinline int extend (int c, int pos)\n\t{\n\t\tint now = new_node (last), pre = last; last = now;\n\t\tnode[now].pos = pos;\n\t\t\n\t\tfor (; pre && !node[pre].ch[c]; pre = node[pre].fa) node[pre].ch[c] = now;\n\n\t\tif (!pre) node[now].fa = 1;\n\t\telse\n\t\t{\n\t\t\tint x = node[pre].ch[c];\n\t\t\tif (node[x].maxlen == node[pre].maxlen + 1) node[now].fa = x;\n\t\t\telse\n\t\t\t{\n\t\t\t\tint y = ++node_cnt;\n\t\t\t\tnode[y] = node[x], node[y].maxlen = node[pre].maxlen + 1;\n\t\t\t\tnode[x].fa = node[now].fa = y;\n\n\t\t\t\tfor (; node[pre].ch[c] == x; pre = node[pre].fa) node[pre].ch[c] = y;\n\t\t\t}\n\t\t}\n\n\t\treturn now;\n\t}\n\n\tinline void build (char *s, int n)\n\t{\n\t\tnode_cnt = last = 1;\n\t\tfor (int i = 1; i <= n; ++i) State[i] = extend (s[i] - 'a', i);\n\t\tfor (int i = 1; i <= n; ++i) SEG :: insert (Root[State[i]], 1, node_cnt, i);\n\t}\n\n\tinline void dfs (int x)\n\t{\n\t\tfor (int i = 0; i < G[x].size(); ++i)\n\t\t{\n\t\t\tint y = G[x][i];\n\t\t\tdfs (y);\n\t\t\tRoot[x] = SEG :: merge (Root[x], Root[y], 1, N);\n\t\t}\n\t}\n\n\tint ans = 0;\n\n\tinline void dfs_calc (int x)\n\t{\n\t\tChkmax(ans, f[x]);\n\t\tfor (int i = 0; i < G[x].size(); ++i)\n\t\t{\n\t\t\tint y = G[x][i];\n\n\t\t\tif (x == 1) f[y] = 1, g[y] = y; \n\t\t\telse if (SEG :: query (Root[g[x]], 1, node_cnt, node[y].pos + node[node[g[x]].fa].maxlen + 1 - node[y].maxlen, node[y].pos) >= 2) f[y] = f[x] + 1, g[y] = y;\n\t\t\telse f[y] = f[x], g[y] = g[x];\n\n\t\t\tdfs_calc (y);\n\t\t}\n\t}\n\n\tinline void solve ()\n\t{\n\t\tfor (int i = 1; i <= node_cnt; ++i) G[node[i].fa].pb (i);\n\t\tdfs (1), dfs_calc (1);\n\t\tcout << ans << endl;\n\t}\n}\n\ninline void Solve ()\n{\n\tSAM :: build (S, N);\n\tSAM :: solve ();\n}\n\ninline void Input ()\n{\n\tN = read<int>();\n\tscanf(\"%s\", S + 1);\n}\n\nint main()\n{\n\n#ifndef ONLINE_JUDGE\n\tfreopen(\"E.in\", \"r\", stdin);\n\tfreopen(\"E.out\", \"w\", stdout);\n#endif\n\n\tInput ();\n\tSolve ();\n\n\treturn 0;\n}\n\n```\n\n","categories":["Problem"],"tags":["Codeforces","线段树合并","贪心","后缀自动机"]},{"title":"「AHOI2013」 差异 - 后缀自动机","url":"/2019/03/08/%E3%80%8CAHOI2013%E3%80%8D-%E5%B7%AE%E5%BC%82-%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/","content":"\n给定一个长度为 $n$ 的字符串 $S$，令 $T_i$表示它从第 $i$个字符开始的后缀，求：\n\n$\\sum_{1 \\le i < j \\le n} len(T_i)+len(T_j)-2*lcp(T_i,T_j)$\n\n<!--more-->\n\n### Links\n\n[LOJ 2377](https://loj.ac/problem/2377)\n\n### Solution\n\n$len$的部分直接算，后面的部分直接反着建`SAM`，在`parent树`上统计贡献即可\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int MAXN = 500000 + 100;\n\nint N;\nchar S[MAXN];\n\nnamespace SAM\n{\n\tconst int MAX_NODE = MAXN << 1;\n\n\tint node_cnt = 1, last = 1;\n\n\tstruct info\n\t{\n\t\tint ch[27], fa, maxlen;\n\t\tLL cnt;\n\t} node[MAX_NODE];\n\n\tvector <int> G[MAX_NODE];\n\n\tinline int new_node (int pre)\n\t{\n\t\tnode[++node_cnt].maxlen = node[pre].maxlen + 1;\n\t\treturn node_cnt;\n\t}\n\n\tinline void extend (int c)\n\t{\n\t\tint now = new_node (last), pre = last; last = now;\n\t\tnode[now].cnt = 1;\n\t\t\n\t\tfor (; pre && !node[pre].ch[c]; pre = node[pre].fa) node[pre].ch[c] = now;\n\n\t\tif (!pre) node[now].fa = 1;\n\t\telse\n\t\t{\n\t\t\tint x = node[pre].ch[c];\n\t\t\tif (node[x].maxlen == node[pre].maxlen + 1) node[now].fa = x;\n\t\t\telse\n\t\t\t{\n\t\t\t\tint y = ++node_cnt;\n\t\t\t\tnode[y] = node[x], node[y].maxlen = node[pre].maxlen + 1, node[y].cnt = 0;\n\t\t\t\tnode[x].fa = node[now].fa = y;\n\n\t\t\t\tfor (; node[pre].ch[c] == x; pre = node[pre].fa) node[pre].ch[c] = y;\n\t\t\t}\n\t\t}\n\t}\n\n\tinline void build (char *s, int n) { for (int i = 1; i <= n; ++i) extend (s[i] - 'a'); }\n\n\tLL ans;\n\n\tinline void dfs (int x)\n\t{\n\t\tLL sum = 0, done = node[x].cnt;\n\n\t\tfor (int i = 0; i < G[x].size(); ++i)\n\t\t{\n\t\t\tint y = G[x][i];\n\t\t\tdfs (y);\n\t\t\tsum += done * node[y].cnt;\n\t\t\tdone += node[y].cnt;\n\t\t}\n\n\t\tans += sum * node[x].maxlen;\n\t\tnode[x].cnt = done;\n\t}\n\n\tinline LL get_ans ()\n\t{\n\t\tfor (int i = 1; i <= node_cnt; ++i) G[node[i].fa].pb (i);\n\t\tdfs (1);\n\t\treturn ans;\n\t}\n}\n\ninline LL Calc (int l, int r) { return (LL)(l + r) * (r - l + 1) / 2ll; }\n\ninline void Solve ()\n{\n\treverse (S + 1, S + N + 1);\n\tSAM :: build (S, N);\n\n\tLL ans = 0;\n\tfor (int i = 1; i <= N; ++i) ans += (LL)Calc (1, N - i) + (LL)(N - i) * (N - i + 1);\n\n\tprintf(\"%lld\\n\", ans - 2ll * SAM:: get_ans ());\n}\n\ninline void Input ()\n{\n\tscanf(\"%s\", S + 1);\n\tN = strlen (S + 1);\n}\n\nint main()\n{\n\n#ifndef ONLINE_JUDGE\n\tfreopen(\"A.in\", \"r\", stdin);\n\tfreopen(\"A.out\", \"w\", stdout);\n#endif\n\n\tInput ();\n\tSolve ();\n\n\treturn 0;\n}\n\n```\n\n","categories":["Problem"],"tags":["后缀自动机"]},{"title":"「NOI2015」品酒大会 - 后缀自动机","url":"/2019/03/08/%E3%80%8CNOI2015%E3%80%8D%E5%93%81%E9%85%92%E5%A4%A7%E4%BC%9A-%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/","content":"\n给出一个长度为$n​$的字符串$S​$和序列$a_i​$\n\n对于$\\forall r\\in [0, n-1]$求$\\sum_{i\\ne j} [lcp(suf_i, suf_j)\\ge r]$和$\\max_{i\\neq j,lcp(suf_i,suf_j)\\ge r} a_i\\times a_j$\n\n$n\\le 300000, |a_i| \\le 10^9​$\n\n<!--more-->\n\n### Links\n\n[LOJ 2133](https://loj.ac/problem/2133)\n\n### Solution\n\n反着建`SAM`，在`parent树`上统计以每个点状态`lcp`的答案\n\n注意除了记$max$之外还需要记$min$，因为权值可能为负数\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int Maxn = 300000 + 100;\nconst LL inf = 0x3f3f3f3f3f3f3f3f;\n\nint N, A[Maxn];\nchar S[Maxn];\n\nnamespace SAM\n{\n\tint node_cnt = 1, last = 1;\n\n\tstruct info\n\t{\n\t\tint maxlen, fa, ch[27], cnt;\n\t\tLL min, max;\n\t} node[Maxn << 1];\n\n\tvector <int> G[Maxn << 1];\n\n\tinline int new_node (int pre, int id)\n\t{\n\t\tnode[++node_cnt].maxlen = node[pre].maxlen + 1;\n\t\tnode[node_cnt].cnt = 1, node[node_cnt].min = node[node_cnt].max = A[id]; \n\t\treturn node_cnt;\n\t}\n\n\tinline void extend (int c, int id)\n\t{\n\t\tint now = new_node (last, id), pre = last; last = now;\n\n\t\tfor (; pre && !node[pre].ch[c]; pre = node[pre].fa) node[pre].ch[c] = now;\n\n\t\tif (!pre) node[now].fa = 1;\n\t\telse\n\t\t{\n\t\t\tint x = node[pre].ch[c];\n\t\t\tif (node[x].maxlen == node[pre].maxlen + 1) node[now].fa = x;\n\t\t\telse\n\t\t\t{\n\t\t\t\tint y = ++node_cnt;\n\t\t\t\tnode[y] = node[x], node[y].maxlen = node[pre].maxlen + 1;\n\t\t\t\tnode[y].cnt = 0, node[y].min = inf, node[y].max = -inf;\n\t\t\t\tnode[x].fa = node[now].fa = y;\n\n\t\t\t\tfor (; node[pre].ch[c] == x; pre = node[pre].fa) node[pre].ch[c] = y;\n\t\t\t}\n\t\t}\n\t}\n\n\tLL Ans1[Maxn << 1], Ans2[Maxn << 1];\n\n\tinline void dfs (int x)\n\t{\n\t\tLL sum = node[x].cnt, ans1 = 0, ans2 = -inf;\n\t\tLL min_now = node[x].min, max_now = node[x].max;\n\n\t\tfor (int i = 0; i < G[x].size(); ++i)\n\t\t{\n\t\t\tint y = G[x][i];\n\t\t\tdfs (y);\n\n\t\t\tif (sum) Chkmax (ans2, max((LL)min_now * node[y].min, (LL)max_now * node[y].max));\n\t\t\tChkmin (min_now, node[y].min);\n\t\t\tChkmax (max_now, node[y].max);\n\n\t\t\tans1 += (LL)node[y].cnt * sum;\n\t\t\tsum += node[y].cnt;\n\t\t}\n\n\t\tnode[x].cnt = sum, node[x].min = min_now, node[x].max = max_now;\n\t\tAns1[node[x].maxlen] += ans1;\n\t\tChkmax(Ans2[node[x].maxlen], ans2);\n\t}\n\n\tinline void build (char *s, int n) \n\t{ \n\t\tnode[1].min = inf, node[1].max = -inf;\n\t\tfor (int i = 1; i <= n; ++i) extend (s[i] - 'a', i); \n\t}\n\n\tinline void solve ()\n\t{\n\t\tfor (int i = 1; i <= node_cnt; ++i) G[node[i].fa].pb (i);\n\t\tfor (int i = 0; i <= N; ++i) Ans2[i] = -inf;\n\t\tdfs (1);\n\t\tfor (int i = N - 1; i >= 0; --i) Ans1[i] += Ans1[i + 1], Chkmax(Ans2[i], Ans2[i + 1]);\n\t\tfor (int i = 0; i < N; ++i) printf(\"%lld %lld\\n\", Ans1[i], Ans2[i] == -inf ? 0 : Ans2[i]);\n\t}\n}\n\ninline void Solve ()\n{\n\treverse (S + 1, S + N + 1);\n\treverse (A + 1, A + N + 1);\n\tSAM :: build (S, N);\n\tSAM :: solve ();\n}\n\ninline void Input ()\n{\n\tN = read<int>();\n\tscanf(\"%s\", S + 1);\n\tfor (int i = 1; i <= N; ++i) A[i] = read<int>();\n}\n\nint main()\n{\n\n#ifndef ONLINE_JUDGE\n\tfreopen(\"A.in\", \"r\", stdin);\n\tfreopen(\"A.out\", \"w\", stdout);\n#endif\n\n\tInput ();\n\tSolve ();\n\n\treturn 0;\n}\n\n```\n\n","categories":["Problem"],"tags":["字符串","后缀自动机"]},{"title":"「Poi2000」公共串 - 后缀自动机","url":"/2019/03/08/%E3%80%8CPoi2000%E3%80%8D%E5%85%AC%E5%85%B1%E4%B8%B2-%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/","content":"\n给出$n$个由小写字母构成的字符串，求它们最长的公共子串的长度\n\n$n\\le 5, \\sum|S|\\le 10000$\n\n<!--more-->\n\n### Links\n\n[BZOJ2946](https://www.lydsy.com/JudgeOnline/problem.php?id=2946)\n\n### Solution\n\n[做法见此](https://hk-cnyali.com/2019/03/06/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%8A%80%E5%B7%A7/)\n\n稍微讲下，就是建出第一个串的`SAM`，然后把后面的串放上面匹配\n\n当然也可以直接上`广义SAM`，但是我不会\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int MAXN = 2000 + 100;\n\nint N, M;\nchar S[MAXN];\n\nnamespace SAM\n{\n\tconst int MAX_NODE = MAXN << 1;\n\tint node_cnt = 1, last = 1;\n\n\tstruct info\n\t{\n\t\tint ch[27], fa, maxlen, max;\n\t} node[MAX_NODE];\n\n\tinline int new_node (int pre)\n\t{\n\t\tnode[++node_cnt].maxlen = node[pre].maxlen + 1;\n\t\treturn node_cnt;\n\t}\n\n\tinline void extend (int c)\n\t{\n\t\tint now = new_node (last), pre = last; last = now;\n\n\t\tfor (; pre && !node[pre].ch[c]; pre = node[pre].fa) node[pre].ch[c] = now;\n\n\t\tif (!pre) node[now].fa = 1;\n\t\telse\n\t\t{\n\t\t\tint x = node[pre].ch[c];\n\t\t\tif (node[x].maxlen == node[pre].maxlen + 1) node[now].fa = x;\n\t\t\telse\n\t\t\t{\n\t\t\t\tint y = ++node_cnt;\n\t\t\t\tnode[y] = node[x]; node[y].maxlen = node[pre].maxlen + 1;\n\t\t\t\tnode[x].fa = node[now].fa = y;\n\n\t\t\t\tfor (; node[pre].ch[c] == x; pre = node[pre].fa) node[pre].ch[c] = y;\n\t\t\t}\n\t\t}\n\t}\n\n\tvector <int> G[MAX_NODE];\n\n\tint Ans[MAX_NODE];\n\n\tinline void build (char *s, int n) \n\t{ \n\t\tfor (int i = 1; i <= n; ++i) extend (s[i] - 'a'); \n\t\tfor (int i = 1; i <= node_cnt; ++i) G[node[i].fa].pb(i);\n\t\tfor (int i = 1; i <= node_cnt; ++i) Ans[i] = node[i].maxlen;\n\t}\n\n\tinline void dfs (int x)\n\t{\n\t\tfor (int i = 0; i < G[x].size(); ++i)\n\t\t{\n\t\t\tint y = G[x][i];\n\t\t\tdfs (y);\n\t\t\tChkmax (node[x].max, node[y].max);\n\t\t}\n\t}\n\n\tinline int get_ans ()\n\t{\n\t\tint ans = 0;\n\t\tfor (int i = 1; i <= node_cnt; ++i) Chkmax (ans, Ans[i]);\n\t\treturn ans;\n\t}\n\n\tinline void query (char *s, int n)\n\t{\n\t\tfor (int i = 1; i <= node_cnt; ++i) node[i].max = 0;\n\n\t\tint now = 1, len = 0;\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t{\n\t\t\tint c = s[i] - 'a';\n\n\t\t\twhile (1)\n\t\t\t{\n\t\t\t\tif (node[now].ch[c]) \n\t\t\t\t{ \n\t\t\t\t\tnow = node[now].ch[c], ++len, Chkmax(node[now].max, len); \n\t\t\t\t\tbreak; \n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (!len) break;\n\t\t\t\t\tif ((--len) == node[node[now].fa].maxlen) now = node[now].fa;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdfs (1);\n\t\tfor (int i = 1; i <= node_cnt; ++i) Chkmin (Ans[i], node[i].max);\n\t}\n\n}\n\ninline void Solve ()\n{\n\tscanf(\"%s\", S + 1), M = strlen(S + 1);\n\tSAM :: build (S, M);\n\n\tfor (int i = 2; i <= N; ++i)\n\t{\n\t\tscanf(\"%s\", S + 1), M = strlen(S + 1);\n\t\tSAM :: query (S, M);\n\t}\n\n\tprintf(\"%d\\n\", SAM :: get_ans ());\n}\n\ninline void Input ()\n{\n\tN = read<int>();\n}\n\nint main()\n{\n\n#ifndef ONLINE_JUDGE\n\tfreopen(\"A.in\", \"r\", stdin);\n\tfreopen(\"A.out\", \"w\", stdout);\n#endif\n\n\tInput ();\n\tSolve ();\n\n\treturn 0;\n}\n\n```\n\n","categories":["Problem"],"tags":["字符串","后缀自动机"]},{"title":"「TJOI / HEOI2016」字符串 - 后缀自动机 + 后缀树 + 线段树合并 + 倍增","url":"/2019/03/08/%E3%80%8CTJOI-HEOI2016%E3%80%8D%E5%AD%97%E7%AC%A6%E4%B8%B2-%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA-%E5%90%8E%E7%BC%80%E6%A0%91-%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%90%88%E5%B9%B6-%E5%80%8D%E5%A2%9E/","content":"\n给定一个长度为 $n$ 的字符串 $S$ \n\n $m$ 次询问，每次询问给出 $a,b,c,d$ \n\n求 $S[a,b]$的所有子串和子串$S[c,d]$的`LCP（最长公共前缀）`的最大值。\n\n$n,m\\le10^5$\n\n<!--more-->\n\n### Links\n\n[LOJ 2059](https://loj.ac/problem/2059)\n\n### Solution\n\n反着建`SAM`就能建出后缀树，后缀树上最两个串的`lca`的`maxlen`就是它们的`lcp`，具体内容[可见此](https://hk-cnyali.com/2019/03/06/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%8A%80%E5%B7%A7/)\n\n反着建完`SAM`之后我们就是要求子串$[d, c]$和$[b, a]$中所有子串的最长公共后缀的最大值\n\n考虑二分答案$ans$，每次要判断$[c - ans + 1, c]$这个子串的`right集合`中是否存在一个位置$p$使得$p\\in [b + ans - 1,a]$\n\n线段树合并求`right集合`即可，注意找$[c - ans + 1, c]$这个子串在`SAM`中对应状态需要用倍增实现，具体也[可见此](https://hk-cnyali.com/2019/03/06/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%8A%80%E5%B7%A7/)\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int Maxn = 1e5 + 100;\n\nint N, M;\nchar S[Maxn];\n\nnamespace SEG\n{\n#define mid ((l + r) >> 1)\n#define ls node[root].ch[0]\n#define rs node[root].ch[1]\n#define lson ls, l, mid\n#define rson rs, mid + 1, r\n\n\tstruct info\n\t{\n\t\tint ch[2], cnt;\n\t} node[Maxn * 60];\n\n\tint node_cnt;\n\n\tinline void push_up (int root) { node[root].cnt = node[ls].cnt + node[rs].cnt; }\n\n\tinline void insert (int &root, int l, int r, int x)\n\t{\n\t\t++node[root = ++node_cnt].cnt;\n\t\tif (l == r) return ;\n\t\tif (x <= mid) insert (lson, x);\n\t\telse insert (rson, x);\n\t}\n\n\tinline int merge (int x, int y, int l, int r)\n\t{\n\t\tif (!x || !y) return x | y;\n\t\tint root = ++node_cnt;\n\t\tls = merge (node[x].ch[0], node[y].ch[0], l, mid);\n\t\trs = merge (node[x].ch[1], node[y].ch[1], mid + 1, r);\n\t\tpush_up (root);\n\t\treturn root;\n\t}\n\n\tinline int query (int root, int l, int r, int x, int y)\n\t{\n\t\tif (x > y) return 0;\n\t\tif (x <= l && r <= y) return node[root].cnt;\n\n\t\tint ans = 0;\n\t\tif (x <= mid) ans += query (lson, x, y);\n\t\tif (y > mid) ans += query (rson, x, y);\n\t\treturn ans;\n\t}\n\n#undef mid\n#undef ls\n#undef rs\n#undef lson\n#undef rson\n}\n\nint Root[Maxn << 1];\n\nnamespace SAM\n{\n\tstruct info\n\t{\n\t\tint maxlen, fa, ch[27];\n\t} node[Maxn << 1];\n\n\tint node_cnt = 1, last = 1;\n\tint State[Maxn];\n\n\tinline int new_node (int pre)\n\t{\n\t\tnode[++node_cnt].maxlen = node[pre].maxlen + 1;\n\t\treturn node_cnt;\n\t}\n\n\tinline int extend (int c)\n\t{\n\t\tint now = new_node (last), pre = last; last = now;\n\n\t\tfor (; pre && !node[pre].ch[c]; pre = node[pre].fa) node[pre].ch[c] = now;\n\n\t\tif (!pre) node[now].fa = 1;\n\t\telse\n\t\t{\n\t\t\tint x = node[pre].ch[c];\n\t\t\tif (node[x].maxlen == node[pre].maxlen + 1) node[now].fa = x;\n\t\t\telse\n\t\t\t{\n\t\t\t\tint y = ++node_cnt;\n\t\t\t\tnode[y] = node[x]; node[y].maxlen = node[pre].maxlen + 1;\n\t\t\t\tnode[x].fa = node[now].fa = y;\n\t\t\t\tfor (; node[pre].ch[c] == x; pre = node[pre].fa) node[pre].ch[c] = y;\n\t\t\t}\n\t\t}\n\n\t\treturn now;\n\t}\n\n\tvector <int> G[Maxn << 1];\n\tint anc[21][Maxn << 1];\n\n\tinline void dfs (int x)\n\t{\n\t\tfor (int i = 1; i <= 20; ++i) anc[i][x] = anc[i - 1][anc[i - 1][x]];\n\t\tfor (int i = 0; i < G[x].size(); ++i)\n\t\t{\n\t\t\tint y = G[x][i];\n\t\t\tanc[0][y] = x;\n\t\t\tdfs (y);\n\t\t\tRoot[x] = SEG :: merge (Root[x], Root[y], 1, node_cnt);\n\t\t}\n\t}\n\n\tinline void build (char *s, int n)\n\t{\n\t\tfor (int i = 1; i <= n; ++i) State[i] = extend (s[i] - 'a');\n\t\tfor (int i = 1; i <= n; ++i) SEG :: insert (Root[State[i]], 1, node_cnt, i);\n\n\t\tfor (int i = 1; i <= node_cnt; ++i) G[node[i].fa].pb (i);\n\t\tdfs (1);\n\t}\n\n\tinline int Check (int ans, int a, int b, int d)\n\t{\n\t\tint x = State[d];\n\t\tif (node[x].maxlen < ans) return 0;\n\t\tfor (int i = 20; i >= 0; --i) if (node[anc[i][x]].maxlen >= ans) x = anc[i][x];\n\t\treturn SEG :: query (Root[x], 1, node_cnt, b + ans - 1, a);\n\t}\n\n\tinline int query (int a, int b, int c, int d)\n\t{\n\t\tint l = 1, r = min (a - b + 1, c - d + 1), ans = 0;\n\t\twhile (l <= r)\n\t\t{\n\t\t\tint mid = l + r >> 1;\n\t\t\tif (Check (mid, a, b, c)) ans = mid, l = mid + 1;\n\t\t\telse r = mid - 1;\n\t\t}\n\t\treturn ans;\n\t}\n}\n\ninline void Solve ()\n{\n\treverse (S + 1, S + N + 1);\n\tSAM :: build (S, N);\n\n\twhile (M--)\n\t{\n\t\tint a = N - read<int>() + 1, b = N - read<int>() + 1, c = N - read<int>() + 1, d = N - read<int>() + 1;\n\t\tprintf(\"%d\\n\", SAM :: query (a, b, c, d));\n\t}\n}\n\ninline void Input ()\n{\n\tN = read<int>(), M = read<int>();\n\tscanf(\"%s\", S + 1);\n}\n\nint main()\n{\n\n#ifndef ONLINE_JUDGE\n\tfreopen(\"A.in\", \"r\", stdin);\n\tfreopen(\"A.out\", \"w\", stdout);\n#endif\n\n\tInput ();\n\tSolve ();\n\n\treturn 0;\n}\n\n```\n\n","categories":["Problem"],"tags":["线段树合并","倍增","字符串","后缀自动机","省选","后缀树"]},{"title":"「模拟赛」19.3.7模拟赛 - Summary","url":"/2019/03/07/%E3%80%8C%E6%A8%A1%E6%8B%9F%E8%B5%9B%E3%80%8D19-3-7%E6%A8%A1%E6%8B%9F%E8%B5%9B-Summary/","content":"","categories":["Problem"],"tags":["Summary","动态规划","数据结构","NTT","字符串","树链剖分","LCT","网络流","后缀自动机"]},{"title":"后缀自动机的一些小技巧","url":"/2019/03/06/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%8A%80%E5%B7%A7/","content":"\n19.3.31UPD\n\n其实是一些很基础很入门很傻逼的东西，就不加密了\n\n<!--more-->\n\n## 常见简单思想\n\n### 拓扑序dp\n\n`SAM`的拓扑序有一个性质，如果有一条转移边 $u \\rightarrow v$则一定有 $|\\mathrm{maxlen}_u| < |\\mathrm{maxlen}_v|$；如果 $\\mathrm{fa}_v = u$也有 $|\\mathrm{maxlen}_u| < |\\mathrm{maxlen}_v|$\n\n因此按照`maxlen`从小到大排序就能实现拓扑序的过程\n\n此外，转移边上走是拓扑序正序；跳`fa`是拓扑序逆序\n\n### 求right集合\n\n在所有前缀$i$所在状态的`right集合`中加入$i$\n\n在`parent树`上线段树合并\n\n### 利用parent树\n\n由于是树形结构，就可以进行一些树上的操作\n\n树上倍增、LCT、点分治等\n\n### 建后缀树\n\n把原串倒着建`SAM`所形成的`parent树`即为后缀树\n\n两个子串的`lcp`长度就是后缀树上两个节点的`lca`的`maxlen`**(注意不是深度！！！)**\n\n也可以这么理解，对于`SAM`上两个结点，它们往`parent树`向上跳的过程就是不断缩后缀的过程，那么`parent树`的lca就是它们的最长公共后缀。于是把原串反着建就变成了`lcp`\n\n\n\n## 经典应用\n\n### 最基础\n\n#### 最长可重叠k重复子串\n\n> 给出一个字符串$S$，找一个子串，使得至少出现$k$次，可以重叠，求最长子串长度 \n\n`right集合`大于等于$k​$的那些节点的最大的`maxlen`\n\n #### 最长不可重叠重复子串\n\n> 给出一个字符串$S$，找一个子串，使得至少出现两次，不能重叠，求最长子串长度\n\n不光要使得`right集合`大于等于2，还需要考虑最靠右的那个位置和最靠左的那个位置之间的距离 \n\n#### 循环同构的最小表示法\n\n> 设 $S$ 为一字符串，$S_i,(i \\in [1, |S|)$表示将 $S$ 的前 $i$ 位剪切并拼接在 $S$ 的最后得到的字符串，所有 $S_i$中字典序最小的一个，称为 $S$ 循环同构的**最小表示**\n>\n> 给出一个字符串$S$，求它的最小表示\n\n直接把$S$倍长建`SAM`，从根开始贪心走最小的转移边，走$|S|$步得到的字符串即为答案\n\n#### 本质不同子串个数\n\n> 给出一个字符串$S$ ，计算本质不同子串的个数。 \n\n所有状态包含的子串总数 \n$$\n\\sum_i maxlen[i] - maxlen[fa[i]]\n$$\n\n### 稍微有点难度\n\n#### 任意子串的出现次数\n\n##### 给字符串\n\n> 给出一个字符串$S$ ，多次询问一个模式串$T$ ，求$T$在字符串$S$中作为子串出现了多少次\n\n在[这里](https://hk-cnyali.com/2019/03/05/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E7%9A%84%E6%80%A7%E8%B4%A8)提到了，一个子串的出现次数就是它所在状态`right集合`的大小，且只有`传统节点`才会有贡献\n\n先`parent树`上子树求和，然后每次读进来一个串时就把它扔到`SAM`暴力匹配，答案就是最后走到的节点的`right集合`大小，复杂度$O(\\sum T)$\n\n* 加强：\n\n  > 求$T$在$S$中的一个区间$[l_i, r_i]$中出现多少次\n\n  线段树合并求`right集合`，查区间和\n\n##### 给区间\n\n>  给出一个字符串$S$ ，多次询问给出$[l, r]$，求$S$的子串$[l, r]$在$S$中出现了多少次\n\n与上面做法类似，但是就不能暴力匹配了。因为复杂度可能达到$O(n^2)​$\n\n考虑类似于「TJOI / HEOI2016」字符串的做法，从前缀$r$在`SAM`中所表示的状态开始，倍增跳`parent`树，找到满足$\\mathrm{minlen}\\le r - l + 1 \\le \\mathrm{maxlen}$的祖先，求那个节点的`right集合`大小即可\n\n#### 第k小子串\n\n##### 本质不同第k小\n\n> 给出一个字符串$S$，求它子串中本质不同的第$k$小子串\n\n按拓扑序（或者在转移的DAG树上）求出以每个状态开头的本质不同子串个数（直接dp即可）\n\n然后按照主席树求第$k$小的方法，贪心枚举每一位，这个节点的某个儿子的大小$>k$，说明要找的串在这个儿子里；否则$k$减去节点大小，继续找\n\n注意，这里求出来的大小和`right集合`大小是不一样的。。。`right集合`大小是在原串中的出现次数，这个是以它开头的子串个数\n\n##### 所有子串第k小\n\n> 给出一个字符串$S$，求它所有子串中第$k$小子串\n\n上面的做法算上`right集合`的大小即可\n\n#### 两个字符串的最长公共子串\n\n> 给出两个字符串$S,T$，求它们的最长公共子串\n\n[这里](https://hk-cnyali.com/2019/03/05/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#%E5%8C%B9%E9%85%8D)和[这道题](https://hk-cnyali.com/2019/03/06/%E3%80%8CNOI2018%E3%80%8D%E4%BD%A0%E7%9A%84%E5%90%8D%E5%AD%97-%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA-%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%90%88%E5%B9%B6/)也讲过了，建出$S$的`SAM`，把$T$的所有前缀扔进去匹配，求个最大值\n\n#### 多个字符串的最长公共子串\n\n>  给出$k​$个字符串$S_1 ... S_k​$，求它们的最长公共子串\n\n* 直接建`广义SAM`，不过这个东西我暂时没太理解。。。\n* 对第一个字符串建`SAM`，把后面的串扔上去匹配，匹配的时候记录一下这个状态对于当前这个串的最长公共子串，然后每次对所有状态取个min即可\n\n#### 动态求子串出现次数\n\n> 给出一个初始字符串$S​$，每次往后添加一个字符或者询问一个子串在该字符串中出现次数 \n\n动态维护`right集合`大小，可以用`LCT`维护。如果不强制在线还可以直接树剖\n\n\n\n## 广义后缀自动机\n\n### 版本一\n\n考虑建立多个串的 `SAM` ，构造时一个一个串插入，插入完一个串后将 `last` 设为 `root` 再重新开始 \n\n### 版本二\n\n考虑建立 `Trie` 的 `SAM` 。插入完 `Trie` 节点 $x$的时候记录一下 `tmp = last` ，然后插入完$x$ 的某个子树后，再将 `last` 赋为 `tmp` ，再插入另一个子树。 \n\n### 版本三\n\n通过离线`Bfs`这棵`Trie树`构造，与上面的做法类似，但是似乎复杂度有保证\n\n---\n\n前两种方法复杂度好像不太稳定，可以卡。这东西我还不是太理解，有点玄学。。。\n\n","categories":["Summary"],"tags":["Summary","数据结构","字符串","后缀自动机"]},{"title":"「NOI2018」你的名字 - 后缀自动机 + 可持久化线段树合并","url":"/2019/03/06/%E3%80%8CNOI2018%E3%80%8D%E4%BD%A0%E7%9A%84%E5%90%8D%E5%AD%97-%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA-%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%90%88%E5%B9%B6/","content":"\n给定一个模板串$S$，多组询问，每次给出一个询问字符串$T$和一个区间$(l,r)$\n\n求$T$有多少个**本质不同**的子串**没有**在$S$的$[l,r]$这段区间当中出现\n\n$|S|, |T|\\le 5*10^5, \\sum|T|\\le 10^6$\n\n<!--more-->\n\n### Links\n\n[LOJ 2720](https://loj.ac/problem/2720)\n\n\n\n### Solution\n\n首先考虑$l=1, r=|S|$怎么做\n\n答案等于$T$中所有本质不同的子串数量减去$S$和$T$的本质不同公共子串数量\n\n然后考虑如何求$S$和$T$本质不同公共子串个数\n\n一个很显然的做法就是把$T​$的`SAM`中每一个状态拿去在$S​$的`SAM`上跑匹配，但$\\sum\\mathrm{maxlen}​$太大，显然不行\n\n进一步思考，我们发现只需要把每个状态`right集合`中**任取**一个右端点所代表的前缀拿去匹配，假设匹配出来的结果为$len$，则当前状态$i$的答案就是区间$[0, len] \\cap [\\mathrm{minlen}_i, \\mathrm{maxlen}_i]$中的整数元素个数\n\n于是我们只需要把$T​$的每个前缀拿去匹配即可，这个利用在`SAM`上做`two pointer`的方法就能做到$O(|S| + |T|)​$\n\n> 具体来说，假设当前在`SAM`上的$x$点，它匹配上了前缀$T_{i-1}$的长度为$len$的后缀，新加入一个字符$T_i = c$\n>\n> 如果$x​$有向$c​$的转移，则直接转移过去，`len++`\n>\n> 否则跳$x$的父亲直到有转移或者到根结点，$len$值相对应改变\n>\n> 这样做相当于一个两个指针在字符串上移动，另外有个节点在`SAM`上跑，复杂度显然是线性的\n\n---\n\n接着考虑$l, r$更一般的做法\n\n大体思路不变，只是每次在`SAM`上进行转移时，需要保证目标状态所对应的子串在$S$的$[l, r]$范围内\n\n那么我们只需要判断在目标状态的`right`集合中是否存在一个右端点$p$满足$p - len + 1\\ge l$且$p\\le r$，即$p\\in[l + len - 1, r]$\n\n这个显然直接线段树合并，求出每个状态的`right`集合，查询区间和是否大于$0$即可\n\n---\n\n注意，线段树合并的时候需要新开节点，而不能用之前的。因为以前的题最后只需要根结点的线段树信息，而这里要用到每个节点的线段树信息，所以要动态开点\n\n\n\n### Code\n\n#### 68pts\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int Maxn = 1e6 + 100;\n\nint N, M;\nchar s[Maxn];\n\nstruct SAM\n{\n\tint node_cnt, last;\n\tstruct info\n\t{\n\t\tint ch[31], maxlen, fa, pos;\n\t} node[Maxn << 1];\n\tvector <int> G[Maxn];\n\n\tinline void init ()\n\t{\n\t\tfor (int i = 1; i <= node_cnt; ++i)\n\t\t{\n\t\t\tnode[i].fa = node[i].pos = 0;\n\t\t\tfor (int j = 0; j <= 30; ++j) node[i].ch[j] = 0;\n\t\t}\n\t\tnode_cnt = last = 1;\n\t}\n\n\tinline int new_node (int pre, int pos)\n\t{\n\t\tnode[++node_cnt].maxlen = node[pre].maxlen + 1;\n\t\tnode[node_cnt].pos = pos;\n\t\treturn node_cnt;\n\t}\n\n\tinline void extend (int pos, int c)\n\t{\n\t\tint now = new_node (last, pos), pre = last; last = now;\n\n\t\tfor (; pre && !node[pre].ch[c]; pre = node[pre].fa) node[pre].ch[c] = now;\n\n\t\tif (!pre) node[now].fa = 1;\n\t\telse\n\t\t{\n\t\t\tint x = node[pre].ch[c];\n\t\t\tif (node[x].maxlen == node[pre].maxlen + 1) node[now].fa = x;\n\t\t\telse\n\t\t\t{\n\t\t\t\tint y = ++node_cnt;\n\t\t\t\tnode[y] = node[x], node[y].maxlen = node[pre].maxlen + 1;\n\t\t\t\tnode[x].fa = node[now].fa = y;\n\t\t\t\tfor (; node[pre].ch[c] == x; pre = node[pre].fa) node[pre].ch[c] = y;\n\t\t\t}\n\t\t}\n\t}\n\n\tinline void build (char *S, int n)\n\t{\n\t\tinit();\n\t\tfor (int i = 1; i <= n; ++i) extend (i, S[i] - 'a');\n\t}\n} S, T;\n\nint len[Maxn];\n\ninline void Solve ()\n{\n\tS.build (s, N);\n\n\tint Q = read<int>();\n\twhile (Q--)\n\t{\n\t\tscanf(\"%s\", s + 1), M = strlen(s + 1);\n\t\tint l = read<int>(), r = read<int>(), now = 1, len_now = 0;\n\t\tfor (int i = 1; i <= M; ++i)\n\t\t{\n\t\t\tint c = s[i] - 'a';\n\t\t\twhile (1)\n\t\t\t{\n\t\t\t\tif (S.node[now].ch[c]) { ++len_now, now = S.node[now].ch[c]; break; }\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (now == 1) break;\n\t\t\t\t\tnow = S.node[now].fa;\n\t\t\t\t\tlen_now = S.node[now].maxlen;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlen[i] = len_now;\n\t\t}\n\n\t\tT.build (s, M);\n\t\tLL ans = 0;\n\t\tfor (int i = 1; i <= T.node_cnt; ++i)\n\t\t{\n\t\t\tans += T.node[i].maxlen - T.node[T.node[i].fa].maxlen;\n\t\t\tans -= max(0, min(T.node[i].maxlen, len[T.node[i].pos]) - T.node[T.node[i].fa].maxlen);\n\t\t}\n\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n}\n\ninline void Input ()\n{\n\tscanf(\"%s\", s + 1), N = strlen(s + 1);\n}\n\nint main()\n{\n\n\tfreopen(\"name.in\", \"r\", stdin);\n\tfreopen(\"name.out\", \"w\", stdout);\n\n\tInput ();\n\tSolve ();\n\n\treturn 0;\n}\n\n```\n\n\n\n#### 100pts\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int Maxn = 1e6 + 100;\n\nint N, M, Root[Maxn << 1];\nchar s[Maxn];\n\nnamespace SEG\n{\n#define mid (l + r >> 1)\n#define ls node[root].ch[0]\n#define rs node[root].ch[1]\n#define lson ls, l, mid\n#define rson rs, mid + 1, r\n\tint node_cnt;\n\n\tstruct info\n\t{\n\t\tint cnt, ch[2];\n\t} node[Maxn * 30];\n\n\tinline void push_up (int root) { node[root].cnt = node[ls].cnt + node[rs].cnt; }\n\n\tinline void insert (int &root, int l, int r, int x)\n\t{\n\t\t++node[root = ++node_cnt].cnt;\n\t\tif (l == r) return ;\n\t\tif (x <= mid) insert (lson, x);\n\t\telse insert (rson, x);\n\t}\n\n\tinline int merge (int x, int y, int l, int r)\n\t{\n\t\tif (!x || !y) return x | y;\n\t\tint root = ++node_cnt;\n\t\tls = merge (node[x].ch[0], node[y].ch[0], l, mid);\n\t\trs = merge (node[x].ch[1], node[y].ch[1], mid + 1, r);\n\t\tpush_up (root);\n\t\treturn root;\n\t}\n\n\tinline int query (int root, int l, int r, int x, int y)\n\t{\n\t\tif (x > y) return 0;\n\t\tif (x <= l && r <= y) return node[root].cnt;\n\n\t\tint ans = 0;\n\t\tif (x <= mid) ans += query (lson, x, y);\n\t\tif (y > mid) ans += query (rson, x, y);\n\t\treturn ans;\n\t}\n\n#undef mid \n#undef ls \n#undef rs \n#undef lson\n#undef rson\n}\n\nstruct SAM\n{\n\tint node_cnt, last;\n\tstruct info\n\t{\n\t\tint ch[31], maxlen, fa, pos;\n\t} node[Maxn << 1];\n\tvector <int> G[Maxn];\n\n\tinline void init ()\n\t{\n\t\tfor (int i = 1; i <= node_cnt; ++i)\n\t\t{\n\t\t\tnode[i].fa = node[i].pos = 0;\n\t\t\tfor (int j = 0; j <= 30; ++j) node[i].ch[j] = 0;\n\t\t}\n\t\tnode_cnt = last = 1;\n\t}\n\n\tinline int new_node (int pre, int pos, int op)\n\t{\n\t\tnode[++node_cnt].maxlen = node[pre].maxlen + 1, node[node_cnt].pos = pos;\n\t\tif (op) SEG :: insert (Root[node_cnt], 1, N, pos);\n\t\treturn node_cnt;\n\t}\n\n\tinline void extend (int pos, int c, int op)\n\t{\n\t\tint now = new_node (last, pos, op), pre = last; last = now;\n\n\t\tfor (; pre && !node[pre].ch[c]; pre = node[pre].fa) node[pre].ch[c] = now;\n\n\t\tif (!pre) node[now].fa = 1;\n\t\telse\n\t\t{\n\t\t\tint x = node[pre].ch[c];\n\t\t\tif (node[x].maxlen == node[pre].maxlen + 1) node[now].fa = x;\n\t\t\telse\n\t\t\t{\n\t\t\t\tint y = ++node_cnt;\n\t\t\t\tnode[y] = node[x], node[y].maxlen = node[pre].maxlen + 1;\n\t\t\t\tnode[x].fa = node[now].fa = y;\n\t\t\t\tfor (; node[pre].ch[c] == x; pre = node[pre].fa) node[pre].ch[c] = y;\n\t\t\t}\n\t\t}\n\t}\n\n\tinline void dfs (int x)\n\t{\n\t\tfor (int i = 0; i < G[x].size(); ++i)\n\t\t{\n\t\t\tint y = G[x][i];\n\t\t\tdfs (y);\n\t\t\tRoot[x] = SEG :: merge (Root[x], Root[y], 1, N);\n\t\t}\n\t}\n\n\tinline void build (char *S, int n, int op)\n\t{\n\t\tinit ();\n\t\tfor (int i = 1; i <= n; ++i) extend (i, S[i] - 'a', op);\n\t\tif (op)\n\t\t{\n\t\t\tfor (int i = 1; i <= node_cnt; ++i) G[node[i].fa].pb (i);\n\t\t\tdfs (1);\n\t\t}\n\t}\n} S, T;\n\nint len[Maxn];\n\ninline void Solve ()\n{\n\tS.build (s, N, 1);\n\n\tint Q = read<int>();\n\twhile (Q--)\n\t{\n\t\tscanf(\"%s\", s + 1), M = strlen(s + 1);\n\t\tint l = read<int>(), r = read<int>(), now = 1, len_now = 0;\n\t\tfor (int i = 1; i <= M; ++i)\n\t\t{\n\t\t\tint c = s[i] - 'a';\n\t\t\twhile (1)\n\t\t\t{\n\t\t\t\tif (SEG :: query (Root[S.node[now].ch[c]], 1, N, l + len_now, r)) { ++len_now, now = S.node[now].ch[c]; break; }\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (now == 1) break;\n\t\t\t\t\t--len_now;\n\t\t\t\t\tif (len_now == S.node[S.node[now].fa].maxlen) now = S.node[now].fa;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlen[i] = len_now;\n\t\t}\n\n\t\tT.build (s, M, 0);\n\t\tLL ans = 0;\n\t\tfor (int i = 1; i <= T.node_cnt; ++i)\n\t\t{\n\t\t\tans += T.node[i].maxlen - T.node[T.node[i].fa].maxlen;\n\t\t\tans -= max(0, min(T.node[i].maxlen, len[T.node[i].pos]) - T.node[T.node[i].fa].maxlen);\n\t\t}\n\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n}\n\ninline void Input ()\n{\n\tscanf(\"%s\", s + 1), N = strlen(s + 1);\n}\n\nint main()\n{\n\n\tfreopen(\"name.in\", \"r\", stdin);\n\tfreopen(\"name.out\", \"w\", stdout);\n\n\tInput ();\n\tSolve ();\n\n\treturn 0;\n}\n\n```\n\n","categories":["Problem"],"tags":["数据结构","线段树合并","字符串","后缀自动机","可持久化"]},{"title":"「模拟赛」19.3.6模拟赛 - Summary","url":"/2019/03/06/%E3%80%8C%E6%A8%A1%E6%8B%9F%E8%B5%9B%E3%80%8D19-3-6%E6%A8%A1%E6%8B%9F%E8%B5%9B-Summary/","content":"","categories":["Summary"],"tags":["Summary","动态规划","数据结构","树状数组","计数","字符串","后缀自动机"]},{"title":"「2017 山东一轮集训 Day5」字符串 - 后缀自动机 + 动态规划","url":"/2019/03/06/%E3%80%8C2017-%E5%B1%B1%E4%B8%9C%E4%B8%80%E8%BD%AE%E9%9B%86%E8%AE%AD-Day5%E3%80%8D%E5%AD%97%E7%AC%A6%E4%B8%B2-%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","content":"\n给定 $n$ 个字符集为小写字母的字符串 $s_i$\n\n一个串 $t$ 是可接受的，当且仅当 $t$ 可以表示成 $p_1 + p_2 + \\cdots + p_n$，其中 $p_i$为 $s_i$的一个子串（可以为空），$+$ 表示字符串的拼接\n\n问有多少种本质不同的字符串 $t$ 是可接受的\n\n答案对 $10^ 9 + 7$取模\n\n<!--more-->\n\n### Links\n\n[LOJ 6071](https://loj.ac/problem/6071)\n\n\n\n### Solution\n\n考虑对每个串建出`SAM`\n\n一个直观的想法是把每个串的本质不同子串个数直接乘起来，但是这样肯定会算重\n\n通过观察不难发现，算重的情况就是第$i$个串的某个状态的一个后缀与第$i+1$个串的某个前缀重叠\n\n如何不考虑这种情况呢？\n\n考虑在`SAM`上dp，从第$n$个串往前倒着dp。如果当前串`SAM`的某个节点上存在某种后继状态，那么在后面的选择中**第一个字符**就不能等于这个后继状态，只有这样才能保证 dp 不会算重\n\n利用这个性质，我们就只需要存$dp[c]$表示后面的串以$c$开头的方案数，直接在`SAM`上转移即可\n\n> 具体来说，先把所有节点`拓扑排序`，按逆拓扑序的顺序进行当前`SAM`上的dp\n\n> 设$f[i]$表示当前`SAM`中状态$i$的答案， 枚举这个点的所有后继状态，如果这个后继状态 $j$ 不存在，那么$f[i] += dp[j]$ ，否则$f[i] += f[j]$。第一个串根节点存的dp值即为最后的答案\n\n### Summary\n\n在`SAM`上dp时，如果当前状态往后有转移边的话，就强制从当前`SAM`中转移；否则从后面字符串的答案转移\n\n这样就能保证dp不算重\n\n\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int Maxn = 1e6 + 100, Mod = 1e9 + 7;\n\nint N, Dp[30];\n\ninline void Add (int &a, int b) { if ((a += b) >= Mod) a -= Mod; }\n\nnamespace SAM\n{\n\tint node_cnt, last;\n\tstruct info\n\t{\n\t\tint maxlen, fa, ch[26];\n\t} node[Maxn << 1];\n\n\tinline int new_node (int pre)\n\t{\n\t\tnode[++node_cnt].maxlen = node[pre].maxlen + 1;\n\t\treturn node_cnt;\n\t}\n\n\tinline void extend (int c)\n\t{\n\t\tint now = new_node (last), pre = last; last = now;\n\n\t\tfor (; pre && !node[pre].ch[c]; pre = node[pre].fa) node[pre].ch[c] = now;\n\t\t\n\t\tif (!pre) node[now].fa = 1;\n\t\telse\n\t\t{\n\t\t\tint x = node[pre].ch[c];\n\t\t\tif (node[x].maxlen == node[pre].maxlen + 1) node[now].fa = x;\n\t\t\telse\n\t\t\t{\n\t\t\t\tint y = ++node_cnt;\n\t\t\t\tnode[y] = node[x], node[y].maxlen = node[pre].maxlen + 1;\n\t\t\t\tnode[x].fa = node[now].fa = y;\n\t\t\t\tfor (; node[pre].ch[c] == x; pre = node[pre].fa) node[pre].ch[c] = y;\n\t\t\t}\n\t\t}\n\t}\n\n\tinline void init ()\n\t{\n\t\tfor (int i = 1; i <= node_cnt; ++i)\n\t\t{\n\t\t\tmemset(node[i].ch, 0, sizeof node[i].ch);\n\t\t\tnode[i].maxlen = node[i].fa = 0;\n\t\t}\n\t\tnode_cnt = last = 1;\n\t}\n\n\tinline void build (string S)\n\t{\n\t\tinit ();\n\t\tfor (int i = 0; i < S.length(); ++i) extend (S[i] - 'a');\n\t}\n\n\tint f[Maxn << 1], P[Maxn << 1], deg[Maxn << 1];\n\n\tinline void top_sort ()\n\t{\n\t\tstatic queue <int> Q;\n\n\t\tfor (int i = 1; i <= node_cnt; ++i) deg[i] = 0;\n\n\t\tfor (int i = 1; i <= node_cnt; ++i) \n\t\t\tfor (int c = 0; c < 26; ++c) \n\t\t\t\tif (node[i].ch[c]) ++deg[node[i].ch[c]];\n\n\t\tfor (int i = 1; i <= node_cnt; ++i) if (!deg[i]) Q.push(i);\n\n\t\tint cnt = 0;\n\t\twhile (!Q.empty())\n\t\t{\n\t\t\tint x = Q.front(); Q.pop();\n\t\t\tP[++cnt] = x;\n\t\t\tfor (int c = 0; c < 26; ++c)\n\t\t\t\tif (node[x].ch[c])\n\t\t\t\t{\n\t\t\t\t\tint y = node[x].ch[c];\n\t\t\t\t\t--deg[y];\n\t\t\t\t\tif (!deg[y]) Q.push(y);\n\t\t\t\t}\n\t\t}\n\t}\n\n\tinline void solve ()\n\t{\n\t\ttop_sort();\n\n\t\tfor (int i = node_cnt; i >= 1; --i)\n\t\t{\n\t\t\tint x = P[i];\n\t\t\tf[x] = 1;\n\n\t\t\tfor (int c = 0; c < 26; ++c)\n\t\t\t\tif (node[x].ch[c]) Add (f[x], f[node[x].ch[c]]);\n\t\t\t\telse Add (f[x], Dp[c]);\n\t\t}\n\n\t\tfor (int c = 0; c < 26; ++ c) if (node[1].ch[c]) Dp[c] = f[node[1].ch[c]];\n\t}\n}\n\nstring S[Maxn];\n\ninline void Solve ()\n{\n\tfor (int i = N; i >= 1; --i)\n\t{\n\t\tSAM :: build (S[i]);\n\t\tSAM :: solve ();\n\t}\n\n\tint ans = 1;\n\tfor (int i = 0; i < 26; ++i) Add (ans, Dp[i]);\n\tprintf(\"%d\\n\", ans);\n}\n\ninline void Input ()\n{\n\tN = read<int>();\n\tfor (int i = 1; i <= N; ++i) cin >> S[i];\n}\n\nint main()\n{\n\n#ifndef ONLINE_JUDGE\n\tfreopen(\"name.in\", \"r\", stdin);\n\tfreopen(\"name.out\", \"w\", stdout);\n#endif\n\n\tInput ();\n\tSolve ();\n\n\treturn 0;\n}\n\n```\n\n","categories":["Problem"],"tags":["动态规划","数据结构","字符串","后缀自动机"]},{"title":"后缀自动机学习笔记","url":"/2019/03/05/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"\n几次尝试学这个都没太搞懂，过几天就忘\n\n今天看了一个讲得超级好的课件之后才真正理解SAM\n\n趁热写一点笔记，省得以后又全忘了\n\n可能大部分都是从ppt里搬来的吧。。。\n\n<!--more-->\n\n## UPD 20.1.31\n\n今天复习了SAM\n\n> [yyb的这篇文章](https://www.cnblogs.com/cjyyb/p/8446205.html) 还写得挺好的\n\n再举一个例子理解一下克隆节点的过程：\n\n![20-1-29-1](/images/20-1-29-1.jpg)\n\n---\n\n> 注：以下的内容（主要是定义）不一定非常严谨，但比较通俗易懂。而且大多数也只是自己对SAM的一点点感性理解，依旧不适合初学者阅读。。。\n>\n> 非常严谨的东西可以看[这里](https://www.cnblogs.com/zjp-shadow/p/9218214.html)或[这里](https://oi.men.ci/suffix-automaton-notes/)\n\n## Brief Introduction\n\n自动机，通俗来说，就是一张带有根和转移边的有向图，每条转移边上有一个字符，一个点出发的所有转移边上的字符必须两两不相同\n\n考虑自动机上一条由根出发的由节点和转移边构成的有向路径，把路径的转移边上的字符按顺序拼接起来可以得到一个字符串$S$ ，那么我们就说这条路径的终点（这是一个节点）接受字符串$S$\n\n如果一个自动机上存在一条由根出发的有向路径使得转移边上的字符按顺序拼接起来可以得到，那么我们就说$S$被这个自动机接受\n\n后缀自动机就是能接受某个串的所有后缀/子串的自动机\n\n\n\n## 一些定义\n\n### 节点/状态\n\n后缀自动机一个节点/状态代表这个节点能接受的串的集合，一个节点内的所有串互相存在后缀关系（一个是另一个的后缀），且长度连续\n\n### right/endpos集合\n\n一个子串在原串中所有结束位置构成的集合，SAM一个节点中所有子串的`right集合`相同\n\n### fa/parent/suffix link\n\nSAM中一个节点所包含的所有子串可以看成是由最长的那个串不断删掉第一个字符构成的，但是有可能最短的那个串长度不为$1$。那么这个`fa`就指向`当前节点包含的最短的串删掉第一个字符`这个串所在的节点\n\n显然，从一个节点不断跳`fa`，就能遍历到所有它的所有后缀\n\n并且，这样的后缀链接形成的`parent树`就是反串的后缀树\n\n### maxlen\n\n一个节点所包含的最长子串的长度\n\n\n\n## 构造\n\n> 这里是一些关于构造的感性认识\n\n使用增量法进行构造，**每次把之前存在的所有后缀都添上一个转移，转移到一个新的节点$now$**\n\n> 其实上面一句话就把构造过程讲完了，下面只是一些细节\n\n而之前存在的所有后缀显然就是上一次添加完的串的所有后缀，于是可以不断跳上一次添加的新节点的`fa`，添加它们到$now$的转移\n\n但是，有可能在跳`fa`的过程中，某个状态转移向当前字符的转移边之前已经出现（显然这种情况只会连续一段地出现，我们先只考虑最先出现的那个状态$pre$）\n\n* 如果$pre$的`maxlen`加上$1$就等于转移到的节点（设为$x$）的`maxlen`，则说明已经存在了连续一段的所有后缀了。也就是说，我们找到了一个能不重不漏地接受当前串所有后缀的节点集合。此时我们只需要把的`fa[now]`指向$x$即可\n* 否则，$x$的`maxlen`大于$pre$的`maxlen + 1`，这说明$x$这个节点能接受的串太多了，而我们当前需要添加转移的只有小于等于`maxlen + 1`的那一部分。于是我们可以把$x$这个点拆分，以`maxlen + 1`为界，把长度小于等于`maxlen + 1`的部分拆出来形成一个新点$y$。那么`fa[now]`和`fa[x]`都要等于$y$。并且$pre$的所有祖先原来有转移向$x$的，现在都要改成向$y$转移\n\n时间复杂度，状态数，转移边数均可以被证明是$O(n)$级别的\n\n> 状态数$\\le 2\\times n$， 转移边数$\\le 3 \\times n$\n\n\n### Code\n\n```cpp\n\tint node_cnt = 1, last = 1;\n\tstruct info\n\t{\n\t\tint ch[30], fa, maxlen, cnt;\n\t} node[Maxn << 1];\n\n\tinline int new_node (int pre)\n\t{\n\t\t++node_cnt;\n\t\tnode[node_cnt].maxlen = node[pre].maxlen + 1;\n\t\treturn node_cnt;\n\t}\n\n\tinline void extend (int c)\n\t{\n\t\tint now = new_node (last), pre = last; last = now;\n\t\tnode[node_cnt].cnt = 1;\n\n\t\tfor (; pre && !node[pre].ch[c]; pre = node[pre].fa) node[pre].ch[c] = now;\n\t\tif (!pre) node[now].fa = 1;\n\t\telse\n\t\t{\n\t\t\tint x = node[pre].ch[c];\n\t\t\tif (node[x].maxlen == node[pre].maxlen + 1) node[now].fa = x;\n\t\t\telse\n\t\t\t{\n\t\t\t\tint y = ++node_cnt; \n\t\t\t\tnode[y] = node[x], node[y].maxlen = node[pre].maxlen + 1, node[y].cnt = 0;\n\t\t\t\tnode[x].fa = node[now].fa = y;\n\t\t\t\tfor (; node[pre].ch[c] == x; pre = node[pre].fa) node[pre].ch[c] = y;\n\t\t\t}\n\t\t}\n\t}\n\n```\n\n\n\n\n\n## 一些简单的性质\n\n### right集合\n\n> 为了方便描述，我们称`传统节点`为每次添加节点时像$now$这样的节点，称`克隆节点`为每次通过拆分出来的，像$y$这样的节点\n\n后缀自动机的状态`right集合`大小是其在`parent树`中子树`传统节点`的数量，代表这个状态所表示的子串出现次数\n\n原因很显然\n\n### 匹配\n\n后缀自动机上的匹配和KMP也差不多\n\n因为KMP的一个状态是$S$的一个前缀，所以它可以匹配到最长的`为S的前缀`的后缀\n\n而后缀自动机的一个状态是$S$的一个子串，所以它可以对$T$的每个前缀求出最长的`为S的子串`的后缀\n\n方法和AC自动机上跳`fail`是几乎一模一样的，只是这里变成跳`fa`。\n\n具体来说，考虑每次新添加进来$T$中的一个字符$c$，如果当前状态有$c$的转移边则匹配成功；否则不断跳`fa`直到匹配上或者跳到根节点\n\n---\n\n还有一些具体的应用还是单独再写一篇吧\n\n这篇文章（可能会？）持续更新\n","categories":["Algorithm"],"tags":["数据结构","字符串","后缀自动机"]},{"title":"「USACO19JAN」Platinum Solution","url":"/2019/03/05/%E3%80%8CUSACO19JAN%E3%80%8DPlatinum-Solution/","content":"\n感觉这一场的后面两题稍微比18DEC的要难一点点\n\nT2的一些小细节想了很久，问了jambow；T3最后一点边界情况没想清楚，经dis提示后才会\n\n<!--more-->\n\n[YALIOJ Link](http://yloj.yali.edu.cn/v3/contest_show.php?cid=404)\n\n## Redistricting\n\n### Description\n\n给出一个长度为$n$的01序列，现在你要把这个序列分成若干个长度不超过$K$的连续段\n\n求最少有多少段1的数量不少于0的数量\n\n\n\n### Constraints\n\n$n\\le 3*10^5$\n\n\n\n### Solution\n\n考虑dp，设$dp[i]$表示考虑到$i$的答案\n$$\ndp[i] = \\min_{j=\\max(0, i - K)}^{i-1} (dp[j] + [sum1(j + 1, i) \\ge \\frac{j-i}{2}])\n$$\n其中$sum1(i,j)$表示区间$i$到$j$中1的个数\n\n显然这个式子拆一下就能变成$j - 2 * sum[j] \\ge i - 2 * sum[i]$，其中$sum[i]$是$1$的前缀和\n\n对于$j-2*sum[j]$这个下标维护一个最小值的线段树，每次算出需要$+1$的部分的下标区间和不$+1​$的下标区间，直接转移\n\n因为有$j\\ge max(0, i-K)$这个限制，所以在线段树维护的时候还要支持删除，那么在最底层开一个可删除堆维护即可\n\n时间复杂度$O(n\\log n)$，最多只会在线段树底层进行$O(n)$次删除，所以不是$O(n \\log ^2 n)$的\n\n\n\n## Exercise Route\n\n### Description\n\n给出一棵$n$个节点的树，另外还有$m-n+1$条非树边（即边数总和为$m$）\n\n求恰好包含两条非树边的**简单**环的个数\n\n\n\n### Constraints\n\n$n, m\\le 2*10^5$\n\n\n\n### Solution\n\n通过观察发现，两条非树边$(x_1, y_1),(x_2, y_2)$要能形成简单环，当且仅当路径$(x_1, y_1)$和$(x_2, y_2)$有公共边\n\n于是可以把路径$(x,y)​$拆成$(x, lca)​$和$(lca, y)​$两段统计贡献，直接树上差分\n\n然后需要多处理一下两条路径的包含情况，也就是它们位于$lca​$所在子树相同。这种情况会多算，需要减掉\n\n\n\n## Train Tracking 2\n\n### Description\n\n有一个长度为$n$，值域$[1, 10^9]$的数组$a_i$\n\n给出$k$, 告诉你$c_i = \\min_{j=i}^{i+-1}a_j$，求满足条件的数组$a$有多少个，答案对$10^9+7$取模\n\n\n\n### Constraints\n\n$n\\le 10^5$\n\n\n\n### Solution\n\n不难发现，若$c_i > c_{i + 1}$，则能确定$a_{i+k}$的值；若$c_i < c_{i+1}$，则能确定$a_{i}$的值\n\n考虑连续一段$c_i$相同的答案：求一段长度为$len$，$c_i$全都为$val$的方案数\n\n令$x = 10^9 - val$，$dp[i]$表示考虑到第$i$个数的方案数，那么有\n$$\ndp[i] = (x + 1)dp[i-1] - x^{k}dp[i - k - 1]\n$$\n\n> 假设第$i$个数随便填$[val, 10^9]$中的数，则有可能区间$[i - k+ 1, i]$全都没有填$val$这个数\n>\n> 这种情况就是$[i-k+1, i]$每个都能填$[val + 1, 10^9]$的数，且第$i-k$位填了$val$（因为要保证$val$在区间$[i-k, i-1]$至少出现一次），剩下前面合法的方案数，即为$x^kdp[i-k-1]$\n\n那么可以把原序列分成$c_i$相同的若干段，每段分别计算\n\n最后特殊处理一下段与段之间相交的情况：若上一段的值$c_{i-1}$大于当前的值$c_i$，那么$a_{i+k-1}$的值能被确定，且$[i, i+k-2]$内的数会在上一段被考虑到，也就是说当前需要考虑的位置要减少$k$个。下一段的情况同理\n\n\n\n## Codes\n\n### T1\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int Maxn = 3e5 + 100, inf = 0x3f3f3f3f;\n\nint N, K, Dp[Maxn];\nchar S[Maxn];\n\nstruct Heap\n{\n\tpriority_queue <int, vector <int>, greater <int> > Q1, Q2;\n\n\tinline void process () { while (!Q2.empty() && Q1.top() == Q2.top()) Q1.pop(), Q2.pop(); }\n\n\tinline void push (int x) { Q1.push(x); }\n\n\tinline void erase (int x) { Q2.push(x); }\n\n\tinline int top () { process();  return (!Q1.empty()) ? Q1.top() : inf; }\n};\n\nnamespace SEG\n{\n#define mid (l + r >> 1)\n#define lson root << 1, l, mid \n#define rson root << 1 | 1, mid + 1, r \n\n\tstruct info\n\t{\n\t\tint min;\n\t\tHeap h;\n\t} node[Maxn << 2];\n\n\tinline void push_up (int root) { node[root].min = min(node[root << 1].min, node[root << 1 | 1].min); }\n\n\tinline void init (int root, int l, int r)\n\t{\n\t\tnode[root].min = inf;\n\t\tif (l == r) return ;\n\t\tinit (lson), init (rson);\n\t}\n\n\tinline void update (int root, int l, int r, int x, int val, int op)\n\t{\n\t\tif (l == r)\n\t\t{\n\t\t\tif (op) node[root].h.push (val);\n\t\t\telse node[root].h.erase (val);\n\t\t\tnode[root].min = node[root].h.top();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (x <= mid) update (lson, x, val, op);\n\t\t\telse update (rson, x, val, op);\n\t\t\tpush_up (root);\n\t\t}\n\t}\n\n\tinline int query (int root, int l, int r, int x, int y)\n\t{\n\t\tif (x > y) return inf;\n\t\tif (x <= l && r <= y) return node[root].min;\n\n\t\tint ans = inf;\n\t\tif (x <= mid) ans = min(ans, query (lson, x, y));\n\t\tif (y > mid) ans = min(ans, query (rson, x, y));\n\t\treturn ans;\n\t}\n\n#undef mid\n#undef lson\n#undef rson\n}\n\nint Sum[Maxn], Val[Maxn];\n\ninline void Solve ()\n{\n\tint cnt = 0;\n\tfor (int i = 0; i <= N; ++i)\n\t{\n\t\tSum[i] = Sum[i - 1] + (S[i] == 'G');\n\t\tVal[++cnt] = i - 2 * Sum[i];\n\t}\n\n\tsort(Val + 1, Val + cnt + 1);\n\tcnt = unique (Val + 1, Val + cnt + 1) - Val - 1;\n\tSum[0] = lower_bound (Val + 1, Val + cnt + 1, Sum[0]) - Val;\n\n\tSEG :: init (1, 1, cnt);\n\tSEG :: update (1, 1, cnt, Sum[0], 0, 1);\n\n\tfor (int i = 1; i <= N; ++i)\n\t{\n\t\tSum[i] = lower_bound (Val + 1, Val + cnt + 1, i - 2 * Sum[i]) - Val;\n\t\tif (i >= K + 1)\n\t\t{\n\t\t\tint x = i - K - 1;\n\t\t\tSEG :: update (1, 1, cnt, Sum[x], Dp[x], 0);\n\t\t}\n\t\tint x1 = SEG :: query (1, 1, cnt, Sum[i], cnt) + 1;\n\t\tint x2 = SEG :: query (1, 1, cnt, 1, Sum[i] - 1);\n\t\tDp[i] = min (x1, x2);\n\t\t//cout << Dp[i] << endl;\n\t\tSEG :: update (1, 1, cnt, Sum[i], Dp[i], 1);\n\t}\n\n\tcout << Dp[N] << endl;\n}\n\ninline void Input ()\n{\n\tN = read<int>(), K = read<int>();\n\tscanf(\"%s\", S + 1);\n}\n\nint main()\n{\n\n#ifdef hk_cnyali\n\tfreopen(\"A.in\", \"r\", stdin);\n\tfreopen(\"A.out\", \"w\", stdout);\n#endif\n\n\tInput ();\n\tSolve ();\n//\tproc_status();\n\n\treturn 0;\n}\n\n```\n\n\n\n### T2\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int Maxn = 2e5 + 100;\n\nint N, M;\nvector <int> G[Maxn];\npii E[Maxn];\n\nint Sum[Maxn];\nmap <pii, int> Map;\n\nnamespace HLD\n{\n\tint dfn[Maxn], dfs_clock, top[Maxn], son[Maxn], size[Maxn], dep[Maxn], fa[Maxn];\n\n\tinline void dfs_pre (int x)\n\t{\n\t\tdep[x] = dep[fa[x]] + 1, size[x] = 1;\n\n\t\tfor (int i = 0; i < G[x].size(); ++i)\n\t\t{\n\t\t\tint y = G[x][i];\n\t\t\tif (y == fa[x]) continue;\n\t\t\tfa[y] = x;\n\t\t\tdfs_pre (y);\n\t\t\tif (size[y] > size[son[x]]) son[x] = y;\n\t\t\tsize[x] += size[y];\n\t\t}\n\t}\n\n\tinline void get_top (int x, int now)\n\t{\n\t\tdfn[x] = ++dfs_clock, top[x] = now;\n\t\tif (son[x]) get_top (son[x], now);\n\n\t\tfor (int i = 0; i < G[x].size(); ++i)\n\t\t{\n\t\t\tint y = G[x][i];\n\t\t\tif (y == fa[x] || y == son[x]) continue;\n\t\t\tget_top (y, y);\n\t\t}\n\t}\n\n\tinline int get_lca (int x, int y)\n\t{\n\t\twhile (top[x] != top[y])\n\t\t{\n\t\t\tif (dep[top[x]] < dep[top[y]]) swap(x, y);\n\t\t\tx = fa[top[x]];\n\t\t}\n\t\tif (dep[x] < dep[y]) swap(x, y);\n\t\treturn y;\n\t}\n}\n\nusing namespace HLD;\n\ninline int cmp (int x, int y) { return dfn[x] < dfn[y]; }\n\ninline void dfs_sum (int x)\n{\n\tfor (int i = 0; i < G[x].size(); ++i)\n\t{\n\t\tint y = G[x][i];\n\t\tif (y == fa[x]) continue;\n\t\tSum[y] += Sum[x];\n\t\tdfs_sum (y);\n\t}\n}\n\nLL ans = 0;\n\ninline void Update (int x, int y) \n{ \n\tint lca = get_lca (x, y);\n\tint fx = *(--upper_bound (G[lca].begin(), G[lca].end(), x, cmp));\n\tint fy = *(--upper_bound (G[lca].begin(), G[lca].end(), y, cmp));\n//\tcout << x << ' ' << y << ' ' << lca << endl;\n//\tcout << fx << ' ' << fy << endl;\n\n\tif (lca != x) ans -= Sum[fx] + Sum[fy], ++Sum[fx], ++Sum[fy];\n\telse ans -= Sum[fy], ++Sum[fy];\n}\n\ninline void Query (int x, int y)\n{\n\tint lca = get_lca (x, y);\n\tint fx = *(--upper_bound (G[lca].begin(), G[lca].end(), x, cmp));\n\tint fy = *(--upper_bound (G[lca].begin(), G[lca].end(), y, cmp));\n\n\tif (lca != x) ans -= Map[mp(fx, fy)], ++Map[mp(fx, fy)];\n\n\tans += max(0, Sum[x] - Sum[lca] - 1);\n\tans += max(0, Sum[y] - Sum[lca] - 1);\n}\n\ninline void Solve ()\n{\n\tdfs_pre (1), get_top (1, 1);\n\tfor (int i = 1; i <= N; ++i) sort(G[i].begin(), G[i].end(), cmp);\n\n\tfor (int i = 1; i <= M; ++i)\n\t{\n\t\tif (dfn[E[i].x] > dfn[E[i].y]) swap(E[i].x, E[i].y);\n\t\tUpdate (E[i].x, E[i].y);\n\t}\n\n\tdfs_sum (1);\n\n\tfor (int i = 1; i <= M; ++i) Query (E[i].x, E[i].y);\n\n\tcout << ans << endl;\n}\n\ninline void Input ()\n{\n\tN = read<int>(), M = read<int>() - (N - 1);\n\n\tfor (int i = 1; i < N; ++i)\n\t{\n\t\tint x = read<int>(), y = read<int>();\n\t\tG[x].pb (y), G[y].pb (x);\n\t}\n\n\tfor (int i = 1; i <= M; ++i) E[i].x = read<int>(), E[i].y = read<int>();\n}\n\nint main()\n{\n\n#ifdef hk_cnyali\n\tfreopen(\"B.in\", \"r\", stdin);\n\tfreopen(\"B.out\", \"w\", stdout);\n#endif\n\n\tInput ();\n\tSolve ();\n\n\treturn 0;\n}\n\n```\n\n\n\n### T3\n\n```cpp\n\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int Maxn = 1e5 + 100;\nconst int Mod = 1e9 + 7;\n\ninline int Pow (int a, int b)\n{\n\tint ans = 1;\n\tfor (int i = b; i; i >>= 1, a = (LL)a * a % Mod) if (i & 1) ans = (LL)ans * a % Mod;\n\treturn ans;\n}\n\nint N, K, A[Maxn];\nint Dp[Maxn];\n\ninline void Add (int &a, int b) { a += b; if (a >= Mod) a -= Mod; }\n\ninline int Calc (int val, int n)\n{\n\tint rest = 1e9 - val, rest_pow = Pow(rest, K);\n\tDp[0] = 1;\n\tfor (int i = 1; i <= n; ++i)\n\t{\n\t\tDp[i] = (LL)(rest + 1) * Dp[i - 1] % Mod;\n\t\tif (i >= K) Add (Dp[i], Mod - (LL)rest_pow * Dp[max(0, i - K - 1)] % Mod);\n\t}\n\treturn Dp[n];\n}\n\ninline void Solve ()\n{\n\tint i = 1, ans = 1;\n\twhile (i <= N - K + 1)\n\t{\n\t\tint j = i, len = K;\n\t\twhile (A[j] == A[j + 1]) ++j, ++len;\n\n\t\tif (A[i - 1] > A[i]) len -= K;\n\t\tif (A[j + 1] > A[j]) len -= K;\n\n\t\tif (len >= 0) ans = (LL)ans * Calc (A[i], len) % Mod;\n\t\ti = j + 1;\n\t}\n\n\tcout << ans << endl;\n}\n\ninline void Input ()\n{\n\tN = read<int>(), K = read<int>();\n\tfor (int i = 1; i <= N - K + 1; ++i) A[i] = read<int>();\n}\n\nint main()\n{\n\n#ifdef hk_cnyali\n\tfreopen(\"C.in\", \"r\", stdin);\n\tfreopen(\"C.out\", \"w\", stdout);\n#endif\n\n\tInput ();\n\tSolve ();\n\n\treturn 0;\n}\n\n```\n\n","categories":["Problem"],"tags":["动态规划","线段树","数据结构","堆","计数","差分","可删除堆","usaco"]},{"title":"「USACO18DEC」Platinum Solution","url":"/2019/03/05/%E3%80%8CUSACO18DEC%E3%80%8DPlatinum%20Solution/","content":"\n最近屈哥布置的USACO的月赛题，难度不是太大，但是T2的一些小细节还是没太想清楚，看了下题解\n\n<!--more-->\n\n> 注：为了优化阅读体验，代码统一放到了文章末尾处\n\n[YALIOJ Link](http://yloj.yali.edu.cn/v3/contest_show.php?cid=400#info)\n\n## Balance Beam\n\n### Links\n\n[Luogu P5155](https://www.luogu.org/problemnew/show/P5155)\n\n### Description\n\n给定一个长为$n$的序列，可以选择以$\\frac{1}{2}$的概率进行左右移动，也可以结束并得到当前位置上的收益$f_i$（$f_i$给出）\n\n求从每个位置开始时使用最优策略的最大期望收益是多少\n\n\n\n### Constraints\n\n$n\\leq 10^5$\n\n\n\n### Solution\n\n一看到$\\frac{1}{2}$的概率随机游走就自然而然地想到了[赌徒破产模型](https://hk-cnyali.com/2019/02/02/%E8%B5%8C%E5%BE%92%E7%A0%B4%E4%BA%A7%E9%97%AE%E9%A2%98%EF%BC%88%E5%8F%A3%E8%83%A1%EF%BC%89/)\n\n显然，以$i$开始的答案，要么是直接在$i$结束，要么是往左/右随机游走到一个收益尽可能大的点并停下\n\n假设往左走到$x$点，往右走到$y$点，那么它们对以$i$位置开始的答案贡献即为$\\frac{y-i}{y-x}f_x + \\frac{i-x}{y-x}f_y$，我们就是要找到点对$(x,y)$使得这个东西最大\n\n这个贡献的式子很优美，稍微观察一下就会发现它就是在坐标系中$(x, f_x)$，$(y, f_y)$这两点的连线与直线$x=i$的焦点的纵坐标\n\n我们要使得交点纵坐标尽量大，那么显然只需要维护一个上凸壳即可（真的很显然，我连图都懒得放了）\n\n\n\n## Sort It Out\n\n### Links\n\n[Luogu P5156](https://www.luogu.org/problemnew/show/P5156)\n\n### Description\n\n给定一个长为$n$的排列，可以选择一个集合$S$，不断重复比较$S$内的每个元素与原排列相邻元素的大小关系，若相邻元素不递增则交换。\n\n你需要选择一个集合$S$使得操作后排列变为上升序列\n\n求满足这样条件的，且集合大小最小的集合中字典序第$k$小的集合 \n\n\n\n### Constraints\n\n$n\\le 10^5, k\\le 10^{18}$\n\n\n\n### Solution\n\n原题意很绕，首先不难注意到这样一个事实：若操作集合$S$后能够将序列排好序，那么$S$中的每个元素在最后序列中都会被放到该放的位置上去（元素$x$被移动到第$x$位），且集合$S$以外的元素的相对位置关系不变。因此$S$以外的元素就必须是一个单调上升子序列\n\n于是题目就能转化为，求原序列字典序第$k$**大**的最长上升子序列（把原问题对偶）\n\n对于这个问题，我们只需要在树状数组求`LIS`的时候多记一个以当前点开头的`LIS`数量，并用一个`vector`记录一下每一次的转移信息，最后把`vector`元素从大到小排序，用类似于线段树求第$k$大的方法计算一下即可\n\n注意在统计第$k$大时，需要保证元素下标单调递增；以及统计次数的时候有可能会爆`long long`，所以要对$10^{18}$取min\n\n具体实现不是很难\n\n\n\n## The Cow Gathering\n\n### Links\n\n[Luogu P5157](https://www.luogu.org/problemnew/show/P5157)\n\n### Description\n\n给定一棵$n$个节点的树，有$m$个限制$(u,v)$表示$u$必须在$v$前删除\n\n问每次删除一个叶子节点，可能**最后一个**留下的点的集合\n\n\n\n### Constraints\n\n$n, m\\le 10^5$\n\n\n\n### Solution\n\n这应该是这一场里最傻逼的一道题了\n\n考虑添加一条限制$(u,v)$后对答案集合产生的影响\n\n显然，以$v$为根，在$u$的子树中的点都不可能最后留下了\n\n于是我们每次把这些点标记一下即可\n\n标记的话，可以直接对以$1$为根，一段连续的`dfs序`操作。具体来说，若以$1$为根时，$v$在$u$的子树中，则倍增/二分找到$v$在$u$的哪个儿子的子树中，对这棵子树外的部分修改；否则直接对$u$的子树修改\n\n可以用前缀和或者树状数组维护\n\n注意，最后还需要跑一遍拓扑排序特判一下无解的情况\n\n\n\n## Codes\n\n### T1\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\ntypedef pair <LL, LL> pll;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int Maxn = 1e5 + 100;\n\nint N;\npii A[Maxn];\n\nnamespace GEOM\n{\n\tint top, Hull[Maxn];\n\tpii Stack[Maxn];\n\n\tinline LL cross (pii x, pii y, pii z) // 向量 x->y 叉乘向量 x->z\n\t{\n\t\tpii a = mp(y.x - x.x, y.y - x.y), b = mp(z.x - x.x, z.y - x.y);\n\t\treturn (LL)a.x * b.y - (LL)b.x * a.y;\n\t}\n\n\tinline void get_hull ()\n\t{\n\t\tStack[++top] = A[0];\n\t\tfor (int i = 1; i <= N + 1; ++i)\n\t\t{\n\t\t\twhile (top > 1 && cross (Stack[top - 1], Stack[top], A[i]) >= 0) --top;\n\t\t\tStack[++top] = A[i];\n\t\t}\n\t\tfor (int i = 1; i <= top; ++i) Hull[i] = Stack[i].x;\n\t}\n}\n\nusing namespace GEOM;\n\ninline void Solve ()\n{\n\tget_hull ();\n\n\tfor (int i = 1; i <= N; ++i)\n\t{\n\t\tint y = lower_bound (Hull + 1, Hull + top + 1, i) - Hull, x = y - 1;\n\t\tx = Hull[x], y = Hull[y];\n\n\t\tif (y == i) printf(\"%lld\\n\", (LL)A[i].y * 100000);\n\t\telse\n\t\t{\n\t\t\tlong double left = (long double)100000 * A[x].y * (y - i) / (y - x);\n\t\t\tlong double right = (long double)100000  * A[y].y * (i - x) / (y - x);\n\t\t\tprintf(\"%lld\\n\", (LL)(left + right));\n\t\t}\n\t}\n}\n\ninline void Input ()\n{\n\tN = read<int>();\n\tA[0] = mp(0, 0);\n\tfor (int i = 1; i <= N; ++i) A[i] = mp(i, read<int>());\n\tA[N + 1] = mp(N + 1, 0);\n}\n\nint main()\n{\n\n#ifdef hk_cnyali\n\tfreopen(\"A.in\", \"r\", stdin);\n\tfreopen(\"A.out\", \"w\", stdout);\n#endif\n\n\tInput ();\n\tSolve ();\n\n\treturn 0;\n}\n\n```\n\n\n\n### T2\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int Maxn = 1e5 + 100;\nconst LL inf = 1e18;\n\nint N, A[Maxn], Vis[Maxn];\nLL K;\n\nstruct info\n{\n\tint max;\n\tLL cnt;\n\tinline void operator += (const info &rhs)\n\t{\n\t\tif (Chkmax(max, rhs.max)) cnt = rhs.cnt;\n\t\telse if (max == rhs.max) cnt = min(inf, cnt + rhs.cnt);\n\t}\n};\n\nnamespace BIT\n{\n#define lowbit(x) (x & (-x))\n\tinfo sum[Maxn];\n\tinline void add (int x, info val) { for (; x; x -= lowbit(x))  sum[x] += val; }\n\tinline info query (int x) { info ans = (info){0, 1}; for (; x <= N; x += lowbit(x)) ans += sum[x]; return ans; }\n}\n\ntypedef pair <int, LL> pil;\n\nvector <pil> G[Maxn];\n\ninline int cmp (pil a, pil b) { return A[a.x] > A[b.x]; }\n\ninline void Solve ()\n{\n\tfor (int i = N; i >= 1; --i)\n\t{\n\t\tinfo now = BIT :: query (A[i] + 1);\n\t\t++now.max;\n\t\tBIT :: add (A[i], now);\n\t\tG[now.max].pb(mp(i, now.cnt));\n\t}\n\n\tint ans = BIT :: query (1).max;\n\tprintf(\"%d\\n\", N - ans);\n\n\tint pos = 0;\n\tfor (int i = ans; i >= 1; --i)\n\t{\n\t\tsort(G[i].begin(), G[i].end(), cmp);\n\t\tfor (int j = 0; j < G[i].size(); ++j)\n\t\t{\n\t\t\tpil now = G[i][j];\n\t\t\tint x = now.x; LL cnt = now.y;\n\t\t\tif (x < pos) continue;\n\t\t\tif (cnt >= K)\n\t\t\t{\n\t\t\t\tVis[A[x]] = 1;\n\t\t\t\tpos = x;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tK -= cnt;\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= N; ++i) if (!Vis[i]) printf(\"%d\\n\", i);\n}\n\ninline void Input ()\n{\n\tN = read<int>(), K = read<LL>();\n\tfor (int i = 1; i <= N; ++i) A[i] = read<int>();\n}\n\nint main()\n{\n\n#ifdef hk_cnyali\n\tfreopen(\"B.in\", \"r\", stdin);\n\tfreopen(\"B.out\", \"w\", stdout);\n#endif\n\n\tInput ();\n\tSolve ();\n\n\treturn 0;\n}\n\n```\n\n\n\n### T3\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n    T sum = 0, fl = 1; char ch = getchar();\n    for (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n    for (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n    return sum * fl;\n}\n\ninline void proc_status ()\n{\n    ifstream t (\"/proc/self/status\");\n    cerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int Maxn = 1e5 + 100;\n\nint N, M, deg[Maxn], Vis[Maxn];\nvector <int> G1[Maxn], G2[Maxn];\n\nint anc[20][Maxn], dep[Maxn], dfn[Maxn], dfs_clock, size[Maxn];\n\ninline void dfs (int x)\n{\n    dfn[x] = ++dfs_clock, size[x] = 1;\n    dep[x] = dep[anc[0][x]] + 1;\n    for (int i = 1; i <= 17; ++i) anc[i][x] = anc[i - 1][anc[i - 1][x]];\n\n    for (int i = 0; i < G1[x].size(); ++i)\n    {\n        int y = G1[x][i];\n        if (y == anc[0][x]) continue;\n        anc[0][y] = x;\n        dfs(y);\n        size[x] += size[y];\n    }\n}\n\ninline void Check ()\n{\n    static queue <int> Q;\n    for (int i = 1; i <= N; ++i) if (deg[i] <= 1) Q.push(i), Vis[i] = 1;\n\n    int cnt = 0;\n    while (!Q.empty())\n    {\n        ++cnt;\n        int x = Q.front(); Q.pop();\n        for (int i = 0; i < G1[x].size(); ++i)\n        {\n            int y = G1[x][i];\n            --deg[y];\n            if (!Vis[y] && deg[y] <= 1) Q.push(y), Vis[y] = 1;\n        }\n        for (int i = 0; i < G2[x].size(); ++i)\n        {\n            int y = G2[x][i];\n            --deg[y];\n            if (!Vis[y] && deg[y] <= 1) Q.push(y), Vis[y] = 1;\n        }\n    }\n\n    if (cnt != N) { for (int i = 1; i <= N; ++i) puts(\"0\"); exit(0); }\n}\n\nint Ans[Maxn], ANS[Maxn];\n\ninline void Solve ()\n{\n    dfs (1);\n    for (int i = 1; i <= M; ++i)\n    {\n        int x = read<int>(), y = read<int>();\n        G2[x].pb(y), ++deg[y];\n\n        if (dfn[x] <= dfn[y] && dfn[y] <= dfn[x] + size[x] - 1)\n        {\n            for (int j = 17; j >= 0; --j) if (dep[anc[j][y]] > dep[x]) y = anc[j][y];\n            ++Ans[1], --Ans[dfn[y]];\n            ++Ans[dfn[y] + size[y]];\n        }\n        else\n        {\n            ++Ans[dfn[x]], --Ans[dfn[x] + size[x]];\n        }\n    }\n\n    Check ();\n\n    for (int i = 1; i <= N; ++i) Ans[i] += Ans[i - 1];\n    for (int i = 1; i <= N; ++i) printf(\"%d\\n\", !Ans[dfn[i]]);\n}\n\ninline void Input ()\n{\n    N = read<int>(), M = read<int>();\n    for (int i = 1; i < N; ++i)\n    {\n        int x = read<int>(), y = read<int>();\n        G1[x].pb(y), G1[y].pb(x);\n        ++deg[x], ++deg[y];\n    }\n}\n\nint main()\n{\n\n#ifdef hk_cnyali\n    freopen(\"C.in\", \"r\", stdin);\n    freopen(\"C.out\", \"w\", stdout);\n#endif\n\n    Input ();\n    Solve ();\n\n    return 0;\n}\n```\n\n","categories":["Problem"],"tags":["数据结构","树状数组","倍增","概率和期望","计算几何","赌徒破产问题","凸包","usaco"]},{"title":"「HNOI2016」树 - 主席树 + 倍增 + 模拟","url":"/2019/03/03/%E3%80%8CHNOI2016%E3%80%8D%E6%A0%91-%E4%B8%BB%E5%B8%AD%E6%A0%91-%E5%80%8D%E5%A2%9E-%E6%A8%A1%E6%8B%9F/","content":"\n给你一棵$n$个节点的模板树，一棵大树初始等于模板树\n\n给出$m$次操作，每次把模板树中以$x$为根的子树复制，并接到大树的$y$号节点上\n\n然后对新节点重标号，新节点的编号为`大树在上一次操作结束时的节点数`加上`这个节点在模板树那棵子树里的排名`\n\n有$q$次询问，每次询问大树上两个节点的距离\n\n$n, m, q\\le 10^5$\n\n<!--more-->\n\n### Links\n\n[LOJ 2050](https://loj.ac/problem/2050)\n\n\n\n### Solution\n\n一道大模拟题\n\n对大树缩一下点，每次只保留复制过来子树的根结点，并处理出倍增数组。对于询问直接倍增求lca，一些细节地方暴力在模板树里求即可\n\n对于求一个点在大树中具体的节点编号为多少，可以对模板树按`dfs序`建出主席树，直接查区间第$k​$大\n\n剩下的就全是~~特别屎的~~细节了\n\n大概讲一些小地方吧：\n\n> 注： 以下（包括代码中）的大点均表示大树在缩完点后剩下的点\n\n* 求lca的时候需要特殊处理一开始的两个端点到其对应的大点的距离；以及最后跳到大点lca的时候的细节问题\n\n* 要判断一下两个大点是否存在祖孙关系，画个图就会发现需要特判\n* 记得开`long long`\n\n想了想还是扔张图上来吧\n\n![19-3-3-1](/images/19-3-3-1.png)\n\n现在不是很想具体解释了，剩下的细节在代码注释里应该都有了，只是可能写的比较凌乱。。。\n\n### Code\n\n~~把注释删掉之后还有6k，而且代码写得奇丑~~\n\n```cpp\n#include <bits/stdc++.h>\n\n#define int long long\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int Maxn = 2e5 + 100;\n\nint N, M, Q;\nint e, Begin[Maxn], To[Maxn << 1], Next[Maxn << 1];\nint fa[Maxn], dfn[Maxn], idfn[Maxn], dfs_clock, Root[Maxn];\nint anc[22][Maxn], dep[Maxn], W[Maxn], size[Maxn];\nvector <int> G[Maxn];\n\ninline void add_edge (int x, int y) { To[++e] = y; Next[e] = Begin[x]; Begin[x] = e; }\n\nnamespace SEG\n{\n#define mid ((l + r) >> 1)\n#define ls node[root].ch[0]\n#define rs node[root].ch[1]\n#define lson ls, l, mid\n#define rson rs, mid + 1, r\n\n\tstruct info\n\t{\n\t\tint ch[2], cnt;\n\t} node[Maxn * 60];\n\tint node_cnt;\n\n\tinline void build (int &root, int l, int r)\n\t{\n\t\troot = ++node_cnt;\n\t\tif (l == r) return ;\n\t\tbuild (lson), build (rson);\n\t}\n\n\tinline void insert (int pre, int &root, int l, int r, int x)\n\t{\n\t\troot = ++node_cnt;\n\t\tnode[root] = node[pre], ++node[root].cnt;\n\n\t\tif (l == r) return ;\n\t\tif (x <= mid) insert (node[pre].ch[0], lson, x);\n\t\telse insert (node[pre].ch[1], rson, x);\n\t}\n\n\tinline int query (int pre, int root, int l, int r, int k)\n\t{\n\t\tif (l == r) return l;\n\t\tint sum_left = node[ls].cnt - node[node[pre].ch[0]].cnt;\n\t\tif (sum_left >= k) return query (node[pre].ch[0], lson, k);\n\t\treturn query (node[pre].ch[1], rson, k - sum_left);\n\t}\n\n#undef mid\n#undef ls\n#undef rs\n#undef lson\n#undef rson\n}\n\nmap <int, int> S;\nint Id[Maxn], fa_Id[Maxn], small_Id[Maxn];\n// Id[i] 表示缩点之后的i号点在大树中的真实标号\n// fa_Id[i] 表示缩点之后的i号点父亲在大树中的真实标号\n// small_Id[i] 表示缩点之后的i号点在模板树中对应的标号\n\ninline void dfs_pre (int x)\n{\n\tId[x] = x, small_Id[x] = x;\n\tidfn[dfn[x] = ++dfs_clock] = x;\n\tdep[x] = dep[fa[x]] + 1, W[x] = W[fa[x]] + 1, size[x] = 1;\n\tfor (int i = 1; i <= 17; ++i) anc[i][x] = anc[i - 1][anc[i - 1][x]];\n\n\tfor (int i = Begin[x]; i; i = Next[i])\n\t{\n\t\tint y = To[i];\n\t\tif (y == fa[x]) continue;\n\t\tfa[y] = fa_Id[y] = anc[0][y] = x;\n\t\tdfs_pre (y);\n\t\tsize[x] += size[y];\n\t}\n}\n\ninline void Init_Anc (int x, int f, int w)\n{\n\tfa[x] = anc[0][x] = f;\n\tdep[x] = dep[f] + 1;\n\tW[x] = W[f] + w;\n\tfor (int i = 1; i <= 17; ++i) anc[i][x] = anc[i - 1][anc[i - 1][x]];\n}\n\ninline int get_lca (int x, int y) // 计算模板树的lca\n{\n\tif (dep[x] < dep[y]) swap(x, y);\n\tfor (int i = 17; i >= 0; --i) if (dep[anc[i][x]] >= dep[y]) x = anc[i][x];\n\tif (x == y) return x;\n\tfor (int i = 17; i >= 0; --i) if (anc[i][x] != anc[i][y]) x = anc[i][x], y = anc[i][y];\n\treturn anc[0][x];\n}\n\ninline int get_id (int x) // 获取一个大树中真实标号的点在模板树的对应标号\n{\n\tif (x <= N) return x;\n\n\tint big_id = S.lower_bound (x) -> y;\n\tint k = x - Id[big_id] + 1; //第k小\n\tint small_id = small_Id[big_id];\n\n\tint ans = SEG :: query (Root[dfn[small_id] - 1], Root[dfn[small_id] + size[small_id] - 1], 1, N, k);\n\treturn ans;\n}\n\nint is_anc, lca; // 记录LCA下面的那一个大点\n\ninline int get_dis (int x, int y) // 计算两个大点的距离\n{\n\tint ans = W[x] + W[y];\n\tif (dep[x] < dep[y]) swap(x, y);\n\tis_anc = x;\n\n\tfor (int i = 17; i >= 0; --i) if (dep[anc[i][x]] > dep[y]) x = anc[i][x], is_anc = x;\n\n\tif (dep[x] > dep[y]) x = anc[0][x];\n\n\tif (x == y) { lca = x; return ans - 2 * W[x]; }\n\tis_anc = 0;\n\n\tfor (int i = 17; i >= 0; --i) if (anc[i][x] != anc[i][y]) x = anc[i][x], y = anc[i][y];\n\n\tint fa_x = get_id (fa_Id[x]), fa_y = get_id (fa_Id[y]);\n\n\tint dis_small = W[get_lca (fa_x, fa_y)] - W[small_Id[anc[0][x]]]; // 两个小点的lca与上面那个大点的距离\n\tans -= 2 * W[anc[0][x]];\n\tans -= 2 * dis_small;\n\n\treturn ans;\n}\n\ninline int query (int x, int y) // 计算两个大树中真实标号点的距离\n{\n\tint id_x = S.lower_bound (x) -> y, id_y = S.lower_bound (y) -> y; // 所在大点的编号\n\n\tint small_x = get_id (x), small_y = get_id (y); // 在模板树中对应编号\n\n\tif (id_x == id_y) return W[small_x] + W[small_y] - 2 * W[get_lca(small_x, small_y)];\n\n\tis_anc = 0;\n\tint ans = get_dis (id_x, id_y);\n\tint dis_x = W[small_x] - W[small_Id[id_x]]; // x与其大点的距离\n\tint dis_y = W[small_y] - W[small_Id[id_y]];\n\tif (!is_anc) return ans + dis_x + dis_y;\n\n\tif (id_x != lca) swap (x, y), swap(small_x, small_y), swap(id_x, id_y), swap(dis_x, dis_y);\n\tis_anc = get_id(fa_Id[is_anc]);\n\tans -= 2 * (W[get_lca (is_anc, small_x)] - W[small_Id[id_x]]);\n\tans += dis_x + dis_y;\n\n\treturn ans;\n}\n\ninline void Solve ()\n{\n\tdfs_pre (1);\n\tSEG :: build (Root[0], 1, N);\n\tfor (int i = 1; i <= N; ++i)\n\t{\n\t\tS[i] = i;\n\t\tSEG :: insert (Root[i - 1], Root[i], 1, N, idfn[i]);\n\t}\n\n\tint node_cnt = N;\n\tfor (int i = N + 1; i <= N + M; ++i)\n\t{\n\t\tint x = read<int>(), y = read<int>();\n\t\tfa_Id[i] = y, small_Id[i] = x, Id[i] = node_cnt + 1;\n\t\tS[node_cnt + size[x]] = i;\n\t\tnode_cnt += size[x];\n\n\t\tif (y <= N) Init_Anc (i, y, 1);\n\t\telse\n\t\t{\n\t\t\tint ff = S.lower_bound(y) -> y;\n\t\t\tint small = get_id(y);\n\t\t\tint dis = W[small] - W[small_Id[ff]] + 1;\n\n\t\t\tInit_Anc (i, ff, dis);\n\t\t}\n\t}\n\n\twhile (Q--)\n\t{\n\t\tint x = read<int>(), y = read<int>();\n\t\tprintf(\"%lld\\n\", query(x, y));\n\t}\n}\n\ninline void Input ()\n{\n\tN = read<int>(), M = read<int>(), Q = read<int>();\n\tfor (int i = 1; i < N; ++i)\n\t{\n\t\tint x = read<int>(), y = read<int>();\n\t\tadd_edge (x, y);\n\t\tadd_edge (y, x);\n\t}\n}\n\nmain()\n{\n\n#ifndef ONLINE_JUDGE\n\tfreopen(\"A.in\", \"r\", stdin);\n\tfreopen(\"A.out\", \"w\", stdout);\n#endif\n\n\tInput ();\n\tSolve ();\n\n\treturn 0;\n}\n\n```\n\n","categories":["Problem"],"tags":["主席树","倍增","毒瘤","模拟"]},{"title":"「HNOI2016」网络 - 树链剖分 + 线段树 + 可删除堆","url":"/2019/03/03/%E3%80%8CHNOI2016%E3%80%8D%E7%BD%91%E7%BB%9C-%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86-%E7%BA%BF%E6%AE%B5%E6%A0%91-%E5%8F%AF%E5%88%A0%E9%99%A4%E5%A0%86/","content":"\n给你一棵$n$个节点的树，有$m$次操作，操作包含以下三种：\n\n1. 新建一个从$u$到$v$的任务，权值为$w$\n2. 删除第$i$个任务\n3. 询问所有不经过$x​$的任务中最大的权值\n\n$n\\le 10^5, m\\le 2*10^5$\n\n<!--more-->\n\n### Links\n\n[LOJ 2049](https://loj.ac/problem/2049)\n\n\n\n### Solution\n\n考虑树剖，树上的一条路经转化为 `dfs序`上的 $O(\\log n)$个区间。\n\n因为只要求不经过某个点任务的最大权值，所以只需要对每个点维护不经过它的任务即可，即对这个任务的补集进行操作。显然，补集区间个数也是$O(\\log n)$级别的\n\n要支持删除，直接在线段树里用可删除堆维护即可（或者我一开始想的是线段树分治，但是常数太太太大需要大力卡常。。）\n\n总复杂度$O(n\\log^3 n)$\n\n\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int Maxn = 1e5 + 100, Maxm = Maxn << 1;\n\nint N, M;\nvector <int> G[Maxn];\n\nstruct query\n{\n\tint op, x, y, v;\n} Q[Maxm];\n\nstruct Heap\n{\n\tpriority_queue <int> Q1, Q2;\n\n\tinline void process () { while (!Q2.empty() && Q1.top() == Q2.top()) Q1.pop(), Q2.pop(); }\n\n\tinline void push (int x) { Q1.push(x); }\n\n\tinline void erase (int x) { Q2.push(x); }\n\n\tinline int top () { process (); return Q1.top(); }\n};\n\nnamespace SEG\n{\n#define mid (l + r >> 1)\n#define lson root << 1, l, mid\n#define rson root << 1 | 1, mid + 1, r\n\tHeap node [Maxn << 2];\n\n\tinline void build (int root, int l, int r)\n\t{\n\t\tnode[root].push(-1);\n\t\tif (l == r) return ;\n\t\tbuild (lson), build (rson);\n\t}\n\n\tinline void update (int root, int l, int r, query x)\n\t{\n\t\tif (x.x > x.y) return ;\n\t\tif (x.x <= l && r <= x.y)\n\t\t{\n\t\t\tif (!x.op) node[root].push (x.v);\n\t\t\telse node[root].erase (x.v);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (x.x <= mid) update (lson, x);\n\t\t\tif (x.y > mid) update (rson, x);\n\t\t}\n\t}\n\n\tinline int query (int root, int l, int r, int x)\n\t{\n\t\tif (l == r) return node[root].top(); \n\n\t\tif (x <= mid) return max (node[root].top(), query (lson, x));\n\t\telse return max (node[root].top(), query (rson, x));\n\t}\n\n#undef mid\n#undef lson\n#undef rson\n}\n\nnamespace HLD\n{\n\tint fa[Maxn], size[Maxn], dep[Maxn], top[Maxn], dfn[Maxn], son[Maxn], dfs_clock;\n\n\tinline void dfs_pre (int x)\n\t{\n\t\tsize[x] = 1, dep[x] = dep[fa[x]] + 1;\n\n\t\tfor (int i = 0; i < G[x].size(); ++i)\n\t\t{\n\t\t\tint y = G[x][i];\n\t\t\tif (y == fa[x]) continue;\n\t\t\tfa[y] = x;\n\t\t\tdfs_pre (y);\n\n\t\t\tif (size[y] > size[son[x]]) son[x] = y;\n\t\t\tsize[x] += size[y];\n\t\t}\n\t}\n\n\tinline void get_top (int x, int now)\n\t{\n\t\ttop[x] = now, dfn[x] = ++dfs_clock;\n\t\tif (son[x]) get_top (son[x], now);\n\n\t\tfor (int i = 0; i < G[x].size(); ++i)\n\t\t{\n\t\t\tint y = G[x][i];\n\t\t\tif (y == fa[x] || y == son[x]) continue;\n\t\t\tget_top (y, y);\n\t\t}\n\t}\n\n\tinline void init () { dfs_pre(1), get_top(1, 1); }\n\n\tpii Seg[Maxn];\n\tint seg_cnt = 0;\n\n\tinline void update (query now)\n\t{\n\t\tint x = now.x, y = now.y;\n\t\tseg_cnt = 0;\n\n\t\twhile (top[x] != top[y])\n\t\t{\n\t\t\tif (dep[top[x]] < dep[top[y]]) swap(x, y);\n\t\t\tSeg[++seg_cnt] = mp(dfn[top[x]], dfn[x]);\n\t\t\tx = fa[top[x]];\n\t\t}\n\n\t\tif (dep[x] > dep[y]) swap(x, y);\n\t\tSeg[++seg_cnt] = mp(dfn[x], dfn[y]);\n\t\tSeg[++seg_cnt] = mp(N + 1, N + 1);\n\n\t\tsort(Seg + 1, Seg + seg_cnt + 1);\n\n\t\tfor (int i = 1; i <= seg_cnt; ++i)\n\t\t\tSEG :: update (1, 1, N, (query){now.op, Seg[i - 1].y + 1, Seg[i].x - 1, now.v});\n\t}\n\n\tinline int query (int x) { return SEG :: query (1, 1, N, dfn[x]); }\n}\n\ninline void Solve ()\n{\n\tHLD :: init ();\n\tSEG :: build (1, 1, N);\n\n\tfor (int i = 1; i <= M; ++i)\n\t{\n\t\tint op = read<int>(), x = read<int>();\n\t\tif (!op)\n\t\t{\n\t\t\tint y = read<int>(), v = read<int>();\n\t\t\tQ[i] = (query){op, x, y, v};\n\t\t\tHLD :: update (Q[i]);\n\t\t}\n\t\telse if (op == 1) Q[x].op = 1, HLD :: update (Q[x]);\n\t\telse printf(\"%d\\n\", HLD :: query (x));\n\t}\n}\n\ninline void Input ()\n{\n\tN = read<int>(), M = read<int>();\n\tfor (int i = 1; i < N; ++i)\n\t{\n\t\tint x = read<int>(), y = read<int>();\n\t\tG[x].pb(y), G[y].pb(x);\n\t}\n}\n\nint main()\n{\n\n#ifndef ONLINE_JUDGE\n\tfreopen(\"A.in\", \"r\", stdin);\n\tfreopen(\"A.out\", \"w\", stdout);\n#endif\n\n\tInput ();\n\tSolve ();\n\n\treturn 0;\n}\n\n```\n\nx","categories":["Problem"],"tags":["线段树","堆","树链剖分","省选","可删除堆"]},{"title":"「HNOI2016」最小公倍数 - 分块 + 可撤销带权并查集","url":"/2019/03/01/%E3%80%8CHNOI2016%E3%80%8D%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0-%E5%88%86%E5%9D%97-%E5%8F%AF%E6%92%A4%E9%94%80%E5%B8%A6%E6%9D%83%E5%B9%B6%E6%9F%A5%E9%9B%86/","content":"\n给定一张 $N$ 个顶点 $M$ 条边的带边权无向图，所有权值都可以分解成 $2^a \\cdot 3^b$的形式\n\n现在有 $q$ 个询问，每次询问给定四个参数 $u、v、a$ 和 $b$，请你求出是否存在一条顶点 $u$ 到 $v$ 之间的路径，使得路径依次经过的边上的权值的最小公倍数为 $2^a \\cdot 3^b$ \n\n**注意**：路径可以不是简单路径。\n\n$n,q\\le 5*10^4, m\\le 10^5$\n\n<!--more-->\n\n### Links\n\n[LOJ 2048](https://loj.ac/problem/2048)\n\n[Luogu P3247](https://www.luogu.org/problemnew/show/P3247)\n\n\n\n### Solution\n\n发现就是询问是否存在一个$u\\to v$的路径,满足$max\\{a\\}=A,max\\{b\\}=B$\n\n对于这种双关键字都要满足限制的问题，我们通常可以考虑分块\n\n> 注：以下内容中，按$(x,y)$排序是指以$x$为第一关键字，$y$为第二关键字排序\n\n首先把边按$(a, b)$排序，并分成$k$块\n\n从小到大枚举$k$个块，每次处理$a$在当前块$a$的范围内的询问\n\n把当前需要处理的询问和前$k-1$个块的操作按$b$排序，依次进行操作。\n\n具体地，我们使用可撤销带权并查集维护，在处理每个询问之前，暴力把当前块内满足条件的边连上，询问完再撤销\n\n实现上的一些细节：\n\n* 首先对询问按$(b,a)$排序，这样每次取出来的询问就是$b$这一维有序的了，于是就能用`two pointer`直接扫\n* 有可能一些$a$相同的边被拆散到多个块内，如果直接判断$a\\in [L[i].a, R[i].a]$的话就可能会导致同一个询问被处理多次。所以应该判断$a\\in [L[i].a, R[i].a + 1)$，这样就保证了每个询问只会在最后一个相同$a$所属的块内被处理\n\n\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int Maxn = 50000 + 100, Maxm = 100000 + 100;\n\nint N, M, Q;\n\nstruct info\n{\n\tint x, y, a, b, id;\n} E[Maxm], Query[Maxn];\n\nint Ans[Maxn];\n\nnamespace DSU\n{\n\tint fa[Maxn], size[Maxn], top;\n\tint val_a[Maxn], val_b[Maxn];\n\tinfo Stack[Maxm << 1];\n\n\tinline void init (int maxn) { top = 0; for (int i = 1; i <= maxn; ++i) fa[i] = i, size[i] = 1, val_a[i] = val_b[i] = -1; }\n\n\tinline int get_fa (int x) { return fa[x] == x ? x : get_fa(fa[x]); }\n\n\tinline void link (info now, int flag) \n\t{ \n\t\tint x = get_fa(now.x), y = get_fa(now.y); \n\t\tif (size[x] < size[y]) swap(x, y);\n\n\t\tif (flag) Stack[++top] = (info){x, y, val_a[x], val_b[x], size[x]}; \n\n\t\tif (x == y)\n\t\t{\n\t\t\tChkmax (val_a[x], now.a);\n\t\t\tChkmax (val_b[x], now.b);\n\t\t\treturn ;\n\t\t}\n\n\t\tChkmax (val_a[x], max(now.a, val_a[y]));\n\t\tChkmax (val_b[x], max(now.b, val_b[y]));\n\t\tfa[y] = x;\n\t\tsize[x] += size[y];\n\t}\n\n\tinline int check (info now)\n\t{\n\t\tint x = get_fa(now.x), y = get_fa(now.y);\n\t\treturn (x == y) && (val_a[x] == now.a) && (val_b[x] == now.b);\n\t}\n\n\tinline void pop ()\n\t{\n\t\twhile (top)\n\t\t{\n\t\t\tinfo now = Stack[top--];\n\t\t\tfa[now.y] = now.y;\n\t\t\tsize[now.x] = now.id;\n\t\t\tval_a[now.x] = now.a;\n\t\t\tval_b[now.x] = now.b;\n\t\t}\n\t}\n}\n\ninline int cmp (info u, info v)\n{\n\tif (u.a == v.a)\n\t{\n\t\tif (u.b == v.b) return u.id < v.id;\n\t\treturn u.b < v.b;\n\t}\n\treturn u.a < v.a;\n}\n\ninline int cmp2 (info u, info v)\n{\n\tif (u.b == v.b)\n\t{\n\t\tif (u.a == v.a) return u.id < v.id;\n\t\treturn u.a < v.a;\n\t}\n\treturn u.b < v.b;\n}\n\nnamespace BLOCK\n{\n\tint block_size, block_cnt, L[Maxm], R[Maxm], Belong[Maxm];\n\n\tinline void init ()\n\t{\n\t\tsort (E + 1, E + M + 1, cmp);\n\t\tblock_size = sqrt(M * log(M)), block_cnt = (M - 1) / block_size + 1;\n\t\t//cout << block_size << ' ' << block_cnt << endl;\n\n\t\tfor (int i = 1; i <= block_cnt; ++i)\n\t\t\tL[i] = R[i - 1] + 1, R[i] = min(M, L[i] + block_size - 1);\n\t\tfor (int i = 1; i <= M; ++i) Belong[i] = (i - 1) / block_size + 1;\n\t}\n\n\tinfo Now[Maxn];\n\n\tinline void solve ()\n\t{\n\t\tsort (Query + 1, Query + Q + 1, cmp2);\n\n\t\tfor (int i = 1; i <= block_cnt; ++i)\n\t\t{\n\t\t\tDSU :: init (N);\n\t\t\tint cnt = 0;\n\t\t\tfor (int j = 1; j <= Q; ++j)\n/**/\t\t\tif (E[L[i]].a <= Query[j].a && Query[j].a < E[R[i] + 1].a)\n\t\t\t\t\tNow[++cnt] = Query[j];\n\n\t\t\tsort (E + 1, E + L[i], cmp2);\n\n\t\t\tint pos = 1;\n\t\t\tfor (int j = 1; j <= cnt; ++j)\n\t\t\t{\n\t\t\t\twhile (pos < L[i] && E[pos].b <= Now[j].b) DSU :: link (E[pos++], 0);\n\n\t\t\t\tfor (int k = L[i]; k <= R[i]; ++k)\n\t\t\t\t\tif (E[k].b <= Now[j].b && E[k].a <= Now[j].a)\n\t\t\t\t\t\tDSU :: link (E[k], 1);\n\n\t\t\t\tAns[Now[j].id] = DSU :: check (Now[j]);\n\t\t\t\tDSU :: pop ();\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline void Solve ()\n{\n\tBLOCK :: init ();\n\tBLOCK :: solve ();\n\n\tfor (int i = 1; i <= Q; ++i) printf(\"%s\\n\", Ans[i] ? \"Yes\" : \"No\");\n\n#ifdef hk_cnyali\n\tcerr << (double)clock() / CLOCKS_PER_SEC << endl;\n#endif\n}\n\ninline void Input ()\n{\n\tN = read<int>(), M = read<int>();\n\n\tfor (int i = 1; i <= M; ++i)\n\t{\n\t\tint x = read<int>(), y = read<int>(), a = read<int>(), b = read<int>();\n\t\tE[i] = (info){x, y, a, b, i};\n\t}\n\tE[M + 1] = (info){0, 0, (int)2e9, (int)2e9, 0};\n\n\tQ = read<int>();\n\n\tfor (int i = 1; i <= Q; ++i)\n\t{\n\t\tint x = read<int>(), y = read<int>(), a = read<int>(), b = read<int>();\n\t\tQuery[i] = (info){x, y, a, b, i};\n\t}\n}\n\nint main()\n{\n\n#ifndef ONLINE_JUDGE\n\tfreopen(\"A.in\", \"r\", stdin);\n\tfreopen(\"A.out\", \"w\", stdout);\n#endif\n\n\tInput ();\n\tSolve ();\n\n\treturn 0;\n}\n```\n\n\n\n### Debug\n\n* 137L： 写成`\tQuery[i].a <= E[R[i]].a `","categories":["Problem"],"tags":["分块","数据结构","并查集","省选"]},{"title":"「FJWC2019」吃 - 概率和期望 + 点分治 + NTT + CDQ分治","url":"/2019/03/01/%E3%80%8CFJWC2019%E3%80%8D%E5%90%83-%E6%A6%82%E7%8E%87%E5%92%8C%E6%9C%9F%E6%9C%9B-%E7%82%B9%E5%88%86%E6%B2%BB-NTT-CDQ%E5%88%86%E6%B2%BB/","content":"\n给你一张$n$个点$m$条边的图，每次会随机选择一个还未删除的点 $v$，然后访问所有与 $v$ **连通**的点，然后删除点 $v$ ，直至所有点都被删除。\n\n求期望访问次数，答案对$998244353$取模\n\n$n\\le 10^5, m\\in[n - 1, n]$\n\n<!--more-->\n\n### Links\n\n[FZOJ 192](http://218.5.5.242:9021/problem/192)\n\n\n\n### Solution\n\n#### Tree\n\n先考虑树的情况\n\n显然这个期望就是每种情况的概率和，又因为期望具有线性性，所以可以考虑`两两点对`对答案的贡献\n\n有序点对$(x, y)$，树上路径长度为$c$（经过$c$个节点），对答案的贡献为$\\frac{1}{c}$\n\n> 若在访问$x$时，$y$能够被访问，则说明$x$到$y$的这条链还没有断\n>\n> 也就是说，在所有删点方案中，只要$x$在`x到y这条链除了x之外的任意一个点被删除`之前删除，就会产生贡献\n>\n> 这个概率就是在只考虑`x到y这条链`的任意排列方案时，钦定第一个为$x$的概率，即为$\\frac{1}{c}$\n\n所以我们只需要对每个$c$求出长度为$c$的路径条数\n\n点分治 + NTT合并即可\n\n> 这个用NTT合并的trick也不难理解\n>\n> 在点分治合并答案时，下标（其实就是深度）也是一个形如$i+j=k$的合并方式，且是乘法运算，所以可以用NTT优化\n\n光以上的部分我就调了一年。。。\n\n------\n\n#### Base-Ring Tree\n\n接下来考虑基环树，仍然是考虑点对$(x, y)$的贡献\n\n* $(x, y)$在同一棵子树内：与树的计算方法相同\n\n* $(x,y)$不在同一棵子树内：\n\n  ![19-3-1-4](/images/19-3-1-4.png)\n\n  令$dep[x] + dep[y] = c$，则此时删除$x$时$x, y$仍联通的概率等于$x$在$a+c$个点中最先删除或在$b+c$个点中最先删除的概率（分别对应经过环的两侧）\n\n  通过容斥我们可以得到此时贡献为$\\frac{1}{a + c} + \\frac{1}{b + c} - \\frac{1}{a + b + c}$\n\n  随便选一条边破环为链，用类似`CDQ分治`的分治方法 + NTT即可\n\n  > 其实这个分治方法也类似于序列上的点分治，就是每次考虑过中点的贡献\n\n总复杂度$O(n\\log^2 n)$\n\n具体实现上，可以先破环为链，对剩下的部分计算一次树情况的答案\n\n这部分我们算出来的答案既包括了每个子树的答案，又包括了各个子树之间通过环上某一条路径的答案\n\n例如，假设破的环在$a$部分中，那么我们相当于已经计算了$\\frac{1}{b+c}$的答案了\n\n那么我们只需要分治计算$\\frac{1}{a+c}$和$\\frac{1}{a+b+c}$的贡献了\n\n这样代码写起来会比较方便，更具体的部分可以直接看代码了，自我感觉写得应该是比较容易理解的\n\n\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int Maxn = 1e5 + 100;\nconst int Mod = 998244353;\nconst int g = 3;\nconst int inf = 0x3f3f3f3f;\n\nint N, M;\nvector <int> G[Maxn];\n\nnamespace MATH\n{\n\tinline void Add (int &a, int b) { a += b; if (a >= Mod) a -= Mod; }\n\n\tinline int Pow (int a, int b)\n\t{\n\t\tint ans = 1;\n\t\tfor (int i = b; i; i >>= 1, a = (LL)a * a % Mod) if (i & 1) ans = (LL)ans * a % Mod;\n\t\treturn ans;\n\t}\n}\n\nusing namespace MATH;\n\nnamespace Poly\n{\n\tint n, rev[Maxn << 2], F[Maxn << 2], G[Maxn << 2], Wn[Maxn << 2], Wn_inv[Maxn << 2];\n\n\tinline void init (int maxn)\n\t{\n\t\tfor (int i = 1; i <= maxn; i <<= 1) Wn[i] = Pow(g, (Mod - 1) / (i << 1)), Wn_inv[i] = Pow(Wn[i], Mod - 2);\n\t}\n\n\tinline void dft (int *A, int flag)\n\t{\n\t\tfor (int i = 0; i < n; ++i) if (rev[i] < i) swap (A[i], A[rev[i]]); \n\n\t\tfor (int mid = 1; mid < n; mid <<= 1)\n\t\t{\n\t\t\tint wn = Wn[mid];\n\t\t\tif (flag < 0) wn = Wn_inv[mid];\n\t\t\tfor (int i = 0; i < n; i += (mid << 1))\n\t\t\t{\n\t\t\t\tint W = 1;\n\t\t\t\tfor (int j = i; j < i + mid; ++j, W = (LL)W * wn % Mod)\n\t\t\t\t{\n\t\t\t\t\tint a = A[j], b = (LL)W * A[j + mid] % Mod;\n\t\t\t\t\tA[j] = (a + b) % Mod, A[j + mid] = (a - b + Mod) % Mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint inv = Pow(n, Mod - 2);\n\t\tif (flag < 0) for (int i = 0; i < n; ++i) A[i] = (LL)A[i] * inv % Mod;\n\t}\n\n\tinline void mul (int *A, int N, int *B, int M, int *Ans)\n\t{\n\t\tn = 1; while (n <= N + M) n <<= 1;\n\t\tfor (int i = 0; i < n; ++i) rev[i] = (rev[i >> 1] >> 1) + (i & 1 ? (n >> 1) : 0);\n\t\tfor (int i = 0; i < n; ++i) F[i] = i <= N ? A[i] : 0;\n\t\tfor (int i = 0; i < n; ++i) G[i] = i <= M ? B[i] : 0;\n\n\t\tdft (F, 1), dft (G, 1);\n\t\tfor (int i = 0; i < n; ++i) F[i] = (LL)F[i] * G[i] % Mod;\n\t\tdft (F, -1);\n\t\tfor (int i = 0; i <= N + M; ++i) Ans[i] = F[i];\n\t}\n}\n\nint Ans[Maxn];\n\nnamespace TREE\n{\n\tint Vis[Maxn], size[Maxn];\n\tint root, min_size, now_size;\n\n\tinline void dfs_pre (int x, int f = 0)\n\t{\n\t\tsize[x] = 1;\n\t\tfor (int y : G[x])\n\t\t{\n\t\t\tif (y == f || Vis[y]) continue;\n\t\t\tdfs_pre (y, x);\n\t\t\tsize[x] += size[y];\n\t\t}\n\t}\n\n\tinline void get_root (int x, int f = 0)\n\t{\n/**/\tint now = now_size - size[x];\n\t\tfor (int y : G[x])\n\t\t{\n\t\t\tif (y == f || Vis[y]) continue;\n\t\t\tget_root (y, x);\n\t\t\tChkmax (now, size[y]);\n\t\t}\n\n\t\tif (Chkmin (min_size, now)) root = x;\n\t}\n\n\tint Sum[Maxn], Buc_All[Maxn], Buc_Now[Maxn], max_dep;\n\n\tinline void get_dep (int x, int f, int dep = 1)\n\t{\n\t\t++Buc_Now[dep], Chkmax(max_dep, dep);\n\t\tfor (int y : G[x])\n\t\t{\n\t\t\tif (y == f || Vis[y]) continue;\n\t\t\tget_dep (y, x, dep + 1);\n\t\t}\n\t}\n\n\tinline void calc (int x)\n\t{\n\t\tint n = 1; ++Ans[1];\n\n\t\tfor (int y : G[x])\n\t\t{\n\t\t\tif (Vis[y]) continue;\n\t\t\tmax_dep = 0, get_dep (y, x);\n\t\t\tSum[1] = Buc_All[1] = 1;\n\n\t\t\tPoly :: mul (Buc_All, n, Buc_Now, max_dep, Sum);\n\n\t\t\tfor (int i = 1; i <= n + max_dep; ++i) Add (Ans[i], 2ll * Sum[i] % Mod);\n\n\t\t\tChkmax(n, max_dep + 1);\n\t\t\tfor (int i = 2; i <= n; ++i)\n\t\t\t\tBuc_All[i] += Buc_Now[i - 1], Buc_Now[i - 1] = 0;\n\t\t}\n\n\t\tfor (int i = 0; i <= n; ++i) Buc_All[i] = Buc_Now[i] = Sum[i] = 0;\n\t}\n\n\tinline void divide (int x)\n\t{\n\t\troot = x, min_size = inf;\n\t\tdfs_pre (x), now_size = size[x], get_root (x), x = root;\n\n\t\tcalc (x); Vis[x] = 1;\n\n\t\tfor (int y : G[x]) if (!Vis[y]) divide (y);\n\t}\n}\n\nnamespace CIRCLE\n{\n\tint Vis[Maxn], Stack[Maxn], top;\n\tint Circle[Maxn], len, In[Maxn];\n\n\tinline void find_circle (int x, int f = 0)\n\t{\n\t\tif (len) return ;\n\t\tVis[x] = 1, Stack[++top] = x;\n\n\t\tfor (int y : G[x])\n\t\t{\n\t\t\tif (y == f) continue;\n\t\t\tif (Vis[y] && !len)\n\t\t\t{\n\t\t\t\twhile (Stack[top] != y) In[Stack[top]] = 1, Circle[++len] = Stack[top--];\n\t\t\t\tIn[y] = 1, Circle[++len] = y;\n\t\t\t\treturn ;\n\t\t\t}\n\t\t\tfind_circle (y, x);\n\t\t}\n\n\t\t--top;\n\t}\n\n\tint n, m;\n\tint L[Maxn], R[Maxn], Sum[Maxn << 2];\n\n\tinline void get_dep (int x, int f, int dep, int op)\n\t{\n\t\tif (!op) ++L[dep], Chkmax(n, dep);\n\t\telse ++R[dep], Chkmax(m, dep);\n\n\t\tfor (int y : G[x])\n\t\t{\n\t\t\tif (y == f || In[y]) continue;\n\t\t\tget_dep (y, x, dep + 1, op);\n\t\t}\n\t}\n\n\tinline void divide (int l, int r)\n\t{\n\t\tif (l == r) return ;\n\n\t\tint mid = l + r >> 1;\n\n\t\tn = m = 0;\n\t\tfor (int i = l; i <= mid; ++i) get_dep (Circle[i], 0, i, 0);\n\t\tfor (int i = mid + 1; i <= r; ++i) get_dep (Circle[i], 0, len - i + 1, 1);\n\n\t\t// l -> 0 ; n -> n - l\n\t\t// (len - r + 1) -> 0 ; m -> m - (len - r + 1)\n/**/\tPoly :: mul (L + l, n - l, R + (len - r + 1), m - (len - r + 1), Sum + l + (len - r + 1));\n\n\t\tfor (int i = l + (len - r + 1); i <= n + m; ++i) Add (Ans[i], 2ll * Sum[i] % Mod);\n\t\tfor (int i = l; i <= n; ++i) L[i] = 0;\n\t\tfor (int i = (len - r + 1); i <= m; ++i) R[i] = 0;\n\n\t\t/********************************************************************************/\n\n\t\tn = m = 0;\n\t\tfor (int i = l; i <= mid; ++i) get_dep (Circle[i], 0, 0, 0);\n\t\tfor (int i = mid + 1; i <= r; ++i) get_dep (Circle[i], 0, 0, 1);\n\n\t\tPoly :: mul (L, n , R, m, Sum);\n\n\t\tfor (int i = 0; i <= n + m; ++i) Add (Ans[len + i], Mod - 2ll * Sum[i] % Mod);\n\t\tfor (int i = 0; i <= n; ++i) L[i] = 0;\n\t\tfor (int i = 0; i <= m; ++i) R[i] = 0;\n\n\t\tdivide (l, mid), divide (mid + 1, r);\n\t}\n\n\tinline void work ()\n\t{\n\t\tfind_circle (1);\n\t\t\n\t\tint x = Circle[1], y = Circle[len];\n\t\tG[x].erase (find (G[x].begin(), G[x].end(), y));\n\t\tG[y].erase (find (G[y].begin(), G[y].end(), x));\n\n/**/\tTREE :: divide (1);\n\t\tdivide (1, len);\n\t}\n}\n\ninline void Solve ()\n{\n\tPoly :: init (N << 1);\n\n\tif (M == N - 1) TREE :: divide (1);\n\telse CIRCLE :: work ();\n\n\tint ans = 0;\n\tfor (int i = 1; i <= N; ++i) Add (ans, (LL)Ans[i] * Pow(i, Mod - 2) % Mod);\n\n\t//for (int i = 1; i <= N; ++i) cout << i << ' ' << Ans[i] << endl;\n\n\tcout << ans << endl;\n}\n\ninline void Input ()\n{\n\tN = read<int>(), M = read<int>();\n\n\tfor (int i = 1; i <= M; ++i)\n\t{\n\t\tint x = read<int>(), y = read<int>();\n\t\tG[x].pb(y), G[y].pb(x);\n\t}\n}\n\nint main()\n{\n\n\tfreopen(\"eat.in\", \"r\", stdin);\n\tfreopen(\"eat.out\", \"w\", stdout);\n\n\tInput ();\n\tSolve ();\n\n\treturn 0;\n}\n\n```\n\n","categories":["Problem"],"tags":["概率和期望","NTT","分治","CDQ分治","点分治"]},{"title":"模拟退火","url":"/2019/02/28/%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB/","content":"\n发现以前没写过模拟退火相关的东西，就在这里提一下吧\n\n<!--more-->\n\n### Brief Introduction\n\n模拟退火和爬山类似，都是一个不断逼近最优解的随机算法\n\n爬山是每次都贪心地往更优方向走；而退火则是以一定概率接受一个更劣的解\n\n具体流程如下：\n\n- 设定一个温度值$T$，随机求一个初始解$x_0$\n\n- 不断随机对当前解$x$进行变动，求出一个新解$x' = x + \\Delta x$（一般而言变动的$\\Delta x$应与当前温度成正比）\n\n  - 若新解比当前解更优，则接受该解\n\n  - 否则，以$e^{\\frac{\\Delta f}{T}}$的概率接受这个劣解\n\n    其中，$\\Delta f$为新解的函数值与当前解的函数值的差\n\n    >  注：**这里无论哪个函数值更大，都需要保证$\\Delta f < 0$**，只有保证$\\Delta f < 0$才有退火的一些理论依据，具体我也不太懂\n\n- 使温度不断下降，即$T = T \\times \\Delta T$。一般$\\Delta T$取$0.95-0.99$的数，模拟降温过程\n\n- 如此反复，直到$T < eps$，其中$eps$为一个趋近于$0$的数\n\n\n\n###  Adjustment\n\n模拟退火的调参就是根据具体的问题，对其中的几个参数$T, \\Delta T, eps$，以及退火的次数进行调整，从而使得退火出来的解更优的过程\n\n一般$eps$比较好确定，而$T$和$\\Delta T$就要通过不断测试，手动二分等方法来具体确定\n\n\n\n### 19.5.20 UPD 关于退火的一些技巧\n\n记得要多退几次火，不要一次退到底，多退几次会更优\n\n记得`while (1)`循环。。。\n\n一开始可以多随几个局面（或者随多少秒的局面），从比较优秀的局面开始退火\n\n","categories":["Algorithm"],"tags":["随机","模拟退火"]},{"title":"「FJWC2019」子图 - 分类讨论 + 枚举 + 暴力","url":"/2019/02/28/%E3%80%8CFJWC2019%E3%80%8D%E5%AD%90%E5%9B%BE-%E5%88%86%E7%B1%BB%E8%AE%A8%E8%AE%BA-%E6%9E%9A%E4%B8%BE-%E6%9A%B4%E5%8A%9B/","content":"\n给出一个$n$个点，$m$ 条边的无向图，求由 $k$ 条边构成的联通子图的个数，对$10^9 + 7$取模\n\n$n\\le10^5,m\\le2*10^5,k\\le4$\n\n<!--more-->\n\n### Links\n\n[FZOJ 191](http://218.5.5.242:9021/problem/191)\n\n\n\n### Pre-Algorithm\n\n你得会在$O(m\\sqrt m)$的复杂度内进行三元环和四元环计数\n\n#### Three-Membered Ring\n\n![19-3-1-1](/images/19-3-1-1.png)\n\n首先把无向图转成有向图，由度数小的向度数大的连边，度数相同就由编号小的向编号大的\n\n那么这样连出来的一定是一个有向无环图\n\n然后考虑一个暴力做法：\n\n* 先枚举点$i$， 把所有$i$连向的点标记为$i$\n* 枚举$i$连向的点$j$\n* 枚举$j$连向的点$k$，若$k$被标记为$i$，则存在一个三元环$(i, j, k)$\n\n因为无向图被我们转化成了dag，所以每个三元环只会在度数最小的点处被统计，不会算重\n\n复杂度的话，显然等于所有被指向点的出度的和\n\n而每个点的出度是不会大于$\\sqrt m$（若存在一个点出度大于$\\sqrt m$，那么它所有出边指向的点的度数都要大于$\\sqrt m$，边的总数就会大于$m$）\n\n所以复杂度为$O(m\\sqrt m)$\n\n\n\n#### Four-Membered Ring\n\n![19-3-1-2](/images/19-3-1-2.png)\n\n四元环的计数与三元环类似，先枚举点$i$，然后枚举连向的点$j$，再枚举$j$连向的点$k$。记录一个$cnt$数组，答案每次加上$cnt[k]$，然后`++cnt[k]`。但是在这里不能转化成有向图\n\n> 因为如果建成有向图，设$val$表示一个点按$(deg, id)$排序的值，那么有$val_i < val_j, val_i < val_k$，但是我们并不确定$val_j$和$val_k$的大小关系\n>\n> 在三元环计数中$val_j$和$val_k$的大小关系可以任意，而四元环中必须要满足$val_j < val_k$，所以不行\n\n考虑一个类似的做法，将所有点重标号，并且把每个点连出的边按照所连出点的$val$值排序\n\n在枚举点的过程中，始终保证$val_i < val_j,val_i < val_k$，如果不满足就立刻`break`\n\n与三元环证明方法类似，这个做法也可以被证明是$O(m\\sqrt m)$的\n\n\n\n### Solution\n\n大力枚举 + 分类讨论\n\n$k=3$时，讨论一下菊花、链、三元环的情况即可，其中算链的时候会多算三次三元环的情况，注意要减去\n\n下面讨论$k=4$的**5种**情况：\n\n![19-3-1-3](/images/19-3-1-3.png)\n\n1. 菊花：\n\n   枚举点$i$，用度数算一下\n\n2. 一条边，一边连两个点，另一边连一个点：\n\n   枚举边$i$，用度数算一下。此时$c$可能与$a$或$b$重合形成`情况3`，所以要减掉$2$次`情况3`\n\n3. 三元环，连一个点：\n\n   枚举三元环，用三元环上点的度数算一下\n\n4. 链：\n\n   枚举点$i$，枚举与$i$相邻的点$y$，$a$为当前的$y$，$c$为之前枚举过的$y$，然后利用度数计算贡献，此时多算的情况：\n\n   * $b$和$d$重合形成`情况5`\n   * $b$和$c$重合且$a$和$d$重合，形成`情况3`\n   * $a$和$d$重合且$b$和$c$重合，形成`三元环`\n\n   总共要减去$2$次`情况5`，$2$次`情况3`，$1$次`三元环`\n\n5. 四元环：\n\n   之前讲过了\n\n时间复杂度$O(m\\sqrt m)$，代码、细节复杂度$O(\\infty)$\n\n\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int Maxn = 1e5 + 100, Maxm = Maxn << 1;\nconst int Mod = 1e9 + 7;\n\nnamespace MATH\n{\n\tint fac[Maxm], ifac[Maxm];\n\n\tinline void Add (int &a, int b) { a += b; if (a >= Mod) a -= Mod; }\n\n\tinline int Pow (int a, int b)\n\t{\n\t\tint ans = 1;\n\t\tfor (int i = b; i; i >>= 1, a = (LL)a * a % Mod) if (i & 1) ans = (LL)ans * a % Mod;\n\t\treturn ans;\n\t}\n\n\tinline int Binom (int n, int m) { if (n < m) return 0; return (LL)fac[n] * ifac[m] % Mod * ifac[n - m] % Mod; }\n\n\tinline void math_init (int maxn)\n\t{\n\t\tfac[0] = 1;\n\t\tfor (int i = 1; i <= maxn; ++i) fac[i] = (LL)fac[i - 1] * i % Mod;\n\t\tifac[maxn] = Pow(fac[maxn], Mod - 2);\n\t\tfor (int i = maxn - 1; i >= 0; --i) ifac[i] = (LL)ifac[i + 1] * (i + 1) % Mod;\n\t}\n}\n\nusing namespace MATH;\n\nint N, M, K;\nint deg[Maxn];\nvector <int> G[Maxn];\npii E[Maxm];\n\ninline int cmp (int x, int y)\n{\n\tif (deg[x] == deg[y]) return x < y;\n\treturn deg[x] < deg[y];\n}\n\nnamespace Three\n{\n\tint Vis[Maxn];\n\n\tinline int calc (int x)\n\t{\n\t\tint ans = 0;\n\n\t\tfor (int y : G[x]) Vis[y] = x;\n\t\tfor (int y : G[x]) for (int z : G[y]) if (Vis[z] == x) Add (ans, 1); \n\n\t\treturn ans;\n\t}\n\n\tinline int solve ()\n\t{\n\t\tint ans = 0;\n\n\t\t// 1. Star\n\t\tfor (int i = 1; i <= N; ++i) Add (ans, Binom (deg[i], 3));\n\n\t\t// 2. Chain\n\t\tfor (int i = 1; i <= M; ++i) Add (ans, (LL)(deg[E[i].x] - 1) * (deg[E[i].y] - 1) % Mod);\n\n\t\t// 3. Ring\n\t\tfor (int i = 1; i <= N; ++i) Add (ans, Mod - 2ll * calc (i) % Mod);\n\n\t\treturn ans;\n\t}\n}\n\nnamespace Four\n{\n\tint Vis[Maxn];\n\n\tinline int calc (int x)\n\t{\n\t\tint ans = 0;\n\t\tfor (int y : G[x]) Vis[y] = x;\n\n\t\tfor (int y : G[x])\n\t\t{\n\t\t\tfor (int z : G[y])\n\t\t\t{\n\t\t\t\tif (Vis[z] != x) continue;\n\n\t\t\t\tAdd (ans, 1);\n\t\t\t\tAdd (ans, ((deg[x] - 2) + (deg[y] - 2) + (deg[z] - 2)) % Mod);\n\t\t\t}\n\t\t}\n\n\t\treturn ans;\n\t}\n\n\tinline int calc_chain (int x)\n\t{\n\t\tint ans = 0, sum = 0;\n\t\tfor (int y : G[x])\n\t\t{\n\t\t\tAdd (ans, (LL)sum * (deg[y] - 1));\n\t\t\tsum += deg[y] - 1;\n\t\t}\n\t\treturn ans;\n\t}\n\n\tint cnt[Maxn];\n\n\tinline int calc_ring (int x)\n\t{\n\t\tint ans = 0;\n\t\tvector <int> Save; Save.clear();\n\n\t\tfor (int y : G[x])\n\t\t{\n\t\t\tif (!cmp(y, x)) break;\n\t\t\tfor (int z : G[y])\n\t\t\t{\n\t\t\t\tif (!cmp(z, x)) break;\n\t\t\t\tAdd (ans, cnt[z]), ++cnt[z], Save.pb(z);\n\t\t\t}\n\t\t}\n\n\t\tfor (int x : Save) cnt[x] = 0;\n\n\t\treturn ans;\n\t}\n\n\tinline int solve ()\n\t{\n\t\tint ans = 0;\n\n\t\t// 1. Star\n\t\tfor (int i = 1; i <= N; ++i) Add (ans, Binom(deg[i], 4));\n\n\t\t// 2. Edge with 2 points on one side, and 1 point on the other side\n\t\tfor (int i = 1; i <= M; ++i)\n\t\t{\n\t\t\tint x = deg[E[i].x], y = deg[E[i].y];\n\t\t\tAdd (ans, (LL)Binom (x - 1, 2) * (y - 1) % Mod);\n\t\t\tAdd (ans, (LL)Binom (y - 1, 2) * (x - 1) % Mod);\n\t\t}\n\n\t\t// 3. Three-membered ring with 1 point\n\t\tfor (int i = 1; i <= N; ++i) Add (ans, Mod - 3ll * calc (i));\n\n\t\t// Add undirected edge\n\t\tfor (int i = 1; i <= M; ++i) G[E[i].y].pb(E[i].x);\n\n\t\t//4. Chain\n\t\tfor (int i = 1; i <= N; ++i) Add (ans, calc_chain (i));\n\n\t\t//5. Four-membered ring\n\t\tstatic int Rank[Maxn];\n\t\tfor (int i = 1; i <= N; ++i) Rank[i] = i, sort(G[i].begin(), G[i].end(), cmp);\n\t\tsort(Rank + 1, Rank + N + 1, cmp);\n\t\tfor (int i = 1; i <= N; ++i) Add (ans, (LL)(Mod - 3) * calc_ring (Rank[i]) % Mod);\n\n\t\treturn ans;\n\t}\n}\n\ninline void Solve ()\n{\n\tint ans = 0;\n\n\tif (K == 1) ans = M;\n\telse if (K == 2) for (int i = 1; i <= N; ++i) Add (ans, Binom (deg[i], 2));\n\telse if (K == 3) ans = Three :: solve ();\n\telse ans = Four :: solve ();\n\t\n\tcout << ans << endl;\n}\n\ninline void Input ()\n{\n\tN = read<int>(), M = read<int>(), K = read<int>();\n\n\tfor (int i = 1; i <= M; ++i) E[i].x = read<int>(), E[i].y = read<int>(), ++deg[E[i].x], ++deg[E[i].y];\n\n\tfor (int i = 1; i <= M; ++i)\n\t{\n\t\tif (!cmp(E[i].x, E[i].y)) swap(E[i].x, E[i].y);\n\t\tG[E[i].x].pb(E[i].y);\n\t}\n}\n\nint main()\n{\n\n\tfreopen(\"subgraph.in\", \"r\", stdin);\n\tfreopen(\"subgraph.out\", \"w\", stdout);\n\n\tmath_init(2e5);\n\tInput ();\n\tSolve ();\n\n\treturn 0;\n}\n\n```\n\n","categories":["Problem"],"tags":["暴力","分类讨论","枚举"]},{"title":"「FJWC2019」最短路 - 最大流","url":"/2019/02/28/%E3%80%8CFJWC2019%E3%80%8D%E6%9C%80%E7%9F%AD%E8%B7%AF-%E6%9C%80%E5%A4%A7%E6%B5%81/","content":"\n给你一张 $n$ 个点$m$ 条边的无向图（点从$0$到$n-1$标号），走过每条边都需要花费 $1$ 秒\n\n给你一个整数 $k$ ，请你选择至多 $k$ 个点，令经过这些点也需要花费 $1$ 秒，使得从点 $0$ 走到点 $n-1$ 的最短时间最大，求这个最大值\n\n注意，不能选择点 $0$ 或点 $n−1$\n\n$n\\le100, m\\le\\frac{n(n-1)}{2}$\n\n<!--more-->\n\n### Links\n\n[FZOJ 190](http://218.5.5.242:9021/problem/190)\n\n\n\n### Brute-Force\n\n看到数据范围这么小，可以考虑模拟退火乱搞。\n\n先随机选$k$个点，每次随机交换两个点，看答案是否更优\n\n注意到，这里的退火并不是真正意义上的退火。因为每次变动解的范围是和$T$无关的，也就相当于是一个乱搞做法，不过能获得$98$分的高分。。。\n\n\n\n### Solution\n\n考虑一个显然对的贪心\n\n每次找到一个大小尽量小的点集$S$，使得从$0$到$n-1$的任意一条最短路中都存在某个点$x\\in S$。然后把$S$的点权设为$1$，再计算一遍最短路，重复以上过程\n\n考虑如何求点集$S$\n\n不难注意到，$S$实际上就是原图的最短路图的最小割点集（即在最短路图中，删掉这个集合就能使得$0$和$n-1$不联通）\n\n于是就很容易转化成一个网络流模型了\n\n* 把$1​$到$n-2​$的每个点$x​$拆成两个点$x_1, x_2​$。从$x_2​$向$x_1​$连边，若$x​$点权已经为$1​$，则容量为$\\infty​$；否则为$1​$\n* 把原图最短路图中的边对应连到此处从左列点往右列点的边，容量为$\\infty$。最短路图中与$0$或$n-1$相连的边直接从源点连向第二列的点，或是从第一列的点连向汇点\n\n这样做就能将割点集转化成割边集，直接求最小割即可\n\n\n\n### Code\n\n#### Brute-Force\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int Maxn = 110, Maxm = Maxn * Maxn;\n\ninline int Rand(int l, int r) { if (r - l + 1 <= 0) return -1; return rand() % (r - l + 1) + l; }\n\nint N, M, K;\nint e, To[Maxm], Begin[Maxn], Next[Maxm];\nint Val[Maxn], A[Maxn], n, m, k, Vis[Maxn], Dis[Maxn];\n\ninline void add_edge (int x, int y) { To[++e] = y; Next[e] = Begin[x]; Begin[x] = e; }\n\npriority_queue<pii , vector<pii> , greater<pii> > Q;\n\ninline int Dijsktra ()\n{\n\tQ.push (mp(0, 0));\n\tmemset (Dis, 0x3f, sizeof(Dis)), Dis[0] = 0;\n\tmemset (Vis, 0, sizeof(Vis));\n\n\twhile (!Q.empty())\n\t{\n\t\tint x = Q.top().y; Q.pop();\n\t\tif(Vis[x]) continue;\n\t\tVis[x] = 1;\n\n\t\tfor(int i = Begin[x]; i; i = Next[i])\n\t\t{\n\t\t\tint y = To[i];\n\t\t\tif (Chkmin(Dis[y], Dis[x] + Val[x] + 1)) Q.push(mp(Dis[y], y));\n\t\t}\n\t}\n\n\treturn Dis[N - 1];\n}\n\nint now_ans, ans;\n\ninline void Init() { random_shuffle(A + 1, A + N - 1); for (int i = 1; i <= K; ++i) Val[A[i]] = 1; }\n\nconst double TIME_LIMIT = 0.9;\nconst double delta = 0.98;\nconst double eps = 1e-8;\n\ninline void Work ()\n{\n\tnow_ans = Dijsktra(); Chkmax(ans, now_ans);\n\tdouble temp = 10000000;\n\twhile (temp > eps)\n\t{\n\t\tint x = Rand(1, K), y = Rand(K + 1, N - 2);\n\n\t\tif (x != -1 && y != -1)\n\t\t{\n\t\t\tswap(A[x], A[y]); swap(Val[A[x]], Val[A[y]]); \n\n\t\t\tint now = Dijsktra(); \n\t\t\tChkmax(ans, now);\n\n\t\t\tif(now > now_ans || exp((now - now_ans) / temp) * RAND_MAX > rand())\n\t\t\t\tnow_ans = now;\n\t\t\telse swap(A[x], A[y]), swap(Val[A[x]], Val[A[y]]);\n\t\t}\n\n\t\ttemp *= delta;\n\n\t\tif (clock() / CLOCKS_PER_SEC > TIME_LIMIT)\n\t\t{\n\t\t\tcout << ans << endl;\n\t\t\texit(0);\n\t\t}\n\t}\n\n\tfor(int i = 0; i < N; ++i) Val[i] = 0;\n}\n\ninline void Solve ()\n{\n\tfor(int i = 1; i < N - 1; ++i) A[i] = i;\n\n\twhile(clock() / CLOCKS_PER_SEC < TIME_LIMIT) Init (), Work ();\n\n\tcout << ans << endl;\n}\n\ninline void Input ()\n{\n\tsrand(20030216);\n\tN = read<int>(), M = read<int>();\n\tK = min(N - 2, read<int>());\n\n\tfor(int i = 1; i <= M; ++i)\n\t{\n\t\tint x = read<int>(), y = read<int>();\n\t\tadd_edge (x, y);\n\t\tadd_edge (y, x);\n\t}\n}\n\nint main()\n{\n\n\tfreopen(\"min.in\", \"r\", stdin);\n\tfreopen(\"min.out\", \"w\", stdout);\n\n\tInput();\n\tSolve();\n\n\treturn 0;\n}\n```\n\n \n\n#### std\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int Maxn = 100 + 20, Maxm = Maxn * Maxn + 100, inf = 0x3f3f3f3f;\n\nint N, M, K;\nint e, Begin[Maxn], To[Maxm << 1], Next[Maxm << 1], W[Maxn];\n\ninline void add_edge (int x, int y) { To[++e] = y; Next[e] = Begin[x]; Begin[x] = e; }\n\nnamespace Dinic\n{\n\tconst int Maxn = 200 + 20;\n\tint e = 1, Begin[Maxn], To[Maxm << 1], Next[Maxm << 1], Cur[Maxn];\n\tint Cap[Maxm << 1], Level[Maxn];\n\n\tinline void add_edge (int x, int y, int z, int p = 0)\n\t{\n\t\tTo[++e] = y; Next[e] = Begin[x]; Begin[x] = e;\n\t\tCap[e] = z; if (!p) add_edge (y, x, 0, 1);\n\t}\n\n\tqueue <int> Q;\n\n\tinline int bfs ()\n\t{\n\t\tmemset(Level, -1, sizeof Level);\n\t\tLevel[1] = 0; Q.push(1);\n\n\t\twhile (!Q.empty())\n\t\t{\n\t\t\tint x = Q.front(); Q.pop();\n\t\t\tfor (int i = Begin[x]; i; i = Next[i])\n\t\t\t{\n\t\t\t\tint y = To[i];\n\t\t\t\tif (Cap[i] > 0 && Level[y] < 0)\n\t\t\t\t{\n\t\t\t\t\tLevel[y] = Level[x] + 1;\n\t\t\t\t\tQ.push(y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn Level[N] != -1;\n\t}\n\n\tinline int find (int x, int k)\n\t{\n\t\tif (x == N) return k;\n\n\t\tint ans = 0;\n\t\tfor (int &i = Cur[x]; i; i = Next[i])\n\t\t{\n\t\t\tint y = To[i], sum;\n\t\t\tif (Level[y] == Level[x] + 1 && Cap[i] > 0 && (sum = find(y, min(Cap[i], k))))\n\t\t\t{\n\t\t\t\tk -= sum, Cap[i] -= sum;\n\t\t\t\tans += sum, Cap[i ^ 1] += sum;\n\t\t\t\tif (!k) break;\n\t\t\t}\n\t\t}\n\n\t\treturn ans;\n\t}\n\n\tinline int work ()\n\t{\n\t\tint ans = 0;\n\t\twhile (bfs())\n\t\t{\n\t\t\tfor (int i = 1; i <= 2 * N; ++i) Cur[i] = Begin[i];\n\t\t\tans += find(1, inf);\n\t\t}\n\n\t\tfor (int i = 2; i < N; ++i) if (Level[i + N] > 0 && Level[i] < 0) W[i] = 1;\n\n\t\treturn ans;\n\t}\n\t\n\tinline void init ()\n\t{\n\t\te = 1; memset(Begin, 0, sizeof Begin);\n\t}\n}\n\nint Vis[Maxn], Dis[Maxn];\nqueue <int> Q;\nvector <int> From[Maxn];\n\ninline int Spfa ()\n{\n\tfor (int i = 1; i <= N; ++i) Dis[i] = inf; \n\tDis[1] = 0, Q.push(1);\n\n\twhile (!Q.empty())\n\t{\n\t\tint x = Q.front(); Q.pop();\n\t\tVis[x] = 0;\n\t\tfor (int i = Begin[x]; i; i = Next[i])\n\t\t{\n\t\t\tint y = To[i];\n\t\t\tif (Chkmin (Dis[y], Dis[x] + W[y] + 1))\n\t\t\t{\n\t\t\t\tif (!Vis[y]) Vis[y] = 1, Q.push(y);\n\t\t\t\tFrom[y].clear(), From[y].pb(x);\n\t\t\t}\n\t\t\telse if (Dis[y] == Dis[x] + W[y] + 1) From[y].pb(x);\n\t\t}\n\t}\n\n\treturn Dis[N];\n}\n\ninline void Build_Graph ()\n{\n\tSpfa(); Dinic :: init ();\n\n\tfor (int x = 2; x < N; ++x)\n\t{\n\t\tDinic :: add_edge (x + N, x, W[x] ? inf : 1);\n\n\t\tfor (int y : From[x]) Dinic :: add_edge (y, x + N, inf);\n\t}\n\n\tfor (int x : From[N]) Dinic :: add_edge (x, N, inf);\n}\n\ninline void Solve ()\n{\n\tint ans = Spfa ();\n\n\twhile (K)\n\t{\n\t\tBuild_Graph ();\n\t\tint now = Dinic :: work ();\n\t\tif (!now || now > K) break;\n\t\t++ans, K -= now;\n\t}\n\n\tcout << ans << endl;\n}\n\ninline void Input ()\n{\n\tN = read<int>(), M = read<int>(), K = read<int>();\n\tfor (int i = 1; i <= M; ++i)\n\t{\n\t\tint x = read<int>() + 1, y = read<int>() + 1;\n\t\tadd_edge (x, y);\n\t\tadd_edge (y, x);\n\t}\n}\n\nint main()\n{\n\n\tfreopen(\"min.in\", \"r\", stdin);\n\tfreopen(\"min.out\", \"w\", stdout);\n\n\tInput ();\n\tSolve ();\n\n\treturn 0;\n}\n\n```\n\n","categories":["Problem"],"tags":["网络流","最大流","模拟退火"]},{"title":"ToDoList for this blog","url":"/2019/02/26/ToDoList-for-this-blog/","content":"\n这几天捣鼓博客，自己搞了一个新主题，速度比之前`NexT`快了很多\n\n但是现在弄这个搜索框弄得我怀疑人生，~~鬼知道我经历了什么~~\n\n索性把一些问题先留着，以后有时间了再继续调整\n\n<!--more-->\n\n* 一些小问题\n\n  - [ ] 解决`Archives`和`Tag`页面因为标题太长，而第二行显示到日期下方的问题\n  - [x] 添加文章目录/导航边栏\n  - [ ] 添加`回到顶部`按钮\n  - [ ] 调整代码样式\n  - [ ] 调整`Tags`页面样式\n  - [ ] 主页分页部分添加具体页码按钮\n  - [x] 文章中的分割线显示不出来 `19.3.5 Done`\n\n\n\n* 一些大工程\n\n  - [x] 添加博客站内搜索（这是一个天坑）\n\n    目前遇到的问题：不会弄一个弹出式的框来显示搜索结果；而单独开一个页面显示结果的话不会把数据传过去。本来想利用`cookies`实现传输，结果因为其存储量太小，搜索结果太多导致无法上传\n\n    19.2.27 UPD\n\n     ~~添加了一个比较粗糙的搜索功能，勉强能用，残余的问题有：~~\n\n    1. ~~只能通过回车进行搜索，无法添加搜索按钮~~\n\n    2. ~~依旧只能上传不超过9篇文章，不过一般比较模糊的搜索都可以在tags中查找来代替因此搜索结果只截取了最近9篇文章~~ \n\n    推到github上之后发现还是用不了，算了弃了弃了\n\n\t20.2.26 UPD\n\n\t今天把搜索功能按next主题的方法搞出来了，效果挺好的。\n\n\t好巧，一年前的今天刚好是把这个主题做出来的日子\n\n  - [x] 添加评论系统\n\n    使用gitment完成，ruby实现自动初始化方法[见此](https://madordie.github.io/post/blog-gitment-auto-setup/#more)\n\n    19.3.1 UPD\n\n    ruby程序还是有问题，返回`Bad Credentials `\n\n\t20.1.28 UPD\n\n\t最终还是用的Valine的评论，又回到最初的起点。。。\n\n\t不过自定义了css后很美观\n\n  - [ ] 添加站内统计系统\n","categories":["Something"]},{"title":"「JOISC 2016 Day 2」女装大佬 - 贪心","url":"/2019/02/26/%E3%80%8CJOISC-2016-Day-2%E3%80%8D%E5%A5%B3%E8%A3%85%E5%A4%A7%E4%BD%AC-%E8%B4%AA%E5%BF%83/","content":"\n题面太长，放不下\n\n<!--more-->\n\n### Links\n\n[LOJ 2734](https://loj.ac/problem/2734)\n\n### Description\n\n有$2n$个人排队上厕所。厕所只有两个单间，一个男女通用，一个女性专用。所有人都排成一队\n\n* 若当前队首是女性，她会优先进入女性专用单间，如果已经被占用则进入男女通用单间；如果男女通用单间也被占用就只好等着了\n* 如果当前队首是男性，他会尝试进入男女通用单间，如果已经被占用他就会继续等待。此时如果女性专用单间为空，当前队列里最前的一位女性会直接进入\n\n假设每个人上厕所需要一个单位的时间，在队列中移动的时间忽略不计。你希望调整队列顺序使得在$n$个单位时间内所有人都上完厕所。\n\n调整顺序可能会引起不满，一个人的不满值定义为调整队列前在他之后且调整队列后在他之前的人数，你希望使得所有人中最大的不满值尽可能小。求这个最小值\n\n> 注：队列以一种特殊的形式给出\n>\n> 给出一个正整数$m$，接下来$m$行，每行一个字符串$S$和一个数字$x$,这一行描述的字符串为给出的字符串重复$x$次后得到的字符串$S$。把每一行描述的字符串接起来即可得到描述整个队列的字符串\n>\n> 描述整个队列的字符串按队列从前到后的顺序依次给出每个人的性别,$M$ 表示男性,$F$ 表示女性\n\n\n\n### Constraints\n\n$n\\le 10^{18}, m\\le 10^5, \\sum|S|\\le 2\\times 10^5$\n\n\n\n### Solution\n\n首先不难发现，最优策略肯定是尽量把男生往前移\n\n考虑把男生看成$-$1，女生看成$1$，那么只要某个队列`后缀和的最小值`大于等于​$-1$，这个队列就一定能在$n$分钟内解决\n\n于是我们就只需要移动`后缀和最小`的那个后缀中的男生，把他们尽量往前移就行了\n\n具体细节见代码，代码很好理解\n\n\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int Maxn = 2e5 + 100;\n\nLL N, M, tot_F;\nLL Suf[Maxn], Min[Maxn], Mul[Maxn];\n// Suf : 后缀和\n// Min : 单次后缀最小值\nchar A[Maxn];\n\ninline void Solve ()\n{\n\tif (tot_F < N) { puts(\"-1\"); return ; }\n\n\tLL sum = 0, ans = LLONG_MAX;\n\tfor (int i = M; i; --i)\n\t{\n\t\tif (Suf[i] < 0) Chkmin (ans, sum + Min[i] + Suf[i] * (Mul[i] - 1));\n\t\telse Chkmin (ans, sum + Min[i]);\n\t\tsum += Suf[i] * Mul[i];\n\t}\n\n\tif (ans >= 0) puts(\"0\");\n\telse printf(\"%lld\\n\", -ans - 1);\n}\n\ninline void Input ()\n{\n\tN = read<LL>(), M = read<int>();\n\tfor (int i = 1; i <= M; ++i)\n\t{\n\t\tscanf(\"%s\", A); Mul[i] = read<LL>();\n\t\tint len = strlen(A) - 1;\n\t\tMin[i] = LLONG_MAX;\n\t\tfor (int j = len; ~j; --j)\n\t\t{\n\t\t\tif (A[j] == 'F') ++Suf[i], tot_F += Mul[i];\n\t\t\telse --Suf[i];\n\t\t\tChkmin(Min[i], Suf[i]);\n\t\t}\n\t}\n}\n\nint main()\n{\n\n#ifndef ONLINE_JUDGE\n\tfreopen(\"queue.in\", \"r\", stdin);\n\tfreopen(\"queue.out\", \"w\", stdout);\n#endif\n\n\tInput ();\n\tSolve ();\n\n\treturn 0;\n}\n\n```\n\n","categories":["Problem"],"tags":["贪心"]},{"title":"树哈希","url":"/2019/02/26/%E6%A0%91%E5%93%88%E5%B8%8C/","content":"\n用来判断两棵有根树是否同构，很简单，稍微记录一下细节~~(贴个代码)~~\n\n~~我会告诉你这篇博客其实是用来测试一下自己瞎折腾的新主题的吗~~\n\n<!--more-->\n\n### Brief Introduction\n\n大致Hash的思路与普通字符串Hash类似，需要注意的点：\n\n* 树Hash需要两个不同的`Base`和一个`Rest`来进行Hash（具体见代码），即先对子树用`Base1`Hash起来后，对这个Hash值用`Base2`和`Rest`进行Hash\n* 求出儿子的Hash值后需要将它们**排序**再计算\n* 具体Hash策略可以模意义下普通Hash，也可以直接异或\n* 此外，如果需要判断无根树是否同构的话，可以把重心作为根进行Hash\n\n### Code\n\n```cpp\nconst int Base1 = 20030123, Base2 = 20030618, Rest = 19260817;\n\nULL Hash[Maxm];\n\ninline void get_hash (int x)\n{\n\tULL Save[Maxm];\n\tSave[0] = 0;\n\n\tint cnt = 0;\n\tfor (int y : G[x]) \n\t{\n\t\tif (y == fa[x]) continue;\n\t\tfa[y] = x;\n\t\tget_hash (y);\n\t\tSave[++cnt] = Hash[y];\n\t}\n\n\tsort(Save + 1, Save + cnt + 1);\n\tHash[x] = 0;\n\tfor (int i = 1; i <= cnt; ++i)\n\t\tHash[x] = Hash[x] * Base1 + Save[i];\n\n\tHash[x] = Hash[x] * Base2 + Rest;\n}\n```\n\n","categories":["Algorithm"],"tags":["Hash"]},{"title":"「CTSC2016」单调上升路径 - 构造","url":"/2019/02/24/%E3%80%8CCTSC2016%E3%80%8D%E5%8D%95%E8%B0%83%E4%B8%8A%E5%8D%87%E8%B7%AF%E5%BE%84-%E6%9E%84%E9%80%A0/","content":"\n有一张$n$（$n$为偶数）个点的完全图$G$，你需要为每条边确定一个不同的边权，使得这张图的最长单调上升路径边数最少\n\n$n\\le 500$\n\n原题中还给出了一个提示：\n\n结论：假设带权无向图 $G$ 有 $100$ 个节点 $1000$ 条边，且所有权值各不相同。那么，$G$ 中一定存在一个单调上升路径，它的长度大于等于 $20$。\n\n证明：假设每个节点上有一个探险家。我们按权值从小到大枚举所有的边，每次将该边连接的节点中的探险家的位置进行对调。可以知道，每个探险家都走的是一条单调上升路径。另外，由于共有 $100$ 个探险家，而探险家一共走了 $2000$ 步，所以有人走了 $20$ 步。证毕。\n\n<!--more-->\n\n### Links\n\n[UOJ 201](http://uoj.ac/problem/201)\n\n\n\n### Solution\n\n由提示可以知道，一张$n$个点$m$条边的图，单调上升路径至少为$\\frac{2m}{n}$\n\n因此完全图的单调上升路径至少为$n-1$，且所有极长单调上升路径长度都为$n-1​$\n\n接下来，考虑把完全图的边分解成$n-1$个大小为$\\frac{n}{2}$的集合，每个集合的边都不在端点处相交\n\n对于第$i$个集合，我们对其赋予从$\\frac{n}{2}\\times (i - 1) + 1$到$\\frac{n}{2}\\times i$大小的边权\n\n这样最长上升路径显然不超过$n-1$，因为**每组边集里的边都最多只经过一次**\n\n---\n\n具体构造这个东西的话，可以把$n-1$个点围成一个圈，中间放一个点\n\n![19-2-24-1](/images/19-2-24-1.png)\n\n每次构造这样的$\\frac{n}{2}$条边，然后把这个多边形旋转一下\n\n特别神仙的一个构造。。。\n\n\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int Maxn = 500 + 10;\n\nint N;\nint A[Maxn][Maxn];\n\ninline int Pos (int x) { return (x + N - 2) % (N - 1) + 1; }\n\ninline void add_edge (int x, int y, int z)\n{\n\tif (x > y) swap(x, y);\n\tA[x][y] = z;\n}\n\ninline void Solve ()\n{\n\tint cnt = 0, K = N / 2 - 1;\n\tfor (int i = 1; i < N; ++i)\n\t{\n\t\tadd_edge (i, N, ++cnt);\n\t\tfor (int j = 1; j <= K; ++j)\n\t\t\tadd_edge (Pos(i + j), Pos(i - j), ++cnt);\n\t}\n\n\tfor (int i = 1; i < N; ++i)\n\t\tfor (int j = i + 1; j <= N; ++j)\n\t\t\tprintf(\"%d%c\", A[i][j], j == N ? '\\n' : ' ');\n}\n\ninline void Input ()\n{\n\tN = read<int>();\n}\n\nint main()\n{\n\n#ifndef ONLINE_JUDGE\n\tfreopen(\"A.in\", \"r\", stdin);\n\tfreopen(\"A.out\", \"w\", stdout);\n#endif\n\n\tInput ();\n\tSolve ();\n\n\treturn 0;\n}\n\n```\n\n","categories":["Problem"],"tags":["构造"]},{"title":"「模拟赛」2.24模拟赛 - Summary","url":"/2019/02/24/%E3%80%8C%E6%A8%A1%E6%8B%9F%E8%B5%9B%E3%80%8D2-24%E6%A8%A1%E6%8B%9F%E8%B5%9B-Summary/","content":"","categories":["Summary"],"tags":["Summary","分块","动态规划","数据结构","状态压缩","Hash","打表","01Trie","Trie"]},{"title":"「HNOI2018」毒瘤 - 虚树 + 状态压缩","url":"/2019/02/23/%E3%80%8CHNOI2018%E3%80%8D%E6%AF%92%E7%98%A4-%E8%99%9A%E6%A0%91-%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/","content":"\n给出一张$n$个点$m$条边的联通图，求图的最大独立集方案数\n\n$n\\le 10^5, m\\le n + 10$\n\n<!--more-->\n\n### Links\n\n[Luogu P4426](https://www.luogu.org/problemnew/show/P4426)\n\n[LOJ 2496](https://loj.ac/problem/2496)\n\n\n\n### Solution\n\n首先考虑树的情况怎么做，设$dp[x][0/1]$表示x选/不选的方案数，显然有转移：\n$$\n\\begin{aligned}\ndp[x][0] = &\\prod_{y} (dp[y][0] + dp[y][1])\\\\\ndp[x][1] = &\\prod_{y} dp[y][0]\n\\end{aligned}\n$$\n因为非树边比较少，所以可以考虑枚举所有非树边连接的点的状态，显然只有三种情况：$(0, 1), (0, 0), (1, 0)$\n\n又因为前两种状态可以合并成`钦定前一个点必不选`这一个状态，复杂度$O(2^{m-n+1}n)$\n\n---\n\n考虑优化这个做法，显然每次枚举状态进行dp可以用虚树优化\n\n把所有非树边连接的点提出来建立虚树，并且对于不同状态，这个虚树的形态是不会变的\n\n因此，我们可以一开始直接把虚树构建出来，只要一个点有至少两棵子树中包含关键点，那么它就是关键点\n\n具体实现上可以记录一个$son[x]​$表示$x​$子树中最深度最浅的关键点是谁\n\n>  因为这里的dp是一个乘积的形式，所以在处理虚边信息（原树中链）时就需要考虑**非虚**子树的贡献\n>\n> 这里定义，对于$x​$而言，若它的某个儿子$y​$子树中有关键点，则称$y​$的子树为$x​$的虚子树；否则称其为$x​$的非虚子树\n\n设$k[x][0/1][0/1]​$表示从$x​$到$son[x]​$这条链上，若$x​$选/不选，$son[x]​$选/不选时，$son[x]​$对于$x​$的dp转移系数\n\n$g[x][0/1]​$表示$x​$选/不选时，非虚子树的方案数，这个可以用类似上面$dp[]​$的方法求出\n\n---\n\n具体转移及实现细节：\n\n```cpp\ninline void dfs1 (int x)\n{\n\tg[x][0] = g[x][1] = 1;\n\n\tfor (int i = Begin[x]; i; i = Next[i])\n\t{\n\t\tint y = To[i];\n\t\tif (fa[y] != x) continue;\n\n\t\tdfs1 (y);\n\n\t\tif (!Son[y]) //说明y的子树中没有一个关键点，即y为x的非虚子树\n\t\t{//直接把y的贡献统计到x上\n\t\t\tg[x][0] = (LL)g[x][0] * (g[y][0] + g[y][1]) % Mod;\n\t\t\tg[x][1] = (LL)g[x][1] * g[y][0] % Mod;\n\t\t}\n\t\telse \n\t\t{\n            //x继承y的转移系数\n\t\t\tk[x][0] = k[y][0] + k[y][1];\n\t\t\tk[x][1] = k[y][0];\n\n\t\t\tif (Key[x]) //若x为关键点，则连虚树边 \n                VTREE :: add_edge (x, Son[y], k[x][0], k[x][1]);\n\t\t\telse Son[x] = Son[y];\n\t\t}\n\t}\n\n\tif (Key[x]) // 清空转移系数\n        k[x][0] = mp(1, 0), k[x][1] = mp(0, 1), Son[x] = x;\n\telse // 把当前点的非虚子树信息乘到转移系数上 \n        k[x][0] *= g[x][0], k[x][1] *= g[x][1];\n}\n```\n\n\n\n幸好这道题不需要对于每次dp都建一遍虚树，不然真的会疯掉。。。\n\n\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int Maxn = 1e5 + 100, Mod = 998244353;\n\ninline pii operator + (const pii &a, const pii &b) { return mp((a.x + b.x) % Mod, (a.y + b.y) % Mod); }\ninline pii operator * (const pii &a, const pii &b) { return mp((LL)a.x * b.x % Mod, (LL)a.y * b.y % Mod); }\ninline pii operator * (const pii &a, const int b) { return mp((LL)a.x * b % Mod, (LL)a.y * b % Mod); }\ninline void operator += (pii &a, const pii &b) { a = a + b; }\ninline void operator *= (pii &a, const int &b) { a = a * b; }\ninline void operator *= (pii &a, const pii &b) { a = a * b; }\n\nint N, M;\nint e, Begin[Maxn], To[Maxn << 1], Next[Maxn << 1];\nint fa[Maxn], Vis[Maxn], extra;\npii E[Maxn];\n\ninline void Add (int &a, int b) { a += b; if (a >= Mod) a -= Mod; }\n\ninline void add_edge (int x, int y) { To[++e] = y; Next[e] = Begin[x]; Begin[x] = e; }\n\nint Key[Maxn], Son[Maxn];\n\nint f[Maxn][2], g[Maxn][2];\npii k[Maxn][2];\n\nnamespace VTREE\n{\n\tint Col[Maxn];\n\tpii k0[Maxn], k1[Maxn];\n\n\tint e, Begin[Maxn], To[Maxn << 1], Next[Maxn << 1];\n\n\tinline void add_edge (int x, int y, pii a, pii b) { To[++e] = y; Next[e] = Begin[x]; Begin[x] = e; k0[e] = a, k1[e] = b; }\n\n\tinline int Calc (pii a, pii b)\n\t{\n\t\ta *= b;\n\t\treturn (a.x + a.y) % Mod;\n\t}\n\n\tinline void get_dp (int x)\n\t{\n\t\tf[x][0] = g[x][0], f[x][1] = g[x][1];\n\t\tif (~Col[x]) f[x][!Col[x]] = 0;\n\n\t\tfor (int i = Begin[x]; i; i = Next[i])\n\t\t{\n\t\t\tint y = To[i];\n\n\t\t\tget_dp (y);\n\n\t\t\tf[x][0] = (LL)f[x][0] * Calc (k0[i], mp(f[y][0], f[y][1])) % Mod;\n\t\t\tf[x][1] = (LL)f[x][1] * Calc (k1[i], mp(f[y][0], f[y][1])) % Mod;\n\t\t}\n\t}\n\n\tinline void work ()\n\t{\n\t\tmemset(Col, -1, sizeof Col);\n\n\t\tint ALL = (1 << extra) - 1, ans = 0;\n\t\tfor (int i = 0; i <= ALL; ++i)\n\t\t{\n\t\t\tint fl = 0;\n\n\t\t\tfor (int j = 1; j <= extra; ++j) \n\t\t\t\tif ((1 << (j - 1)) & i) \n\t\t\t\t{\n\t\t\t\t\tif (Col[E[j].x] == 0 || Col[E[j].y] == 1) { fl = 1; break; }\n\t\t\t\t\tCol[E[j].x] = 1, Col[E[j].y] = 0;\n\t\t\t\t}\n\t\t\t\telse \n\t\t\t\t{\n\t\t\t\t\tif (Col[E[j].x] == 1) { fl = 1; break; }\n\t\t\t\t\tCol[E[j].x] = 0;\n\t\t\t\t}\n\n\t\t\tif (!fl)\n\t\t\t{\n\t\t\t\tget_dp (1);\n\t\t\t\tAdd (ans, (f[1][0] + f[1][1]) % Mod);\n\t\t\t}\n\n\t\t\tfor (int j = 1; j <= extra; ++j) Col[E[j].x] = Col[E[j].y] = -1;\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n}\n\ninline int dfs0 (int x)\n{\n\tVis[x] = 1;\n\tint cnt = 0;\n\n\tfor (int i = Begin[x]; i; i = Next[i])\n\t{\n\t\tint y = To[i];\n\t\tif (y == fa[x]) continue;\n\n\t\tif (Vis[y])\n\t\t{\n\t\t\tKey[x] = 1;\n\t\t\tif (Vis[y] == 1) E[++extra] = mp(y, x);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfa[y] = x;\n\t\t\tcnt += dfs0(y);\n\t\t}\n\t}\n\n\tVis[x] = 2;\n\tif (cnt > 1) Key[x] = 1;\n\n\treturn cnt || Key[x];\n}\n\ninline void dfs1 (int x)\n{\n\tg[x][0] = g[x][1] = 1;\n\n\tfor (int i = Begin[x]; i; i = Next[i])\n\t{\n\t\tint y = To[i];\n\t\tif (fa[y] != x) continue;\n\n\t\tdfs1 (y);\n\n\t\tif (!Son[y])\n\t\t{\n\t\t\tg[x][0] = (LL)g[x][0] * (g[y][0] + g[y][1]) % Mod;\n\t\t\tg[x][1] = (LL)g[x][1] * g[y][0] % Mod;\n\t\t}\n\t\telse \n\t\t{\n\t\t\tk[x][0] = k[y][0] + k[y][1];\n\t\t\tk[x][1] = k[y][0];\n\n\t\t\tif (Key[x]) VTREE :: add_edge (x, Son[y], k[x][0], k[x][1]);\n\t\t\telse Son[x] = Son[y];\n\t\t}\n\t}\n\n\tif (Key[x]) k[x][0] = mp(1, 0), k[x][1] = mp(0, 1), Son[x] = x;\n\telse k[x][0] *= g[x][0], k[x][1] *= g[x][1];\n}\n\ninline void Solve ()\n{\n\tKey[1] = 1;\n\tdfs0 (1), dfs1 (1);\n\tVTREE :: work ();\n}\n\ninline void Input ()\n{\n\tN = read<int>(), M = read<int>();\n\tfor (int i = 1; i <= M; ++i)\n\t{\n\t\tint x = read<int>(), y = read<int>();\n\t\tadd_edge (x, y);\n\t\tadd_edge (y, x);\n\t}\n}\n\nint main()\n{\n\n#ifndef ONLINE_JUDGE\n\tfreopen(\"A.in\", \"r\", stdin);\n\tfreopen(\"A.out\", \"w\", stdout);\n#endif\n\n\tInput ();\n\tSolve ();\n\n\treturn 0;\n}\n```\n\n","categories":["Problem"],"tags":["状态压缩","省选","虚树"]},{"title":"「HEOI2014」大工程 - 虚树 + 动态规划","url":"/2019/02/22/%E3%80%8CHEOI2014%E3%80%8D%E5%A4%A7%E5%B7%A5%E7%A8%8B-%E8%99%9A%E6%A0%91-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","content":"\n给你一棵$n$个点的树，有$q$次询问。\n\n每次询问给出一个$k$，并给出一个大小为$k$的点集$S$。求这$k$个点两两所形成的$\\binom{k}{2}$条路径中：\n\n* 所有路径长度和\n* 最短路径的长度\n* 最长路径的长度\n\n$n\\le 10^6, (\\sum k)\\le 2n$\n\n<!--more-->\n\n### Links\n\n[ Luogu P4103](https://www.luogu.org/problemnew/show/P4103)\n\n[LOJ 2219](https://loj.ac/problem/2219)\n\n\n\n### Solution\n\n显然可以构建虚树，下面考虑三个小问怎么做\n\n1. * 显然可以考虑每条边对答案的贡献，答案就是每条边的边权乘以两端子树内关键点数目\n   * 我自己做的时候没想到这个trick，于是就用了一种特别麻烦的树形dp，具体可以见代码\n2. 我们可以设$f[x]$表示从$x$开始，向子树能够延伸的最短链的长度。每次遍历一遍所有儿子，求出最短链和次短链的和，对答案取`min`即可\n3. 与2类似\n\n\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int Maxn = 1000000 + 100;\nconst int inf = 0x3f3f3f3f;\n\nint N, Q;\nint e, Begin[Maxn], To[Maxn << 1], Next[Maxn << 1];\nint fa[Maxn], dfn[Maxn], dfs_clock, son[Maxn], top[Maxn], size[Maxn], dep[Maxn];\n\ninline void add_edge (int x, int y) { To[++e] = y; Next[e] = Begin[x]; Begin[x] = e; }\n\ninline void dfs_init (int x)\n{\n\tdep[x] = dep[fa[x]] + 1, size[x] = 1;\n\n\tfor (int i = Begin[x]; i; i = Next[i])\n\t{\n\t\tint y = To[i];\n\t\tif (y == fa[x]) continue;\n\t\tfa[y] = x;\n\t\t\n\t\tdfs_init (y);\n\t\tif (size[y] > size[son[x]]) son[x] = y;\n\t\tsize[x] += size[y];\n\t}\n}\n\ninline void dfs_init (int x, int now)\n{\n\tdfn[x] = ++dfs_clock, top[x] = now;\n\tif (son[x]) dfs_init (son[x], now);\n\n\tfor (int i = Begin[x]; i; i = Next[i])\n\t{\n\t\tint y = To[i];\n\t\tif (y == fa[x] || y == son[x]) continue;\n\n\t\tdfs_init (y, y);\n\t}\n}\n\ninline int get_lca (int x, int y)\n{\n\twhile (top[x] != top[y])\n\t{\n\t\tif (dep[top[x]] < dep[top[y]]) swap(x, y);\n\t\tx = fa[top[x]];\n\t}\n\tif (dep[x] < dep[y]) swap(x, y);\n\treturn y;\n}\n\nint K, A[Maxn];\n\nnamespace VTREE\n{\n\tint e, Begin[Maxn], To[Maxn << 1], Next[Maxn << 1], W[Maxn << 1];\n\tint Stack[Maxn], top;\n\tint Key[Maxn];\n\n\tinline void add_edge (int x, int y, int z) { To[++e] = y; Next[e] = Begin[x]; Begin[x] = e; W[e] = z; }\n\n\tinline int cmp_by_dfn (int x, int y) { return dfn[x] < dfn[y]; }\n\n\tinline void build ()\n\t{\n\t\tfor (int i = 1; i <= K; ++i) Key[A[i]] = 1;\n\t\tsort(A + 1, A + K + 1, cmp_by_dfn);\n\t\tfor (int i = K; i > 1; --i) A[++K] = get_lca (A[i], A[i - 1]); A[++K] = 1;\n\t\tsort(A + 1, A + K + 1, cmp_by_dfn);\n\t\tK = unique (A + 1, A + K + 1) - A - 1;\n\n\t\tfor (int i = 1; i <= K; ++i)\n\t\t{\n\t\t\twhile (top && dfn[Stack[top]] + size[Stack[top]] - 1 < dfn[A[i]]) --top;\n\t\t\tif (top) add_edge (Stack[top], A[i], dep[A[i]] - dep[Stack[top]]);\n\t\t\tStack[++top] = A[i];\n\t\t}\n\t}\n\n\tLL Dp[Maxn], f[Maxn], g[Maxn]; \n\t// Dp[X] : the answer of X's subtree\n\t// f[X] : the sum of the path from the key points in X's subtree to X\n\t// g[X] : the sum of the key points in X's subtree\n\n\tinline void get_dp1 (int x)\n\t{\n\t\tDp[x] = f[x] = g[x] = 0;\n\t\tif (Key[x]) ++g[x];\n\n\t\tfor (int i = Begin[x]; i; i = Next[i])\n\t\t{\n\t\t\tint y = To[i];\n\n\t\t\tget_dp1 (y);\n\n\t\t\tg[x] += g[y];\n\t\t\tDp[x] += Dp[y];\n\t\t}\n\n\t\tfor (int i = Begin[x]; i; i = Next[i])\n\t\t{\n\t\t\tint y = To[i];\n\t\t\tLL now = f[y] + g[y] * W[i];\n\t\t\tf[x] += now;\n\t\t\tDp[x] += (g[x] - g[y]) * now;\n\t\t}\n\t}\n\n\tLL ans1, ans2;\n\n\t// f[x] : the length of the shortest chain in X's subtree\n\t// g[x] : the length of the longest chain in X's subtree\n\n\tinline void get_dp2 (int x)\n\t{\n\t\tf[x] = inf, g[x] = -inf;\n\n\t\tLL Max = -inf, Sec_Max = -inf, Min = inf, Sec_Min = inf;\n\n\t\tif (Key[x]) Min = Max = 0;\n\n\t\tfor (int i = Begin[x]; i; i = Next[i])\n\t\t{\n\t\t\tint y = To[i];\n\n\t\t\tget_dp2 (y);\n\n\t\t\tf[y] += W[i], g[y] += W[i];\n\n\t\t\tif (f[y] <= Min) Sec_Min = Min, Min = f[y];\n\t\t\telse if (f[y] <= Sec_Min) Sec_Min = f[y];\n\n\t\t\tif (g[y] >= Max) Sec_Max = Max, Max = g[y];\n\t\t\telse if (g[y] >= Sec_Max) Sec_Max = g[y];\n\t\t}\n\n\t\tf[x] = Min, g[x] = Max;\n\t\tChkmin (ans1, Min + Sec_Min);\n\t\tChkmax (ans2, Max + Sec_Max);\n\t}\n\n\tinline void solve ()\n\t{\n\t\tget_dp1 (1);\n\t\tprintf(\"%lld \", Dp[1]);\n\t\tans1 = 0x3f3f3f3f3, ans2 = -1;\n\t\tget_dp2 (1);\n\t\tprintf(\"%lld %lld\\n\", ans1, ans2);\n\t}\n\n\tinline void init ()\n\t{\n\t\tfor (int i = 1; i <= K; ++i) Begin[A[i]] = Key[A[i]] = 0;\n\t\te = top = 0;\n\t}\n}\n\ninline void Solve ()\n{\n\tdfs_init (1);\n\tdfs_init (1, 1);\n\n\tQ = read<int>();\n\twhile (Q--)\n\t{\n\t\tK = read<int>();\n\t\tfor (int i = 1; i <= K; ++i) A[i] = read<int>();\n\t\tVTREE :: build ();\n\t\tVTREE :: solve ();\n\t\tVTREE :: init ();\n\t}\n}\n\ninline void Input ()\n{\n\tN = read<int>();\n\tfor (int i = 1; i < N; ++i)\n\t{\n\t\tint x = read<int>(), y = read<int>();\n\t\tadd_edge (x, y);\n\t\tadd_edge (y, x);\n\t}\n}\n\nint main()\n{\n\n#ifndef ONLINE_JUDGE\n\tfreopen(\"A.in\", \"r\", stdin);\n\tfreopen(\"A.out\", \"w\", stdout);\n#endif\n\n\tInput ();\n\tSolve ();\n\n\treturn 0;\n}\n\n```\n\n","categories":["Problem"],"tags":["省选","虚树"]},{"title":"「CF613D」Kingdom and its Cities - 虚树 + 贪心","url":"/2019/02/21/%E3%80%8CCF613D%E3%80%8DKingdom-and-its-Cities-%E8%99%9A%E6%A0%91-%E8%B4%AA%E5%BF%83/","content":"\n给你一棵$n$个结点的树。\n\n有$q$次询问，每次询问给出$k$和一个大小为$k$的点集$S$，求最少删掉多少个不在$S$中的点可以使得$S$中的点两两不联通。\n\n无解输出$-1$\n\n$n, q, (\\sum k)\\le 10^5$\n\n<!--more-->\n\n### Links\n\n[CF613D](https://codeforces.com/problemset/problem/613/D)\n\n\n\n### Solution\n\n又是一道虚树的板子题\n\n首先考虑单次查询怎么做，显然可以直接贪心\n\n设$f[x]$表示$x$的子树内要满足条件至少删掉几个点，$g[x]$表示$x$的子树内还剩下多少个$S$中的点与$x$联通（为被阻断）\n\n分类讨论一下，然后用虚树优化即可\n\n这道题甚至比[消耗战](https://hk-cnyali.com/2019/02/20/%E3%80%8CSDOI2011%E3%80%8D%E6%B6%88%E8%80%97%E6%88%98-%E8%99%9A%E6%A0%91-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/)还要简单\n\n\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int Maxn = 1e5 + 100;\n\nint N, Q;\nint e, Begin[Maxn], To[Maxn << 1], Next[Maxn << 1];\nint fa[Maxn], dep[Maxn], dfn[Maxn], dfs_clock, size[Maxn], son[Maxn], top[Maxn];\nint K, A[Maxn << 1];\n\ninline void add_edge (int x, int y) { To[++e] = y; Next[e] = Begin[x]; Begin[x] = e; }\n\ninline void dfs0 (int x)\n{\n\tdep[x] = dep[fa[x]] + 1, size[x] = 1;\n\n\tfor (int i = Begin[x]; i; i = Next[i])\n\t{\n\t\tint y = To[i];\n\t\tif (y == fa[x]) continue;\n\t\tfa[y] = x;\n\n\t\tdfs0(y);\n\n\t\tif (size[y] > size[son[x]]) son[x] = y;\n\t\tsize[x] += size[y];\n\t}\n}\n\ninline void dfs1 (int x, int now)\n{\n\tdfn[x] = ++dfs_clock, top[x] = now;\n\n\tif (son[x]) dfs1 (son[x], now);\n\n\tfor (int i = Begin[x]; i; i = Next[i])\n\t{\n\t\tint y = To[i];\n\t\tif (y == fa[x] || y == son[x]) continue;\n\n\t\tdfs1(y, y);\n\t}\n}\n\ninline int get_lca (int x, int y)\n{\n\twhile (top[x] != top[y])\n\t{\n\t\tif (dep[top[x]] < dep[top[y]]) swap(x, y);\n\t\tx = fa[top[x]];\n\t}\n\tif (dep[x] < dep[y]) swap(x, y);\n\treturn y;\n}\n\nint f[Maxn], g[Maxn], Vis[Maxn];\n\nnamespace VTREE\n{\n\tint Begin[Maxn], To[Maxn << 2], Next[Maxn << 2];\n\tint top, Stack[Maxn << 1];\n\n\tinline void add_edge (int x, int y) { To[++e] = y; Next[e] = Begin[x]; Begin[x] = e; }\n\n\tinline void get_dp (int x)\n\t{\n\t\tf[x] = g[x] = 0;\n\t\tint cnt = 0, sum = 0;\n\n\t\tfor (int i = Begin[x]; i; i = Next[i])\n\t\t{\n\t\t\tint y = To[i];\n\t\t\tif (y == fa[x]) continue;\n\n\t\t\tget_dp (y);\n\n\t\t\tf[x] += f[y];\n\t\t\tif (g[y]) ++cnt, sum = g[y];\n\t\t}\n\n\t\tif (Vis[x])\n\t\t{\n\t\t\tf[x] += cnt;\n\t\t\tg[x] = 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (cnt <= 1) g[x] = sum;\n\t\t\telse ++f[x], g[x] = 0;\n\t\t}\n\t}\n\n\tinline int cmp_by_dfn (int x, int y) { return dfn[x] < dfn[y]; }\n\n\tinline void build ()\n\t{\n\t\tsort(A + 1, A + K + 1, cmp_by_dfn);\n/**/\tfor (int i = K; i > 1; --i) A[++K] = get_lca (A[i], A[i - 1]); A[++K] = 1;\n\t\tsort(A + 1, A + K + 1, cmp_by_dfn);\n\t\tK = unique (A + 1, A + K + 1) - A - 1;\n\n\t\tfor (int i = 1; i <= K; ++i)\n\t\t{\n\t\t\twhile (top && dfn[Stack[top]] + size[Stack[top]] - 1< dfn[A[i]]) --top;\n\t\t\tif (top) add_edge (Stack[top], A[i]); \n\t\t\tStack[++top] = A[i];\n\t\t}\n\n\t}\n\n\tinline int work ()\n\t{\n\t\tget_dp (1);\n\t\treturn f[1];\n\t}\n\n}\n\ninline void Init () { for (int i = 1; i <= K; ++i) Vis[A[i]] = VTREE :: Begin[A[i]] = 0; e = VTREE :: top = 0; }\n\ninline void Solve ()\n{\n\tdfs0(1), dfs1(1, 1);\n\n\tQ = read<int>();\n\twhile (Q--)\n\t{\n\t\tK = read<int>(); for (int i = 1; i <= K; ++i) A[i] = read<int>(), Vis[A[i]] = 1;\n\n\t\tint fl = 0;\n\t\tfor (int i = 1; i <= K; ++i) if (Vis[fa[A[i]]]) {fl = 1; break; }\n\n\t\tif (fl) puts(\"-1\");\n\t\telse\n\t\t{\n\t\t\tVTREE :: build ();\n\t\t\tprintf(\"%d\\n\", VTREE :: work());\n\t\t}\n\n\t\tInit();\n\t}\n}\n\ninline void Input ()\n{\n\tN = read<int>();\n\tfor (int i = 1; i < N; ++i)\n\t{\n\t\tint x = read<int>(), y = read<int>();\n\t\tadd_edge (x, y);\n\t\tadd_edge (y, x);\n\t}\n}\n\nint main()\n{\n\n#ifndef ONLINE_JUDGE\n\tfreopen(\"D.in\", \"r\", stdin);\n\tfreopen(\"D.out\", \"w\", stdout);\n#endif\n\n\tInput ();\n\tSolve ();\n\n\treturn 0;\n}\n\n```\n\n","categories":["Problem"],"tags":["Codeforces","贪心","虚树"]},{"title":"「SDOI2011」消耗战 - 虚树 + 动态规划","url":"/2019/02/20/%E3%80%8CSDOI2011%E3%80%8D%E6%B6%88%E8%80%97%E6%88%98-%E8%99%9A%E6%A0%91-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","content":"\n给你一棵$n$个结点带边权的树。有$m$ 次询问，每次询问给出$k$，并给出一个包含 k 个点的点集 $S$\n\n求将点集$S$与 $1$ 号点切断最小的代价\n\n$n \\le 2.5 \\times 10^5, m \\ge 1, \\sum k \\le 5 \\times 10^5$\n\n<!--more-->\n\n### Links\n\n[Luogu P2495](https://www.luogu.org/problemnew/show/P2495)\n\n\n\n### Solution\n\n考虑一组询问，很容易想到一个这样的dp：\n\n设$dp[x]$表示$x$的子树都合法的最小代价，$Min[x]$表示$x$到根的路径上边权最小值，则\n$$\ndp[x] = \n\\begin{cases}\nMin[x] &x \\in S\\\\\\\\\nmin\\{\\Big(\\sum_{y\\in son[x]} dp[y]\\Big) , Min[x]\\} &\\text{otherwise}\n\\end{cases}\n$$\n预处理出$Min$数组之后直接在虚树上dp即可\n\n第一次写虚树，用的倍增求lca，慢死了，下次记得用树剖求\n\n\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int Maxn = 250000 + 100, Maxk = 500000;\n\nint N, Q, K;\nint e, Begin[Maxn], To[Maxn << 1], Next[Maxn << 1], W[Maxn << 1];\nint dfn[Maxn], size[Maxn], dfs_clock, dep[Maxn], anc[20][Maxn];\nLL Min[Maxn];\n\ninline void add_edge (int x, int y, int z) { To[++e] = y; Next[e] = Begin[x]; Begin[x] = e; W[e] = z; }\n\nint A[Maxk];\n\ninline int get_lca (int x, int y)\n{\n\tif (dep[x] < dep[y]) swap(x, y);\n\tfor (int i = 18; i >= 0; --i) if (dep[anc[i][x]] >= dep[y]) x = anc[i][x];\n\tif (x == y) return x;\n\tfor (int i = 18; i >= 0; --i) if (anc[i][x] != anc[i][y]) x = anc[i][x], y = anc[i][y];\n\treturn anc[0][x];\n}\n\nnamespace VTREE\n{\n\tint e, Begin[Maxn], To[Maxn << 1], Next[Maxn << 1];\n\tint Save[Maxk], save_cnt;\n\tint Stack[Maxk], top;\n\tint Vis[Maxk];\n\n\tinline void add_edge (int x, int y) { To[++e] = y; Next[e] = Begin[x]; Begin[x] = e; }\n\n\tinline void init ()\n\t{\n\t\tfor (int i = 1; i <= save_cnt; ++i) Begin[Save[i]] = 0, Vis[Save[i]] = 0;\n\t\te = save_cnt = top = 0;\n\t}\n\n\tinline int cmp_by_dfn (int x, int y) { return dfn[x] < dfn[y]; }\n\n\tinline void build ()\n\t{\n\t\tsort(A + 1, A + K + 1, cmp_by_dfn);\n\t\tfor (int i = 1; i <= K; ++i) Vis[A[i]] = 1;\n\t\tfor (int i = K; i > 1; --i) A[++K] = get_lca (A[i], A[i - 1]); A[++K] = 1;\n\t\tsort(A + 1, A + K + 1, cmp_by_dfn);\n\t\tK = unique (A + 1, A + K + 1) - A - 1;\n\t\tfor (int i = 1; i <= K; ++i) Save[++save_cnt] = A[i];\n\n\t\tfor (int i = 1; i <= K; ++i)\n\t\t{\n\t\t\twhile (top && dfn[Stack[top]] + size[Stack[top]] - 1 < dfn[A[i]]) --top;\n\t\t\tif (top) add_edge (Stack[top], A[i]);\n\t\t\tStack[++top] = A[i];\n\t\t}\n\t}\n\n\tinline LL get_dp (int x)\n\t{\n\t\tif (Vis[x]) return Min[x];\n\n\t\tLL sum = 0;\n\t\tfor (int i = Begin[x]; i; i = Next[i]) sum += get_dp (To[i]);\n\n\t\treturn min(Min[x], sum);\n\t}\n\n\tinline void work ()\n\t{\n\t\tprintf(\"%lld\\n\", get_dp (1));\n\t}\n}\n\ninline void dfs_pre (int x)\n{\n\tdfn[x] = ++dfs_clock, dep[x] = dep[anc[0][x]] + 1, size[x] = 1;\n\tfor (int i = 1; i <= 18; ++i) anc[i][x] = anc[i - 1][anc[i - 1][x]];\n\n\tfor (int i = Begin[x]; i; i = Next[i])\n\t{\n\t\tint y = To[i];\n\t\tif (y == anc[0][x]) continue;\n\t\tanc[0][y] = x, Min[y] = min(Min[x], (LL)W[i]);\n\n\t\tdfs_pre (y);\n\n\t\tsize[x] += size[y];\n\t}\n}\n\ninline void Solve ()\n{\n/**/Min[1] = 2e18;\n\tdfs_pre (1);\n\t\n\tQ = read<int>();\n\twhile (Q--)\n\t{\n\t\tK = read<int>();\n\t\tfor (int i = 1; i <= K; ++i) A[i] = read<int>();\n\t\tVTREE :: init ();\n\t\tVTREE :: build ();\n\t\tVTREE :: work ();\n\t}\n}\n\ninline void Input ()\n{\n\tN = read<int>();\n\n\tfor (int i = 1; i < N; ++i)\n\t{\n\t\tint x = read<int>(), y = read<int>(), z = read<int>();\n\t\tadd_edge (x, y, z);\n\t\tadd_edge (y, x, z);\n\t}\n}\n\nint main()\n{\n\n#ifndef ONLINE_JUDGE\n\tfreopen(\"A.in\", \"r\", stdin);\n\tfreopen(\"A.out\", \"w\", stdout);\n#endif\n\n\tInput ();\n\tSolve ();\n\n\treturn 0;\n}\n\n```\n\n","categories":["Problem"],"tags":["动态规划","省选","虚树"]},{"title":"虚树学习笔记","url":"/2019/02/19/%E8%99%9A%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"\n又是一个全机房只有我不会的知识点\n\n同样，这篇文章也不适用于对这个知识点一无所知，且需要大量严谨证明的同学阅读\n\n<!--more-->\n\n### 定义\n\n虚树是一个用来优化树形dp的数据结构\n\n考虑将原树中的某一个点集 $S$ 提取出来，构成一棵新的并能保持原树结构的一棵树。\n\n为了保持结构，我们除了集合$S$的点之外，还需要在虚树中添加$S$中任意两点的$lca​$。\n\n因为有这么一条性质：\n\n> 一个点集$S$中两两$lca$的集合，就是把$S$按`dfn序`排序后，相邻两点的$lca$的集合\n>\n> 这个性质很好理解\n\n于是我们发现，总点数是$O(S)$级别的\n\n\n\n### 构建\n\n考虑求集合$S$的虚树\n\n设关键点集合$T$表示$S$集合中两两点的$lca$，以及 $S$ 本身。用上面的那条性质就能轻松求出集合$T$\n\n我们把集合$T$按照`dfn序`排序\n\n接下来，我们使用一个栈维护一条从根下来的关键点链，然后不断对于这个栈进行操作，每次将新加进来的点与栈顶元素连一条边。\n\n考虑从一条关键点链跳到另外一条关键点链上的过程，我们只需要不断弹栈，直到栈顶元素是当前新加进来点的祖先为止\n\n感性理解就是有一条链从左往右不断移动，每个点只需要连上它在这条链的父亲\n\n\n\n### 核心代码\n\n```cpp\n\t\tsort(A + 1, A + K + 1, cmp_by_dfn);\n\t\tfor (int i = K; i > 1; --i) A[++K] = get_lca (A[i], A[i - 1]); A[++K] = 1;\n\t\tsort(A + 1, A + K + 1, cmp_by_dfn);\n\t\tK = unique (A + 1, A + K + 1) - A - 1;\n\n\t\tfor (int i = 1; i <= K; ++i)\n\t\t{\n\t\t\twhile (top && dfn[Stack[top]] + size[Stack[top]] - 1 < dfn[A[i]]) --top;\n\t\t\tif (top) add_edge (Stack[top], A[i]);\n\t\t\tStack[++top] = A[i];\n\t\t}\n```\n\n\n\n### 应用\n\n虚树往往用来处理一些答案与关键点有关，且关键点总数$\\sum k$不是很大的树形dp题\n\n每次构建虚树，在虚树上进行dp即可，复杂度是$O((\\sum k)* \\log n)$的\n\n具体来说，虚树上的一条边就相当于原树中的某一条链，但是这一条链上的dp转移与关键点无关\n\n于是我们就可以预处理出原树中链上与关键点无关的转移（或者转移系数之类的），每次dp的时候只需要考虑当前虚树上的转移，虚树边上的转移直接利用预处理的信息即可\n\n> 到了这里，我们就可以理解虚树的本质了\n>\n> 在与关键点有关的树形dp中，有一些边上的转移实际上是与关键点无关的，而如果我们对于每一次询问都$O(n)$进行dp的话，显然会有很多重复转移。于是我们可以预处理出这些重复的转移\n>\n> 这样便产生了虚树，它的本质就是把与当前关键点有关的转移单独提出来，单独进行转移，而虚树边上的转移都是与当前关键点无关，可以预处理出来的\n\n因此虚树的思想还是对在暴力计算中冗余、重复处理的东西进行优化，从而优化时间复杂度\n\n","categories":["Algorithm"],"tags":["数据结构","虚树"]},{"title":"「UR #6」智商锁 - 随机 + Matrix-Tree","url":"/2019/02/17/%E3%80%8CUR-6%E3%80%8D%E6%99%BA%E5%95%86%E9%94%81-%E9%9A%8F%E6%9C%BA-Matrix-Tree/","content":"\n给出$k$，请你构造一个结点数不超过 $100$ 的无向图，使得这个无向图中生成树的个数对$998244353$取模后恰好等于$k$\n\n$k\\in [0, 998244353)$\n\n<!--more-->\n\n### Links\n\n[UOJ75](http://uoj.ac/problem/75)\n\n\n\n### Solution\n\n很妙的一道题啊\n\n首先需要知道这么一个结论：\n\n> 把生成树个数为$a_1,a_2...a_n$的$n$个图通过相邻两个图任意两个点连一条边的方法串联起来后，得到新图的生成树个数为$\\prod_{i=1}^{n}a_i$\n\n这个正确性很显然\n\n接着开始乱搞\n\n那么我们考虑总共随机出$1000$张$12$个点的图，并用`Matrix-Tree`定理分别求出它们的生成树个数。每张图每条边生成的概率为$0.8$\n\n然后我们试图找出四张图，使得这四张图的生成树个数的乘积为$K$\n\n具体实现的话，显然可以`meet in middle`，求出任意两张图的生成树个数的乘积和逆元，`hash`判断一下是否存在\n\n这个算法的正确概率大于$99\\%$，[具体证明见此](http://vfleaking.blog.uoj.ac/blog/180)\n\n> 感性理解一下（以下把模数视作$10^9$）\n>\n> 因为每条边选择的概率比较大，且$12$个点的完全图生成树个数为$12^{10}$远大于模数$10^9$，所以生成树个数也会比较大，因此可以近似地看成是模数范围内均匀分布的随机数，这一点与`hash`类似\n>\n> 所以我们就有了$1000^4=10^{12}$个在$10^9$范围内均匀分布的随机数，用这$10^{12}$个数去覆盖$0$到$10^9$中间的所有数概率还是非常大的\n\n\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int Mod = 998244353;\nconst int Maxn = 1e3 + 100;\nconst int Maxk = 100 + 5;\n\nint N = 1000, K;\n\ninline int Rand (int l, int r) { return rand() % (r - l + 1) + l; }\ninline int Rand (int r) { return rand() % r + 1; }\n\ninline int Pow (int a, int b)\n{\n\tint ans = 1;\n\tfor (int i = b; i; i >>= 1, a = (LL)a * a % Mod) if (i & 1) ans = (LL)ans * a % Mod;\n\treturn ans;\n}\n\ninline void Add (int &a, int b) { a += b; if (a >= Mod) a -= Mod; }\n\nnamespace Matrix\n{\n\n\tconst int Maxn = 12 + 5;\n\n\tint A[Maxn][Maxn];\n\n\tinline void init () { memset(A, 0, sizeof A); }\n\n\tinline void add_edge (int x, int y) { --A[x][y], --A[y][x], ++A[x][x], ++A[y][y]; }\n\n\tinline int gauss (int n)\n\t{\n\t\tint ans = 1;\n\t\tfor (int i =1; i <= n; ++i)\n\t\t{\n\t\t\tif (!A[i][i])\n\t\t\t{\n\t\t\t\tfor (int j = i + 1; j <= n; ++j)\n\t\t\t\t\tif (A[j][i])\n\t\t\t\t\t{\n\t\t\t\t\t\tswap(A[i], A[j]);\n\t\t\t\t\t\tans = (LL)ans * (Mod - 1) % Mod;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\tif (!ans) return 0;\n\t\t\t}\n\n\t\t\tint inv = Pow(A[i][i], Mod - 2);\n\t\t\tfor (int j = i + 1; j <= n; ++j)\n\t\t\t{\n\t\t\t\tint now = (LL)A[j][i] * inv % Mod;\n\t\t\t\tfor (int k = i; k <= n; ++k) Add (A[j][k], Mod - (LL)A[i][k] * now % Mod);\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 1; i <= n; ++i) ans = (LL)ans * A[i][i] % Mod;\n\n\t\treturn ans;\n\t}\n}\n\nstruct info\n{\n\tint G[Maxk][Maxk], sum1, sum2, n;\n\n\tinline void init () { memset(G, 0, sizeof G); n = 0; }\n\n\tinline void build ()\n\t{\n\t\tn = 12;\n\t\tMatrix :: init();\n\t\tfor (int i = 1; i < 12; ++i)\n\t\t\tfor (int j = i + 1; j <= 12; ++j)\n\t\t\t{\n\t\t\t\tif (Rand(1, 10) <= 8) G[i][j] = 1, Matrix :: add_edge (i, j);\n\t\t\t\tG[j][i] = G[i][j];\n\t\t\t}\n\t\tsum1 = Matrix :: gauss (n - 1);\n\t\tsum2 = Pow(sum1, Mod - 2);\n\t}\n\n\tinline void print ()\n\t{\n\t\tint m = 0;\n\t\tfor (int i = 1; i < n; ++i)\n\t\t\tfor (int j = i + 1; j <= n; ++j)\n\t\t\t\tif (G[i][j]) ++m;\n\n\t\tprintf(\"%d %d\\n\", n, m);\n\t\tfor (int i = 1; i < n; ++i)\n\t\t\tfor (int j = i + 1; j <= n; ++j)\n\t\t\t\tif (G[i][j]) printf(\"%d %d\\n\", i, j);\n\t}\n\n} A[Maxn];\n\n#include <ext/pb_ds/hash_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nconst int Maxs = Maxn * Maxn;\n\npair <int, pii> Map1[Maxs];\n__gnu_pbds :: gp_hash_table <int, pii > Map2;\n\nint state_cnt;\n\ninline void merge (info &x, info y)\n{\n\tfor (int i = 1; i <= y.n; ++i)\n\t\tfor (int j = 1; j <= y.n; ++j)\n\t\t\tx.G[x.n + i][x.n + j] = y.G[i][j];\n\t\n\tx.G[x.n][x.n + 1] = x.G[x.n + 1][x.n] = 1;\n\tx.n += y.n;\n}\n\ninline void Print (int a, int b, int c, int d)\n{\n\tinfo ans; ans.init();\n\n\tmerge (ans, A[a]); merge (ans, A[b]);\n\tmerge (ans, A[c]); merge (ans, A[d]);\n\n\tans.print();\n}\n\ninline void Solve ()\n{\n\tif (!K) { puts(\"2 0\"); return ; }\n\n\tfor (int i = 1; i <= state_cnt; ++i)\n\t{\n\t\tint x = Map1[i].y.x, y = Map1[i].y.y, val1 = Map1[i].x;\n\t\tint val2 = (LL)K * val1 % Mod;\n\t\tif (Map2[val2].x)\n\t\t{\n\t//\t\tprintf(\"%d %d %d %d\\n\", A[x].sum1, A[y].sum1, A[Map2[val2].x].sum1, A[Map2[val2].y].sum1);\n\t//\t\tprintf(\"%lld\\n\", (LL)A[x].sum1 * A[y].sum1 % Mod * A[Map2[val2].x].sum1 % Mod * A[Map2[val2].y].sum1 % Mod);\n\t\t\tPrint(x, y, Map2[val2].x, Map2[val2].y);\n\t\t\treturn ;\n\t\t}\n\t}\n}\n\ninline void Input ()\n{\n\tK = read<int>();\n}\n\n\ninline void Init ()\n{\n\tsrand(time(0));\n\n\tfor (int i = 1; i <= N; ++i) A[i].build ();\n\n\tfor (int i = 1; i <= N; ++i)\n\t\tfor (int j = i; j <= N; ++j)\n\t\t{\n\t\t\tMap1[++state_cnt] = mp((LL)A[i].sum2 * A[j].sum2 % Mod, mp(i, j));\n\t\t\tMap2[(LL)A[i].sum1 * A[j].sum1 % Mod] = mp(i, j);\n\t\t}\n}\n\nint main()\n{\n\n#ifndef ONLINE_JUDGE\n\tfreopen(\"moonfly.in\", \"r\", stdin);\n\tfreopen(\"moonfly.out\", \"w\", stdout);\n#endif\n\n\tInit();\n\tint Testcase = read<int>();\n\n\twhile (Testcase--)\n\t{\n\t\tInput();\n\t\tSolve();\n\t}\n\n\treturn 0;\n}\n\n```\n\n","categories":["Problem"],"tags":["随机","Matrix-Tree"]},{"title":"「UR #9」App管理器 - 贪心 + dfs","url":"/2019/02/17/%E3%80%8CUR-9%E3%80%8DApp%E7%AE%A1%E7%90%86%E5%99%A8-%E8%B4%AA%E5%BF%83-dfs/","content":"\n给你一个$n$个点$m$条边的混合图（既有有向边也有无向边）\n\n你需要给所有无向边定向，使得新图中任意点两两可达\n\n输出任意一种方案，数据保证有解\n\n$n, m\\le 5000$\n\n<!--more-->\n\n### Links\n\n[UOJ134](http://uoj.ac/problem/134)\n\n\n\n### Solution\n\n考虑贪心地给边$(x, y)$定向，若$x$不需要经过$(x,y )$这条边就能到$y$，那么就把这条边设为$y\\rightarrow x$；否则设为$x\\rightarrow y$\n\n因为题目保证有解，所以这样贪心显然是对的。具体证明[见此](http://vfleaking.blog.uoj.ac/blog/694)\n\n\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int Maxn = 5000 + 100;\n\nint N, M, G[Maxn][Maxn], Ans[Maxn];\nint e = 1, Begin[Maxn], To[Maxn << 1], Next[Maxn << 1], Vis[Maxn], mark_now;\npii E[Maxn];\n\ninline void add_edge (int x, int y) { To[++e] = y; Next[e] = Begin[x]; Begin[x] = e; ++G[x][y]; }\n\ninline int dfs (int x, int to)\n{\n\tVis[x] = mark_now;\n\tif (x == to) return 1;\n\tfor (int i = Begin[x]; i; i = Next[i])\n\t{\n\t\tint y = To[i];\n\t\tif (Vis[y] == mark_now || !G[x][y]) continue;\n\t\tif (dfs(y, to)) return 1;\n\t}\n\treturn 0;\n}\n\ninline void Solve ()\n{\n\tfor (int i = 1; i <= M; ++i)\n\t{\n\t\tif (Ans[i])\n\t\t{\n\t\t\tint x = E[i].x, y = E[i].y;\n\t\t\t--G[x][y];\n\t\t\t++mark_now;\n\t\t\tif (!dfs(x, y)) ++G[x][y], --G[y][x], Ans[i] = 0;\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= M; ++i) printf(\"%d\\n\", Ans[i]);\n}\n\ninline void Input ()\n{\n\tN = read<int>(), M = read<int>();\n\tfor (int i = 1; i <= M; ++i)\n\t{\n\t\tint x = read<int>(), y = read<int>();\n\t\tAns[i] = !read<int>();\n\t\tE[i] = mp(x, y);\n\t\tadd_edge (x, y);\n\t\tif (Ans[i]) add_edge (y, x);\n\t}\n}\n\nint main()\n{\n\n#ifndef ONLINE_JUDGE\n\tfreopen(\"ffish.in\", \"r\", stdin);\n\tfreopen(\"ffish.out\", \"w\", stdout);\n#endif\n\n\tInput();\n\tSolve();\n\n\treturn 0;\n}\n\n```\n\n","categories":["Problem"],"tags":["贪心"]},{"title":"Matrix-Tree定理","url":"/2019/02/16/Matrix-Tree%E5%AE%9A%E7%90%86/","content":"\n请注意，此文章内不含任何证明，因为我懒的写~~也不会~~，就先记着个结论好了\n\n比较详细但易懂的证明可见[这里](https://www.cnblogs.com/candy99/p/6420935.html)\n\n<!--more-->\n\n### Matrix-Tree\n\n#### Brief Introduction\n\n用来求解无向图生成树个数的结论\n\n设$G$表示邻接矩阵，$D$表示度数矩阵。定义基尔霍夫矩阵$C=D-G$\n\n将基尔霍夫任意去掉对角线上的任意一个位置所在行和所在列，形成一个行列式，高斯消元求出行列式的值即为答案。\n\n\n\n#### 有向图\n\n有向图的生成树也可以用$Matrix-Tree$定理计算。\n\n外向树就是入度矩阵-邻接矩阵；内向树就是出度矩阵-邻接矩阵。\n\n\n\n### 求解行列式\n\n>  注：这里也只有结论\n\n#### 行列式的值\n\n$$\ndet(A)=\\sum\\limits_{(p_1p_2...p_n)}\\delta(p_1p_2...p_n)a_{1,p_1}a_{2,p_2}...a_{n,p_n}=|A|\n$$\n\n其中$\\delta(i_1i_2...i_n)=(-1)^{t}$，$t$是逆序对的个数，可以将排列分为奇排列和偶排列\n\n> 本来还写了一些~~鬼畜~~的理解方法，看了一点线代之后发现这个还是挺好理解的\n>\n> 上面那个式子已经写的很清楚了\n>\n> 实在要解释一下的话，那个$\\sum$就是在枚举所有排列，然后对每个排列都求出其中元素的乘积，乘上$-1$的`逆序对数`次方，最后把所有排列的答案求和\n\n\n\n#### 几个重要性质\n\n* 交换矩阵的任意两行或任意两列，行列式的值取相反数。\n* 矩阵的一行减去另一行的 $k$ 倍，行列式不变。\n\n有了这两个性质就能用高斯消元求解了，把矩阵消乘对角矩阵，对角线值的乘积即为答案\n\n\n\n### Code（模意义下）\n\n```cpp\nnamespace Matrix\n{\n\tconst int maxn = 300 + 10;\n\n\tint A[maxn][maxn];\n\n\tinline void init () { memset(A, 0, sizeof A); }\n\n\tinline void add_edge (int x, int y) { ++A[x][x], ++A[y][y], --A[x][y], --A[y][x]; }\n\n\tinline int gauss (int n)\n\t{\n\t\tint ans = 1;\n\t\tfor (int i = 1; i <= n; ++i) for (int j = 1; j <= n; ++j) A[i][j] = (A[i][j] + Mod) % Mod;\n\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t{\n\t\t\tif (!A[i][i])\n\t\t\t{\n\t\t\t\tint id = i;\n\t\t\t\tfor (int j = i + 1; j <= n; ++j)\n\t\t\t\t\tif (A[j][i])\n\t\t\t\t\t{\n\t\t\t\t\t\tswap(A[i], A[j]);\n\t\t\t\t\t\tans = (LL)ans * (Mod - 1) % Mod;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\tif (!ans) return 0;\n\t\t\t}\n\n\t\t\tint inv = Pow(A[i][i], Mod - 2);\n\t\t\tfor (int j = i + 1; j <= n; ++j)\n\t\t\t{\n\t\t\t\tint now = (LL)A[j][i] * inv % Mod;\n\t\t\t\tfor (int k = i + 1; k <= n; ++k) Add (A[j][k], Mod - (LL)now * A[i][k] % Mod);\n\t\t\t\tA[j][i] = 0;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 1; i <= n; ++i) ans = (LL)ans * A[i][i] % Mod;\n\n\t\treturn ans;\n\t}\n}\n\n```\n\n","categories":["Algorithm"],"tags":["矩阵","Matrix-Tree"]},{"title":"「清澄A1482」登顶计划 - 单调栈 + 计算几何","url":"/2019/02/16/%E3%80%8C%E6%B8%85%E6%BE%84A1482%E3%80%8D%E7%99%BB%E9%A1%B6%E8%AE%A1%E5%88%92-%E5%8D%95%E8%B0%83%E6%A0%88-%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/","content":"\n你在一座由$n$个点构成的山脉中爬山，第$i$个点坐标为$(x_i, y_i)$\n\n你的爬山策略是：\n\n* **一直**往当前可见的最高点的方向走，也就是说你的策略是不断动态变化的\n\n求从每个顶点出发，到达所能到达的最高点的路程分别是多少\n\n\n\n加强版：$n\\le 5*10^5​$\n\n<!--more-->\n\n### Links\n\n[清澄A1482](http://www.tsinsen.com/A1482)\n\n### Solution\n\n> 这是一道2013年的论文题，论文里讲得非常详细\n\n首先考虑如何计算一个点向一侧能看到的最高峰\n\n以左侧为例，设点$i$向左能看到的最高点为$L[i]$，则$i$左侧的所有点都在$i$与$L[i]$的连线之下\n\n不难发现，$i$与$L[i]$即为$i$与$i​$向左的上凸壳的最后两个点。所以，可能看得更高的点一定是上凸壳上某一条线与它右侧的山峰的第一个交点或本身的顶点。\n\n我们从前往后维护凸壳，每一次单调栈弹栈，就代表凸壳上的某一条线向右第一个相交。这样可以直接做单调栈来求出这些关键点。只有这些关键点才会对答案产生贡献。求出关键点后,也同样可以用单调栈求出每个关键点的$L[i]$和$R[i]​$\n\n设$H[i] = \\max\\{\\max\\{y_{L[i]}, y_{R[i]}\\}, y_i\\}$。我们发现对于某个点$i$，它确定向某个方向走后，至少会走到第一个$H[i] \\le H[x]$的位置,而剩下的路线和直接从x号点出发相同。\n\n于是可以从$x$到$i$连一条边,则整个图构成了一棵森林，我们将边权设为$x$到$i​$的距离，最后可以直接dfs一遍求出答案。\n\n求向左向右第一个$H[x]$大于等于$H[i]$的$x$同样也可以用单调栈解决。\n\n总时间复杂度$O(n)​$\n\n\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef long double ld;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int Maxn = 2e6 + 100;\nconst ld eps = 1e-7;\nconst ld inf = 1e18;\n\nstruct point\n{\n\tld x, y;\n\n\tinline point operator + (const point &rhs) const { return (point){x + rhs.x, y + rhs.y}; }\n\tinline point operator - (const point &rhs) const { return (point){x - rhs.x, y - rhs.y}; }\n};\n\nnamespace GEOM\n{\n\tinline ld sqr (ld x) { return x * x; }\n\n\tinline int check (ld x) { if (x > eps) return 1; if (x < -eps) return -1; return 0; }\n\t\n\tinline ld cross (point a, point x, point y) { x = x - a, y = y - a; return x.x * y.y - x.y * y.x; }\n\n\tinline int check (point a, point x, point y) { return check(cross(a, x, y)); }\n\n\tinline point get_intersection (point a, point b, point c, point d)\n\t{\n\t\tld k1 = (a.y - b.y) / (a.x - b.x), b1 = a.y - k1 * a.x;\n\t\tld k2 = (c.y - d.y) / (c.x - d.x), b2 = c.y - k2 * c.x;\n\t\tld x = (b2 - b1) / (k1 - k2);\n\t\treturn (point){x, x * k1 + b1};\n\t}\n\n\tinline ld get_dis (point a, point b) { return sqrt(sqr(a.x - b.x) + sqr(a.y - b.y));}\n}\n\nint NN, N, Stack[Maxn], top, Vis[Maxn];\npoint A[Maxn], B[2][Maxn], C[Maxn];\n\ninline void Get_All_Point ()\n{\n\tint cnt[2] = {0, 0};\n\n\tfor (int k = 0; k < 2; ++k)\n\t{\n\t\tint d = k ? -1 : 1;\n\t\tStack[top = 1] = 1;\n\t\tfor (int i = 2; i <= N; ++i)\n\t\t{\n\t\t\twhile (top > 1)\n\t\t\t{\n\t\t\t\tpoint now = A[Stack[top]], pre = A[Stack[top - 1]];\n\t\t\t\tint op = GEOM :: check (A[i], now, pre) * d;\n\t\t\t\tif (op > 0) break;\n\t\t\t\tif (op < 0 && Stack[top] != i - 1) B[k][++cnt[k]] = GEOM :: get_intersection (now, pre, A[i], A[i - 1]);\n\t\t\t\t--top;\n\t\t\t}\n\t\t\tif (top && A[Stack[top]].y < A[i].y) --top;\n\t\t\tStack[++top] = i;\n\t\t}\n\t\treverse (A + 1, A + N + 1);\n\t}\n\n\treverse (B[1] + 1, B[1] + cnt[1] + 1);\n\n\tint pos1 = 1, pos2 = 1, pos3 = 1, len = 0;\n\twhile (1)\n\t{\n\t\tif (pos1 > N && pos2 > cnt[0] && pos3 > cnt[1]) break;\n\t\tld a = A[pos1].x, b = B[0][pos2].x, c = B[1][pos3].x;\n\t\tif (pos1 > N) a = inf;\n\t\tif (pos2 > cnt[0]) b = inf;\n\t\tif (pos3 > cnt[1]) c = inf;\n\n\t\tif (GEOM :: check(a - b) <= 0 && GEOM :: check(a - c) <= 0) C[++len] = A[pos1], Vis[len] = 1, ++pos1;\n\t\telse if (GEOM :: check(b - a) <= 0 && GEOM :: check(b - c) <= 0) C[++len] = B[0][pos2], ++pos2;\n\t\telse C[++len] = B[1][pos3], ++pos3;\n\t}\n\n\tfor (int i = 1; i <= len; ++i) A[i] = C[i];\n\tN = len;\n}\n\nint L[Maxn], R[Maxn];\nld H[Maxn], Sum[Maxn];\n\ninline void Get_LR ()\n{\n\tStack[top = 1] = 1;\n\tfor (int i = 2; i <= N; ++i)\n\t{\n\t\twhile (top && GEOM :: check (A[Stack[top]].y - A[i].y) < 0) --top;\n\t\twhile (top > 1 && GEOM :: check (A[i], A[Stack[top]], A[Stack[top - 1]]) <= 0) --top;\n\t\tif (top) L[i] = Stack[top];\n\t\tStack[++top] = i;\n\t}\n\n\tStack[top = 1] = N;\n\tfor (int i = N - 1; i >= 1; --i)\n\t{\n\t\twhile (top && GEOM :: check (A[Stack[top]].y - A[i].y) < 0) --top;\n\t\twhile (top > 1 && GEOM :: check (A[i], A[Stack[top]], A[Stack[top - 1]]) >= 0) --top;\n\t\tif (top) R[i] = Stack[top];\n\t\tStack[++top] = i;\n\t}\n\n\tfor (int i = 1; i <= N; ++i) H[i] = max(max(A[L[i]].y, A[R[i]].y), A[i].y);\n\tfor (int i = 2; i <= N; ++i) Sum[i] = Sum[i - 1] + GEOM :: get_dis (A[i], A[i - 1]);\n}\n\nint Begin[Maxn], To[Maxn << 1], Next[Maxn << 1], e;\nld W[Maxn << 1];\n\ninline void add_edge (int x, int y, ld z) { To[++e] = y; Next[e] = Begin[x]; Begin[x] = e; W[e] = z; }\n\ninline void Build_Graph ()\n{\n\tStack[top = 1] = 1;\n\tfor (int i = 2; i <= N; ++i)\n\t{\n\t\twhile (top && GEOM :: check (H[Stack[top]] - H[i]) < 0) --top;\n\t\tif ((L[i] || R[i]) && GEOM :: check (A[L[i]].y - A[R[i]].y) > 0) add_edge (Stack[top], i, Sum[i] - Sum[Stack[top]]);\n\t\tStack[++top] = i;\n\t}\n\n\tStack[top = 1] = N;\n\tfor (int i = N - 1; i >= 1; --i)\n\t{\n\t\twhile (top && GEOM :: check (H[Stack[top]] - H[i]) < 0) --top;\n\t\tif ((L[i] || R[i]) && GEOM :: check (A[L[i]].y - A[R[i]].y) < 0) add_edge (Stack[top], i, Sum[Stack[top]] - Sum[i]);\n\t\tStack[++top] = i;\n\t}\n}\n\nld Ans[Maxn];\n\ninline void dfs (int x)\n{\n\tfor (int i = Begin[x]; i; i = Next[i])\n\t{\n\t\tint y = To[i];\n\t\tAns[y] = Ans[x] + W[i];\n\t\tdfs(y);\n\t}\n}\n\ninline void Solve ()\n{\n\tGet_All_Point ();\n\tGet_LR ();\n\tBuild_Graph ();\n\n\tfor (int i = 1; i <= N; ++i) if(L[i] + R[i] == 0) dfs(i);\n\tfor (int i = 1; i <= N; ++i) if (Vis[i]) printf(\"%.8Lf\\n\", Ans[i]);\n}\n\ninline void Input ()\n{\n\tN = read<int>();\n\tfor (int i = 1; i <= N; ++i) A[i].x = read<int>(), A[i].y = read<int>();\n}\n\nint main()\n{\n\n#ifndef ONLINE_JUDGE\n\tfreopen(\"doe.in\", \"r\", stdin);\n\tfreopen(\"doe.out\", \"w\", stdout);\n#endif\n\n\tInput();\n\tSolve();\n\n\treturn 0;\n}\n\n```\n\n","categories":["Problem"],"tags":["单调栈","计算几何"]},{"title":"「CF578F」Mirror Box - 神仙题 + Matrix-Tree","url":"/2019/02/16/%E3%80%8CCF578F%E3%80%8DMirror-Box-%E7%A5%9E%E4%BB%99%E9%A2%98-Matrix-Tree/","content":"\n题意太长，就放里面了\n\n<!--more-->\n\n### Links\n\n[CF578F](https://codeforces.com/contest/578/problem/F)\n\n### Description\n\n![19-2-16-1](/images/19-2-16-1.png)\n\n### Constraints\n\n$n,m\\le 100$，*的个数不超过$300$\n\n\n\n### Solution\n\n神仙结论题\n\n对盒子中所有的顶点（一共有$(n + 1)(m + 1)$个顶点）进行黑白染色，,如果把一面镜子看成一条边的话，那么一面镜子连接了两个颜色相同的顶点。\n\n结论：完美盒子的充要条件是某种颜色的点形成了一棵树。\n\n接下来是十~~you~~分~~chou~~优~~you~~美~~chang~~的证明：\n\n![19-2-16-2](/images/19-2-16-2.png)\n\n\n\n枚举是白点形成了树还是黑点形成了树，然后把已知的边连上，就可以把原来的问题规模缩小到与*的个数同规模的生成树计数了，直接$Matrix-Tree$，时间复杂度$O(300^3)$\n\n> 注意：若形成的联通块数量大于300，则一定无解\n\n\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int Maxn = 100 + 10;\n\nint Mod;\n\nint N, M, Id[Maxn][Maxn];\nchar S[Maxn][Maxn];\n\ninline int Pow (int a, int b)\n{\n\tint ans = 1;\n\tfor (int i = b; i; i >>= 1, a = (LL)a * a % Mod) if (i & 1) ans = (LL)ans * a % Mod;\n\treturn ans;\n}\n\ninline void Add (int &a, int b) { a += b; if (a >= Mod) a -= Mod; }\n\nnamespace DSU\n{\n\tconst int maxn = Maxn * Maxn;\n\tint fa[maxn];\n\n\tinline void init (int maxn) { for (int i = 0; i <= maxn; ++i) fa[i] = i; }\n\tinline int find (int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); }\n\tinline int judge (int x, int y) { return find(x) == find(y); }\n\tinline void link (int x, int y) { fa[find(x)] = find(y); }\n}\n\nnamespace Matrix\n{\n\tconst int maxn = 300 + 10;\n\n\tint A[maxn][maxn];\n\n\tinline void init () { memset(A, 0, sizeof A); }\n\n\tinline void add_edge (int x, int y) { ++A[x][x], ++A[y][y], --A[x][y], --A[y][x]; }\n\n\tinline int gauss (int n)\n\t{\n\t\tint ans = 1;\n\t\tfor (int i = 1; i <= n; ++i) for (int j = 1; j <= n; ++j) A[i][j] = (A[i][j] + Mod) % Mod;\n\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t{\n\t\t\tif (!A[i][i])\n\t\t\t{\n\t\t\t\tint id = i;\n\t\t\t\tfor (int j = i + 1; j <= n; ++j)\n\t\t\t\t\tif (A[j][i])\n\t\t\t\t\t{\n\t\t\t\t\t\tswap(A[i], A[j]);\n\t\t\t\t\t\tans = (LL)ans * (Mod - 1) % Mod;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\tif (!ans) return 0;\n\t\t\t}\n\n\t\t\tint inv = Pow(A[i][i], Mod - 2);\n\t\t\tfor (int j = i + 1; j <= n; ++j)\n\t\t\t{\n\t\t\t\tint now = (LL)A[j][i] * inv % Mod;\n\t\t\t\tfor (int k = i + 1; k <= n; ++k) Add (A[j][k], Mod - (LL)now * A[i][k] % Mod);\n\t\t\t\tA[j][i] = 0;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 1; i <= n; ++i) ans = (LL)ans * A[i][i] % Mod;\n\n\t\treturn ans;\n\t}\n}\n\nint P[Maxn * Maxn], ans;\n\ninline void Solve ()\n{\n\tDSU :: init ((N + 1) * (M + 1));\n\tfor (int i = 1; i <= N; ++i)\n\t\tfor (int j = 1; j <= M; ++j)\n\t\t{\n\t\t\tif (S[i][j] == '*') continue;\n\t\t\tint x, y;\n\t\t\tif (S[i][j] == '/') x = Id[i][j + 1], y = Id[i + 1][j];\n\t\t\telse x = Id[i][j], y = Id[i + 1][j + 1];\n\n\t\t\tif (DSU :: judge (x, y)) { puts(\"0\"); return ; }\n\t\t\tDSU :: link (x, y);\n\t\t}\n\n\tfor (int k = 0; k < 2; ++k)\n\t{\n\n\t\tint cnt = 0;\n\t\tMatrix :: init ();\n\n\t\tfor (int i = 1; i <= N + 1; ++i)\n\t\t\tfor (int j = 1; j <= M + 1; ++j)\n\t\t\t\tif ((i + j) % 2 == k && DSU :: find(Id[i][j]) == Id[i][j]) P[Id[i][j]] = ++cnt;\n\n\t\tif (cnt > 300) continue;\n\n\t\tfor (int i = 1; i <= N; ++i)\n\t\t\tfor (int j = 1; j <= M; ++j)\n\t\t\t\tif (S[i][j] == '*')\n\t\t\t\t{\n\t\t\t\t\tint x, y;\n\t\t\t\t\tif ((i + j) % 2 == k) x = Id[i][j], y = Id[i + 1][j + 1];\n\t\t\t\t\telse x = Id[i][j + 1], y = Id[i + 1][j];\n\t\t\t\t\tx = P[DSU :: find(x)], y = P[DSU :: find(y)];\n\t\t\t\t\tMatrix :: add_edge (x, y);\n\t\t\t\t}\n\n\t\tAdd (ans, Matrix :: gauss (cnt - 1));\n\t}\n\n\tcout << ans << endl;\n}\n\ninline void Input ()\n{\n\tN = read<int>(), M = read<int>(), Mod = read<int>();\n\tfor (int i = 1; i <= N; ++i) scanf(\"%s\", S[i] + 1);\n}\n\ninline void Init ()\n{\n\tint tot_cnt = 0;\n\tfor (int i = 1; i <= N + 1; ++i)\n\t\tfor (int j = 1; j <= M + 1; ++j)\n\t\t\tId[i][j] = ++tot_cnt;\n}\n\nint main()\n{\n\n#ifndef ONLINE_JUDGE\n\tfreopen(\"xxx.in\", \"r\", stdin);\n\tfreopen(\"xxx.out\", \"w\", stdout);\n#endif\n\n\tInput();\n\tInit();\n\tSolve();\n\n\treturn 0;\n}\n```\n\n","categories":["Problem"],"tags":["Codeforces","神仙题","Matrix-Tree"]},{"title":"「CF814E」An unavoidable detour for home - 动态规划","url":"/2019/02/16/%E3%80%8CCF814E%E3%80%8DAn-unavoidable-detour-for-home-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","content":"\n给出$n$个点，和每个点的度让你构造出一张无向图满足以下两条性质：\n\n1. 点$1$到点$i$仅有**唯一**一条最短路\n\n2. 点$1$到点$i$的最短路长度大于等于点$1$到点$i-1$的最短路长度\n\n求能构成满足条件的无重边无自环的无向图的个数\n\n原题：$n\\le 50$\n\n加强版：$n \\le 400$\n\n<!--more-->\n\n### Links\n\n[CF814](https://codeforces.com/contest/814/problem/E)\n\n\n\n### Solution\n\n通过观察性质，发现Bfs序是一段一段连续的，那么可以考虑dp，每次转移一段Bfs序\n\n设$dp[i][j]$表示$[i, j]$这一段作为新的Bfs层，且$[1,j]$的点都连好边的方案数\n\n设$[i,j]$中有$a$个$d=2$的点，$b$个$d=3$的点，考虑枚举下一层的点数有转移：\n$$\ndp[i][j] \\rightarrow dp[j + 1][j + k] * f[a][b][k]\n$$\n其中$f[i][j][k]$表示$i+k$个度数为$1$的点，$j$个度数为$2$的点，且$k$个度数为$1$的点只能和其他$i+j$个点连边的方案数\n\n* 若$k>0$：枚举$k$个点中的一个和$i+j$个点中哪个点连\n* 否则，若$i>0$：枚举$i$个点中的一个和$j​$个点中哪个点连\n* 否则：用若干个环覆盖$j$个点的方案数，要注意不能有两个点的环，因为会产生重边\n\n具体转移见[这里](https://loj.ac/article/37)\n\n\n\n### Code\n\n> 注：此代码为加强版代码，因空间过大且模数与原题不同，无法通过原题。原题代码见[CF的提交记录](https://codeforces.com/contest/814/submission/49938966)\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int Maxn = 400 + 20;\nconst int Mod = 998244353;\n\nint N, A[Maxn], Sum[3][Maxn], Dp[Maxn][Maxn];\nint fac[Maxn], ifac[Maxn];\n\ninline void Add (int &a, int b) { a += b; if (a >= Mod) a -= Mod; }\n\ninline int get_sum (int op, int l, int r) { return Sum[op][r] - Sum[op][l - 1]; }\n\ninline int Pow (int a, int b)\n{\n\tint ans = 1;\n\tfor (int i = b; i; i >>= 1, a = (LL)a * a % Mod) if (i & 1) ans = (LL)ans * a % Mod;\n\treturn ans;\n}\n\nint f[Maxn][Maxn][Maxn];\n\ninline int Binom (int n, int m) { if (n < m) return 0; return (LL)fac[n] * ifac[m] % Mod * ifac[n - m] % Mod; }\n\ninline int get_f (int i, int j, int k)\n{\n\tif (i < 0 || j < 0) return 0;\n\tif (f[i][j][k]) return f[i][j][k] - 1;\n\n\tint sum = 0;\n\tif (k) sum = ((LL)i * get_f(i - 1, j, k - 1) % Mod + (LL)j * get_f(i + 1, j - 1, k - 1) % Mod) % Mod;\n\telse if (i) sum = ((LL)(i - 1) * get_f(i - 2, j, k) % Mod + (LL)j * get_f(i, j - 1, k) % Mod) % Mod;\n\telse if (j > 2)\n\t\tfor (int l = 2; l < j; ++l) Add (sum, (LL)get_f(i, j - l - 1, k) * Binom(j - 1, l) % Mod * fac[l] % Mod * ifac[2] % Mod);\n\telse sum = !j;\n\n\tf[i][j][k] = sum + 1;\n\n\treturn sum;\n}\n\ninline void Solve ()\n{\n\tint ans = 0;\n\n\tif (A[1] == 1) Dp[2][3] = 1;\n\telse Dp[2][4] = 1;\n\n\tfor (int i = 2; i <= N; ++i)\n\t\tfor (int j = i ; j <= N; ++j)\n\t\t{\n\t\t\tif (!Dp[i][j]) continue;\n\n\t\t\tint sum[3];\n\t\t\tfor (int k = 0; k < 3; ++k) sum[k] = get_sum (k, i, j);\n\n\t\t\tif (j == N) Add (ans, (LL)Dp[i][j] * get_f(sum[1], sum[2], 0) % Mod);\n\t\t\telse\n\t\t\t\tfor (int k = 1; k <= sum[0] && k + j <= N; ++k)\n\t\t\t\t\tAdd (Dp[j + 1][j + k], (LL)Dp[i][j] * get_f(sum[1], sum[2], k) % Mod);\n\t\t}\n\n\tcout << ans << endl;\n}\n\ninline void Input ()\n{\n\tN = read<int>();\n\tfor (int i = 1; i <= N; ++i)\n\t{\n\t\tA[i] = read<int>() - 1;\n\t\tfor (int j = 0; j < 3; ++j) Sum[j][i] = Sum[j][i - 1];\n\t\tSum[0][i] += A[i], ++Sum[A[i]][i];\n\t}\n}\n\ninline void Init (int maxn)\n{\n\tfac[0] = 1;\n\tfor (int i = 1; i <= maxn; ++i) fac[i] = (LL)fac[i - 1] * i % Mod;\n\tifac[maxn] = Pow(fac[maxn], Mod - 2);\n\tfor (int i = maxn - 1; ~i; --i) ifac[i] = (LL)ifac[i + 1] * (i + 1) % Mod;\n}\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"ffb.in\", \"r\", stdin);\n\tfreopen(\"ffb.out\", \"w\", stdout);\n#endif\n\tInput();\n\tInit(N);\n\tSolve();\n\treturn 0;\n}\n\n```\n\n","categories":["Problem"],"tags":["Codeforces","动态规划"]},{"title":"线性基小结","url":"/2019/02/11/%E7%BA%BF%E6%80%A7%E5%9F%BA%E5%B0%8F%E7%BB%93/","content":"\n线性基是常用来解决子集异或/线性空间中一些题目的算法\n\n<!--more-->\n\n## 算法\n\n具体定义概念见[Menci的博客](https://oi.men.ci/linear-basis-notes/)，写的很好，这里只记录一些感性的理解\n\n> 注：以下没有注明的话，线性基均指的是异或线性基\n\n### 简介\n\n简单来说，线性基就是在异或运算下，只需要一个大小为$c$的集合$\\beta$（$c$表示数字位数）就能通过相互进行异或运算表示出一个全集$S$中的所有数。也就是说，它可以将集合$S$在异或意义下的一个压缩\n\n>  为什么只需要大小为$c$的集合呢？显然，只需要一个全是2的幂次的集合就能表示出所有数，因此上界肯定是$c$\n\n它可以表示成这样一组数（也可以说是一组$0/1$向量）：$a_1, a_2\\dots a_c$，其中$a_x$的最高位的$1$在第$x$位\n\n而在这里所提到的线性基（包括代码实现）都是最简意义下的。即只要某一位它出现在了某个数的最高位，那么其他数字中它这一位就为$0$（如果不为$0$就可以消掉）；而如果某一位没有作为最高位出现过，可以有多个数字这一位为$0$\n\n由此不难看出，它是一个类似于对角矩阵的东西，大概可能长这样：\n$$\n\\begin{bmatrix}\n1&0&1&0&\\cdots&0&0&0\\\\\n0&1&1&0&\\cdots&0&1&0\\\\\n0&0&0&0&\\cdots&0&0&0\\\\\n0&0&0&1&\\cdots&0&0&0\\\\\n0&0&0&0&\\cdots&1&1&0\\\\\n0&0&0&0&\\cdots&0&0&0\\\\\n0&0&0&0&\\cdots&0&0&1\n\\end{bmatrix}\n$$\n其中第$i$行表示线性基中的$a_i$\n\n### 实现\n\n显然，我们可以用$O(nc^2)$的高斯消元暴力求线性基，但是这样并不优美。于是有一种$O(nc)$贪心动态构造的方法：\n\n对于一个新加入的数$x$，从大到小枚举$x$的每一个为$1$的二进制位$i$：\n\n* 如果$a_i=0$，那么令$a_i = x$\n\n  用已经存在的$a_{j(j<i)}$消掉$x$在第$j$位的影响\n\n  用当前的$x$消掉已经存在的$a_{j(j>i)}$在第$i$位的影响\n\n  并结束插入的过程\n\n* 否则$x = x \\oplus a_i$\n\n这样贪心的构造显然是对的，证明见文章开头的博客，这里不多赘述\n\n> 写一下感性理解，对于当前为$1$的最高位$i$，如果$a_i\\ne0$，就说明已经存在一个最高位为$i$的数，那么直接用这个$a_i$就能把$x$的第$i$位消掉；而如果$a_i=0$，就说明此时的$x$是最先出现的最高位为$i$的数，直接插进线性基即可\n\n### 合并\n\n扫一遍线性基，暴力插入另一个即可\n\n复杂度$O(c^2)$\n\n[具体见此](https://hk-cnyali.com/2019/02/11/%E3%80%8CSCOI2016%E3%80%8D-%E5%B9%B8%E8%BF%90%E6%95%B0%E5%AD%97-%E7%BA%BF%E6%80%A7%E5%9F%BA-%E5%80%8D%E5%A2%9E/)\n\n## 模板\n\n```cpp\nnamespace Basis\n{\n\tconst int Maxlen = 30;\n\n\tint A[Maxlen + 10];\n\n\tinline int insert (int x)\n\t{\n\t\tfor (int i = Maxlen; ~i; --i)\n\t\t{\n\t\t\tif (!(x & (1 << i))) continue;\n\t\t\tif (!A[i])\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < i; ++j) if (x & (1 << j)) x ^= A[j];\n\t\t\t\tfor (int j = i + 1; j <= Maxlen; ++j) if (A[j] & (1 << i)) A[j] ^= x;\n\t\t\t\tA[i] = x;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tx ^= A[i];\n\t\t}\n\t\treturn 0;\n\t}\n}\n```\n\n\n\n## 应用\n\n### 求异或最大/小值；与$x$异或的最大/小值\n\n高位往低位贪心，如果异或上当前的数能使答案更优就异或\n\n### 求异或$k$小值\n\n由于线性基中从高位往低位的前缀异或和显然是单调不降的，因此只需要对$k$做二进制拆分，取线性基中对应位数的值异或起来即可\n\n核心代码：\n\n```cpp\nfor (int i = 0; i <= Maxlen; ++i) if (A[i]) v.push_back(A[i]);\nfor (int i = 0; i < v.size(); ++i) if (k & (1ll << i)) ans ^= v[i];\n```\n\n### 求异或排名\n\n与上个操作是互逆操作\n\n核心代码：\n\n```cpp\nfor (int i = 0; i <= Maxlen; ++i) if (A[i]) bit.push_back(i);\nfor (int i = 0; i < bit.size(); ++i) if (x & (1ll << bit[i])) ans |= (1 << i);\n```\n\n\n\n### 解异或方程组\n\n见[「SDOI2010」外星千足虫](http://hk-cnyali.com/2019/02/11/%E3%80%8CSDOI2010%E3%80%8D%E5%A4%96%E6%98%9F%E5%8D%83%E8%B6%B3%E8%99%AB-%E7%BA%BF%E6%80%A7%E5%9F%BA-%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/)\n\n### 扩展到线性空间\n\n线性基也可以用来求解线性空间的解方程/线性无关问题\n\n具体可见[「JLOI2015」装备购买](https://www.luogu.org/problemnew/show/P3265) ，但是我并没有写博客，就把代码放这里：\n\n```cpp\nnamespace Basis\n{\n\tlong double A[Maxn][Maxn];\n\tint Vis[Maxn];\n\n\tinline int insert (long double x[])\n\t{\n\t\tfor (int i = 1; i <= N; ++i)\n\t\t{\n\t\t\tif (fabs(x[i]) < eps) continue;\n\n\t\t\tif (!Vis[i])\n\t\t\t{\n\t\t\t\tlong double base = x[i];\n\t\t\t\tfor (int j = i; j <= N; ++j) x[j] /= base;\n\n\t\t\t\tfor (int j = i + 1; j <= N; ++j)\n\t\t\t\t{\n\t\t\t\t\tif (!Vis[j]) continue;\n\t\t\t\t\tbase = x[j];\n\t\t\t\t\tfor (int k = 1; k <= N; ++k) x[k] -= base * A[j][k];\n\t\t\t\t}\n\n\t\t\t\tfor (int j = 1; j < i; ++j)\n\t\t\t\t{\n\t\t\t\t\tif (!Vis[j]) continue;\n\t\t\t\t\tbase = A[j][i];\n\t\t\t\t\tfor (int k = 1; k <= N; ++k) A[j][k] -= base * x[k];\n\t\t\t\t}\n\n\t\t\t\tfor (int j = 1; j <= N; ++j) A[i][j] = x[j];\n\t\t\t\tVis[i] = 1;\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tlong double base = x[i];\n\t\t\tfor (int j = i; j <= N; ++j) x[j] -= base * A[i][j];\n\t\t}\n\t\treturn 0;\n\t}\n}\n```\n\n### 最大路径异或和\n\n见[「WC2011」Xor - 线性基](https://hk-cnyali.com/2019/02/11/%E3%80%8CWC2011%E3%80%8DXor-%E7%BA%BF%E6%80%A7%E5%9F%BA/)\n\n### 树上路径最大异或和 \n\n见[「WC2011」Xor](http://hk-cnyali.com/2019/02/11/%E3%80%8CWC2011%E3%80%8DXor-%E7%BA%BF%E6%80%A7%E5%9F%BA/) \n\n---\n\n其他应用基本都是建立在这些操作之上了\n\n","categories":["Algorithm"],"tags":["Summary","线性基","高斯消元"]},{"title":"「CF1100F」Ivan and Burgers  - 线性基 - 分治","url":"/2019/02/11/%E3%80%8CCF1100F%E3%80%8DIvan-and-Burgers-%E7%BA%BF%E6%80%A7%E5%9F%BA-%E5%88%86%E6%B2%BB/","content":"\n给定长度为$n$的序列$a_i$，有次$q$询问$(l,r)$，求在$a_{l\\dots r}$中选取任意个，使得它们的异或和最大\n\n$n\\le 500000, a_i\\le 10^6$\n\n<!--more-->\n\n### Links\n\n[CF1100F](https://codeforces.com/contest/1100/problem/F)\n\n\n\n### Solution\n\n考虑分治，把序列和询问一起分治\n\n类似于树上点分治的做法，每次只计算跨区间的答案\n\n对于当前分治区间，处理出以$mid$为中心，分别向两边扩展的前/后缀线性基（$[l, mid)$的后缀和$(mid, r]$的前缀），询问的时候直接合并起来就行了\n\n总复杂度$O(n\\log^2 n)$，好想好写好调也跑得过\n\n\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int Maxn = 5e5 + 100, Maxlen = 20;\n\nint N, A[Maxn], M;\n\nstruct info {int x, y, id;};\n\nstruct Basis\n{\n\tint A[Maxlen + 2];\n\n\tinline void init () { memset(A, 0, sizeof A); }\n\n\tinline int insert (int x)\n\t{\n\t\tfor (int i = Maxlen; ~i; --i)\n\t\t{\n\t\t\tif (!(x & (1 << i))) continue;\n\t\t\tif (!A[i])\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < i; ++j) if (x & (1 << j)) x ^= A[j];\n\t\t\t\tfor (int j = i + 1; j <= Maxlen; ++j) if (A[j] & (1 << i)) A[j] ^= x;\n\t\t\t\tA[i] = x;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tx ^= A[i];\n\t\t}\n\t\treturn 0;\n\t}\n\n\tfriend Basis merge (const Basis &a, const Basis &b)\n\t{\n\t\tBasis res = a;\n\t\tfor (int i = 0; i <= Maxlen; ++i) if (b.A[i]) res.insert(b.A[i]);\n\t\treturn res;\n\t}\n\n\tinline int query (int ans = 0)\n\t{\n\t\tfor (int i = Maxlen; i >= 0; --i) Chkmax(ans, ans ^ A[i]);\n\t\treturn ans;\n\t}\n\n}B[Maxn];\n\nint Ans[Maxn];\ninfo Q[Maxn], Q1[Maxn], Q2[Maxn];\n\ninline void Divide (int l, int r, int L, int R)\n{\n\tif (L > R) return ;\n\tif (l == r)\n\t{\n\t\tfor (int i = L; i <= R; ++i) Ans[Q[i].id] = A[l];\n\t\treturn ;\n\t}\n\n\tint mid = l + r >> 1, len1 = 0, len2 = 0;\n\tB[mid].init(), B[mid].insert (A[mid]);\n\tfor (int i = mid - 1; i >= l; --i) B[i] = B[i + 1], B[i].insert (A[i]);\n\tfor (int i = mid + 1; i <= r; ++i) B[i] = B[i - 1], B[i].insert (A[i]);\n\n\tfor (int i = L; i <= R; ++i)\n\t{\n\t\tif (Q[i].x <= mid)\n\t\t{\n\t\t\tif (Q[i].y > mid) Ans[Q[i].id] = merge (B[Q[i].x], B[Q[i].y]).query();\n\t\t\telse Q1[++len1] = Q[i];\n\t\t}\n\t\telse Q2[++len2] = Q[i];\n\t}\n\n\tfor (int i = 1; i <= len1; ++i) Q[L + i - 1] = Q1[i];\n\tfor (int i = 1; i <= len2; ++i) Q[L + len1 - 1 + i] = Q2[i];\n\n\tDivide (l, mid, L, L + len1 - 1), Divide (mid + 1, r, L + len1, L + len1 + len2 - 1);\n}\n\ninline void Solve ()\n{\n\tDivide(1, N, 1, M);\n\tfor (int i = 1; i <= M; ++i) printf(\"%d\\n\", Ans[i]);\n}\n\ninline void Input ()\n{\n\tN = read<int>();\n\tfor (int i = 1; i <= N; ++i) A[i] = read<int>();\n\tM = read<int>();\n\tfor (int i = 1; i <= M; ++i) Q[i].x = read<int>(), Q[i].y = read<int>(), Q[i].id = i;\n}\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"F.in\", \"r\", stdin);\n\tfreopen(\"F.out\", \"w\", stdout);\n#endif\n\tInput();\n\tSolve();\n\treturn 0;\n}\n```\n\n","categories":["Problem"],"tags":["Codeforces","分治","线性基"]},{"title":"「CF1101G」(Zero XOR Subset)-less - 线性基","url":"/2019/02/11/%E3%80%8CCF1101G%E3%80%8D-Zero-XOR-Subset-less-%E7%BA%BF%E6%80%A7%E5%9F%BA/","content":"\n给出一个长度为$n$的序列$\\{a_i\\}$，试将其划分为尽可能多的非空子段，满足每一个元素出现且仅出现在其中一个子段中，且在这些子段中任取若干子段，它们包含的所有数的异或和不能为$0$．\n\n$n\\le10^5, a_i\\le 10^9$ \n\n<!--more-->\n\n### Links\n\n[CF1101G](https://codeforces.com/contest/1101/problem/G)\n\n\n\n### Solution\n\n一看到“异或”、“子段”的字眼就不难想到与前缀异或和有关\n\n再仔细想想就会发现题目就是要求最多选出多少个前缀异或和，使得它们线性无关，且$sum_n$必选，即$sum_n\\ne 0$\n\n\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int Maxn = 2e5 + 100;\n\nint N, A[Maxn], Sum[Maxn];\n\nnamespace Basis\n{\n\tconst int Maxlen = 30;\n\n\tint A[Maxlen + 10];\n\n\tinline int insert (int x)\n\t{\n\t\tfor (int i = Maxlen; ~i; --i)\n\t\t{\n\t\t\tif (!(x & (1 << i))) continue;\n\t\t\tif (!A[i])\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < i; ++j) if (x & (1 << j)) x ^= A[j];\n\t\t\t\tfor (int j = i + 1; j <= Maxlen; ++j) if (A[j] & (1 << i)) A[j] ^= x;\n\t\t\t\tA[i] = x;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tx ^= A[i];\n\t\t}\n\t\treturn 0;\n\t}\n}\n\ninline void Solve ()\n{\n\tfor (int i = 1; i <= N; ++i) Sum[i] = Sum[i - 1] ^ A[i];\n\tif (!Sum[N]) { puts(\"-1\"); return ; }\n\t\n\tBasis :: insert(Sum[N]);\n\tint ans = 1;\n\tfor (int i = 1; i < N; ++i) ans += Basis :: insert (Sum[i]);\n\tcout<<ans<<endl;\n}\n\ninline void Input ()\n{\n\tN = read<int>();\n\tfor (int i = 1; i <= N; ++i) A[i] = read<int>();\n}\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"G.in\", \"r\", stdin);\n\tfreopen(\"G.out\", \"w\", stdout);\n#endif\n\tInput();\n\tSolve();\n\treturn 0;\n}\n\n```\n\n","categories":["Problem"],"tags":["Codeforces","线性基"]},{"title":"「CF938G」Shortest Path Queries - 线段树分治 + 线性基 + 并查集","url":"/2019/02/11/%E3%80%8CCF938G%E3%80%8DShortest-Path-Queries-%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%88%86%E6%B2%BB-%E7%BA%BF%E6%80%A7%E5%9F%BA-%E5%B9%B6%E6%9F%A5%E9%9B%86/","content":"\n给出一个$n$个点的连通带权无向图，边有边权，要求支持$q$ 个操作:\n\n* `1 x y d` 在原图中加入一条$x$ 到$y$ 权值为$d$的边\n\n* `2 x y` 把图中$x$ 到$y$ 的边删掉\n\n* `3 x y` 表示询问$x$ 到$y$的异或最短路\n\n保证任意操作后原图连通无重边自环且操作均合法\n\n$n,m,q\\le200000$\n\n<!--more-->\n\n### Links\n\n[CF938G](https://codeforces.com/contest/938/problem/G)\n\n\n\n### Solution\n\n先线段树分治把时间这一维去掉\n\n用可撤销并查集维护联通性，顺便维护一下当前点到父亲这条边上的异或值\n\n同[这道题](http://hk-cnyali.com/2019/02/11/「WC2011」Xor-线性基/)的套路，把出现的环丢到线性基里即可\n\n\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int Maxn = 4e5 + 100, Maxm = 4e5 + 100, Maxlen = 30;\n\nint N, M, Q, edge_cnt;\n\nstruct edge\n{\n\tint x, y, z;\n\tint l, r;\n}E[Maxm];\n\nmap <pii, int> Vis;\n\nstruct Basis\n{\n\n\tint A[Maxlen + 2];\n\n\tinline int insert (int x)\n\t{\n\t\tfor (int i = Maxlen; ~i; --i)\n\t\t{\n\t\t\tif (!(x & (1 << i))) continue;\n\t\t\tif (!A[i])\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < i; ++j) if (x & (1 << j)) x ^= A[j];\n\t\t\t\tfor (int j = i + 1; j <= Maxlen; ++j) if (A[j] & (1 << i)) A[j] ^= x;\n\t\t\t\tA[i] = x;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tx ^= A[i];\n\t\t}\n\t\treturn 0;\n\t}\n\n\tinline int query (int ans = 0)\n\t{\n\t\tfor (int i = Maxlen; i >= 0; --i) Chkmin(ans, ans ^ A[i]);\n\t\treturn ans;\n\t}\n}B[Maxn << 1];\n\nnamespace DSU\n{\n\tint fa[Maxn], sum[Maxn], size[Maxn];\n\n\tinline void init (int maxn) { for (int i = 1; i <= maxn; ++i) fa[i] = i, sum[i] = 0, size[i] = 1; }\n\n/**/inline int find (int x) { return fa[x] == x ? x : find(fa[x]); }\n\n\tinline int get_sum (int x) { int ans = 0; while (fa[x] != x) ans ^= sum[x], x = fa[x]; return ans; }\n\n\tinline pii link (int now, int x, int y, int z)\n\t{\n\t\tz ^= get_sum (x) ^ get_sum (y);\n\t\tx = find(x), y = find(y);\n\t\tif (x == y) { B[now].insert (z); return mp(0, 0); }\n\n\t\tif (size[x] < size[y]) swap(x, y);\n\t\tfa[y] = x, sum[y] = z, size[x] += size[y];\n\t\treturn mp(x, y);\n\t}\n\n\tinline int query (int x, int y) { return get_sum(x) ^ get_sum(y); }\n\n\tinline void pop (pii now)\n\t{\n\t\tint x = now.x, y = now.y;\n\t\tfa[y] = y, sum[y] = 0, size[x] -= size[y];\n\t}\n}\n\nint Ans[Maxn];\npii Query[Maxn];\n\nnamespace SEG\n{\n#define mid ((l + r) >> 1)\n#define ls root << 1\n#define rs root << 1 | 1\n#define lson root << 1, l, mid\n#define rson root << 1 | 1, mid + 1, r\n\n\tstruct info { int x, y, z; };\n\n\tvector <info> node[Maxn << 2];\n\tvector <pii> Stack[Maxn << 2];\n\n\tinline void modify (int root, int l, int r, int x, int y, int u, int v, int w)\n\t{\n\t\tif (x <= l && r <= y) { node[root].pb((info){u, v, w}); return ; }\n\n\t\tif (x <= mid) modify (lson, x, y, u, v, w);\n\t\tif (y > mid) modify (rson, x, y, u, v, w);\n\t}\n\n\tinline void process (int root, int l, int r)\n\t{\n\t\tfor (int i = 0; i < node[root].size(); ++i)\n\t\t{\n\t\t\tint x = node[root][i].x, y = node[root][i].y, z = node[root][i].z;\n\t\t\tStack[root].pb(DSU :: link (root, x, y, z));\n\t\t}\n\n\t\tif (l == r) Ans[l] = B[root].query (DSU :: query (Query[l].x, Query[l].y));\n\t\telse \n\t\t{\n\t\t\tB[ls] = B[rs] = B[root];\n\t\t\tprocess (lson), process (rson);\n\t\t}\n\n\t\tfor (int i = Stack[root].size() - 1; ~i; --i) DSU :: pop (Stack[root][i]);\n\t}\n}\n\ninline void Solve ()\n{\n/**/for (int i = 1; i <= edge_cnt; ++i) SEG :: modify (1, 1, Q, E[i].l, E[i].r, E[i].x, E[i].y, E[i].z);\n\n\tDSU :: init (N);\n/**/SEG :: process (1, 1, Q);\n\n\tfor (int i = 1; i <= Q; ++i) if (Query[i].x) printf(\"%d\\n\", Ans[i]);\n}\n\ninline void Input ()\n{\n\tN = read<int>(), M = edge_cnt = read<int>();\n\tfor (int i = 1; i <= M; ++i) E[i].x = read<int>(), E[i].y = read<int>(), E[i].z = read<int>();\n\n\tQ = read<int>();\n\tfor (int i = 1; i <= M; ++i) E[i].l = 1, E[i].r = Q, Vis[mp(E[i].x, E[i].y)] = i;\n\n\tfor (int i = 1; i <= Q; ++i)\n\t{\n\t\tint op = read<int>(), x = read<int>(), y = read<int>(), z;\n\t\tif (op == 1)\n\t\t{\n\t\t\tz = read<int>();\n\t\t\tE[++edge_cnt] = (edge){x, y, z, i, Q};\n\t\t\tVis[mp(x, y)] = edge_cnt;\n\t\t}\n\t\telse if (op == 2)\n\t\t{\n\t\t\tE[Vis[mp(x, y)]].r = i;\n\t\t\tVis[mp(x, y)] = 0;\n\t\t}\n\t\telse Query[i] = mp(x, y);\n\t}\n}\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"G.in\", \"r\", stdin);\n\tfreopen(\"G.out\", \"w\", stdout);\n#endif\n\tInput();\n\tSolve();\n\treturn 0;\n}\n\n```\n\n\n\n### Debug\n\n* 78L：写成`return fa[x] == x ? x : fa[x]`\n* 147L,150L：线段树范围写成$N$\n","categories":["Problem"],"tags":["Codeforces","并查集","线性基","线段树分治"]},{"title":"「SCOI2016」 幸运数字 - 线性基 - 倍增","url":"/2019/02/11/%E3%80%8CSCOI2016%E3%80%8D-%E5%B9%B8%E8%BF%90%E6%95%B0%E5%AD%97-%E7%BA%BF%E6%80%A7%E5%9F%BA-%E5%80%8D%E5%A2%9E/","content":"\n给你一棵$n$个点带点权的树，有$m$次查询，每次询问一条链上的最大异或和\n\n$n\\le 20000, m\\le 200000, a_i\\le 2^{60}$\n\n<!--more-->\n\n### Links\n\n[Luogu P3292](https://www.luogu.org/problemnew/show/P3292)\n\n\n\n### Solution\n\n直接倍增+线性基即可\n\n这里主要练一下线性基的合并，直接暴力枚举另一个线性基里的值暴力插入\n\n\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int Maxn = 2e4 + 100, Maxlen = 60;\n\nint N, Q;\nint e, Begin[Maxn], To[Maxn << 1], Next[Maxn << 1];\nLL W[Maxn];\n\nstruct Basis\n{\n\n\tLL A[Maxlen + 1];\n\n\tinline void init () { memset(A, 0, sizeof A); }\n\n\tinline int insert (LL x)\n\t{\n\t\tfor (int i = Maxlen; i >= 0; --i)\n\t\t{\n\t\t\tif (!(x & (1ll << i))) continue;\n\t\t\tif (!A[i])\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < i; ++j) if (x & (1ll << j)) x ^= A[j];\n\t\t\t\tfor (int j = i + 1; j <= Maxlen; ++j) if (A[j] & (1ll << i)) A[j] ^= x;\n\t\t\t\tA[i] = x;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tx ^= A[i];\n\t\t}\n\t\treturn 0;\n\t}\n\n\tfriend Basis merge (const Basis &a, const Basis &b)\n\t{\n\t\tBasis ans = a;\n\t\tfor (int i = 0; i <= Maxlen; ++i) if (b.A[i]) ans.insert (b.A[i]);\n\t\treturn ans;\n\t}\n\n\tinline LL query (LL ans = 0)\n\t{\n\t\tfor (int i = 0; i <= Maxlen; ++i) Chkmax(ans, ans ^ A[i]);\n\t\treturn ans;\n\t}\n\n} B[15 + 1][Maxn];\n\ninline void add_edge (int x, int y) { To[++e] = y; Next[e] = Begin[x]; Begin[x] = e; }\n\nint anc[15 + 1][Maxn], dep[Maxn];\n\ninline void dfs (int x)\n{\n\tdep[x] = dep[anc[0][x]] + 1;\n\tB[0][x].insert (W[x]);\n\tfor (int i = 1; i <= 15; ++i)\n\t{\n\t\tanc[i][x] = anc[i - 1][anc[i - 1][x]];\n\t\tB[i][x] = merge (B[i - 1][x], B[i - 1][anc[i - 1][x]]);\n\t}\n\n\tfor (int i = Begin[x]; i; i = Next[i])\n\t{\n\t\tint y = To[i]; if (y == anc[0][x]) continue;\n\n\t\tanc[0][y] = x;\n\n\t\tdfs(y);\n\t}\n}\n\nBasis ans;\n\ninline void get_lca (int x, int y)\n{\n\tans.insert(W[x]), ans.insert(W[y]);\n\n\tif (dep[x] < dep[y]) swap(x, y);\n\tfor (int i = 15; i >= 0; --i)\n\t\tif (dep[anc[i][x]] >= dep[y]) \n\t\t{\n\t\t\tans = merge (ans, B[i][x]);\n\t\t\tx = anc[i][x];\n\t\t}\n\n\n\tif (x == y) return ;\n\n\tfor (int i = 15; i >= 0; --i)\n\t\tif (anc[i][x] != anc[i][y]) \n\t\t{\n\t\t\tans = merge(ans, merge(B[i][x], B[i][y]));\n\t\t\tx = anc[i][x], y = anc[i][y];\n\t\t}\n\n\tans.insert(W[x]), ans.insert(W[y]);\n\tans.insert(W[anc[0][x]]);\n}\n\ninline void Solve ()\n{\n\tdfs(1);\n\twhile (Q--)\n\t{\n\t\tint x = read<int>(), y = read<int>();\n\t\tans.init();\n\t\tget_lca (x, y);\n\t\tprintf(\"%lld\\n\", ans.query());\n\t}\n}\n\ninline void Input ()\n{\n\tN = read<int>(), Q = read<int>();\n\tfor (int i = 1; i <= N; ++i) W[i] = read<LL>();\n\tfor (int i = 1; i < N; ++i)\n\t{\n\t\tint x = read<int>(), y = read<int>();\n\t\tadd_edge (x, y);\n\t\tadd_edge (y, x);\n\t}\n}\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"A.in\", \"r\", stdin);\n\tfreopen(\"A.out\", \"w\", stdout);\n#endif\n\tInput();\n\tSolve();\n\treturn 0;\n}\n\n```\n\n","categories":["Problem"],"tags":["倍增","线性基","省选"]},{"title":"「WC2011」Xor - 线性基","url":"/2019/02/11/%E3%80%8CWC2011%E3%80%8DXor-%E7%BA%BF%E6%80%A7%E5%9F%BA/","content":"\n给出一个$n$个点$m$条边的带边权无向联通图，求一条从$1$到$n$的路径（可以重复经过某些点和边），使得路径异或和最大\n\n$n\\le 50000, m \\le 100000, a_i\\le 10^{18}$\n\n<!--more-->\n\n### Links\n\n[BZOJ2115](https://www.lydsy.com/JudgeOnline/problem.php?id=2115) \n\n\n\n### Solution\n\n这道题的思路在[这里](https://hk-cnyali.com/2018/10/04/10-04-%E5%9B%BE%E8%AE%BA%E6%9D%82%E9%A2%98-%E7%AC%94%E8%AE%B0/)写过\n\n就是通过猜测得到两个结论：\n\n> 对于一条从$1$到$n$的路径异或和，一定可以表示成任意一条从$1$到$n$的路径异或上某个环\n>\n> 对于这个图的任意一棵生成树，通过其中若干个非树边所构成的环异或之后，一定能表示出这个图中的任意一个环\n\n然后直接用线性基搞就可以了\n\n对于图上路径异或和最大问题好像都是基于这个套路\n\n\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int Maxn = 50000 + 100, Maxm = 100000 + 100;\n\nint N, M, e = 1, Begin[Maxn], To[Maxm << 1], Next[Maxm << 1];\nLL W[Maxm << 1];\n\ninline void add_edge (int x, int y, LL z) { To[++e] = y; Next[e] = Begin[x]; Begin[x] = e; W[e] = z; }\n\nLL Dis[Maxn];\nint Vis[Maxn], Vis_Edge[Maxm];\n\ninline void dfs (int x)\n{\n\tVis[x] = 1;\n\tfor (int i = Begin[x]; i; i = Next[i])\n\t{\n\t\tint y = To[i]; if (Vis[y]) continue;\n\t\tVis_Edge[i >> 1] = 1;\n\n\t\tDis[y] = Dis[x] ^ W[i];\n\t\tdfs(y);\n\t}\n}\n\nstruct info {int x, y; LL z; } E[Maxm];\n\nnamespace Basis\n{\n\tconst int Maxlen = 63;\n\tLL A[Maxlen + 10];\n\n\tinline int insert (LL x)\n\t{\n\t\tfor (int i = Maxlen; i >= 0; --i)\n\t\t{\n\t\t\tif (!(x & (1ll << i))) continue;\n\t\t\tif (!A[i])\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < i; ++j) if (x & (1ll << j)) x ^= A[j];\n\t\t\t\tfor (int j = i + 1; j <= Maxlen; ++j) if (A[j] & (1ll << i)) A[j] ^= x;\n\t\t\t\tA[i] = x;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tx ^= A[i];\n\t\t}\n\t\treturn 0;\n\t}\n\n\tinline LL query (LL ans)\n\t{\n\t\tfor (int i = 0; i <= Maxlen; ++i) Chkmax(ans, ans ^ A[i]);\n\t\treturn ans;\n\t}\n}\n\ninline void Solve ()\n{\n\tdfs(1);\n\n\tfor (int i = 1; i <= M; ++i)\n\t{\n\t\tif (Vis_Edge[i]) continue;\n\t\tint x = E[i].x, y = E[i].y; LL z = E[i].z;\n//\t\tprintf(\"(%d %d) : (%lld %lld) %d\\n\", x, y, Dis[x], Dis[y], HLD :: get_lca(x, y));\n\t\tLL now = z ^ Dis[x] ^ Dis[y];\n\t\tBasis :: insert (now);\n\t}\n\n\tcout << Basis :: query (Dis[N]) << endl;\n}\n\ninline void Input ()\n{\n\tN = read<int>(), M = read<int>();\n\tfor (int i = 1; i <= M; ++i)\n\t{\n\t\tint x = read<int>(), y = read<int>(); LL z = read<LL>();\n\t\tE[i] = (info){x, y, z};\n\t\tadd_edge (x, y, z);\n\t\tadd_edge (y, x, z);\n\t}\n}\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"A.in\", \"r\", stdin);\n\tfreopen(\"A.out\", \"w\", stdout);\n#endif\n\tInput();\n\tSolve();\n\treturn 0;\n}\n\n```\n\n","categories":["Problem"],"tags":["线性基"]},{"title":"「SDOI2010」外星千足虫 - 线性基 / 高斯消元","url":"/2019/02/11/%E3%80%8CSDOI2010%E3%80%8D%E5%A4%96%E6%98%9F%E5%8D%83%E8%B6%B3%E8%99%AB-%E7%BA%BF%E6%80%A7%E5%9F%BA-%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/","content":"\n有$n$个未知数$x_1,x_2,...,x_n$，给出$m$条消息，每条消息选出一些未知数并告诉你他们的和的奇偶性\n\n你的目标是判断每个未知数的奇偶性\n\n如果前$k$条消息就可以确定所有未知数的奇偶性，输出$k$以及所有未知数的奇偶性，否则输出存在多解\n\n$n\\le1000,m\\le2000$\n\n<!--more-->\n\n### Links\n\n[Luogu P2447](https://www.luogu.org/problemnew/show/P2447)\n\n\n\n### Solution\n\n可以直接高斯消元或者用线性基解异或方程组\n\n线性基做的话，用`bitset`存，把常数项也压进去，当作一个新的变量跟着一起异或就行了\n\n\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int Maxn = 1000 + 100, Maxm = 2000 + 100;\n\nint N, M;\n\nnamespace Basis\n{\n\tbitset <Maxn> A[Maxm];\n\n\tinline int insert (bitset <Maxn> x)\n\t{\n\t\tfor (int i = 0; i < N; ++i)\n\t\t{\n\t\t\tif (!x[i]) continue;\n\t\t\tif (!A[i].any())\n\t\t\t{\n\t\t\t\tfor (int j = i + 1; j < N; ++j) if (x[j]) x ^= A[j];\n\t\t\t\tfor (int j = 0; j < i; ++j) if (A[j][i]) A[j] ^= x;\n\t\t\t\tA[i] = x;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tx ^= A[i];\n\t\t}\n\t\treturn 0;\n\t}\n\n\tinline void query ()\n\t{\n\t\tfor (int i = 0; i < N; ++i) A[i][N] ? puts(\"?y7M#\") : puts(\"Earth\");\n\t}\n}\n\nchar S[Maxn];\nbitset <Maxn> A;\n\ninline void Solve ()\n{\n\tint cnt = 0, pos = 0;\n\tfor (int i = 1; i <= M; ++i)\n\t{\n\t\tscanf(\"%s\", S);\n\t\tfor (int j = 0; j < N; ++j) A[j] = S[j] - '0';\n\t\tint x = read<int>();\n\t\tA[N] = x;\n\t\tif (Basis :: insert (A)) ++cnt, pos = i;\n\t}\n\n\tif (cnt < N) { puts(\"Cannot Determine\"); return ; }\n\n\tcout<<pos<<endl;\n\tBasis :: query ();\n}\n\ninline void Input ()\n{\n\tN = read<int>(), M = read<int>();\n}\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"A.in\", \"r\", stdin);\n\tfreopen(\"A.out\", \"w\", stdout);\n#endif\n\tInput();\n\tSolve();\n\treturn 0;\n}\n```\n\n","categories":["Problem"],"tags":["线性基","高斯消元","省选"]},{"title":"「HNOI2017」大佬 - 动态规划 + 搜索 + two pointer","url":"/2019/02/10/%E3%80%8CHNOI2017%E3%80%8D%E5%A4%A7%E4%BD%AC-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%90%9C%E7%B4%A2-two-pointer/","content":"有一个大佬，自信值为$C$，你的自信值为$\\mathrm{mc}$，初始$L=0, F=1$\n\n大佬每天会使你的自信值减少$a_i$，你只要自信值非负，则每天可以选择以下操作之一：\n\n1. 让自己的自信值提高$w_i$\n\n2. 让大佬的自信值$C$减一\n\n3. 让自己等级$L$加一\n\n4. 让自己的嘲讽能力$F*=L$\n\n5. 对大佬造成$F​$的伤害$(mc-=F)​$，然后使$L=0,F=1​$。该操作不能超过两次\n\n多组询问$c​$，对于每组询问回答能否恰好使得$c=0​$，询问相互独立\n\n$1\\le n, \\mathrm{mc}\\le 100, 1\\le m\\le 20; 1\\le a_i, w_i\\le\\mathrm{mc}, 1\\le C_i\\le 10^8​$\n\n<!--more-->\n\n### Links\n\n[Luogu P3724](https://www.luogu.org/problemnew/show/P3724)\n\n[LOJ 2021](https://loj.ac/problem/2021)\n\n\n\n### Analysis\n\n原问题可以拆成两个部分，求出在活着的前提下最多能进行其他操作的天数\n\n剩下的部分由于状态数很少，可以`Bfs`出所有状态，利用所求东西的单调性，`two pointer`解决\n\n\n\n### Solution\n\n首先肯定是尽量苟活，也就是花费最少的天数提高自信值\n\n这个东西可以dp算一下，$dp[i][j]$表示到第$i$天，自信值为$j$时，最多可以花费多少天进行提高自信值以外的操作\n\n最后扫一遍就能求出最多能进行其他操作的天数$MaxDay$\n\n接下来考虑3、4操作，发现又可以dp，不难注意到状态数很少这个事实，于是可以`Bfs+Hash`求出所有状态\n\n状态$(f, d)$表示用$d$天可以产生$f$的嘲讽能力\n\n最后考虑5操作，不操作和操作一次的情况很好判断，下面讨论操作两次的情况：\n\n假设两次的状态分别为$(f_1, d_1),(f_2, d_2)$，那么需要满足：\n$$\n\\begin{aligned}\n&d_1 + d_2 \\le MaxDay\\\\\\\\\n&f_1 + f_2 \\le C\\\\\\\\\n&f_1 + f_2 + (MaxDay - d_1 - d_2) \\ge C\n\\end{aligned}\n$$\n显然第三个限制包含了第一个限制，于是可以只考虑后面两个限制，而最后一个限制可以化简为：\n$$\nf_1 - d_1 + f_2 - d_2 \\ge C - MaxDay\n$$\n考虑按$f$排序，用`two pointer`扫出对于每个$f_i$作为$f_1$时，所对应$f_2$的范围\n\n由于此时$f_1, d_1, C, MaxDay$都是确定的，所以只要考虑$f_2 - d_2$的最大值，这个在指针扫的时候记录一下即可\n\n\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int Maxn = 100 + 10;\n\nint N, M, MC, A[Maxn], W[Maxn], C[Maxn], MaxC;\nint Dp[Maxn][Maxn], MaxDay;\n\ninline void Pre_Dp ()\n{\n\tfor (int i = 1; i <= N; ++i)\n\t{\n\t\tfor (int j = A[i]; j <= MC; ++j)\n\t\t{\n\t\t\tChkmax(Dp[i][j - A[i]], Dp[i - 1][j] + 1);\n\t\t\tChkmax(Dp[i][min(j - A[i] + W[i], MC)], Dp[i - 1][j]);\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= N; ++i) for (int j = 0; j <= MC; ++j) Chkmax(MaxDay, Dp[i][j]);\n}\n\nstruct info { int d, f, l; };\n\nset <pii> S;\npii State[(int)1e6 + 100];\nint state_cnt;\n\ninline void Bfs ()\n{\n\tstatic queue <info> Q;\n\tQ.push((info){1, 1, 0});\n\n\twhile (!Q.empty())\n\t{\n\t\tinfo x = Q.front(); Q.pop();\n\t\tif (x.d == MaxDay) continue;\n\t\tQ.push((info){x.d + 1, x.f, x.l + 1});\n\t\tif (x.l > 1 && (LL)x.f * x.l <= MaxC && !S.count(mp(x.f * x.l, x.d + 1)))\n\t\t{\n\t\t\tQ.push((info){x.d + 1, x.f * x.l, x.l});\n\t\t\tS.insert(mp(x.f * x.l, x.d + 1)), State[++state_cnt] = mp(x.f * x.l, x.d + 1);\n\t\t}\n\t}\n\n\tsort(State + 1, State + state_cnt + 1);\n}\n\ninline void Solve ()\n{\n\tPre_Dp();\n\tBfs();\n\n\tfor (int pp = 1; pp <= M; ++pp)\n\t{\n\t\tif (MaxDay >= C[pp]) { puts(\"1\"); continue; }\n\n\t\tint j = 1, Max = -0x3f3f3f3f, fl = 0;\n\t\tfor (int i = state_cnt; i >= 1; --i)\n\t\t{\n/**/\t\twhile (j < state_cnt && State[i].x + State[j].x <= C[pp]) Chkmax(Max, State[j].x - State[j].y), ++j;\n\n\t\t\tif (State[i].x <= C[pp] && State[i].x - State[i].y >= C[pp] - MaxDay) {fl = 1; break; }\n\t\t\tif (State[i].x - State[i].y + Max >= C[pp] - MaxDay) {fl = 1; break; }\n\t\t}\n\n\t\tprintf(\"%d\\n\", fl);\n\t}\n}\n\ninline void Input ()\n{\n\tN = read<int>(), M = read<int>(), MC = read<int>();\n\tfor (int i = 1; i <= N; ++i) A[i] = read<int>();\n\tfor (int i = 1; i <= N; ++i) W[i] = read<int>();\n\tfor (int i = 1; i <= M; ++i) Chkmax(MaxC, C[i] = read<int>());\n}\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"A.in\", \"r\", stdin);\n\tfreopen(\"A.out\", \"w\", stdout);\n#endif\n\tInput();\n\tSolve();\n\treturn 0;\n}\n\n```\n\n","categories":["Problem"],"tags":["动态规划","搜索","two pointers","省选"]},{"title":"「Template」通配符单模式串匹配 - FFT","url":"/2019/02/10/%E3%80%8CTemplate%E3%80%8D%E9%80%9A%E9%85%8D%E7%AC%A6%E5%8D%95%E6%A8%A1%E5%BC%8F%E4%B8%B2%E5%8C%B9%E9%85%8D-FFT/","content":"\n带通配符单模式串匹配\n\n$n \\le 300000$\n\n<!--more-->\n\n### Links\n\n[Luogu P4173 残缺的字符串](https://www.luogu.org/problemnew/show/P4173)\n\n### Solution\n\n令通配符=0\n\n若字符$a,b$匹配，则$(a-b)^2ab=0$，又因为$(a-b)^2ab$为非负整数，所以只需要$\\sum=0$\n\n直接把模式串翻转，用$f$来判断是否匹配\n$$\n\\begin{aligned}\nf[i] &= \\sum_{j=0}^{i}(A[j] - B[i - j])^2A[j]B[i - j]\\\\\\\\\n&= \\sum_{j=0}^{i}A[j]^3B[i - j] - 2\\sum_{j=0}^{i}A[j]^2B[i - j]^2 + \\sum_{j=0}^{i}A[j]B[i - j]^3\n\\end{aligned}\n$$\n做三次`FFT`即可\n\n> 考虑到FFT常数太大，我们只需要先做6次`DFT`，最后`IDFT`一次即可\n\n\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int Maxn = 1500000;\nconst double eps = 0.5, PI = acos(-1.0);\n\nint N, M;\ndouble A[Maxn], B[Maxn], C[Maxn], D[Maxn];\nchar S[Maxn];\n\nstruct Complex \n{\n\tdouble x, y;\n\n\tinline Complex operator + (const Complex &rhs) const { return (Complex){x + rhs.x, y + rhs.y}; }\n\tinline Complex operator - (const Complex &rhs) const { return (Complex){x - rhs.x, y - rhs.y}; }\n\tinline Complex operator * (const Complex &rhs) const { return (Complex){x * rhs.x - y * rhs.y, x * rhs.y + y * rhs.x}; }\n\tinline Complex operator * (const double &rhs) const { return (Complex){x * rhs, y * rhs}; }\n} Ans[Maxn];\n\nnamespace Poly\n{\n\tint n, rev[Maxn];\n\tComplex F[Maxn], G[Maxn];\n\n\tinline void init (int N, int M)\n\t{\n\n\t\tn = 1; while (n < N + M) n <<= 1;\n\t\tfor (int i = 0; i < n; ++i) rev[i] = (rev[i >> 1] >> 1) + (i & 1 ? (n >> 1) : 0);\n\t}\n\n\tinline void DFT (Complex A[], int flag)\n\t{\n\t\tfor (int i = 0; i < n; ++i) if (rev[i] < i) swap(A[i], A[rev[i]]);\n\n\t\tfor (int mid = 1; mid < n; mid <<= 1)\n\t\t{\n\t\t\tComplex Wn = (Complex){cos(PI / mid), sin(PI / mid) * flag};\n\n\t\t\tfor (int i = 0; i < n; i += (mid << 1))\n\t\t\t{\n\t\t\t\tComplex W = (Complex){1, 0};\n\t\t\t\tfor (int j = i; j < i + mid; ++j, W = W * Wn)\n\t\t\t\t{\n\t\t\t\t\tComplex a = A[j], b = W * A[j + mid];\n\t\t\t\t\tA[j] = a + b, A[j + mid] = a - b;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (flag < 0) for (int i = 0; i < n; ++i) A[i].x /= n;\n\t}\n\n\tinline void FFT (double A[], int N, double B[], int M)\n\t{\n/**/\tfor (int i = 0; i < n; ++i) F[i] = (Complex){i < N ? A[i] : 0, 0};\n\t\tfor (int i = 0; i < n; ++i) G[i] = (Complex){i < M ? B[i] : 0, 0};\n\n\t\tDFT(F, 1), DFT(G, 1);\n\t\tfor (int i = 0; i < n; ++i) F[i] = F[i] * G[i];\n\t}\n\n\tinline void Work ()\n\t{\n\t\tinit(N, M);\n\t\tfor (int i = 0; i < N; ++i) C[i] = A[i] * A[i] * A[i];\n\t\tfor (int i = 0; i < M; ++i) D[i] = B[i];\n\t\tFFT (C, N, D, M);\n\t\tfor (int i = 0; i < n; ++i) Ans[i] = Ans[i] + F[i];\n\n\t\tfor (int i = 0; i < N; ++i) C[i] = A[i] * A[i];\n\t\tfor (int i = 0; i < M; ++i) D[i] = B[i] * B[i];\n\t\tFFT (C, N, D, M);\n\t\tfor (int i = 0; i < n; ++i) Ans[i] = Ans[i] - F[i] * 2.0;\n\n\t\tfor (int i = 0; i < N; ++i) C[i] = A[i];\n\t\tfor (int i = 0; i < M; ++i) D[i] = B[i] * B[i] * B[i];\n\t\tFFT (C, N, D, M);\n\t\tfor (int i = 0; i < n; ++i) Ans[i] = Ans[i] + F[i];\n\n\t\tDFT(Ans, -1);\n//\t\tfor (int i = 0; i < n; ++i) printf(\"%.0lf \", Ans[i].x); puts(\"\");\n\t}\n}\n\nvector <int> p;\n\ninline void Solve ()\n{\n\tPoly :: Work ();\n\tfor (int i = N - 1; i < M; ++i) if (fabs(Ans[i].x) < eps) p.pb(i - N + 2);\n\n\tcout<<p.size()<<endl;\n\tfor (int i = 0; i < p.size(); ++i) printf(\"%d \", p[i]);\n}\n\ninline void Input ()\n{\n\tN = read<int>(), M = read<int>();\n\tscanf(\"%s\", S); for (int i = 0; i < N; ++i) if (S[i] != '*') A[i] = S[i] - 'a' + 1;\n\tscanf(\"%s\", S); for (int i = 0; i < M; ++i) if (S[i] != '*') B[i] = S[i] - 'a' + 1;\n\treverse(A, A + N);\n}\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"A.in\", \"r\", stdin);\n\tfreopen(\"A.out\", \"w\", stdout);\n#endif\n\tInput();\n\tSolve();\n\treturn 0;\n}\n\n```\n\n\n\n### Debug\n\n* 84L：`i < N`写成`i <= N`","categories":["Problem"],"tags":["字符串","FFT"]},{"title":"「CF850F」Rainbow Balls - 期望 + 动态规划","url":"/2019/02/07/%E3%80%8CCF850F%E3%80%8DRainbow-Balls-%E6%9C%9F%E6%9C%9B-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","content":"\n袋子里有$n$种球，第$i$种颜色有$a_i$ 个\n\n每次操作随机选两个球，将第一个球染成第二个球的颜色\n\n求全部颜色变成相同的期望次数\n\n$1 \\le n \\le 2500, 1 \\le a_i \\le 10^5$\n\n<!--more-->\n\n### Links\n\n[CF850F](https://codeforces.com/contest/850/problem/F)\n\n\n\n### Solution\n\n发现直接dp不好设状态，因为确定了最终颜色之后，剩下的颜色具体是什么无关紧要，于是考虑设计与最终颜色有关的状态，即先枚举最终颜色\n\n设$f[i]$表示当前有$i$个钦定颜色的球，到结束的期望时间，记$s=\\sum_{i=1}^{n}a_i$\n$$\nf[i] = p(f[i - 1] + f[i + 1]) + (1-2p)f[i] + E\n$$\n其中$p=\\frac{i(s-i)}{s(s-1)}$，为选出一个钦定的球和一个其他颜色球的概率，变多变少都是这个概率\n\n而$E=\\frac{i}{s}$，为产生贡献的期望时间\n\n> 为什么这里$E\\ne 1$呢？\n>\n> 一句话概括，就是当前钦定的颜色必须存在，即个数不能为$0$\n>\n> 具体地，当前的$i$个球减少与增加一个的概率均等，最后目标是要在到达$0$之前到达$s$\n>\n> 这实际上就是一个[赌徒破产问题](https://hk-cnyali.com/2019/02/02/%E8%B5%8C%E5%BE%92%E7%A0%B4%E4%BA%A7%E9%97%AE%E9%A2%98%EF%BC%88%E5%8F%A3%E8%83%A1%EF%BC%89/)\n>\n> 解一下方程就能得到从$i$个球在到$0$个球之前到$s$个球的概率为$\\frac{i}{s}$，因此期望步数就为$\\frac{i}{s}$\n>\n> 或者也可以这么理解：只有$\\frac{i}{s}$的概率到达的后续状态是合法的\n>\n> 仔细思考一下，这个期望与平时所求的期望不同的本质原因是，这个期望的初始状态和终止状态比较奇怪，可能到达一些不合法的状态，这才导致了产生贡献的期望不同\n\n化简一下得到\n$$\n2f[i] = f[i - 1] + f[i + 1] + \\frac{s-1}{s-i}\n$$\n边界情况：\n$$\n\\begin{aligned}\nf[1] - f[2] &= -f[1] + 1\\\\\\\\\nf[s] &= 0\n\\end{aligned}\n$$\n按照套路化一下\n$$\n\\begin{aligned}\nf[i] - f[i + 1] &= f[i - 1] - f[i] + \\frac{s-1}{s-i}\\\\\\\\\n&=-f[1] + \\sum_{j=1}^{i}\\frac{s-1}{s-j}\n\\end{aligned}\n$$\n继续化简得到\n$$\n\\begin{aligned}\nf[1] &= f[1] - f[s]\\\\\\\\\n&= \\sum_{i=1}^{s-1}f[i] - f[i+1]\\\\\\\\\n&= \\sum_{i=1}^{s-1}\\big(-f[1] + \\sum_{j=1}^{i}\\frac{s-1}{s-j}\\big)\\\\\\\\\n&= -\\sum_{i=1}^{s-1}f[1] + \\sum_{i=1}^{s-1}\\sum_{j=1}^{i}\\frac{s-1}{s-j}\\\\\\\\\n&= -(s-1)f[1] + \\sum_{i=1}^{s-1}\\frac{s-1}{s-i}\\cdot (s-i)\\\\\\\\\n&= (1-s)f[1] + (s-1)^2\n\\end{aligned}\n$$\n\n于是顺利得到\n$$\nf[1] = \\frac{(s-1)^2}{s}\n$$\n直接递推即能得到所有$f$，答案就是$\\sum_{i=1}^{n}f[a_i]$\n\n\n\n### Summary\n\n这道题首先要会通过剔除不必要的信息来巧妙设dp状态；一个比较难的点是中间应用赌徒破产模型那里，剩下的都是套路\n\n\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int Maxn = 1e5 + 100, Mod = 1e9 + 7;\n\nint N, S, A[Maxn], Max;\nint f[Maxn];\n\ninline int Pow (int a, int b)\n{\n\tint ans = 1;\n\tfor (int i = b; i; i >>= 1, a = (LL)a * a % Mod) if (i & 1) ans = (LL)ans * a % Mod;\n\treturn ans;\n}\n\ninline void Add (int &a, int b) { a += b; if (a >= Mod) a -= Mod; }\n\ninline void Solve ()\n{\n\tf[1] = (LL)(S - 1) * (S - 1) % Mod * Pow(S, Mod - 2) % Mod;\n\n\tfor (int i = 1; i < Max; ++i) f[i + 1] = ((2ll * f[i] - f[i - 1] - (LL)(S - 1) * Pow(S - i, Mod - 2) % Mod) % Mod + Mod) % Mod;\n\n\tint ans = 0;\n\tfor (int i = 1; i <= N; ++i) Add (ans, f[A[i]]);\n\tcout<<ans<<endl;\n}\n\ninline void Input ()\n{\n\tN = read<int>();\n\tfor (int i = 1; i <= N; ++i) A[i]= read<int>(), S += A[i], Chkmax(Max, A[i]);\n}\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"F.in\", \"r\", stdin);\n\tfreopen(\"F.out\", \"w\", stdout);\n#endif\n\tInput();\n\tSolve();\n\treturn 0;\n}\n```\n\n","categories":["Problem"],"tags":["Codeforces","动态规划","概率和期望"]},{"title":"赌徒破产问题（口胡）","url":"/2019/02/02/%E8%B5%8C%E5%BE%92%E7%A0%B4%E4%BA%A7%E9%97%AE%E9%A2%98%EF%BC%88%E5%8F%A3%E8%83%A1%EF%BC%89/","content":"\n自己推了一大版式子推烦了，索性就先只口胡一下这个思想吧。。。\n\n<!--more-->\n\n别人的文章：[Link1](https://blog.csdn.net/solotzg/article/details/48655355)  [Link2](https://blog.csdn.net/newsonglin/article/details/79963856)  [Link3](https://blog.csdn.net/u014609452/article/details/52984691)\n\n## Description\n\n其实并不知道这个模型到底叫什么，网上好像有个这种叫法就暂且这么叫它吧\n\n这类问题一般都是一个这样的模型：\n\n> 一个赌徒一开始有$h$枚金币，每次有$p$的概率获得一枚金币或$(1-p)$的概率丢掉一枚金币，若他的金币多于$T$（赚够收手获胜）或者少于$S$（破产）则游戏结束，求他在破产前（在多于$S$的前提下）获胜（达到$T$）的概率\n\n\n\n## Solution\n\n设$f[i]$表示当前收益为$i$时刻的条件下能最终获胜的概率，则显然有转移方程：\n$$\nf[i] = p\\cdot f[i + 1] + (1-p)\\cdot f[i - 1]\n$$\n不难发现这实际上就是一个二阶常系数线性齐次递推式，运用高中课内知识我们可以知道它的特征方程是：\n$$\nx^2 - \\frac{1}{p}x + \\frac{1-p}{p} = 0\n$$\n它有两个特征根：$x_1 = 1, x_2 = \\frac{1-p}{p}$，于是我们能够得到它的通解为（$p=\\frac{1}{2}$有重根时需要特殊处理一下）：\n\n$f[n] = c_1(\\frac{1-p}{p})^n + c_2$\n\n然后再根据已知条件，一般是与题中$S,T$相关的信息（如$f[S] = 0, f[T] = 1$之类的关系）求出$c_1, c_2$，从而求出$f[n]$\n\n\n\n19.3.5 UPD\n\n今天翻出这篇文章，想着还是补一下这个比较通用的结论：\n\n> 初始点为$x$，在数轴区间$[a,b],x\\in [a, b]$上随机游走，每次往左右概率均等，走到$a$点或$b$点停止。\n>\n> 那么先走到$a$的概率为$\\frac{b-x}{b-a}$，先走到$b$的概率为$\\frac{x-a}{b-a}$\n\n\n\n## Problems\n\n只有口胡\n\n### SRM667 Div1 CatsOnTheCircle\n\n#### Description\n\n$N$只猫围成一圈玩游戏，顺时针编号$0$到$N-1$，$N-1$与$0$相邻。游戏规则如下：\n\n* 一开始编号$0$的猫拿着一个球\n\n* 每个回合中手里拿球的猫抛硬币，该硬币有$\\frac{P}{10^9}$的概率正面朝上，$(1-\\frac{P}{10^9})$的概率反面朝上\n\n* 如果硬币正面朝上，则该猫 $j$ 把球传给编号为$(j+1) \\% N$的猫，否则传给编号为$(j-1+N)\\%N$的猫\n\n* 该游戏持续进行直到每只猫至少拿到一次球。且最终拿球的猫赢得游戏\n\n给定$N, K, P$，求编号为$K$的猫赢得游戏的概率\n\n#### Analysis\n\n通过观察发现，如果最后是猫$K$拿到球，那么上一轮一定是$K-1$号猫或者$K+1$号猫拿球，且除了$K$号猫之外所有的猫都拿过球，所以答案就是$P(K+1 | K-1) + P(K-1 | K + 1)$\n\n不难发现这实际上就是把上述模型的上下边界调整了一下，直接上模型即可\n\n\n\n### 51nod 1563 夹克赌坊\n\n题意都懒得放了，只不过是分了两段的赌徒破产问题，这样就会有两个特征方程，即要求出$c_1, c_2, d_1, d_2$\n\n因此在题目中多隐藏了两个条件，即在分段函数临界处有两个等量关系\n\n还是利用这些等量关系暴力推系数即可","categories":["Algorithm"],"tags":["概率和期望","特征方程","赌徒破产问题"]},{"title":"「HDU4336」Card Collector - 期望 + Min-Max容斥","url":"/2019/02/01/%E3%80%8CHDU4336%E3%80%8DCard-Collector-%E6%9C%9F%E6%9C%9B-Min-Max%E5%AE%B9%E6%96%A5/","content":"\n有$n$种卡片，第$i$种出现的概率为$p_i$（$\\sum p_i$不一定为$1$），问收集所有卡片的期望次数\n\n$n\\le 20$\n\n<!--more-->\n\n### Links\n\n[HDU4336](http://acm.hdu.edu.cn/showproblem.php?pid=4336)\n\n### Solution & Code\n\n傻逼题，有两种做法：\n\n#### 暴力Dp\n\n$dp[i]$表示从集合$i$开始的期望次数，直接枚举下一个没在当前集合中出现的元素$y$，设$j = i \\And y$，用$No$表示没有抽中卡片的概率（即$1 - \\sum_{i=1}^{n} p_i$）那么很显然有方程：\n$$\ndp[i] = \\sum dp[j]p_y + dp[i](\\sum_{z\\in i}p_z + No) + 1\n$$\n化简得到\n$$\ndp[i] = \\frac{\\sum dp[j]p_y + 1}{1 - \\sum_{z\\in i}p_z - No}\n$$\n写得好看一点就是\n$$\ndp[i] = \\frac{\\sum dp[j]p_y + 1}{\\sum p_y}\n$$\n答案就是$dp[0]$\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int Maxn = 20 + 5, Maxs = (1 << 20) + 100;\n\nint N;\ndouble P[Maxn], Dp[Maxs], No;\n\ninline void Solve ()\n{\n\tmemset(Dp, 0, sizeof Dp);\n\tint ALL = (1 << N) - 1;\n\n\tfor (int state = ALL - 1; state >= 0 ; --state)\n\t{\n\t\tdouble sum = 0;\n\n\t\tfor (int i = 1; i <= N; ++i)\n\t\t{\n\t\t\tif ((1 << (i - 1)) & state) { sum += P[i]; continue;}\n\t\t\tint to = state | (1 << (i - 1));\n\t\t\tDp[state] += Dp[to] * P[i];\n\t\t}\n\n\t\t++Dp[state];\n\t\tDp[state] /= (1 - sum - No);\n\t}\n\tprintf(\"%.5lf\\n\", Dp[0]);\n}\n\ninline void Input ()\n{\n\tNo = 0;\n\tfor (int i = 1; i <= N; ++i) scanf(\"%lf\", &P[i]), No += P[i];\n\tNo = 1 - No;\n}\n\nint main()\n{\n#ifdef hk_cnyali\n\tfreopen(\"A.in\", \"r\", stdin);\n\tfreopen(\"A.out\", \"w\", stdout);\n#endif\n\twhile (scanf(\"%d\", &N) != EOF)\n\t{\n\t\tInput();\n\t\tSolve();\n\t}\n\treturn 0;\n}\n\n```\n\n\n\n#### Min-Max容斥\n\n用$Min-Max$容斥的套路，将集合内最后一个元素出现的期望次数转化为求这个集合中最早出现的元素的期望次数，即\n$$\nE(\\max\\{ALL\\})=\\sum_\\limits{S\\in ALL, S \\ne \\emptyset}(-1)^{|S+1|}E(\\min\\{S\\})\n$$\n用和之前dp类似的推式子的方法可以得到$E(\\min\\{S\\})=\\frac{1}{\\sum\\limits_{i\\in S}p_i}​$\n\n直接dfs搜子集即可\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int Maxn = 20 + 5;\n\nint N;\ndouble P[Maxn], ans;\n\ninline void dfs (int x, double sum, int op)\n{\n\tif (x == N) { if (sum > 1e-7) ans += op / sum; return ; }\n\tdfs(x + 1, sum + P[x + 1], -op);\n\tdfs(x + 1, sum, op);\n}\n\ninline void Solve ()\n{\n\tans = 0;\n\tdfs(0, 0, -1);\n\tprintf(\"%.6lf\\n\", ans);\n}\n\ninline void Input ()\n{\n\tfor (int i = 1; i <= N; ++i) scanf(\"%lf\", &P[i]);\n}\n\nint main()\n{\n#ifdef hk_cnyali\n\tfreopen(\"A.in\", \"r\", stdin);\n\tfreopen(\"A.out\", \"w\", stdout);\n#endif\n\twhile (scanf(\"%d\", &N) != EOF)\n\t{\n\t\tInput();\n\t\tSolve();\n\t}\n\treturn 0;\n}\n\n```\n\n","categories":["Problem"],"tags":["动态规划","状态压缩","概率和期望","Min-Max容斥"]},{"title":"「CF908D」New Year and Arbitrary Arrangement - 期望 + 动态规划","url":"/2019/02/01/%E3%80%8CCF908D%E3%80%8DNew-Year-and-Arbitrary-Arrangement-%E6%9C%9F%E6%9C%9B-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","content":"\n给出正整数$p_a,p_b,k$\n\n一开始有一个空串，每一次有$\\frac{p_a}{p_a+p_b}$的概率在末尾加入$a$，$\\frac{p_b}{p_a+p_b}$的概率在串末尾加入$b$\n\n当串中存在$k$个子序列$ab$时停止，求停止时子序列$ab$个数的期望，答案对$10^9+7$取模\n\n$k \\le 1000$\n\n<!--more-->\n\n### Links\n\n[CF908D](http://codeforces.com/problemset/problem/908/D)\n\n### Solution\n\n> 注：以下所有的$p_a$表示原题中的$\\frac{p_a}{p_a+p_b}$，$p_b $表示 $\\frac{p_b}{p_a+p_b}$\n\n显然子序列$ab$的个数只与当前已经有多少个$a$和已经出现的子序列$ab$的个数有关\n\n那么首先有一个很简单的dp：$dp[i][j]$表示已经出现了$i$个$a$，$j$个子序列$ab$，到结束时子序列$ab$个数的期望。\n\n考虑往后加的是$a$还是$b$，很容易得到转移方程：\n$$\ndp[i][j] = dp[i + 1][j] * p_a + dp[i][i + j] * p_b\n$$\n\n但是我们会发现终止状态，也就是边界情况并不好处理，因为这个dp会无限进行下去\n\n仔细思考一下，使得它无限进行下去的原因是这样一种情况：到后面$a$的个数很多但$b$很少，可能加上一个$b$就会停止了，但一直加的是$a$\n\n再提炼一下，发现就是当$i+j\\ge k$时很不好考虑\n\n因此我们对于$i+j\\ge k$时，直接计算$dp$值，因为此时只要再添一个$b$就能终止\n\n设$S = dp[i][j](i+j\\ge k)$，考虑这个$b$什么时候被添上，那么就有：\n$$\n\\begin{aligned}\nS &= (i + j)p_b + (i + j + 1)p_ap_b + (i+j+2)p_a^2p_b+...\\\\\\\\\n&=p_b\\sum_{x=0}^{\\infty}(i+j+x)p_a^x\n\\end{aligned}\n$$\n\n等比数列求和一下得到\n$$\nS = i + j + \\sum_{x = 1}^{\\infty}p_a^x\n$$\n其中$\\sum_{x=1}^{\\infty}p_a^x$就j是无穷等比数列求和，不难发现它就是$\\frac{p_a^{\\infty} - p_a}{1 - p_a} = \\frac{p_a}{p_a - 1} = \\frac{p_a}{p_b}$\n\n所以当$i+j\\ge k$时，$dp[i][j] = i + j + \\frac{p_a}{p_b}$\n\n### Summary\n\n在dp边界是$\\infty$时可以考虑把后面的某些dp值根据其具体意义直接计算\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int Maxn = 1e3 + 100, Mod = 1e9 + 7;\n\nint Pa, Pb, K, Div;\n\ninline int Pow (int a, int b)\n{\n\tint ans = 1;\n\tfor (int i = b; i; i >>= 1, a = (LL)a * a % Mod) if (i & 1) ans = (LL)ans * a % Mod;\n\treturn ans;\n}\n\nint Dp[Maxn][Maxn];\n\ninline int get_dp (int i, int j)\n{\n\tif (i + j >= K) return (i + j + Div) % Mod;\n\tif (Dp[i][j]) return Dp[i][j];\n\treturn Dp[i][j] = ((LL)get_dp (i + 1, j) * Pa % Mod + (LL)get_dp (i, i + j) * Pb % Mod) % Mod;\n}\n\ninline void Solve ()\n{\n\tprintf(\"%d\\n\", get_dp(1, 0));\n}\n\ninline void Input ()\n{\n\tK = read<int>(), Pa = read<int>(), Pb = read<int>();\n\tPa = (LL)Pa * Pow(Pa + Pb, Mod - 2) % Mod;\n\tPb = (1 - Pa + Mod) % Mod;\n\tDiv = (LL)Pa * Pow(Pb, Mod - 2) % Mod;\n}\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"D.in\", \"r\", stdin);\n\tfreopen(\"D.out\", \"w\", stdout);\n#endif\n\tInput();\n\tSolve();\n\treturn 0;\n}\n\n```\n\n","categories":["Problem"],"tags":["Codeforces","动态规划","概率和期望"]},{"title":"「HDU4652」Dice - 期望 + 动态规划","url":"/2019/01/31/%E3%80%8CHDU4652%E3%80%8DDice-%E6%9C%9F%E6%9C%9B-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%20/","content":"\n有一个$m$面的骰子，不停地掷骰子，求以下两种情况的期望步数：\n\n1. 连续出现$n$个相同的时候停止\n2. 连续出现$n$个不同的时候停止\n\n$n,m\\le 10^6$\n\n<!--more-->\n\n### Links\n\n[HDU4652](http://acm.hdu.edu.cn/showproblem.php?pid=4652)\n\n### Solution\n\n首先很容易设出一个dp：$f[i]$表示连续出现$i$个相同时的期望步数，$g[i]$表示连续出现$i$个不同时的期望步数\n$$\nf[i] = \\frac{1}{m}f[i + 1] + \\frac{m-1}{m}f[1] + 1\\\\\ng[i] = \\frac{m-i}{m}g[i + 1] + \\frac{1}{m}\\sum_{j=1}^{i}g[j] + 1\n$$\n有两种比较套路的处理方法（其实也很容易想到，这里只详细说明$f$的求法，$g$类似）：\n\n* 差分：\n  $$\n  f[i + 1] - f[i + 2] = m(f[i] - f[i + 1])\n  $$\n  特别地，\n  $$\n  \\begin{aligned}\n  &f[0] = \\frac{1}{m}f[1] + \\frac{m-1}{m}f[1] + 1\\\\\n  \\Rightarrow &f[0] - f[1] = 1\n  \\end{aligned}\n  $$\n  所以我们有：\n  $$\n  \\begin{aligned}\n  f[0] -& f[1] = 1\\\\ \\\\\n  f[1] -& f[2] = m\\\\ \\\\\n  f[2] -& f[3] = m^2\\\\\\\\\n  &...\\\\\\\\\n  f[n - 1] - &f[n] = m^{n-1}\n  \\end{aligned}\n  $$\n  对上述式子求和可以得到：\n  $$\n  f[0] - f[n] = \\sum_{i=0}^{n-1}m^i\n  $$\n  因为$f[n] = 0$，所以直接得到$f[0] = \\sum_\\limits{i=0}^{n-1}m^i$，这个也可以用等比数列求和随便化一下，不过$g$的式子化不了\n\n* 把所有状态都用$f[0]$表示\n\n  其实这个做法和差分本质是一样的，直接代入即可，这里就不赘述了\n\n\n\n### Summary\n\n当dp方程中出现一些比较难处理的，与$i$无关的项的时候可以考虑差分将其抵消，推导出差分的关系，再通过求和计算\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nint N, M, op;\n\ninline void Solve ()\n{\n\tif (!op)\n\t{\n\t\tLL ans = 0;\n\t\tfor (int i = 0; i <= N - 1; ++i) ans += pow(M, i);\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\telse\n\t{\n\t\tdouble ans = 0, sum = 1;\n\t\tfor (int i = 0; i <= N - 1; ++i)\n\t\t{\n\t\t\tsum = sum * M / (M - i);\n\t\t\tans += sum;\n\t\t}\n\t\tprintf(\"%.7lf\\n\", ans);\n\t}\n}\n\ninline void Input ()\n{\n\tscanf(\"%d%d%d\", &op, &M, &N);\n}\n\nint main()\n{\n#ifdef hk_cnyali\n\tfreopen(\"A.in\", \"r\", stdin);\n\tfreopen(\"A.out\", \"w\", stdout);\n#endif\n\tint Testcase;\n\twhile (scanf(\"%d\", &Testcase) != EOF)\n\t{\n\t\twhile (Testcase--)\n\t\t{\n\t\t\tInput();\n\t\t\tSolve();\n\t\t}\n\t}\n\treturn 0;\n}\n\n```\n\n>  $P.S.$这道题不知道为什么用`read <int>()`就会`T`，改成`scanf`就A了...","categories":["Problem"],"tags":["动态规划","概率和期望"]},{"title":"WC2019游记","url":"/2019/01/31/WC2019%E6%B8%B8%E8%AE%B0/","content":"\n冬眠体验较好\n\n<!--more-->\n\n### 讲课\n\n基本上什么都听不懂，Day1的时候去第二课堂混了下，好像也没太多意义，后面就干脆在第一课堂冬眠了\n\n第一课堂有桌子~~可以搞颓~~好评\n\n去看了文艺汇演，结果出了点小事故，问题比较敏感就不做评论了，具体情况可以上知乎了解\n\n\n### 考试\n\n第一次考`WC`，也是第一次以正式选手的身份参加除了`NOIp`之外的`CCF NOI`系列赛事\n\n考试之前居然不能敲配置，开考后花了15mins才把配置敲完\n\n先大概看了下三道题：T1T2似乎有很多暴力分啊，T3好像连暴力都不会啊\n\n先花了`40mins`左右的时间把T1`48pts`的暴力写了，然后就开始刚T2\n\nT2这个checker真的有毒，玩了半个多小时才搞清楚怎么用，接着一路把5个`Subtask`的暴力都写了。`Subtask2`因为没有发现`jmp val`的`val`可以为一个变量，于是只写了最暴力的暴力\n\n最后`1`h左右的时候想了一下T3，`Subtask1`和`Subtask3`似乎都有点想法，但是还是不会。。。\n\n当时权衡了一下，放弃了T3，去写T2`Subtask2`的二分，一直调到下考前`10mins`才调出来，结果最后还是挂了（我记得我当时还测了一下0的情况啊。。。）\n\n查分：$48+52+0=100$\n\n最后拿了OI生涯第一块`Ag`，不知道重测之后自己的分数有没有变化。。。\n\n`Ag`线似乎是88，`Au`线似乎是125，为什么分数线这么低啊。。。暴力写满$48+66+31=145$就有`Au`了\n\n而且T3的$7N$做法也并没有那么难，这种题想不出来只能说明自己智商不够，果然这次WC的区分度就在T3，T3有分基本就`Au`了\n\n### Summary\n\n有一点点遗憾T3没能拿分，与`Au`失之交臂。这次考试反映出的一些问题：\n\n1. 题面很长的时候一定要静下心来读题，把细节都看清楚，不要再出现T2白白丢掉20分的这种情况\n2. 要珍惜平时训练交互题的机会，逼自己写暴力、找性质，提高智商。。。\n\n","categories":["Summary"],"tags":["Summary","OI历程"]},{"title":"「THUSC 2016」补退选 - Trie + 暴力","url":"/2019/01/26/%E3%80%8CTHUSC-2016%E3%80%8D%E8%A1%A5%E9%80%80%E9%80%89-Trie-%E6%9A%B4%E5%8A%9B/","content":"\n有$n$个事件，每次给出$S$：\n\n1. 在当前字符串集中加入$S$\n2. 在当前字符串集中删去$S$\n3. 查询最早在哪个事件之后，$S$为前缀的字符串数量超过了$v$\n\n强制在线\n\n$n\\le 10^5, |S|\\le 60$\n\n<!--more-->\n\n### Links\n\n[LOJ2291](https://loj.ac/problem/2291)\n\n### Solution\n\n一开始还以为要二分答案，后面发现直接在`Trie`上模拟，对于每个节点维护一个`vector`暴力记录答案即可\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> T read ()\n{\n    T sum = 0, fl = 1; char ch = getchar();\n    for (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n    for (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n    return sum * fl;\n}\n\ninline void proc_status()\n{\n    ifstream t (\"/proc/self/status\");\n    cerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) <<endl;\n}\n\nconst int Maxn = 1e5 + 100;\n\nint N, M;\n\nint node_cnt = 1;\nstruct info\n{\n    int ch[27], cnt; \n\tvector <int> p;\n}node[Maxn * 40];\n\nstruct TRIE\n{\n\n    inline void insert (char *S, int op, int id)\n    {\n        int n = strlen(S), now= 1;\n        for (int i = 0; i < n; ++i)\n        {\n\t\t\tint x = S[i] - 'a';\n\t\t\tif (!node[now].ch[x]) node[now].ch[x] = ++node_cnt;\n\t\t\tnow = node[now].ch[x];\n\t\t\tnode[now].cnt += op;\n\t\t\tif (node[now].cnt > node[now].p.size()) node[now].p.pb(id);\n        }\n    }\n\n\tinline int query (char *S, int times)\n\t{\n\t\tint n = strlen(S), now = 1;\n\t\tfor (int i = 0; i < n; ++i) now = node[now].ch[S[i] - 'a'];\n\t\tif (!now || node[now].p.size() <= times) return -1;\n\t\treturn node[now].p[times];\n\t}\n\n} T;\n\ninline void Solve ()\n{\n\tint ans = 0;\n\tfor (int id = 1; id <= M; ++id)\n\t{\n\t\tint op = read<int>(); \n\t\tchar S[100]; scanf(\"%s\", S);\n\n\t\tif (op <= 2) T.insert(S, op == 1 ? 1 : -1, id);\n\t\telse\n\t\t{\n\t\t\tint a = read<int>(), b = read<int>(), c = read<int>();\n\t\t\tint sum = ((LL)a * abs(ans) + b) % c;\n\t\t\tans = T.query (S, sum);\n\t\t\tprintf(\"%d\\n\", ans);\n\t\t}\n\t}\n}\n\ninline void Input ()\n{\n\tM = read<int>();\n}\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n    freopen(\"A.in\", \"r\", stdin);\n    freopen(\"A.out\", \"w\", stdout);\n#endif\n    Input();\n    Solve();\n    return 0;\n}\n```\n\n","categories":["Problem"],"tags":["暴力","Trie"]},{"title":"PKUWC2019酱油记","url":"/2019/01/25/PKUWC2019%E9%85%B1%E6%B2%B9%E8%AE%B0/","content":"\n真的是去打酱油的。。。\n\n<!--more-->\n\n### Day0\n\n翻了翻之前做的`PKUWC2018`的题，看了下`PKUSC2018`的题，回忆了一些算法就睡了。睡得很早。\n\n\n\n### Day1\n\n12：50才进考场差评\n\n开场5mins我还在敲配置的时候就看到旁边那位老哥切掉了T1。。。\n\nT1花了我一个小时才想出来吧，不过写完就直接A了。\n\n剩下两道题一分都没拿，不会虚树导致T2一分都没拿到\n\n于是`Day1`就$100+0+0=100$滚粗了，大众分$200$\n\n\n\n### Day2\n\n数学考试一拿到题就蒙了，9道题答+1道平面几何\n\n就prufer序和状压这两道题写了下，其他基本都是找规律/蒙的，平面几何花了太多时间。期望得分$27-47$\n\n下午考试就只拿了三个暴力分，花了将近4h去写T1的$Subtask2$，没调出来，滚粗。\n\nT2基本没看，T3计算几何本来也只会暴力，结果这两道题全tm是结论题。。。\n\n`Day2`得分$22+21+11=54$\n\n两天总得分$200$都没上，当然没有面试资格，实在是太菜了 \n\n\n\n### Summary\n\n这次`PKUWC`算是出来见了见世面，发现自己真的是很菜很菜\n\n借此机会总结一下学习过程中的一些问题：\n\n1. 现在开始不能再刷水题了，要多去想难题，多思考，哪怕是部分分，不要一看到难题就放弃\n2. 学算法不要囫囵吞枣，每个算法都要理解它的来龙去脉，要先自己想一想这个算法的经典题怎么做，多思考之后再去学算法。把学算法当成做题一样去对待。并且学完之后尽量先自己按照自己的思路写代码，写完之后再看别人的写法\n3. 考试的时候不要讨论，有的题可能别人点一下就会了，但这对自己的能力没有任何提升作用\n4. 多刷题！！！","categories":["Summary"],"tags":["Summary","OI历程"]},{"title":"斜率优化学习笔记","url":"/2019/01/17/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"\n关于斜率优化这个玄学东西一些自己的~~bb~~理解（似乎和网上的理解方法都不太一样？）\n\n<!--more-->\n\n\n\n# **分割线以下写的东西都是假的 不要看！！！**\n\n## UPD 19-8-11 最一般的斜率优化\n\n$$dp[i] = \\min_{j < i}\\{a[i] * b[j] + c[i] + d[j]\\}$$\n\n保证$a[],b[]$都**单调递增**（不管$a[]$本身是不是单增，都可以通过移项变成单增形式）\n\n考虑两个决策$j,k$,且$j < k$，若$j$比$k$优，那么式子最终会化成\n$$\n\\frac{d[j] - d[k]}{b[j] - b[k]} ~?~a[i]\n$$\n其中$?$处可能是$>$，也可能是$<$\n\n斜率优化的本质是利用决策单调性，即在某时刻决策$j$比$k$优，那么在之后的任何时刻都要满足$j$比$k$优\n\n又因为$a[i]$单增，因此这里必须是$<$。如果为$>$的话，要把限制条件`j比k优`改成`k比j优`\n\n对于这两种不同的限制条件，需要用不同的数据结构维护：\n\n* $j < k$，且$j$比$k$优：单调栈（弹后面）\n* $j < k$，且$k$比$j$优：单调队列（弹队首）\n\n> 因为要把更劣的决策弹掉\n\n再考虑要维护上凸壳还是下凸壳：\n\n* 单调栈：弹后面，因此要满足斜率单降，上凸壳\n* 单调队列：弹队首，因此要满足斜率单增，下凸壳\n\n> 以单调栈为例：\n>\n> ![19-8-11-2](/images/19-8-11-2.png)\n>\n> 红色的线代表上面的$a[i]$，它自下而上单增\n>\n> 左边是斜率单减，右边单增\n>\n> 如果是右边的情况，斜率单增的话，那么只有在最上面那根线的时候才会一次性把栈里的东西弹掉，显然不行\n>\n> （注意这里是如果当前直线满足的话，就把该直线下面的所有点都弹掉）\n\n\n\n总结一下流程：\n\n设$j < k$化式子，保证$a[i]$单增\n\n* $j$比$k$优$\\rightarrow$单调栈$\\rightarrow$上凸壳\n* $k$比$j$优$\\rightarrow$单调队列$\\rightarrow$下凸壳\n\n\n\n---\n\n### 基本形式\n\n$$\ndp[i] = \\min_{j < i}\\{a[i] * b[j] + c[i] + d[j]\\}\n$$\n\n\n\n其中$b$具有单调性（假设$b$单增）\n\n假设我们有两个决策$j,k(k < j)$，且对于$i$而言，在$j$的决策比$k$优，那么有\n$$\n\\begin{aligned}\n&a[i] * b[j] + c[i] + d[j] < a[i]*b[k] + c[i] + d[k]\\\\\\\\\n\\Rightarrow &a[i](b[j] - b[k]) < d[k] - d[j]\\\\\\\\\n\\Rightarrow &\\frac{d[k] - d[j]}{b[j] - b[k]} > a[i]\\\\\\\\\n\\Rightarrow &\\frac{d[j] - d[k]}{b[j] - b[k]} < -a[i]\n\\end{aligned}\n$$\n不难发现，如果$j,k$满足这个条件的话，那么$j$的决策比$k$优\n\n记$Slope(j, k) = \\frac{d[j] - d[k]}{b[j] - b[k]}$，把$b$看作横坐标，$d$看作纵坐标。\n\n因为当前的$-a[i]$是固定的，所以对于某一个决策$k$而言，如果某个在它后面的决策$j$比它优，在图像上来看就是$j$点在`斜率为-a[i]，且过k点的直线(也就是下图中的红色直线)`的下方\n\n![19-1-17-1](/images/19-1-17-1.png)\n\n继续观察发现，对于像$j_2$这种不在下凸壳上的点，无论$-a[i]$为多少，它一定不会是最优决策\n\n>  证明：\n>\n> 1. 若$j_2$决策比$k$劣那显然$j_2$不是最优\n> 2. 若$j_2$决策比$k$优（即上图所示情况），则$j_3$的决策一定比$j_2$优，因此$j_2$肯定不为最优\n\n因此，最优解一定出现在下凸壳上，我们可以用单调栈维护凸壳\n\n但是，下凸壳上的哪个点才是最优的呢？\n\n不难发现，最优解$x$一定满足$Slope(x - 1, x) < -a[i]$且$Slope(x + 1, x) > -a[i]$\n\n也就是说，$-a[i]$刚好夹在它与前后两个点的斜率之间\n\n> 通过图像感性理解，其实就是把一条斜率为$-a[i]$的直线从无穷小处移过来，于凸壳第一个相交的点\n>\n> 因为这个点往左/右走的话，斜率一定会分别变小/变大，而这两种情况都会使得答案更劣，于是这个交点就是最优解\n\n特别地，如果$-a[i]$单调递增，可以直接用单调队列维护，直接把队首小于$-a[i]$的不断弹出即可\n\n否则就必须在单调栈上二分查找\n\n### 乱bb一些东西\n\n自己理解来看，斜率优化在优化dp转移时，主要是两个部分。首先根据斜率的一些性质建立出凸壳，去掉了很多不需要的转移，并且使得有用的转移是斜率单调的。然后对于每次转移，就只需要在凸壳上二分斜率，或是直接维护单调队列，用指针扫一下即可。\n\n这段东西都是自己瞎bb的，要是理解错了就gg了。。。\n\n### 更一般的情况\n\n上面的式子中，如果$b[i]$也不单调的话，就需要用`Splay`维护动态凸包/CDQ分治优化解决了\n\n一般来说直接写分治会更加简便灵活，这个东西也类似于一个三维偏序，一维下标要满足$j<i$；一维$b[]$要满足在静态的时候单增；还有一维是斜率$-a[i]$\n\n与分治有关的部分在[这里](https://hk-cnyali.com/2019/01/10/%E5%88%86%E6%B2%BB%E6%80%9D%E6%83%B3%E5%B0%8F%E7%BB%93/)也提到过，这里就重点写下计算贡献的过程\n\n考虑用$[l,mid]$中求出的dp值去更新$[mid+1,r]$的dp值： \n\n由于这个子问题已经是静态的了，顺序对此时的贡献是没有影响的，于是可以直接排序 \n\n对于$[l,mid]$中的所有决策点按$b[]$排序，可以线性构造出这个凸壳 \n\n再对$[mid+1,r]$中的状态按斜率排序，这样又能线性在凸壳中找到最优点\n\n总复杂度$O(n\\log^2 n)$，写归并排序的话是$O(n\\log n)$的\n","categories":["Algorithm"],"tags":["动态规划","斜率优化"]},{"title":"Atcoder Educational DP Contest","url":"/2019/01/16/Atcoder-Educational-DP-Contest/","content":"\n全都是`普及+`的傻逼dp题，但是自己dp能力实在太弱，就都去写了一下。。。\n\n下面是一些稍微没有那么傻逼的题，然后自己对dp的一些思考就放在了[这里](https://hk-cnyali.com/Debug)（我dp真的刚入门）\n\n<!--more-->\n\n### F\n\n#### Description\n\n求两个串的LCS并输出方案\n\n$n\\le 3000$\n\n#### Solution\n\n以前没仔细想过如何输出方案，于是调了半天才过。。。\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\n\ninline void proc_status()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) <<endl;\n}\n\ntemplate <typename T> T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\nconst int Maxn = 3000 + 100;\n\nint N, M, Dp[Maxn][Maxn];\nchar S[Maxn], T[Maxn];\n\nstack <char> Stack;\n\ninline void Solve ()\n{\n\tfor (int i = 1; i <= N; ++i)\n\t\tfor (int j = 1; j <= M; ++j)\n\t\t{\n\t\t\tDp[i][j] = max(Dp[i - 1][j], Dp[i][j - 1]);\n\t\t\tif (S[i] == T[j]) Chkmax(Dp[i][j], Dp[i - 1][j - 1] + 1);\n\t\t}\n\tint tmp = Dp[N][M];\n\tfor (int i = N; i >= 1; --i)\n\t\tfor (int j = M; j >= 1; --j)\n\t\t{\n\t\t\tif (S[i] == T[j] && Dp[i][j] == tmp)\n\t\t\t{\n\t\t\t\t--tmp, Stack.push(S[i]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\twhile (!Stack.empty()) printf(\"%c\", Stack.top()), Stack.pop();\n}\n\ninline void Input ()\n{\n\tscanf(\"%s\", S + 1); scanf(\"%s\", T + 1);\n\tN = strlen(S + 1), M = strlen(T + 1);\n}\n\nint main()\n{\n#ifdef hk_cnyali\n\tfreopen(\"F.in\", \"r\", stdin);\n\tfreopen(\"F.out\", \"w\", stdout);\n#endif\n\tInput();\n\tSolve();\n\treturn 0;\n}\n\n```\n\n\n\n### J\n\n#### Description\n\n有$n$个盘子，第$i$个盘子里有$a_i(1\\le a_i\\le 3)$个寿司，重复以下操作直至所有寿司都被拿完：\n\n* 等概率选择一个盘子，如果盘子里有寿司则吃掉一个，否则什么也不做\n\n问吃掉所有寿司的期望操作次数\n\n$n\\le 300$\n\n#### Solution\n\ndp时记录当前还剩一个、两个、三个的盘子分别有多少，记搜即可\n\n```cpp\ninline double Calc (int i, int j, int k)\n{\n\tif (Dp[i][j][k]) return Dp[i][j][k];\n\tif (i + j + k == 0) return 0;\n\tdouble ans = 1;\n\tif (i) ans += Calc(i - 1, j, k) * i / N;\n\tif (j) ans += Calc(i + 1, j - 1, k) * j / N;\n\tif (k) ans += Calc(i, j + 1, k - 1) * k / N;\n\tif (i + j + k != N) ans *= 1.0 * N / (1.0 * i + j + k);\n\treturn Dp[i][j][k] = ans;\n}\n\n```\n\n\n\n### K\n\n简单博弈题，懒得放题意了\n\n对于一个局面，只要它能够走到必败态它就是必胜态\n\n暴力做法的话在转移的时候要先拓扑排序处理一下\n\n\n\n### L\n\n也懒得放题意了，区间dp模板题\n\n我的暴力做法调了大半天，转移的细节需要稍微注意一下\n\n\n\n### O\n\n#### Description\n\n给一张每边$n$个点的二分图，求完美匹配数量\n\n$n\\le 21$\n\n#### Solution\n\n$dp[i][state]​$表示左边前$i​$个人匹配右边$state​$状态的方案数，直接转移\n\n\n\n### R\n\n#### Description\n\n求一个$n$个点的有向图长度为$k$的不同路径数量对$10^9+7$取模\n\n$n\\le50, k\\le 10^{18}$\n\n#### Solution\n\n矩阵快速幂优化\n\n\n\n### S\n\n数位dp模板题\n\n以前没怎么写过数位dp，它的套路是在记搜的时候记录一下当前有没有卡在上界，以此决定后面能填的最高为是多少\n\n```cpp\ninline int get_dp (int x, int sum, int limit)\n{\n\tif (!limit && Vis[x][sum]) return Dp[x][sum];\n\tif (x == N + 1) { if (!sum) return 1; return 0; }\n\n\tint Max = limit ? A[x] : 9, ans = 0;\n\tfor (int i = 0; i <= Max; ++i)\n\t\tAdd (ans, get_dp (x + 1, (sum + i) % D, limit && i == Max));\n\n\tif (!limit) Dp[x][sum] = ans, Vis[x][sum] = 1;\n\treturn ans;\n}\n```\n\n\n\n### T\n\n经典套路，和[地精部落](https://hk-cnyali.com/2018/09/27/%E3%80%8CSDOI2010%E3%80%8D%E5%9C%B0%E7%B2%BE%E9%83%A8%E8%90%BD-Dp/)类似\n\n\n\n### U\n\n枚举子集/超集技巧：\n\n```\nfor (int sub = state; sub; sub = (sub - 1) & state)\nfor (int super = state; super <= ALL; super = (super + 1) | state)\n```\n\n\n\n### V\n\n直接dp，在从父亲向儿子转移时因为模数不是质数不能除，所以要记录前后缀积转移\n\n\n\n### W\n\n#### Description\n\n有$m$个区间$[l_i, r_i]$，每个价值为$a_i$\n\n对于一个长度为$n$的01串，如果1在$[l_i, r_i]$中至少出现一次，则区间会对答案产生$a_i$的贡献\n\n求所有01串中答案的最大值\n\n#### Solution\n\n考虑一个区间，我们只在它里面最右边那个1的位置计算它的贡献，这样就避免了会重复计算答案的问题\n\n设$dp[i]$位为1时，前$i$位的最大价值和\n\n$dp[i] = \\max_{j < i}dp[j]$\n\n对于一个区间，我们在经过它右端点的时候再让$[l_i, r_i]$的dp值加上$a_i$，用线段树维护即可\n\n#### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) <<endl;\n}\n\nconst int Maxn = 2e5 + 100;\n\nint N, M;\nstruct info\n{\n\tint l, r, w;\n} A[Maxn];\n\ninline int cmp (info a, info b) { return a.r < b.r; }\n\nnamespace SEG\n{\n#define mid ((l + r) >> 1)\n#define ls node[root << 1]\n#define rs node[root << 1 | 1]\n#define lson root << 1, l, mid\n#define rson root << 1 | 1, mid + 1, r\n\tstruct tree\n\t{\n\t\tLL max, tag;\n\t}node[Maxn << 2];\n\n\tinline void push_up (int root) { node[root].max = max(ls.max, rs.max); }\n\n\tinline void push_down (int root, int l, int r)\n\t{\n\t\tif (!node[root].tag) return ;\n\t\tls.tag += node[root].tag; ls.max += node[root].tag;\n\t\trs.tag += node[root].tag; rs.max += node[root].tag;\n\t\tnode[root].tag = 0;\n\t}\n\n\tinline void update (int root, int l, int r, int x, int y, LL z)\n\t{\n\t\tif (x <= l && r <= y) node[root].max += z, node[root].tag += z;\n\t\telse\n\t\t{\n\t\t\tpush_down(root, l, r);\n\t\t\tif (x <= mid) update (lson, x, y, z);\n\t\t\tif (y > mid) update (rson, x, y, z);\n\t\t\tpush_up (root);\n\t\t}\n\t}\n\n\tinline LL query (int root, int l, int r, int x, int y)\n\t{\n\t\tif (x <= l && r <= y) return node[root].max;\n\t\telse\n\t\t{\n\t\t\tpush_down(root, l, r);\n\t\t\tLL ans = 0;\n\t\t\tif (x <= mid) ans = max(ans, query (lson, x, y));\n\t\t\tif (y > mid) ans = max(ans, query (rson, x, y));\n\t\t\treturn ans;\n\t\t}\n\t}\n\n#undef mid\n#undef ls\n#undef rs\n#undef lson\n#undef rson\n}\n\ninline void Solve ()\n{\n\tsort(A + 1, A + M + 1, cmp);\n\t\n\tint j = 1;\n\tfor (int i = 1; i <= N; ++i)\n\t{\n\t\tSEG :: update (1, 1, N, i, i, SEG :: query (1, 1, N, 1, i));\n\n\t\twhile (A[j].r == i)\n\t\t{\n\t\t\tSEG :: update (1, 1, N, A[j].l, A[j].r, A[j].w);\n\t\t\t++j;\n\t\t}\n\t}\n\n\tcout<<max(0ll, SEG :: node[1].max)<<endl;\n}\n\ninline void Input ()\n{\n\tN = read<int>(), M = read<int>();\n\tfor (int i = 1; i <= M; ++i)\n\t\tA[i].l = read<int>(), A[i].r = read<int>(), A[i].w = read<int>();\n}\n\nint main()\n{\n#ifdef hk_cnyali\n\tfreopen(\"W.in\", \"r\", stdin);\n\tfreopen(\"W.out\", \"w\", stdout);\n#endif\n\tInput();\n\tSolve();\n\treturn 0;\n}\n\n```\n\n\n\n### X\n\n贪心地考虑，对于两个物品$i$、$j$而言，$i$如果在$j$前面被选，那么把$i$放$j$前面所剩的空间要比把$j$放$i$前面所剩的空间多，即$s_j - v_i > s_i - v_j$，即$s_i + v_i < s_j + v_j$\n\n按这个排序后直接dp即可\n\n\n\n### Y\n\n#### Description\n\n一个$H\\times W$的网格，上面有$n$个关键点，问从$(1,1)$走到$(H, W)$且不经过这$n$个点的方案数S（只能向下或向右走），答案对$10^9+7$取模\n\n#### Solution\n\n不难想到最简单的容斥，设$dp[i]$表示从$(1,1)$走到$x_i, y_i$且中途不经过关键点的方案数\n\n那么$dp[i] = \\binom{x_i+y_i-2}{x_i-1}\\sum_{x_j < x_i, y_j < y_i}\\binom{x_i-x_j+y_i-y_j}{x_i-x_j}\\cdot dp[j]$\n\n排个序就没了\n\n \n\n### Z\n\n斜率优化模板题，另外写一篇文章总结一下\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","categories":["Problem"],"tags":["动态规划"]},{"title":"「CF768G」The Winds of Winter - 树上启发式合并 - set","url":"/2019/01/13/%E3%80%8CCF768G%E3%80%8DThe-Winds-of-Winter-%E6%A0%91%E4%B8%8A%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6-set/","content":"\n给定一棵$n$个节点的树。\n\n对于每个点单独考虑，删掉它，你可以把一个节点的父亲改成另一个节点（只能做一次），使森林中最大的树$size$最小。对每个点求出这个答案\n\n$n\\le 10^5$\n\n<!--more-->\n\n### Links\n\n[CF768G](https://codeforces.com/contest/768/problem/G)\n\n\n\n### Solution\n\n不难发现，在点 $x$ 处计算答案时，会从最大的联通块中选择一棵子树接到最小的联通块上\n\n二分答案, 转化成区间存在性问题, 直接用`multiset`在每个点上维护子树内所有点的 $size$ 信息\n\n此外还需要单独考虑一下子树外联通块的情况，并且这个点到根的这条链上的信息也要单独维护，因为它们的$size$会减掉当前点的$size$\n\n树上启发式合并维护即可\n\n具体细节见代码\n\n\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\n\ninline void proc_status()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) <<endl;\n}\n\ntemplate <typename T> T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\nconst int Maxn = 1e5 + 100;\n\nint N;\nint e, Begin[Maxn], To[Maxn << 1], Next[Maxn << 1];\nint size[Maxn], son[Maxn], snd[Maxn], min_size[Maxn];\nint Ans[Maxn];\n\nmultiset <int> S[4];\n//S[0]: anc, S[1]: heavy, S[2]: light, S[3]: other\n\ninline void add_edge (int x, int y) { To[++e] = y; Next[e] = Begin[x]; Begin[x] = e; }\n\ninline void dfs_pre (int x)\n{\n\tsize[x] = 1, min_size[x] = 0x3f3f3f3f;\n\n\tfor (int i = Begin[x]; i; i = Next[i])\n\t{\n\t\tint y = To[i];\n\t\tdfs_pre(y);\n\t\tsize[x] += size[y];\n\t\tif (size[y] > size[son[x]]) snd[x] = size[son[x]], son[x] = y;\n\t\telse if (size[y] > snd[x]) snd[x] = size[y];\n\t\tChkmin(min_size[x], size[y]);\n\t}\n\n\tif (size[x] != N) Chkmin(min_size[x], N - size[x]);\n}\n\ninline void Modify (int x, int val, int k)\n{\n\tif (val == 1) S[k].insert(x), S[3].erase(S[3].find(x));\n\telse S[k].erase(S[k].find(x)), S[3].insert(x);\n}\n\ninline void Add (int x, int k)\n{\n\tModify (size[x], 1, k);\n\tfor (int i = Begin[x]; i; i = Next[i]) Add (To[i], k);\n}\n\ninline void Erase (int x, int k)\n{\n\tModify (size[x], -1, k);\n\tfor (int i = Begin[x]; i; i = Next[i]) Erase (To[i], k);\n}\n\ninline int Find (int Min, int Max, int l, int r, int k, int delta)\n{\n\tif (Min == Max && l <= Min && Min <= r) return Min;\n\n\tint ans = 0x3f3f3f3f;\n\twhile (l <= r)\n\t{\n\t\tint mid = l + r >> 1;\n\t\tmultiset <int> :: iterator x = S[k].lower_bound(Max - mid + delta);\n\t\tif (x != S[k].end() && (*x) <= mid - Min + delta) r = mid - 1, ans = mid;\n\t\telse l = mid + 1;\n\t}\n\treturn ans;\n}\n\ninline void Calc (int x)\n{\n\tif (!son[x]) { Ans[x] = N - size[x]; return; }\n\tif (size[x] == N || size[son[x]] > N - size[x]) // max subtree is heavy\n\t\tAns[x] = Find (min_size[x], size[son[x]], max(N - size[x], snd[x]), size[son[x]], 1, 0);\n\telse // root is in the max subtree\n\t\tAns[x] = min(Find (min_size[x], N - size[x], size[son[x]], N - size[x], 0, size[x]), \n\t\t\t\t\t Find (min_size[x], N - size[x], size[son[x]], N - size[x], 3, 0));\n}\n\nmultiset <int> :: iterator it, Save[Maxn];\n\ninline void dfs (int x, int flag)\n{\n\tModify (size[x], 1, 0);\n\n\tfor (int i = Begin[x]; i; i = Next[i])\n\t{\n\t\tint y = To[i];\n\t\tif (y != son[x]) dfs(y, 0);\n\t}\n\n\tif (son[x]) dfs(son[x], 1);\n\n\tfor (int i = Begin[x]; i; i = Next[i])\n\t{\n\t\tint y = To[i];\n\t\tif (y != son[x]) Add (y, 2);\n\t}\n\n\tS[0].erase(S[0].find(size[x]));\n\tCalc(x); \n\tS[3].insert(size[x]);\n\n\tif (flag)\n\t{\n\t\tModify(size[x], 1, 1);\n\t\tint top = 0;\n\t\tfor (it = S[2].begin(); it != S[2].end(); ++it) S[1].insert(*it), Save[++top] = it;\n\t\tfor (int i = 1; i <= top; ++i) S[2].erase(Save[i]);\n\t}\n\telse\n\t{\n\t\tfor (int i = Begin[x]; i; i = Next[i])\n\t\t{\n\t\t\tint y = To[i];\n\t\t\tif (y != son[x]) Erase (y, 2);\n\t\t\telse Erase (y, 1);\n\t\t}\n\t}\n}\n\nint root;\n\ninline void Solve ()\n{\n\tdfs_pre (root);\n\tfor (int i = 1; i <= N; ++i) S[3].insert(size[i]);\n\n\tdfs(root, 0);\n\n\tfor (int i = 1; i <= N; ++i) printf(\"%d\\n\", Ans[i]);\n}\n\ninline void Input ()\n{\n\tN = read<int>();\n\tfor (int i = 1; i <= N; ++i)\n\t{\n\t\tint x = read<int>(), y = read<int>();\n\t\tif (!x) { root = y; continue; }\n\t\tadd_edge (x, y);\n\t}\n}\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"G.in\", \"r\", stdin);\n\tfreopen(\"G.out\", \"w\", stdout);\n#endif\n\tInput();\n\tSolve();\n\treturn 0;\n}\n```\n\n","categories":["Problem"],"tags":["Codeforces","set","启发式合并"]},{"title":"树相关小结","url":"/2019/01/12/%E6%A0%91%E7%9B%B8%E5%85%B3%E5%B0%8F%E7%BB%93/","content":"\n树上一些比较经典或是可能比较偏~~其实是自己太菜没学过不太会~~的内容\n\n<!--more-->\n\n## 孩子兄弟表示法\n\n把普通的树转化为二叉树\n\n### 实现\n\n对于一个点，如果它在原树中有儿子，则随便找一个（或按某种顺序选取）在二叉树中把它做为它的左儿子；如果在原树中有兄弟，那么随便找一个（或按某种顺序选取）在二叉树中作为它的右儿子，不断递归构造（即左孩子右兄弟）\n\n### 应用\n\n一般不需要真正建出来，在表达式树/某些树形dp中用到了这个思想\n\n## prufer序列\n\n常用于有标号的无根树计数\n\n* 无根树转prufer序列\n\n  每次选取编号最小的叶子，把它父亲记录，并把它自己删除\n\n* prufer序列转无根树\n\n  设点集$V={1,2,3,...,n}$，每次取出prufer序列中最前面的元素$u$，在$V$中找到编号最小的没有在prufer序列中出现的元素$v$，给$u$，$v$连边然后分别删除，不断重复此过程。最后在$V$中剩下两个节点，给它们连边。最终得到的就是无根树。\n\n### 结论/应用\n\n* 任何一棵无根树都有一种prufer序列与它一一对应，反之亦然\n* 有编号无根树计数：$n^{n-2}$\n* 有编号有根树计数：$n^{n-2}*n = n^{n-1}$\n* 可以均匀地随机一棵树\n* prufer序列中某个编号出现的次数就等于这个编号的节点在无根树中的度数-1\n* $n$个节点的度为$deg[i]$的无根树共有$\\frac{(n-2)!}{\\sum_{i=1}^{n}(deg[i] - 1)!}$个，因为此时prufer编码中的数字$i$恰好出现$deg[i]−1$次\n\n\n\n## 长链剖分\n\n一种$O(n)$合并深度相关信息的方法：[见此](https://hk-cnyali.com/2019/01/07/%E3%80%8CPOI2014%E3%80%8DHotel%E5%8A%A0%E5%BC%BA%E7%89%88-%E6%A0%91%E5%BD%A2Dp-%E9%95%BF%E9%93%BE%E5%89%96%E5%88%86/)\n\n这里介绍另外一种形式，用来$O(n\\log n)-O(1)$求$k$祖先\n\n首先不难发现一个性质：\n\n> 任意一个点的$k$级祖先所在链的链长一定大于等于$k$ \n>\n> 因为如果这个点和他的$k$级祖先在一条链上，那么结论显然成立。\n>\n> 如果不在一条链上，那么一开始这个祖先没有选择这棵子树是因为别的子树更深，故而所在链一定是大于$k$的，结论仍然成立。\n\n对于每条重链，在每条重链顶部预处理出重链顶端向上$k$步之内的祖先，以及向下$k$步重链上的所有点。$k$为重链长度。再对每个点求出$2^i$祖先的倍增数组\n\n考虑询问$x$的$k$级祖先，先利用倍增数组跳$2^l$祖先，其中$l$满足$\\frac{k}{2}<l\\le k$（即$k$的最高位），设剩余层数为$k'$，可以发现$k'< \\frac{k}{2}$\n\n利用之前证明的性质，我们可以发现当前节点所在链链长一定严格大于$k'$\n\n如果链头在当前节点的$k'$级祖先上面，那么我们利用链头向下的数组可以得到答案，否则利用向上的数组得到答案\n\n可以发现询问总复杂度是$O(1)$的","categories":["Algorithm"],"tags":["长链剖分","prufer序列"]},{"title":"「PKUWC2018」猎人杀 - 概率 + 容斥 + NTT","url":"/2019/01/12/%E3%80%8CPKUWC2018%E3%80%8D%E7%8C%8E%E4%BA%BA%E6%9D%80-%E6%A6%82%E7%8E%87-%E5%AE%B9%E6%96%A5-NTT/","content":"\n一开始有$n$个猎人，第$i$个猎人有仇恨度$w_i$，每个猎人死亡后必须开一枪，且被射中的人也会死亡。 \n\n假设当前还活着的猎人有$[i_1...i_m]$，那么有$\\frac{w_{i_k}}{\\sum\\limits_{j=1}^{m}w_{i_j}}$概率是向猎人$i_k$开枪。 \n\n一开始第一枪由你打响，目标的选择方法和猎人一样，求$1$号猎人最后一个死的的概率。\n\n答案对$998244353$取模 \n\n$w_i>0, 1\\le\\sum w_i\\le 100000$\n\n<!--more-->\n\n### Links\n\n[LOJ2541](https://loj.ac/problem/2541)\n\n\n\n### Solution\n\n考虑开枪时，如果打到死掉的猎人，就再打一枪，一直到打到活着的猎人停止\n\n不难发现，这和原问题的概率是一样的\n\n> 感性理解，每次如果没打中，再新打一枪的时候对于活着的人被打中的概率还是和上一轮一样的\n\n题目要求$1$号猎人后面恰好没有人死的概率，考虑容斥，枚举在他后面死的人\n\n设$S$为枚举到的人的$w_i$的和，$A$表示$\\sum\\limits_{i=1}^{n}w_i$那么有\n$$\nans = (-1)^{|S|} \\sum_{i=0}^{\\infty} (1-\\frac{S+w_1}{A})^i\\frac{w_1}{A}\n$$\n后面那一坨无限概率怎么算呢？\n\n> 令\n> $$\n> T = \\sum_{i=0}^{\\infty} (1-\\frac{S+w_1}{A})^i\n> $$\n> 那么有\n> $$\n> (1-\\frac{S+w_1}{A})T=\\sum_{i=1}^{\\infty} (1-\\frac{S+w_1}{A})^i\n> $$\n> 作差可以得到\n> $$\n> T=\\frac{A}{S+w_1}\n> $$\n>\n\n所以答案就是$ans=(-1)^{|S|}\\frac{w_1}{S+w_1}$\n\n注意到题目$\\sum w_i$比较小，所以可以考虑对于每个$S$，求出它前面的容斥系数的和\n\n这个可以直接构造生成函数$\\prod\\limits_{i=2}^{n}(1-x^{w_i})$，用分治+NTT在$O(n\\log^2n)$的时间复杂度内快速计算\n\n\n\n### Summary\n\n这道题前面推概率那里实在是太神仙了\n\n倒是后半部分用NTT优化比较套路，比较容易想\n\n这道题思维难度还是挺大的。。。\n\n\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\n\ninline void proc_status()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) <<endl;\n}\n\ntemplate <typename T> T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\nconst int Maxn = 1e5 + 100, Mod = 998244353, g = 3;\n\nint N, W[Maxn];\n\nvector <int> F[Maxn << 2];\nint cnt;\n\ninline int Pow (int a, int b)\n{\n\tint ans = 1;\n\tfor (int i = b; i; i >>= 1, a = (LL)a * a % Mod) if (i & 1) ans = (LL)ans * a % Mod;\n\treturn ans;\n}\n\nnamespace Poly\n{\n\tint n, rev[Maxn << 2], A[Maxn << 2], B[Maxn << 2];\n\n\tinline void DFT (int *A, int flag)\n\t{\n\t\tfor (int i = 0; i < n; ++i) if (i < rev[i]) swap(A[i], A[rev[i]]);\n\n\t\tfor (int mid = 1; mid < n; (mid <<= 1))\n\t\t{\n/**/\t\tint Wn = Pow(g, (Mod - 1) / mid / 2);\n\t\t\tif (flag < 0) Wn = Pow(Wn, Mod - 2);\n\n\t\t\tfor (int i = 0; i < n; i += (mid << 1))\n\t\t\t{\n\t\t\t\tint W = 1;\n\t\t\t\tfor (int j = i; j < i + mid; ++j, W = (LL)W * Wn % Mod)\n\t\t\t\t{\n\t\t\t\t\tint x = A[j], y = (LL)W * A[j + mid] % Mod;\n\t\t\t\t\tA[j] = (x + y) % Mod, A[j + mid] = (x - y + Mod) % Mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint inv = Pow(n, Mod - 2);\n\t\tif (flag < 0) for (int i = 0; i < n; ++i) A[i] = (LL)A[i] * inv % Mod;\n\t}\n\n\tinline vector <int> NTT (vector <int> F, vector <int> G)\n\t{\n//\t\tfor (int i = 0; i < F.size(); ++i) cout<<F[i]<<\" \"; puts(\"\");\n//\t\tfor (int i = 0; i < G.size(); ++i) cout<<G[i]<<\" \"; puts(\"\");\n\t\tint N = F.size(), M = G.size(); n = 1;\n\t\tfor (int i = 0; i < N; ++i) A[i] = F[i];\n\t\tfor (int i = 0; i < M; ++i) B[i] = G[i];\n\n\t\twhile (n <= N + M) n <<= 1;\n\t\tfor (int i = 0; i < n; ++i) rev[i] = (rev[i >> 1] >> 1) + (i & 1 ? (n >> 1) : 0);\n\t\tfor (int i = N; i <= n; ++i) A[i] = 0;\n\t\tfor (int i = M; i <= n; ++i) B[i] = 0;\n\n\t\tDFT (A, 1), DFT (B, 1);\n\t\tfor (int i = 0; i < n; ++i) A[i] = 1ll * A[i] * B[i] % Mod;\n\t\tDFT (A, -1);\n\n\t\tfor (int i = 0; i < N; ++i) F[i] = A[i];\n\t\tfor (int i = N; i < N + M; ++i) F.pb(A[i]);\n//\t\tfor (int i = 0; i < F.size(); ++i) cout<<F[i]<<\" \"; puts(\"\");puts(\"\");\n\t\treturn F;\n\t}\n}\n\ninline int solve (int l, int r)\n{\n\tint id = ++cnt;\n\tif (l == r)\n\t{\n\t\tF[id].pb(1); for (int i = 1; i < W[l]; ++i) F[id].pb(0); F[id].pb(Mod - 1);\n\t\treturn id;\n\t}\n\n\tint mid = l + r >> 1;\n\tint lid = solve (l, mid), rid = solve (mid + 1, r);\n\n\tF[id] = Poly :: NTT (F[lid], F[rid]);\n\t\n\treturn id;\n}\n\ninline void Add (int &a, int b) { a += b; if (a >= Mod) a -= Mod; }\n\ninline void Solve ()\n{\n\tsolve (2, N);\n\n\tint ans = 0;\n//\tfor (int i = 0; i <= sum; ++i) cout<<F[1][i]<<\" \";\n//\tputs(\"\");\n\tfor (int i = 0; i < F[1].size(); ++i)\n\t\tif (F[1][i]) \n\t\t\tAdd (ans, (LL)W[1] * Pow((i + W[1]) % Mod, Mod - 2) % Mod * F[1][i] % Mod);\n\tcout<<ans<<endl;\n}\n\ninline void Input ()\n{\n\tN = read<int>();\n\tfor (int i = 1; i <= N; ++i) W[i] = read<int>();\n}\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"A.in\", \"r\", stdin);\n\tfreopen(\"A.out\", \"w\", stdout);\n#endif\n\tInput();\n\tSolve();\n\treturn 0;\n}\n\n```\n\n","categories":["Problem"],"tags":["容斥","概率和期望","NTT"]},{"title":"FFT、NTT小结","url":"/2019/01/11/FFT%E3%80%81NTT%E5%B0%8F%E7%BB%93/","content":"\n这种东西还是写一点比较重要的思路和式子之类的放在这里比较好，毕竟过一段时间估计就会忘。。。\n\n其实并不太建议初学者看这篇文章，因为它真的只是备忘用的，很多东西都写的比较简单。。。\n\n特别详细的解释可以[戳这里](https://www.luogu.org/blog/command-block/fft-xue-xi-bi-ji)，这篇文章是真$\\cdot$小学生都看得懂\n\n<!--more-->\n\n## FFT(快速傅里叶变换)\n\n主要流程是选取一些合适的点值，通过`DFT`变换，把多项式由系数表示法转化为点值表示法，直接把两个多项式对应点值相乘，再通过`IDFT`转化回点值表示法。整个算法在$O(n\\log n)$的时间复杂度内完成了两个多项式的卷积\n\n\n\n### 单位复数根\n\n设$\\omega^n=1$，则$\\omega$有$n$个解，把复平面上的单位圆分成$n$等分\n\n定义$\\omega_{n}$为最小的那个解，也就是从$(1,0)$开始逆时针方向第一个解 \n\n那么$\\omega_n^i(i\\in [0,n-1])$就表示出了这$n$个解，其中$\\omega_{n}^{0}$表示$(1,0)$\n\n* 如何求$\\omega_{n}$呢？\n\n  这个东西本质上就是单位圆上一个$n$等分点的坐标，显然就是$(\\cos\\theta, \\sin\\theta)$，也就是$(\\cos{\\frac{2\\pi}{n}}, \\sin{\\frac{2\\pi}{n}})$。这个东西根本不需要什么欧拉公式去求\n\n---\n\n有一些关于这个东西的性质：\n\n* $\\omega_{n}^{i+n}=\\omega_{n}^{i}*\\omega_{n}^n = \\omega_n^i$\n\n* 消去引理：$\\omega_{dn}^{dk}=\\omega_{n}^k$\n\n* 折半引理：$\\omega_{n}^{k+\\frac{n}{2}}=-\\omega_{n}^k$\n\n  > 上面这两个都可以利用单位圆很显然地发现\n\n* 求和引理：对于任意整数$n\\le1$和不能被$n$整除的$k$，有$\\sum\\limits_{j=0}^{n-1}(\\omega_{n}^{k})^j=0$\n\n  > 这个可以用等比数列求和证明\n\n这些引理在下面化式子的时候都会用到\n\n\n\n### DFT\n\n我们选$w_{n}^k$来求点值，即要求$A(\\omega_{n}^{k})~ (k\\in[0, n-1])$\n\n把多项式$A(x)$按下标奇偶性划分成两个部分：\n$$\nA(x) = (a_0+a_2x^2+a_4x^4+...+a{n-2}x^{n-2})+(a_1x+a_3x^3+a_5x^5+...+a_{n-1}x^{n-1})\n$$\n令\n$$\nA_1(x)=a_0+a_2x+a_4x^2+...+a_{n-2}x^{\\frac{n}{2}-1}\\\\\nA_2(x)=a_1+a_3x+a_5x^2+...+a_{n-1}x^{\\frac{n}{2}-1}\n$$\n那么有\n$$\nA(x) = A_1(x^2) + xA_2(x^2)\n$$\n假设现在我们要求$A(\\omega_{n}^k),k\\in[0, \\frac{n}{2}] $\n$$\n\\begin{aligned}\nA(\\omega_{n}^k) &= A_1(\\omega_{n}^{2k})+\\omega_n^kA_2(\\omega_n^{2k})\\\\\n &=A_1(\\omega_{\\frac{n}{2}}^k)+\\omega_{n}^kA_2(\\omega_{\\frac{n}{2}}^k)\n \\end{aligned}\n$$\n而\n$$\n\\begin{aligned}\nA(\\omega_{n}^{k+\\frac{n}{2}}) &= A_1(\\omega_{n}^{2k+n})+\\omega_n^{k+\\frac{n}{2}}A_2(\\omega_n^{2k+n})\\\\\n&=A_1(\\omega_{n}^{2k})-\\omega_n^{k}A_2(\\omega_n^{2k})\\\\\n &=A_1(\\omega_{\\frac{n}{2}}^{k})-\\omega_{n}^kA_2(\\omega_{\\frac{n}{2}}^k)\n \\end{aligned}\n$$\n\n于是我们就可以通过分治递归，利用$A_1({\\omega_{\\frac{n}{2}}^{k}})$和$A_2({\\omega_{\\frac{n}{2}}^{k}})$来求出$A({\\omega_{\\frac{n}{2}}^{k}})$\n\n复杂度$O(n \\log n)$\n\n### IDFT\n\n`IDFT`的结论用上面提到的求和引理和一系列的化式子（或者用矩阵）可以证明，但在这里并不想写了\n\n结论就是做一遍`DFT`，其中$\\omega_{n}$改为$\\omega_{n}^{-1}$，然后最后乘$\\frac{1}{n}$\n\n\n\n### 二进制翻转\n\n发现在做`DFT`的时候需要把奇数偶数下标分开算，再合并起来。 不过直接这么做会很慢，考虑把数组直接按照最后的形态分奇偶排好。\n$$\n\\begin{aligned}\n&(a_0, a_1, a_2, a_3, a_4, a_5, a_6, a_7)\\\\\n&(a_0, a_2, a_4, a_6)(a_1, a_3, a_5, a_7)\\\\\n&(a_0, a_4)(a_2, a_6)(a_1, a_5)(a_3, a_7)\\\\\n&(a_0)(a_4)(a_2)(a_6)(a_1)(a_5)(a_3)(a_7)\n\\end{aligned}\n$$\n\n\n通过观察发现，最后的每个位置的数字恰好就是原数字在二进制下按位反转的结果。\n\n> 感性理解一下，每次重新划分相当于是按照最低位为0还是1分的，为0则会分到前面一半（最高位为0），为1则会分到后面一半。因此最后就是原数二进制反转的结果\n\n注意到这一点后，就可以直接处理出这个置换数组$rev[]$了：\n\n```cpp\nrev[i] = (rev[i >> 1] >> 1) + (i & 1 ? n >> 1 : 0)\n```\n\n> 这个相当于看$i$二进制最低位是什么\n\n\n\n## NTT(快速数论变换)变换\n\n考虑在模意义下卷积，也就是卷出来的系数要对某个数取模\n\n一般而言，模数要是$2^ab+1$的形式，其中$2^a$要不小于n\n\n我们需要找到在模意义下什么东西具有单位复数根$\\omega_{n}$的性质\n\n答案是原根$g$，通常使用的$998244353$的原根$g=3$\n\n由于$g^{mod-1} = 1$，我们就可以用$g^{\\frac{mod-1}{p}}$来代替$\\omega_{n}$\n\n不难证明原根也有单位复数根的那些性质\n\n\n\n## 分治FFT\n\n假设我们有一个长这样的递推式：$f(n) = \\sum\\limits_{i=0}^{i-1}f(i)g(n-i)$\n\n和CDQ分治、分治优化Dp的思想类似，其实就是考虑跨中点的贡献\n\n先递归求$[l, mid]$的答案，此时$[l,mid]$对$[mid + 1, r]$的贡献长这样：$f(x) = \\sum\\limits_{i=l}^{mid}f(i)g(x-i),x\\in[mid + 1, r]$\n\n把$[l, mid]$的$f$与$g$卷起来，算出所有$[l,mid]$的值对于$[mid+1, r]$中每个位置对应的贡献，最后递归计算$[mid + 1, r]$的答案\n\n需要注意的是，必须先递归左边，求出答案并算完左边对右边的贡献后，再递归右边，原因比较显然\n\n这个算法常数比较大，有时可以区间长度小于某个值（如20）就暴力计算\n","categories":["Algorithm"],"tags":["NTT","FFT"]},{"title":"分治思想小结","url":"/2019/01/10/%E5%88%86%E6%B2%BB%E6%80%9D%E6%83%B3%E5%B0%8F%E7%BB%93/","content":"\n各种关于分治方法的大合集，只是为了怕自己忘记，实际上都是一些很傻逼的东西。。。\n\n<!--more-->\n\n### 分治的主要思想\n\n把一个大小为$n$的问题划分成$k$部分（往往$k=2$），通常每一部分大小为$\\frac{n}{k}$\n\n递归解决每一部分，然后合并每一部分的答案，并计算原问题的答案，我们假设这一步复杂度为$A(n)$\n\n有总复杂度$T(n) = T(\\frac{n}{k}) * k + A(n)​$，可以用主定理计算\n\n一些简单的复杂度计算：\n\n* 若$A(n) = O(n)$，那么$T(n)=O(n\\log n)$\n* 若$A(n) = O(n^{1 + \\epsilon})$，那么$T(n) = A(n)$\n\n\n\n#### 一个优化的小技巧\n\n当分治区间小于某个值（如20）时，直接跑暴力\n\n这对于某些常数较大的分治而言很有用（比如`FFT`等）\n\n\n\n### 点分治\n\n#### 题型\n\n往往是统计树上路径条数的问题\n\n#### 实现过程\n\n* 找重心\n* 统计过重心的答案\n* 分治递归计算\n\n\n\n#### 复杂度\n\n因为每次找的重心，分下去规模至少除以2，保证了递归层数不超过$O(\\log n)$。计算答案是$O(n)$的，所以总复杂度是$O(n\\log n)$的。如果统计答案的时候还要用数据结构维护的话就往复杂度上套$\\log$\n\n\n\n### 网格图上的分治\n\n#### Problem\n\n给一个$n*m$的带权网格图，每次询问两点之间最短路\n\n#### Solution\n\n首先有一个比较暴力的分治方法\n\n每次找到网格图的中线，把网格图划分成左右两部分。\n\n处理出中线上的所有点到每个点的最短路，复杂度是$O\\big(n^2m\\log (nm)\\big)$\n\n考虑询问的每一对点：\n\n* 如果分别位于中线两侧，那么显然最优方案一定经过中线，计算此时答案并停止这个询问往下递归\n* 如果位于中线同一侧，计算经过中线时对答案的贡献，并且这个询问还需要往下递归\n\n> 这样做的话每个询问最多会被计算答案$O(\\log(n))$次，所以是对的\n\n总复杂度$T(n,m) = T(\\frac{n}{2}, m)+O(n^2\\log (nm))$\n\n当$n$比较大的时候复杂度会爆炸\n\n考虑优化，每次都分割较大的那一维，复杂度可以做到$O((nm)^{1.5})$\n\n显然这个也能做到在线\n\n\n\n### CDQ分治\n\n用来解决三维偏序问题（再高维可以直接套，当然维度再高就没有什么意义了。。。）\n\n#### Description\n\n$n$个点，每个点有三个属性$a,b,c$，对于每个$i$求满足$a_j\\le a_i, b_j\\le <b_i, c_j\\le c_i$的$j$个数\n\n#### Solution\n\n先排序去掉第一维的限制\n\n接着考虑分治，每次分成左半段和右半段，考虑**跨区间的贡献**\n\n因为第一维已经排好序，所以此时所有右半段的点不会对左半段产生贡献\n\n左右两侧分别按第二维排序，用`BIT`统计第三维限制下的答案\n\n\n\n### 整体二分\n\n先考虑这样一个问题：长度为$n$的数列，求$[l,r]$中第$k$大的数\n\n这个显然是可以二分答案做的，每次对于二分出的一个答案，统计区间内比它小的数的个数来check\n\n那么如果有$m$个这样的询问呢？\n\n顾名思义，整体二分就是把这样很多的二分答案放到一起来处理\n\n相当于是在值域上分治，把操作和值域丢一起算答案\n\n递归函数$f(l, r, L, R)$表示当前二分答案区间为$[l, r]$，答案可能在这个区间内的修改/询问的编号在$[L, R]$内\n\n每次将答案二分，把$[L,R]$里的修改操作按被修改数的权值$\\le mid$和$>mid$分成左右两边，如果$\\le mid$，就把它下标所在位置在`BIT`里+1。\n\n把$[L,R]$里的查询操作按`BIT`上查询区间里的$sum\\ge k$和$<k$分成左右两边，如果$\\ge k$就丢左边，否则那么$k$减去$sum$，丢右边。不断分治即可\n\n\n\n### 分治优化Dp\n\n长得像这样的dp：$dp[i] = \\min_{j < i}dp[j] + w(j, i)$\n\n还是把序列分成两半，先在左半边上整体做dp，然后计算所有跨区间的贡献（也就是左半部分dp值对右半部分的贡献），然后对右半边做dp\n\n具体这类题目，往往和斜率优化dp比较像。需要对于左半边区间维护一个凸包，右半边在上面查询即可\n\n\n\n### 分治FFT\n\n[见这里](https://hk-cnyali.com/2019/01/11/FFT%E3%80%81NTT%E5%B0%8F%E7%BB%93/)\n\n","categories":["Algorithm"],"tags":["NTT","分治","CDQ分治","点分治","FFT","整体二分"]},{"title":"「CF960G」Bandit Blues - 第一类斯特林数 + NTT","url":"/2019/01/10/%E3%80%8CCF960G%E3%80%8DBandit-Blues-%E7%AC%AC%E4%B8%80%E7%B1%BB%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0-NTT/","content":"\n给定$n,a,b$，求有多少个长度为$n$的排列满足前缀最大值数量恰好为$a$，后缀最大值数量恰好为$b$\n\n$n, a, b\\le 10^5$\n\n<!--more-->\n\n### Links\n\n[CF960G](https://codeforces.com/contest/960/problem/G)\n\n\n\n### Solution\n\n不难发现，全局最大值把整个排列分成了两个部分\n\n首先很容易想到一个$O(n^2)$暴力，先枚举最大值的位置$p$，然后设$dp[i][j]$表示一个长度为$i$ 的排列，满足从左到右有 $j$ 个在前缀中为最大值的元素的方案数，答案即为$\\sum_{p=1}^{n}dp[p-1][a - 1] * dp[n - p][b - 1] * \\binom{n - 1}{p - 1}$\n\n在转移$dp[i][j]$的时候，可以发现转移式子和第一类斯特林数一模一样\n\n那么考虑它的组合意义实际上就是把$i$个数分成$j$个环排列\n\n>  为了满足前缀最大值的限制，我们强制从大到小把每个数放到排列中。如果要使得它成为前缀最大值就放到排列的最前面；否则每个数放进去的时候都可以加到当前排列的任何一个数的后面，并且它不会成为前缀最大值。\n\n那么我们就不需要枚举全局最大值的位置了\n\n我们直接考虑把除最大值外剩下的$n-1$个数分成$(a-1)+(b-1)=a+b-2$个环排列，再乘个组合数枚举每个排列放在最大值前面还是最大值后面即可\n\n答案就是${n-1\\brack a+b-2} * \\binom{a+b-2}{a-1}$\n\n用`NTT`优化第一类斯特林数的计算\n\n---\n\n这里稍微写一下吧，但感觉还是会专门写一篇总结。。。\n\n首先对于第一类斯特林数，我们有生成函数$x^\\overline{n} = \\sum\\limits_{i=0}^{n-1}{n \\brack i}x^i$，或者是带符号的$x^\\underline{n} = \\sum\\limits_{i=0}^{n-1}(-1)^{n-i}{n \\brack i}x^i$\n\n其中$x^\\overline{n}= \\prod\\limits_{i=0}^{i-1}(x+i)$，$x^\\underline{n}= \\prod\\limits_{i=0}^{i-1}(x-i)$，分别称为上升幂和下降幂\n\n>可以考虑$x^\\underline{n}$和$x^\\overline{n}$这两个多项式每项系数的dp过程，发现和第一类斯特林数是一样的\n\n然后就可以用`NTT`优化多项式乘法了，可以递归分治，每次暴力用`NTT`合并，复杂度是$O(n\\log^2 n)$，足够通过此题\n\n---\n\n然而第一类斯特林数也存在$O(n\\log n)$的做法，也比较好理解。这里懒得写了，到时候写总结的时候再写。可以先看[yyb巨佬的博客](https://www.cnblogs.com/cjyyb/p/10142878.html)\n\n\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\n\ninline void proc_status()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) <<endl;\n}\n\ntemplate <typename T> T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\nconst int Maxn = 2e5 + 100, Mod = 998244353, g = 3;\n\nint N, a, b;\nint fac[Maxn], ifac[Maxn];\n\ninline int Pow (int a, int b)\n{\n\tint ans = 1;\n\tfor (int i = b; i; i >>= 1, a = 1ll * a * a % Mod) if (i & 1) ans = 1ll * ans * a % Mod;\n\treturn ans;\n}\n\ninline void Init (int maxn)\n{\n\tfac[0] = 1;\n\tfor (int i = 1; i <= maxn; ++i) fac[i] = 1ll * fac[i - 1] * i % Mod;\n\tifac[maxn] = Pow(fac[maxn], Mod - 2);\n\tfor (int i = maxn - 1; i >= 0; --i) ifac[i] = 1ll * ifac[i + 1] * (i + 1) % Mod;\n}\n\ninline int C (int n, int m) { return 1ll * fac[n] * ifac[m] % Mod * ifac[n - m] % Mod; }\n\nnamespace Poly\n{\n\tint n, rev[Maxn << 2];\n\n\tinline void DFT (int *A, int flag)\n\t{\n\t\tfor (int i = 0; i < n; ++i) if (i < rev[i]) swap (A[i], A[rev[i]]);\n\n\t\tfor (int mid = 1; mid < n; mid <<= 1)\n\t\t{\n\t\t\tint Wn = Pow(g, (Mod - 1) / mid / 2);\n\t\t\tif (flag == -1) Wn = Pow(Wn, Mod - 2);\n\t\t\tfor (int i = 0; i < n; i += (mid << 1))\n\t\t\t{\n\t\t\t\tint W = 1;\n\t\t\t\tfor (int j = i; j < i + mid; ++j, W = 1ll * W * Wn % Mod)\n\t\t\t\t{\n\t\t\t\t\tint x = A[j], y = 1ll * W * A[j + mid] % Mod;\n/**/\t\t\t\tA[j] = (x + y) % Mod, A[j + mid] = (x - y + Mod) % Mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint inv = Pow(n, Mod - 2);\n\t\tif (flag == -1) for (int i = 0; i < n; ++i) A[i] = 1ll * A[i] * inv % Mod;\n\t}\n\n\tinline void NTT (int *A, int *B, int N, int M)\n\t{\n\t\tn = 1; while (n <= N + M) n <<= 1;\n\t\tfor (int i = N; i < n; ++i) A[i] = 0;\n\t\tfor (int i = M; i < n; ++i) B[i] = 0;\n\t\tfor (int i = 0; i < n; ++i) rev[i] = (rev[i >> 1] >> 1) | (i & 1 ? (n >> 1) : 0);\n\n\t\tDFT (A, 1), DFT (B, 1);\n\t\tfor (int i = 0; i < n; ++i) A[i] = 1ll * A[i] * B[i] % Mod;\n\t\tDFT (A, -1);\n\t}\n}\n\nint A[25][Maxn << 2], B[Maxn << 2];\n\ninline int solve (int l, int r, int d)\n{\n\tif (l == r) { A[d][0] = l - 1, A[d][1] = 1; return 2; }\n\tint mid = l + r >> 1;\n\tint n = solve (l, mid, d + 1);\n\tfor (int i = 0; i < n; ++i)\tA[d][i] = A[d + 1][i];\n\tint m = solve(mid + 1, r, d + 1);\n\tfor (int i = 0; i < m; ++i)\tB[i] = A[d + 1][i];\n\tPoly :: NTT(A[d], B, n, m);\n\treturn n + m;\n}\n\ninline int S (int n, int m)\n{\n\t// (x + 0) * (x + 1) * (x + 2) * ... * (x + n - 1) \n\tsolve(1, n, 0);\n\treturn A[0][m];\n}\n\ninline void Solve ()\n{\n    if (a + b - 2 > N - 1 || !a || !b) { puts(\"0\"); return ; }\n    if (N == 1) { puts(\"1\"); return ; }\n\tInit(2e5);\n    cout<<1ll * S(N - 1, a + b - 2) * C(a + b - 2, a - 1) % Mod<<endl;\n}\n\ninline void Input ()\n{\n\tN = read<int>(), a = read<int>(), b = read<int>();\n}\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"permutation.in\", \"r\", stdin);\n\tfreopen(\"permutation.out\", \"w\", stdout);\n#endif\n\tInput();\n\tSolve();\n\treturn 0;\n}\n\n```\n\n\n\n### Debug\n\n* 62L：写成`mid=0`。。。\n* 72L：忘记取模。。。\n","categories":["Problem"],"tags":["Codeforces","斯特林数","NTT"]},{"title":"「CF1045H」Self-exploration - 计数","url":"/2019/01/10/%E3%80%8CCF1045H%E3%80%8DSelf-exploration-%E8%AE%A1%E6%95%B0/","content":"\n给你一个用二进制表示的区间$[A,B]$\n\n求这个区间内的数在二进制的表示下有$a$个00，$b$个01，$c$个10，$d$个11的有多少个\n\n$1\\le A \\le B\\le 2^{100000}$\n\n<!--more--> \n\n### Links\n\n[CF1045H](https://codeforces.com/contest/1045/problem/H)\n\n\n\n### Solution\n\n首先考虑没有区间$[A,B]$限制的时候怎么做\n\n不难发现，序列是由若干段连续的$0$或$1$交替组成的\n\n总的$1$的个数为$b+d+1$，最后我们要把它们分成$b+1$个连续段。根据隔板法有$\\binom{b+d}{b}$种方案，$0$的情况同理\n\n所以答案就是$\\binom{b+d}{b}*\\binom{a+c-1}{c-1}$\n\n接着考虑如何把多算的部分减掉\n\n利用类似数位dp的思想，从高位往低位考虑，枚举在哪一位上第一次超过限制，那么后面就能随便填，又转化成上面那个式子了\n\n\n### Summary\n\n又是一道并不难的组合计数题。考试的时候一直在想如何优化数位dp，没发现能直接通过组合数计算答案\n\n虽然发现了序列由若干段$01$交替组成，但没有很好地利用这个性质与已知信息的联系，所以才没想到\n\n以后的组合计数题都要逼着自己去想，去推，先独立思考，否则不可能有提高\n\n\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\n\ninline void proc_status()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) <<endl;\n}\n\ntemplate <typename T> T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\nconst int Maxn = 200000 + 100, Mod = 1000000007;\n\nint N, A[Maxn], M, B[Maxn], a, b, c, d;\nint fac[Maxn], ifac[Maxn];\nchar S[Maxn];\n\ninline void Add (int &a, int b) { a += b; if (a >= Mod) a -= Mod; }\n\ninline int Pow (int a, int b)\n{\n\tint ans = 1;\n\tfor (int i = b; i; i >>= 1, a = 1ll * a * a % Mod) if (i & 1) ans = 1ll * ans * a % Mod;\n\treturn ans;\n}\n\ninline int C (int n, int m) { return 1ll * fac[n] * ifac[m] % Mod * ifac[n - m] % Mod; }\n\ninline int calc (int n, int m) \n{ \n\tif (n < 0 || m < 0) return 0;\n\tif (!m) return !n;\n\treturn C(n + m - 1, m - 1); \n}\n\ninline int solve ()\n{\n\tif (a + b + c + d > N - 1) return 0;\n\tint ans = 1ll * calc (d, b + 1) * calc (a, c) % Mod;\n\tif (a + b + c + d < N - 1) return ans;\n\n\tint aa = a, bb = b, cc = c, dd = d;\n\tfor (int i = N - 1; i >= 1; --i)\n\t{\n\t\tif (A[i] == 1)\n\t\t{\n/**/\t\tif (A[i + 1] == 1) --dd;\n\t\t\telse --bb;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (A[i + 1] == 1) Add (ans, Mod - 1ll * calc (dd - 1, bb + 1) * calc(aa, cc) % Mod);\n\t\telse Add (ans, Mod - 1ll * calc (dd, bb) * calc(aa, cc) % Mod);\n\n\t\tif (A[i + 1] == 1) --cc; else --aa;\n\t}\n\treturn ans;\n}\n\ninline void Solve ()\n{\n\tif (b + 1 < c || c < b) { cout<<0<<endl; return ; }\n\t--A[1];\n\tfor (int i = 1; i < N; ++i) if (A[i] < 0) A[i] = 1, --A[i + 1];\n\tif (!A[N]) --N;\n\tint ans = Mod - solve();\n\tswap(N, M), swap(A, B);\n\tprintf(\"%d\\n\", (ans + solve()) % Mod);\n}\n\ninline void Input ()\n{\n\tscanf(\"%s\", S + 1); N = strlen(S + 1);\n\tfor (int i = 1; i <= N; ++i) A[i] = S[N - i + 1] - '0';\n\tscanf(\"%s\", S + 1); M = strlen(S + 1);\n\tfor (int i = 1; i <= M; ++i) B[i] = S[M - i + 1] - '0';\n\ta = read<int>(), b = read<int>(), c = read<int>(), d = read<int>();\n}\n\ninline void Init (int maxn)\n{\n\tfac[0] = 1;\n\tfor (int i = 1; i <= maxn; ++i) fac[i] = 1ll * fac[i - 1] * i % Mod;\n\tifac[maxn] = Pow(fac[maxn], Mod - 2);\n\tfor (int i = maxn - 1; i >= 0; --i) ifac[i] = 1ll * ifac[i + 1] * (i + 1) % Mod;\n}\n\nint main()\n{\n#ifdef hk_cnyali\n\tfreopen(\"H.in\", \"r\", stdin);\n\tfreopen(\"H.out\", \"w\", stdout);\n#endif\n\tInit(2e5);\n\tInput();\n\tSolve();\n\treturn 0;\n}\n\n```\n\n","categories":["Problem"],"tags":["Codeforces","计数","组合数学"]},{"title":"「CF838D」Airplane Arrangements - 概率","url":"/2019/01/09/%E3%80%8CCF838D%E3%80%8DAirplane-Arrangements-%E6%A6%82%E7%8E%87/","content":"\n$n$ 个位置排成一排，有 $m$ 个人依次进场选位置\n\n每个人开始会选择一个方向（从左至右或从右至左）并选择一个位置。他会走到他选择的那个位置，如果那个位置被人占用了，他会沿着他选择的方向一路走到第一个空位并坐下。\n\n求有多少种情况满足每个人都有座位。\n\n$1\\le m \\le  n\\le 10^6$\n\n<!--more-->\n\n### Links\n\n[CF838D](https://codeforces.com/contest/838/problem/D)\n\n\n\n### Solution\n\n新加入一个$n+1$号点，把所有点看成一个环\n\n每个人从选择的位置开始，往顺时针/逆时针走，找到第一个空座位就坐下\n\n一旦$n+1$这个点被占据，就说明有人找不到座位，所以题目转化为求$n+1$这个点没被占据的方案数\n\n原题中总方案数是$(2n)^m$的，但在这里我们假设每个人都有可能从$n+1$出发，即总方案数为$(2n+2)^m$，这样就能保证每个点是等价的，且对答案不会产生影响（从$n+1$出发的答案都是不合法的）\n\n所以每个点被占据的概率相同，均为$\\frac{m}{n+1}$\n\n因此$n+1$这个点没有被占据的概率就是$\\frac{n+1-m}{n+1}$\n\n答案即为总方案数乘概率\n\n\n\n### Summary\n\n在所有点等价的情况下，如果某个东西的方案数不好算，可以考虑用总方案数乘上这个时间发生的概率\n\n\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\n\ninline void proc_status()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) <<endl;\n}\n\ntemplate <typename T> T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\nconst int Maxn = 1000000 + 100, Mod = 1e9 + 7;\n\nint N, M;\n\ninline int Pow (int a, int b)\n{\n\tint ans = 1;\n\tfor (int i = b; i; i >>= 1, a = 1ll * a * a % Mod) if (i & 1) ans = 1ll * ans * a % Mod;\n\treturn ans;\n}\n\ninline void Solve ()\n{\n\tprintf(\"%lld\\n\", 1ll * Pow((2ll * N + 2) % Mod, M) * (N + 1 - M) % Mod * Pow(N + 1, Mod - 2) % Mod);\n}\n\ninline void Input ()\n{\n\tN = read<int>(), M = read<int>();\n}\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"D.in\", \"r\", stdin);\n\tfreopen(\"D.out\", \"w\", stdout);\n#endif\n\tInput();\n\tSolve();\n\treturn 0;\n}\n\n```\n\n","categories":["Problem"],"tags":["Codeforces","数学","概率和期望"]},{"title":"分块思想小结","url":"/2019/01/09/%E5%88%86%E5%9D%97%E6%80%9D%E6%83%B3%E5%B0%8F%E7%BB%93/","content":"\n关于分块思想的一点点理解和总结\n\n<!--more-->\n\n主要思想是通过把某一维东西分成若干块（下标/值域/操作时间/etc），通过在较为均衡的时间内维护整块、散块或是某些题中一些特定的信息，从而达到修改和查询/预处理和查询的时间复杂度的平衡。\n\n具体来说，往往是通过降低复杂度较高/操作次数较多部分的复杂度，提升复杂度较低/操作次数较少部分的复杂度来达到平衡的目的\n\n需要注意的是，分块不一定都是分成$\\sqrt n$块，需要根据具体题目计算复杂度，算出最优块大小。不过我们一般直接测试实际运行时间，手动调整块大小。\n\n<!--more-->\n\n## 实现过程\n\n把问题规模$n$分成$k$块，每块大小为$\\frac{n}{k}$\n\n微观来看，每个块花费$f(\\frac{n}{k})$时间；宏观来看，$k$个块花费$g(k)$时间\n\n找到$k$满足$f(\\frac{n}{k})=g(k)$，此时复杂度最优\n\n## 几类经典问题\n\n### 最基础的分块\n\n给一个长度为$n$的序列$a[]$，支持以下操作：\n\n1. 令$a[x]=y$\n2. 计算$\\sum_{i=l}^{r} a[i]$\n\n#### Solution\n\n有两种解决方法：\n\n* $O(1)$修改，$O(\\sqrt n)$查询\n\n  > 记录每个整块内部的元素和\n  >\n  > 修改直接修改原序列以及所在块的元素和，查询直接暴力跳整块、计算散块\n\n* $O(\\sqrt n)$修改，$O(1)$查询\n\n  > 记录整块的元素和的前缀和，再预处理出每个块内的前缀和\n  >\n  > 修改时暴力修改所有前缀和（所有整块的以及所在整块内的），直接利用前缀和$O(1)$查询\n\n根据实际情况选择更优方法\n\n\n\n### $\\pm 1$RMQ\n\n求相邻元素相差恰好为$1$的序列的RMQ，复杂度$O(n)-O(1)$\n\n#### Solution\n\n考虑分块，分成$k$块，用`ST表`处理出两两整块之间的最小值，且预处理出每个块内的前后缀和\n\n感性理解一下，这个时候$k$取越大越好\n\n但是不难发现，这样做会存在一个问题，如何计算询问端点全都落在某一整块内的答案？\n\n由于$\\pm1$这个性质，不难发现把每个块内的元素减掉这个块第一个元素的值后，所有的整块内最多只有$O(2^{\\frac{n}{k}})$种可能性（这里感性理解一下可能的情况是很少的，具体大小下面有写）。预处理出所有可能数列的所有最小值的出现位置。复杂度是$O\\big(2^\\frac{n}{k}(\\frac{n}{k})^2\\big)$\n\n预处理+查询的总复杂度是$O(k\\log k+m)$的\n\n令两者相等，求出$k=\\frac{n}{\\log(\\frac{n}{\\log^2n})} = \\frac{2n}{\\log n}$，此时复杂度是$O(n+m)$\n\n\n\n### 区间众数\n\n可以通过莫队做到$O(n\\sqrt m)$，注意不用数据结构维护，直接开个桶，暴力更新最大值即可\n\n考虑如何用分块在线做\n\n依旧设分成$k$块，考虑计算$num[x][y]$表示$x$这个数在前$y$个块里的出现次数，这可以$O(nk)$预处理（先处理出第$y$个块的，再扫一遍求前缀和）\n\n紧接着，我们就能求出任意两个整块中间这段区间的众数了（对于每个左端点往右扫一遍，用一个桶记录出现次数）\n\n对于一个询问$[l,r]$答案要么在中间连续的整块中，要么在散块的前缀/后缀中\n\n最后有可能成为答案的数只有$O(\\frac{n}{k})$个（中间一个，两边散块长度$O(\\frac{n}{k})$）\n\n暴力枚举这些数，还是用一个桶计算可能的数的出现次数，扫一遍即可\n\n当$k=\\frac{n}{\\sqrt m}$时，最优复杂度为$O(n\\sqrt m)$\n\n\n\n### 更一般的模型/思想\n\n长度为$n$的序列，有$m$次询问。暴力查询是$T(n,m)$的\n\n#### Solution\n\n分$k$块，每块$\\frac{n}{k}$个，查询变成每次$T(\\frac{n}{k},m)$的了\n\n总复杂度$k*T(\\frac{n}{k},m)$\n\n------\n\n举个例子，$T(n,m)=O(n^2+m)$时，$k=\\frac{n}{\\sqrt m}$有最优复杂度$O(n\\sqrt m)$\n\n\n\n### 基于操作时间的分块\n\n长度为$n$的序列，有$m$次操作（修改或询问），暴力复杂度$T(n,m)$\n\n#### Solution\n\n把操作序列分成$k$块，每块$\\frac{m}{k}$个，每个块暴力操作需要花费$T(n,\\frac{m}{k})$的时间\n\n在处理完每个块之后，整体应用这些操作的复杂度为$B(n,k)$\n\n总复杂度为$k*\\big(T(n,\\frac{m}{k}) + B(n,k)\\big)$\n\n------\n\n一个例题：\n\n$n$个点的树，$m$次操作：\n\n1. 标记$x$这个点\n2. 找$x$与其最近的被标记点的距离\n\n这里只考虑分块做法\n\n此时$T(n,m)$的暴力做法就是对于每个询问，答案要么是以前已经在之前块内处理完的答案，要么是当前块内在它前面的修改\n\n$B(n,m)$的做法就是用`bfs`$O(n)$重新计算每个点到最近被标记点的距离\n\n------\n\n最后，分块还有一些比较套路的操作（如值域分块查区间第$k$大等），但由于~~我比较懒~~思想都比较类似，就不赘述了\n\n","categories":["Algorithm"],"tags":["Summary","分块","数据结构"]},{"title":"「BZOJ5058」期望逆序对 - 计数 + 矩阵快速幂 + 树状数组","url":"/2019/01/08/%E3%80%8CBZOJ5058%E3%80%8D%E6%9C%9F%E6%9C%9B%E9%80%86%E5%BA%8F%E5%AF%B9-%E8%AE%A1%E6%95%B0-%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/","content":"\n给出一个$n$ 的排列，求 $k$ 次随机交换之后，所有方案的逆序对的和\n\n$n\\le 500000,k\\le 10^9 $\n\n神仙题\n\n<!--more-->\n\n### Brief Analysis\n\n总体思路是考虑每对数字对答案的贡献\n\n每对$a_i,a_j$在末状态的时候，所处位置有三种可能的情况， $i$，$j$ ，或其他位置\n\n不难发现，这个数对最后的位置情况只有$7$种，那么写出矩阵后可以用矩阵快速幂算出最后每种状态的方案数\n\n最后再用`BIT`统计答案即可\n\n### Whole Solution\n\n对于每对数，考虑计算它们在最终状态对答案的贡献\n\n设初始状态下，当前考虑$i$和$j$这两个位置上的数，设它们分别为$A、B$\n\n因为对于这两个数来说其他所有位置的数都是等价的，于是可以都看成$C$（注意，因为实际上$C$是不同的，所以计算方案时也要看作不同，这里只是因为它对当前数对的贡献都没有影响，于是方便表示都记为$C$）\n\n即\n$$\n\\begin{aligned}\n\\text{val: }&CCCACCCBCCC\\\\\n\\text{id: }&12\\dots i... \\dots j......\n\\end{aligned}\n$$\n那么最终状态下$(i,j)$位置所对应的值无非就是$(A,B),(A,C), (B,A), (B,C), (C, A), (C, B), (C, C)$这七种情况\n\n显然，计算的过程可以用矩阵快速幂优化，考虑转移一步时的转移矩阵如下：\n\n（矩阵的第$i$行$j$列表示从第$i$个状态转移到第$j$个状态所需要乘上的值）\n$$\n\\begin{bmatrix}\n\\binom{n-2}{2}& n-2 & 1 & 0 & 0 & n-2 & 0\\\\\n1& \\binom{n-2}{2}+n-3 & 0 & 1 & 1 & 0 &n-3 \\\\\n 1& 0 & \\binom{n-2}{2} & n-2 & n-2 & 0 &0 \\\\\n 0& 1 & 1 & \\binom{n-2}{2}+n-3 & 0 & 1 & n-3\\\\\n0 & 1 & 1 & 0 & \\binom{n-2}{2}+n-3 & 1 & n-3\\\\\n1 & 0 & 0 & 1 & 1 & \\binom{n-2}{2}+n-3 & n-3\\\\\n 0& 1 & 0 & 1 & 1 &1  & \\binom{n-2}{2}+2(n-4)+1\n\\end{bmatrix}\n$$\n最终矩阵的第一行从$0$到$6$分别表示状态为$(A,B),(A,C), (B,A), (B,C), (C, A), (C, B), (C, C)$的答案\n\n但是，如果我们直接枚举$A,B$的话复杂度是$O(n^2)$的，显然过不了\n\n注意到，在确定$A$和$B$中任意一个后，另外一个的具体的值并不重要，只需要知道它们的大小关系\n\n不妨确定$B$，利用树状数组统计所有$A$的贡献\n\n------\n\n假设当前考虑到第$i$个数，它的值为$B(a_i)$，用树状数组维护几个值：\n\n* $num_a$：原排列中位置在$B$之前，且权值比$B$小的数的个数\n\n* $f_a$：原排列中位置在$B$之前，且权值比$B$小的数，它所有前面的位置的和\n\n  ​\t这个好拗口啊，用式子表示就是$f_a=\\sum_{j < i, a_j<B}j-1$\n\n* $g_a$：原排列中位置在$B$之前，且权值比$B$小的数，它所有后面的位置（不包括$i$）的和\n\n  ​\t同样，用式子表示是$g_a\\sum_{j<i, a_j < B}n-j-1$（要再减一是因为要去掉$i$这个位置）\n\n$num_b,f_b,g_b$为位置在$B$之前，权值比$B$大的值，定义与上面类似\n\n设$ans[i] | i\\in[0,6]$表示之前处理出来的矩阵中第$0$行第$i$列的值（即从一开始$(A,B)$状态转移到第$i$个状态所需要乘上的值）\n\n那么统计最终答案的方法：\n\n$(A,B):num_b * ans[0]$\n\n> 在$B$前面，满足$A>B$的$A$的个数\n\n$(A,C): (f_a + g_b)*ans[1] * \\frac{1}{n-2}$\n\n> 因为最终的$B$的位置不确定，分两种情况考虑\n>\n> 若最终$B$在$A$前面，那么要满足$B>A$\n>\n> 若最终$B$在$A$后面，那么要满足$A>B$，且此时$B$不能放在$i$的位置，这就是为什么前面计算$g_a、g_b$的时候需要$-1$\n>\n> 顺便在这里解释一下所有只要带$C​$的就要除$n-2​$的原因是，在做矩阵快速幂的时候我们是把所有的等价$C​$的总数都算进去了，但此处需要计算某一个具体的$C​$的影响，所以要把方案数除以$n-2​$\n\n$(B,A):num_a * ans[2]$\n\n> 同$(A,B)$\n\n$(B,C):(f_b + g_a) * ans[3] * \\frac{1}{n-2}$\n\n> 同$(A, C)$\n\n$(C, A): \\Big(num_a * (i - 2) + num_b * (n -i)\\Big)*ans[4] * \\frac{1}{n-2}$\n\n> 大致思想同$(A,C)$，考虑$A$和$B$的位置关系\n\n$(C,B): \\Big(num_b * (i-2) + num_a * (n-i)\\Big)*ans[5] * \\frac{1}{n-2}$\n\n> 同$(C,A)$\n\n最后还剩一种$(C,C)$，我们可以把它提出来，对所有的$C$一起算\n\n$(C,C): \\binom{n}{2}*\\frac{1}{2}*ans[6]$\n\n> 对于这些$C$,总共有$\\binom{n}{2}$ 种组合，每两种组合只会产生一个逆序对，要么大的在前面要么小的在前面\n\n------\n\n总复杂度$O(n\\log n + 7^3\\log k)$\n\n\n\n### Something\n\n在最后一步算答案的时候，不难~~观察样例和打表~~发现，$ans[]$中有几对值是相同的\n\n目前网上的所有题解我感觉对$ans[]$的解释都有点问题，不过因为恰好相同所以答案是正确的\n\n但我按自己的想法推出来的东西写完之后是能过的\n\n不知道是不是我自己太菜还没想清楚啊。。。\n\n\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\n\ninline void proc_status()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) <<endl;\n}\n\ntemplate <typename T> T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\nconst int Maxn = 5e5 + 10, Maxk = 10, Mod = 1e9 + 7;\n\nint N, K, A[Maxn], fac[Maxn], ifac[Maxn];\n\ninline void Add (int &a, int b) { a += b; if (a >= Mod) a -= Mod; }\n\ninline int Pow (int a, int b)\n{\n\tint ans = 1;\n\tfor (; b; a = 1ll * a * a % Mod, b >>= 1) if (b & 1) ans = 1ll * ans * a % Mod;\n\treturn ans;\n}\n\ninline int C (int n, int m) {return 1ll * fac[n] * ifac[m] % Mod * ifac[n - m] % Mod; } \n\nstruct BIT\n{\n#define lowbit(x) (x & (-x))\n\tint sum[Maxn];\n\tinline void add (int x, int val) { for (; x <= N; x += lowbit(x)) Add (sum[x], val); }\n\tinline int query (int x) { int ans = 0; for (; x; x -= lowbit(x)) Add (ans, sum[x]); return ans; }\n} T[3];\n\nstruct Matrix\n{\n\tint A[Maxk][Maxk];\n\n\tinline void init () \n\t{ \n\t\tmemset(A, 0, sizeof A); \n\t\tfor (int i = 0; i <= 6; ++i) A[i][i] = 1;\n\t}\n\n\tinline void _init ()\n\t{\n\t\tfor (int i = 0; i <= 6; ++i) A[i][i] = C(N - 2, 2);\n\t\tA[0][1] = A[0][5] = N - 2, A[0][2] = 1;\n\t\tA[1][0] = A[1][3] = A[1][4] = 1, Add (A[1][1], N - 3), A[1][6] = N - 3;\n\t\tA[2][0] = 1, A[2][3] = A[2][4] = N - 2;\n\t\tA[3][1] = A[3][2] = A[3][5] = 1, Add (A[3][3], N - 3), A[3][6] = N - 3;\n\t\tA[4][1] = A[4][2] = A[4][5] = 1, Add (A[4][4], N - 3), A[4][6] = N - 3;\n\t\tA[5][0] = A[5][3] = A[5][4] = 1, Add (A[5][5], N - 3), A[5][6] = N - 3;\n\t\tA[6][1] = A[6][3] = A[6][4] = A[6][5] = 1, Add (A[6][6], 2ll * (N - 4) % Mod + 1);\n\t}\n\n\tinline Matrix operator * (const Matrix &rhs) const\n\t{\n\t\tMatrix c;\n\t\tfor (int i = 0; i <= 6; ++i)\n\t\t\tfor (int j = 0; j <= 6; ++j)\n\t\t\t{\n\t\t\t\tc.A[i][j] = 0;\n\t\t\t\tfor (int k = 0; k <= 6; ++k)\n\t\t\t\t\tAdd (c.A[i][j], 1ll * A[i][k] * rhs.A[k][j] % Mod);\n\t\t\t}\n\t\treturn c;\n\t}\n\n} trans, sum;\n\ninline void Init ()\n{\n\tfac[0] = 1;\n\tfor (int i = 1; i <= N; ++i) fac[i] = 1ll * fac[i - 1] * i % Mod;\n\tifac[N] = Pow(fac[N], Mod - 2);\n\tfor (int i = N - 1; i >= 0; --i) ifac[i] = 1ll * ifac[i + 1] * (i + 1) % Mod;\n\tsum.init(), trans._init();\n}\n\nint Ans[Maxk];\n\ninline void Solve ()\n{\n\tInit();\n\tfor (int i = K; i; trans = trans * trans, i >>= 1)\n\t{\n\t\tif (i & 1) sum = sum * trans;\n\t}\n\tfor (int i = 0; i <= 6; ++i) Ans[i] = sum.A[0][i];\n\n\tint f_sum = 0, g_sum = 0, ans = 0;\n\tint inv = Pow(N - 2, Mod - 2);\n\tfor (int i = 1; i <= N; ++i)\n\t{\n\t\tint num_a = T[0].query (A[i]), f_a = T[1].query (A[i]), g_a = T[2].query (A[i]);\n\t\tint num_b = i - 1 - num_a, f_b = f_sum - f_a, g_b = g_sum - g_a;\n\n\t\tAdd (ans, 1ll * num_b * Ans[0] % Mod);\n\t\tAdd (ans, 1ll * (f_a + g_b) % Mod * Ans[1] % Mod * inv % Mod);\n\t\tAdd (ans, 1ll * num_a * Ans[2] % Mod);\n\t\tAdd (ans, 1ll * (f_b + g_a) % Mod * Ans[3] % Mod * inv % Mod);\n\t\tAdd (ans, 1ll * (1ll * num_a * (i - 2) % Mod + 1ll * num_b * (N - i) % Mod) % Mod * Ans[4] % Mod * inv % Mod);\n\t\tAdd (ans, 1ll * (1ll * num_b * (i - 2) % Mod + 1ll * num_a * (N - i) % Mod) % Mod * Ans[5] % Mod * inv % Mod);\n\n\t\tT[0].add (A[i], 1), T[1].add (A[i], i - 1), T[2].add (A[i], N - i - 1);\n\t\tAdd (f_sum, i - 1), Add (g_sum, N - i - 1);\n\t}\n\tAdd (ans, 1ll * C(N, 2) * Pow(2, Mod - 2) % Mod * Ans[6] % Mod);\n\tcout<<ans<<endl;\n}\n\ninline void Input ()\n{\n\tN = read<int>(), K = read<int>();\n\tfor (int i = 1; i <= N; ++i) A[i] = read<int>();\n}\n\nint main()\n{\n#ifdef hk_cnyali\n\tfreopen(\"A.in\", \"r\", stdin);\n\tfreopen(\"A.out\", \"w\", stdout);\n#endif\n\tInput();\n\tSolve();\n\treturn 0;\n}\n```\n\n","categories":["Problem"],"tags":["数据结构","树状数组","计数","矩阵快速幂","矩阵"]},{"title":"「CF605E」Intergalaxy Trips - 期望 + 贪心","url":"/2019/01/07/%E3%80%8CCF605E%E3%80%8DIntergalaxy-Trips-%E6%9C%9F%E6%9C%9B-%E8%B4%AA%E5%BF%83/","content":"\n$n$个点的完全图，有无数天，每天每条边有$p_{i,j}$的概率出现，求**最优策略下**（可以停在原地）从$1$号点到达$n$号点的期望距离\n\n$n\\le 2000$\n\n<!--more-->\n\n### Links\n\n[CF605E](https://codeforces.com/contest/605/problem/E)\n\n### Solution\n\n贪心考虑不难发现，最优策略一定是每次尽量尝试走向期望时间小的点，如果不能走再考虑第二小的，以此类推，直到某个点的期望时间比它大，那么就不往那边走，直接留在原地\n\n设$dp[x]$表示$x$号点走到$n$号点最优的期望时间，$a_i$表示$dp[x]$第$i$小的$x$,那么有\n$$\ndp[a_i] = 1 + \\sum_{j = 1}^{i}dp[a_j]\\cdot p_{a_i, a_j} \\cdot \\prod_{k=1}^{j-1}(1-p_{a_i,a_k})\n$$\n\n\n显然$a_1 = n$，后面的$a_i$都可以通过不断找出当前局面最小的$dp$值求出\n\n至于计算$dp$值的话，稍微化简一下变成：\n$$\ndp[a_i] = \\frac{1 + \\sum_{j=1}^{i-1}dp[a_j]\\cdot p_{a_i, a_j}\\cdot \\prod_{k=1}^{j-1}(1-p_{a_i, a_k})}{1 - \\prod_{j=1}^{i-1}(1-p_{a_i, a_j})}\n$$\n分别维护一下分子部分和$\\prod$的部分即可\n\n时间复杂度$O(n^2)$\n\n\n\n### Summary\n\n这道题思路真的非常简单，但是自己想的时候就是想不清楚。\n\n这种$dp$和贪心的思想以及转化问题的能力还是太薄弱了\n\n\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\n\ninline void proc_status()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) <<endl;\n}\n\ntemplate <typename T> T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\nconst int Maxn = 1000 + 100;\n\nint N, A[Maxn], Vis[Maxn];\ndouble P[Maxn][Maxn], Dp[Maxn], Prod[Maxn], Sum[Maxn];\n\ninline void Solve ()\n{\n\tfor (int i = 1; i <= N; ++i) Prod[i] = Sum[i] = 1;\n\tA[1] = N, Dp[N] = 0, Vis[N] = 1;\n\tDp[0] = 1e9;\n\tfor (int i = 2; i <= N; ++i)\n\t{\n\t\tfor (int j = 1; j <= N; ++j)\n\t\t{\n\t\t\tif (Vis[j]) continue;\n\t\t\tSum[j] += Dp[A[i - 1]] * P[j][A[i - 1]] * Prod[j];\n\t\t\tProd[j] *= (1.0 - P[j][A[i - 1]]);\n\t\t\tDp[j] = Sum[j] / (1.0 - Prod[j]);\n\t\t}\n\t\tint pos = 0;\n\t\tfor (int j = 1; j <= N; ++j) if (!Vis[j] && Dp[j] < Dp[pos]) pos = j;\n\t\tVis[A[i] = pos] = 1;\n\t}\n\tprintf(\"%.10lf\\n\", Dp[1]);\n}\n\ninline void Input ()\n{\n\tN = read<int>();\n\tfor (int i = 1; i <= N; ++i) for (int j = 1; j <= N; ++j) P[i][j] = 1.0 * read<int>() / 100;\n}\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"E.in\", \"r\", stdin);\n\tfreopen(\"E.out\", \"w\", stdout);\n#endif\n\tInput();\n\tSolve();\n\treturn 0;\n}\n\n```\n\n","categories":["Problem"],"tags":["Codeforces","贪心","概率和期望"]},{"title":"「POI2014」Hotel加强版 - 树形Dp + 长链剖分","url":"/2019/01/07/%E3%80%8CPOI2014%E3%80%8DHotel%E5%8A%A0%E5%BC%BA%E7%89%88-%E6%A0%91%E5%BD%A2Dp-%E9%95%BF%E9%93%BE%E5%89%96%E5%88%86/","content":"\n给出一棵 $n$ 个点的无根树，在这棵树上选三个互不相同的节点，使得这个三个节点两两之间距离相等，输出方案数\n\n$n\\le 10^5$\n\n<!--more-->\n\n### Links\n\n[BZOJ4543](https://www.lydsy.com/JudgeOnline/problem.php?id=4543)\n\n### Solution\n\n不难发现，三个点两两的距离相同只有两种情况：\n\n1. 存在一个三个点公共的$lca$\n\n2. 存在一个点，使得这个点到另外两个子树中距离它为$d$的点以及这个点的$d$次祖先\n\n本质上来说这其实也是同一类\n\n考虑树形dp，通过枚举中心点来统计答案\n\n设$f[x][i]$表示在$x$的子树中，距离$x$为$i$的点数\n\n$g[x][i]$表示在$x$的子树中，两个点的$lca$到$x$的距离为$d-i$的点数，其中$d$为两个点到$lca$的距离\n\n计算答案的话就是$ans += f[y][i-1]*g[x][i]+f[x][i-1]*g[y][i]$\n\n更新$f、g$的话就是\n$$\n\\begin{aligned}\nf[x][i] &+= f[y][i - 1]\\\\\ng[x][i-1] &+= g[y][i]\\\\\ng[x][i+1] &+= f[x][i+1]*f[y][i]\n\\end{aligned}\n$$\n注意先更新答案再转移$f、g$，这样就获得了一个$O(n^2)$的做法\n\n---\n\n接下来介绍一下长链剖分：\n\n观察$dp$式子可以发现，第二维状态只与深度有关，于是可以考虑使用长链剖分来维护这个dp\n\n具体地，类似于轻重链剖分/`dsu on tree`的方法，每个点的重儿子定为子树内叶子深度最大的儿子\n\n不难发现，如果只有一个儿子，我们可以直接将数组赋值\n\n用指针实现的话实际上就是$f[x] = f[y] - 1, g[x] = g[y] + 1$\n\n于是我们就做到了$O(1)$继承重儿子信息，而对于轻儿子则暴力合并\n\n这样做总复杂度是$O(n)$的\n\n>下面是对复杂度的证明：\n>\n>不难发现所有轻儿子都是某一条重链的顶部，转移时的复杂度是重链长度\n>\n>那么复杂度拆分成两个部分：直接从重儿子转移$O(1)$，从轻儿子转移$O(heavy\\_len)$\n>\n>因为每个点有且仅有一个父亲，所以一条重链只被一个点暴力转移，而每次转移复杂度是重链长\n>\n>所以总复杂度就是$O(\\sum heavy\\_len)=O(n)$\n\n---\n\n所以如果需要快速合并这一类与深度相关的信息，就可以使用长链剖分了\n\n如果不是与深度相关的话就可以考虑`dsu on tree`/线段树合并\n\n具体写代码的时候有一些关于指针、动态分配内存的~~骚~~操作，需要熟练\n\n\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\n\ninline void proc_status()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) <<endl;\n}\n\ntemplate <typename T> T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\nconst int Maxn = 1e5 + 100;\n\nint N, e, Begin[Maxn], To[Maxn << 1], Next[Maxn << 1];\n\ninline void add_edge (int x, int y) { To[++e] = y; Next[e] = Begin[x]; Begin[x] = e; }\n\nLL Pool[Maxn << 2];\nLL *f[Maxn], *g[Maxn], *now(Pool + 1), ans;\nint dep[Maxn], maxdep[Maxn], son[Maxn];\n\ninline void new_node (int x)\n{\n/**/f[x] = now, now += ((maxdep[x] - dep[x] + 1) << 1);\n/**/g[x] = now, now += ((maxdep[x] - dep[x] + 1) << 1);\n}\n\ninline void dfs_pre (int x, int fa)\n{\n\tmaxdep[x] = dep[x] = dep[fa] + 1;\n\tfor (int i = Begin[x]; i; i = Next[i])\n\t{\n\t\tint y = To[i];\n\t\tif (y == fa) continue;\n\t\tdfs_pre (y, x);\n\t\tChkmax(maxdep[x], maxdep[y]);\n\t\tif (maxdep[y] > maxdep[son[x]]) son[x] = y;\n\t}\n}\n\ninline void dfs (int x, int fa)\n{\n\tif (son[x])\n\t{\n\t\tf[son[x]] = f[x] + 1, g[son[x]] = g[x] - 1;\n\t\tdfs(son[x], x);\n\t}\n\tf[x][0] = 1, ans += g[x][0];\n\tfor (int i = Begin[x]; i; i = Next[i])\n\t{\n\t\tint y = To[i];\n\t\tif (y == fa || y == son[x]) continue;\n\t\tnew_node(y);\n\t\tdfs(y, x);\n\t\tfor (int j = 1; j <= maxdep[y] - dep[x]; ++j)\n\t\t\tans += 1ll * f[y][j - 1] * g[x][j] + 1ll * f[x][j - 1] * g[y][j];\n\t\tfor (int j = 0; j <= maxdep[y] - dep[x]; ++j)\n\t\t{\n\t\t\tif (j) f[x][j] += f[y][j - 1];\n\t\t\tif (j) g[x][j - 1] += g[y][j];\n\t\t\tg[x][j + 1] += 1ll * f[x][j + 1] * f[y][j];\n\t\t}\n\t}\n}\n\ninline void Solve ()\n{\n\tans = 0;\n\tdfs_pre(1, 0);\n\tnew_node(1);\n\tdfs(1, 0);\n\tcout<<ans<<endl;\n}\n\ninline void Input ()\n{\n\tfor (int i = 1; i < N; ++i) { int x = read<int>(), y = read<int>(); add_edge (x, y), add_edge (y, x); }\n}\n\ninline void Init ()\n{\n\te = 0;\n\tmemset(Begin, 0, sizeof Begin);\n\tmemset(son, 0, sizeof son);\n\twhile (now != Pool) *now = 0, --now; *now = 0; now = Pool + 1;\n}\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"three.in\", \"r\", stdin);\n\tfreopen(\"three.out\", \"w\", stdout);\n#endif\n\twhile (scanf(\"%d\", &N) != EOF)\n\t{\n\t\tif (!N) break;\n\t\tInit();\n\t\tInput();\n\t\tSolve();\n\t}\n\treturn 0;\n}\n\n```\n\n\n\n### Debug\n\n* 44, 45L: 动态分配内存的时候只要分配$(maxdep[x] - dep[x] + 1) * 2$，一开始照着yyb博客里分配了$maxdep[x] * 2$，结果RE了","categories":["Problem"],"tags":["动态规划","长链剖分"]},{"title":"「CF860E」Arkady and a Nobody-men - 树剖","url":"/2019/01/03/%E3%80%8CCF860E%E3%80%8DArkady-and-a-Nobody-men-%E6%A0%91%E5%89%96/","content":"\n给你一棵$n$个节点的树\n\n定义 $f (x, y) = \\sum_{p\\in subtree(y),p!=y} [dep(p) \\le dep(x)]$\n\n定义 $g(x) = \\sum_{x\\in subtree(p),p!=x} f (x, p)$\n\n对于所有 $i \\in [1, n]$,求 $g(i)$\n\n$n\\le 5*10^5$​\n\n<!--more-->\n\n### Links\n\n[CF860E](https://codeforces.com/contest/860/problem/E)\n\n\n\n### Solution\n\n考虑每个$p$对$g(i)$的贡献，不难发现$g(i) = \\sum_{dep(p) \\le dep(i),p\\ne i} dep(lca(p,i))$\n\n考虑把所有点按深度从小到大排序，相同深度的同时加入，每加入一个点就把它到根这条链上的节点权值+1\n\n每个点的答案就是它到根链上的权值和\n\n树剖维护，时间复杂度$O(n \\log^2 n)$，CF上能跑过\n\n这道题还有$O(n)$长链剖分的高妙做法，但是并不会\n\n\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\n\ninline void proc_status()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) <<endl;\n}\n\ntemplate <typename T> T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\nconst int Maxn = 5e5 + 100;\n\nint N, fa[Maxn], root, dep[Maxn], dfn[Maxn], dfs_clock, size[Maxn], son[Maxn], top[Maxn];\nint e, Begin[Maxn], To[Maxn << 1], Next[Maxn << 1];\n\ninline void add_edge (int x, int y) { To[++e] = y; Next[e] = Begin[x]; Begin[x] = e; }\n\nvector <int> vec[Maxn];\nint Maxdep;\n\ninline void dfs (int x)\n{\n\tdep[x] = dep[fa[x]] + 1, size[x] = 1;\n\tChkmax(Maxdep, dep[x]);\n\tvec[dep[x]].pb(x);\n\tfor (int i = Begin[x]; i; i = Next[i]) \n\t{ \n\t\tint y = To[i]; \n\t\tdfs(y); \n\t\tsize[x] += size[y];\n\t\tif (size[y] > size[son[x]]) son[x] = y;\n\t}\n}\n\ninline void dfs (int x, int now)\n{\n\tdfn[x] = ++dfs_clock, top[x] = now;\n\tif (son[x]) dfs(son[x], now);\n\tfor (int i = Begin[x]; i; i = Next[i])\n\t{\n\t\tint y = To[i];\n\t\tif (y == fa[x] || y == son[x]) continue;\n\t\tdfs(y, y);\n\t}\n}\n\nLL Ans[Maxn];\n\nnamespace SEG\n{\n#define ls (root << 1)\n#define rs (root << 1 | 1)\n#define lson ls, l, mid\n#define rson rs, mid + 1, r\n\tstruct tree\n\t{\n\t\tLL sum, tag;\n\t} Tree[Maxn << 2];\n\n\tinline void push_up (int root) { Tree[root].sum = Tree[ls].sum + Tree[rs].sum; }\n\tinline void push_down (int root, int l, int r, int mid)\n\t{\n\t\tif (!Tree[root].tag) return ;\n\t\tTree[ls].tag += Tree[root].tag, Tree[rs].tag += Tree[root].tag;\n\t\tTree[ls].sum += Tree[root].tag * (mid - l + 1), Tree[rs].sum += Tree[root].tag * (r - mid);\n\t\tTree[root].tag = 0;\n\t}\n\n\tinline void update (int root, int l, int r, int x, int y, int z)\n\t{\n\t\tif (x <= l && r <= y) { Tree[root].sum += 1ll * (r - l + 1) * z; Tree[root].tag += z; return ; }\n\t\tint mid = l + r >> 1;\n\t\tpush_down (root, l, r, mid);\n\t\tif (x <= mid) update (lson, x, y, z);\n\t\tif (y > mid) update (rson, x, y, z);\n\t\tpush_up (root);\n\t}\n\n\tinline LL query (int root, int l, int r, int x, int y)\n\t{\n\t\tif (x <= l && r <= y) return Tree[root].sum;\n\t\tint mid = l + r >> 1; LL ans = 0;\n\t\tpush_down(root, l, r, mid);\n\t\tif (x <= mid) ans += query (lson, x, y);\n\t\tif (y > mid) ans += query (rson, x, y);\n\t\treturn ans;\n\t}\n\n#undef ls\n#undef rs\n#undef lson\n#undef rson\n}\n\ninline void Update (int x)\n{\n\twhile (x)\n\t{\n\t\tSEG :: update (1, 1, N, dfn[top[x]], dfn[x], 1);\n\t\tx = fa[top[x]];\n\t}\n}\n\ninline LL Query (int x)\n{\n\tLL ans = 0;\n\twhile (x)\n\t{\n\t\tans += SEG :: query (1, 1, N, dfn[top[x]], dfn[x]);\n\t\tx = fa[top[x]];\n\t}\n\treturn ans;\n}\n\ninline void Solve ()\n{\n\tdfs(root);\n\tdfs(root, root);\n\tfor (int i = 1; i <= Maxdep; ++i)\n\t{\n\t\tfor (int j = 0; j < vec[i].size(); ++j) Update (vec[i][j]);\n\t\tfor (int j = 0; j < vec[i].size(); ++j) Ans[vec[i][j]] = Query (vec[i][j]);\n\t}\n\tfor (int i = 1; i <= N; ++i) printf(\"%lld \", Ans[i] - dep[i]);\n}\n\ninline void Input ()\n{\n\tN = read<int>();\n\tfor (int i = 1; i <= N; ++i) fa[i] = read<int>(), add_edge (fa[i], i), (!fa[i]) ? (root = i) : 0;\n}\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"chuyu.in\", \"r\", stdin);\n\tfreopen(\"chuyu.out\", \"w\", stdout);\n#endif\n\tInput();\n\tSolve();\n\treturn 0;\n}\n\n```\n\n","categories":["Problem"],"tags":["Codeforces","线段树","数据结构","树链剖分"]},{"title":"「ZJOI2016」大森林 - LCT","url":"/2019/01/03/%E3%80%8CZJOI2016%E3%80%8D%E5%A4%A7%E6%A3%AE%E6%9E%97-LCT/","content":"\n有$n$棵树，一开始都只有一个节点，标号为1。每棵树都有一个生长节点，有生长出子节点的能力。你需要支持以下$m$个操作：\n\n* `0 l r` ：将第 $l$ 棵树到第 $r$ 棵树的生长节点下面长出一个子节点，子节点的标号为上一个$0$号操作叶子标号加$1$，$l$ 到 $r$ 之间的树长出的节点标号都相同。\n* `1 l r x`：将第 $l$ 棵树到第 $r$ 棵树的生长节点改到标号为 $x$ 的节点。对于 $i\\in [l,r]$ 这棵树，如果标号$x$的点不在其中，那么这个操作对该树不产生影响。\n* `2 x u v`：询问第 $x$ 棵树中节点 $u$ 到节点 $v$ 点的距离。保证这棵树中节点 $u$ 和节点 $v$ 存在。\n\n$n\\le 10^5, m\\le 3 * 10^5$\n\n<!--more-->\n\n### Links\n\n[Luogu P3348](https://www.luogu.org/problemnew/show/P3348)\n\n\n\n### Solution\n\n因为题目保证询问的节点存在，所以对于每一棵树，我们都可以把它先操作完再询问。\n\n考虑离线，按树的编号做扫描线，即先把第一棵树的形态全都建出来，回答询问，然后把它变化到第二棵树的形态……以此类推\n\n那么现在就需要考虑如何从某一棵树变化到下一棵树\n\n不难发现，更换生长节点的实质就是更换某些节点的父亲：在$l$处将当前生成节点及其包含的节点全部移植到它更改后的位置，再在$r+1$处移植回来\n\n为了方便进行这个操作，我们在每个生长节点下新建一个虚点（虚点权值为$0$，实点权值为$1$），把接下来需要生长出的节点都接在这个虚点的下方，那么每次只需要更换虚点的父亲即可\n\n形象地理解以下，一开始形成的是一棵这样的东西：\n\n![19-1-3-1](/images/19-1-3-1.jpg)\n\n就是一条虚点构成的链，上面带了许多实点\n\n每次操作就是把某个虚点切断它与父亲的边，再连到某个实点上\n\n---\n\n最后考虑一下如何计算两点距离\n\n因为这道题树是有根的，`LCT`不能`make_root`，因此不能`split`算答案\n\n那么直接用$sum[x]+sum[y]-2*sum[lca]$即可\n\n对于求 $lca$ ，先 `access(y)` ，再在`access(x)`的时候得到的**最后一个**跳虚边的点即是它们的 $lca$\n\n具体码的时候要注意因为没有`make_root`，某些细节稍微有改变 \n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\n\ninline void proc_status()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) <<endl;\n}\n\ntemplate <typename T> T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\nconst int Maxn = 5e5 + 100;\n\nint N, M, Q;\n\nint node_cnt, id[Maxn], real_num;\nstruct tree\n{\n\tint fa, ch[2], rev, sum, val;\n} Tree[Maxn];\n\nnamespace LCT\n{\n#define ls (Tree[x].ch[0])\n#define rs (Tree[x].ch[1])\n\tint Stack[Maxn], top;\n\n\tinline int is_root (int x) { return Tree[Tree[x].fa].ch[0] != x && Tree[Tree[x].fa].ch[1] != x; }\n\tinline int judge (int x) { return Tree[Tree[x].fa].ch[1] == x; }\n\tinline void connect (int x, int f, int dir) { Tree[x].fa = f; Tree[f].ch[dir] = x; } \n\tinline void push_up (int x) { Tree[x].sum = Tree[ls].sum + Tree[rs].sum + Tree[x].val; }\n\tinline void push_down (int x) { if (Tree[x].rev) swap(ls, rs), Tree[ls].rev ^= 1, Tree[rs].rev ^= 1, Tree[x].rev = 0; } \n\tinline void rotate (int x) \n\t{\n\t\tint f = Tree[x].fa, anc = Tree[f].fa, dirx = judge (x), dirf = judge (f);\n\t\tif (!is_root(f)) Tree[anc].ch[dirf] = x; Tree[x].fa = anc;\n\t\tconnect (Tree[x].ch[dirx ^ 1], f, dirx);\n\t\tconnect (f, x, dirx ^ 1);\n\t\tpush_up(f), push_up(x);\n\t}\n\tinline void splay (int x) \n\t{ \n\t\tStack[++top] = x; for (int y = x; !is_root(y); y = Tree[y].fa) Stack[++top] = Tree[y].fa;\n\t\twhile (top) push_down(Stack[top--]);\n\t\tfor (; !is_root(x); rotate (x)) if (!is_root(Tree[x].fa)) rotate (judge(x) == judge(Tree[x].fa) ? Tree[x].fa : x);\n\t}\n\n\tinline int access (int x) { int y = 0; for (; x; x = Tree[y = x].fa) splay(x), rs = y, push_up(x); return y; }\n\tinline void link (int x, int f) { splay(x); Tree[x].fa = f; }\n\tinline void cut (int x) \n\t{ \n\t\taccess(x), splay (x); \n/**/\tTree[ls].fa = 0, ls = 0; /*not Tree[ls].fa = ls = 0;*/\n\t\tpush_up(x); \n\t}\n\tinline void newnode (int f, int val) \n\t{ \n/**/\t++node_cnt; Tree[node_cnt].val = Tree[node_cnt].sum = val; \n        /*not Tree[++node_cnt].val = Tree[node_cnt].sum = val;*/\n\t\tlink (node_cnt, f); \n\t\tif (val) id[++real_num] = node_cnt; \n\t}\n\tinline int query (int x, int y) \n\t{ \n\t\tint ans = 0;\n\t\taccess (x), splay(x), ans += Tree[x].sum;\n\t\tint lca = access(y); splay(y), ans += Tree[y].sum;\n\t\taccess(lca), splay(lca), ans -= Tree[lca].sum * 2;\n\t\treturn ans;\n\t}\n\n#undef ls\n#undef rs\n}\n\nstruct query { int pos, time, x, y, op; } Query[Maxn];\n\ninline int cmp (query a, query b)\n{\n\tif (a.pos == b.pos) { if (a.op == b.op) return a.time < b.time; return a.op < b.op; }\n\treturn a.pos < b.pos;\n}\n\nint L[Maxn], R[Maxn], Ans[Maxn];\n\ninline void Solve ()\n{\n\tLCT :: newnode(0, 1), LCT :: newnode(1, 0);\n\tL[real_num] = 1, R[real_num] = N;\n\tint last = 2, op_cnt = 0;\n\n\tfor (int i = 1; i <= M; ++i)\n\t{\n\t\tint op = read<int>();\n\t\tif (!op)\n\t\t{\n\t\t\tLCT :: newnode (last, 1);\n\t\t\tL[real_num] = read<int>(), R[real_num] = read<int>();\n\t\t}\n\t\telse if (op == 1)\n\t\t{\n\t\t\tint l = read<int>(), r = read<int>(), x = read<int>();\n\t\t\tChkmax(l, L[x]), Chkmin(r, R[x]);\n\t\t\tif (l > r) continue;\n\t\t\tLCT :: newnode (last, 0);\n\t\t\tQuery[++op_cnt] = (query){l, i, node_cnt, id[x], op};\n\t\t\tQuery[++op_cnt] = (query){r + 1, i, node_cnt, last, op};\n\t\t\tlast = node_cnt;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint x = read<int>(), u = read<int>(), v = read<int>();\n\t\t\tQuery[++op_cnt] = (query){x, ++Q, id[u], id[v], op};\n\t\t}\n\t}\n\t\n\tsort (Query + 1, Query + op_cnt + 1, cmp);\n\n\tfor (int i = 1; i <= op_cnt; ++i)\n\t{\n\t\tif (Query[i].op == 1) LCT :: cut(Query[i].x), LCT :: link (Query[i].x, Query[i].y);\n\t\telse Ans[Query[i].time] = LCT :: query (Query[i].x, Query[i].y);\n\t}\n\n\tfor (int i = 1; i <= Q; ++i) printf(\"%d\\n\", Ans[i]);\n}\n\ninline void Input ()\n{\n\tN = read<int>(), M = read<int>();\n}\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"A.in\", \"r\", stdin);\n\tfreopen(\"A.out\", \"w\", stdout);\n#endif\n\tInput();\n\tSolve();\n\treturn 0;\n}\n\n```\n\n\n\n### Debug\n\n一个超级坑的点。。。\n\n* 73L和78L本质错的地方是一样的，具体见[Debug](https://hk-cnyali.com/Debug/)\n\n","categories":["Problem"],"tags":["数据结构","LCT","省选"]},{"title":"「19.1.2模拟」柴犬 - 伪树剖 + 线段树维护历史最值","url":"/2019/01/02/%E3%80%8C19-1-2%E6%A8%A1%E6%8B%9F%E3%80%8D%E6%9F%B4%E7%8A%AC-%E4%BC%AA%E6%A0%91%E5%89%96-%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%BB%B4%E6%8A%A4%E5%8E%86%E5%8F%B2%E6%9C%80%E5%80%BC/","content":"\n<!--more-->\n\n### Description\n\n给你一棵$n$个节点的树，初始权值为$A_i$，需要支持三种操作：\n\n* 把$(u,v)$这条链上的所有点权值$+x$，与这条链相邻的所有点权值$+y$\n* 查询$x$的权值\n* 查询$x$权值的历史最大值\n\n\n\n### Constraints\n\n$n,m\\le 10^5$\n\n\n\n### Solution\n\n首先考虑如何用维护历史最大值，区间修改单点查询\n\n线段树维护两个`tag`：`now`表示当前的加法标记，`max`表示加法标记的最大值\n\n注意，这里的两个`tag`都是还未下传的，只要下传就都要设为0\n\n下面是`push_down`的代码：\n\n```cpp\ninline void push_down (int root)\n{\n\tif (!Tree[root].now && !Tree[root].max) return ;\n\tChkmax(ls.max, ls.now + Tree[root].max);\n\tChkmax(rs.max, rs.now + Tree[root].max);\n\tls.now += Tree[root].now, rs.now += Tree[root].now;\n\tTree[root].now = Tree[root].max = 0;\n}\n```\n\n---\n\n接下来考虑如何做这道题\n\n不难发现，链上信息可以直接树剖维护，而其相邻点的信息就其实是轻儿子信息\n\n考虑稍微改变一下剖分方法，把所有轻儿子按照父亲的 $dfs$ 序排序\n\n感性理解一下就是先自顶向下遍历重链上的每个重儿子，全部遍历完后再自顶向下遍历重链上每个重儿子的轻儿子。 代码如下：\n\n```cpp\nvoid work1(int o) {\n\tid[o] = ++clk;\n\tif (son[o]) work1(son[o]);\n}\n\nvoid work2(int o) {\n\tidl[o] = clk + 1;\n\tfor (int i = Begin[o]; i; i = Next[i]) {\n\t\tint u = to[i];\n\t\tif (u == fa[o] || u == son[o]) continue;\n\t\tid[u] = ++clk;\n\t}\n\tidr[o] = clk;\n\tif (son[o]) work2(son[o]);\n}\n\nvoid DFS_decompose(int o) {\n\tif (son[fa[o]] == o) top[o] = top[fa[o]]; \n\telse {\n\t\ttop[o] = o;\n\t\tif (son[o]) work1(son[o]);\n\t\twork2(o);\n\t}\n\tfor (int i = Begin[o]; i; i = Next[i]) {\n\t\tint u = to[i];\n\t\tif (u == fa[o]) continue;\n\t\tDFS_decompose(u);\n\t}\n}\n```\n\n其中`work1`是遍历重儿子，`work2`是遍历轻儿子，`DFS_decompose`是整个剖分的过程\n\n这样剖分过后，就能很好地在线段树上维护重链的一段轻儿子的信息了（因为是连续的）\n\n有一些~~很多~~很骚的细节见代码注释\n\n\n\n### Code(from dy0607)\n\n由于dy的代码实在是写得太好了，忍不住直接贴他的了\n\n```cpp\n#include <bits/stdc++.h>\n\n#define For(i, j, k) for (int i = j; i <= k; i++)\n#define Forr(i, j, k) for (int i = j; i >= k; i--)\n\nconst int N = 1e5 + 10;\n\nusing namespace std;\n\nstruct Info {\n\tint mx, cur;\n\t\n\tInfo operator + (Info b) const {\n\t\treturn (Info){max(cur + b.mx, mx), cur + b.cur};\n\t}\n};\n\nint val[N];\n\nstruct Segment_Tree {\n\n\tInfo A[N << 2];\n\n\t#define lc (o << 1)\n\t#define rc (o << 1 | 1)\n\t#define M ((L + R) >> 1)\t\n\n\tvoid build(int o, int L, int R) {\n\t\tif (L == R) A[o] = (Info){val[L], val[L]};\n\t\telse build(lc, L, M), build(rc, M + 1, R);\n\t}\n\n\tvoid pushdown(int o) {\n\t\tA[lc] = A[lc] + A[o], A[rc] = A[rc] + A[o];\n\t\tA[o] = (Info){0, 0};\n\t}\n\n\tvoid add(int o, int L, int R, int l, int r, Info w) {\n\t\tif (l <= L && R <= r) A[o] = A[o] + w;\n\t\telse {\n\t\t\tpushdown(o);\n\t\t\tif (l <= M) add(lc, L, M, l, r, w);\n\t\t\tif (r > M) add(rc, M + 1, R, l, r, w);\n\t\t}\n\t}\n\n\tvoid add(int o, int L, int R, int l, int r, int w) {\n\t\tadd(o, L, R, l, r, (Info){w, w});\n\t}\n\n\tInfo query(int o, int L, int R, int x) {\n\t\tif (L == R) return A[o];\n\t\telse {\n\t\t\tpushdown(o);\n\t\t\treturn x <= M ? query(lc, L, M, x) : query(rc, M + 1, R, x);\n\t\t}\n\t}\n\n}T;\n\nint Begin[N], Next[N << 1], to[N << 1], e;\n\nvoid add(int u, int v) {\n\tto[++e] = v, Next[e] = Begin[u], Begin[u] = e;\n}\n\nint n, m;\nint A[N];\n\nint fa[N], sz[N], son[N], dep[N];\n\nvoid DFS_init(int o) {\n\tsz[o] = 1;\n\tfor (int i = Begin[o]; i; i = Next[i]) {\n\t\tint u = to[i];\n\t\tif (u == fa[o]) continue;\n\t\tfa[u] = o, dep[u] = dep[o] + 1;\n\t\tDFS_init(u);\n\t\tsz[o] += sz[u];\n\t\tif (sz[u] > sz[son[o]]) son[o] = u;\n\t}\n}\n\nint top[N], id[N], idl[N], idr[N], clk;\n\nvoid work1(int o) {\n\tid[o] = ++clk;\n\tif (son[o]) work1(son[o]);\n}\n\nvoid work2(int o) {\n\tidl[o] = clk + 1;\n\tfor (int i = Begin[o]; i; i = Next[i]) {\n\t\tint u = to[i];\n\t\tif (u == fa[o] || u == son[o]) continue;\n\t\tid[u] = ++clk;\n\t}\n\tidr[o] = clk;\n\tif (son[o]) work2(son[o]);\n}\n\nvoid DFS_decompose(int o) {\n\tif (son[fa[o]] == o) top[o] = top[fa[o]]; \n\telse {\n\t\ttop[o] = o;\n\t\tif (son[o]) work1(son[o]);\n\t\twork2(o);\n\t}\n\tfor (int i = Begin[o]; i; i = Next[i]) {\n\t\tint u = to[i];\n\t\tif (u == fa[o]) continue;\n\t\tDFS_decompose(u);\n\t}\n}\n\nint main() {\n\n\tfreopen(\"t.in\", \"r\", stdin);\n\tfreopen(\"t.out\", \"w\", stdout);\n\n\tscanf(\"%d%d\", &n, &m);\n\tFor(i, 1, n) scanf(\"%d\", &A[i]);\n\tFor(i, 2, n) {\n\t\tint u, v;\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tadd(u, v), add(v, u);\n\t}\n\t\n\tdep[1] = 1;\n\tDFS_init(1);\n\tid[1] = clk = 1;\n\tDFS_decompose(1);\n\n\tFor(i, 1, n) val[id[i]] = A[i];\n\tT.build(1, 1, n);\n\n\twhile (m--) {\n\t\tint ty;\n\t\tscanf(\"%d\", &ty);\n\t\tif (!ty) {\n\t\t\tint u, v, x, y;\n\t\t\tscanf(\"%d%d%d%d\", &u, &v, &x, &y);\n\n\t\t\tvector<int> vec;\n\t\t\twhile (top[u] != top[v]) {\n\t\t\t\tint a = top[u], b = top[v];\n\t\t\t\tif (dep[a] < dep[b]) swap(a, b), swap(u, v);\n\t\t\t\tif (u != a) T.add(1, 1, n, id[son[a]], id[u], x);\n\t\t\t\tif (y >= 0) T.add(1, 1, n, id[a], id[a], x - y);\n\t\t\t\telse vec.push_back(id[a]);\n\t\t\t\t/*\n\t\t\t\t   对于每一个重链顶端(除了询问链的最底部)的点，它都会在158行被算+y的贡献，但它实际贡献是+x，所以在149行需要算x-y的贡献\n\t\t\t\t   那为什么要讨论y的正负呢？\n\t\t\t\t   假设某个点权值本来为3,如果+2再-2的话，历史最大值就变成了5，而实际上这个+2再-2的操作是不存在的\n\t\t\t\t   所以需要判断y的正负，若y>=0则先-y，再+y；若y<0则先+y,再-y。这样就能保证先往小的更新，再边大，就不会影响历史最大值\n\t\t\t\t*/\n\t\t\t\tif (idl[a] <= idr[u]) T.add(1, 1, n, idl[a], idr[u], y); // 轻儿子信息更新\n\t\t\t\tif (son[u]) T.add(1, 1, n, id[son[u]], id[son[u]], y);\n\t\t\t\tu = fa[a];\n\t\t\t}\n\t\t\tif (dep[u] > dep[v]) swap(u, v);\n\n\t\t\tif (u == top[u]) {\n\t\t\t\tT.add(1, 1, n, id[u], id[u], x);\n\t\t\t\tif (u != v) T.add(1, 1, n, id[son[u]], id[v], x);\n\t\t\t} else {\n\t\t\t\tT.add(1, 1, n, id[u], id[v], x);\n\t\t\t}\n\t\t\t/*\n\t\t\t   上面要把重链的顶部单独考虑\n\t\t\t   这是因为重链的顶端会作为它父亲的某个轻儿子被遍历到，所以重链的顶端和这条重链下面的部分是不一定连续的\n\t\t\t*/\n\t\t\tif (idl[u] <= idr[v]) T.add(1, 1, n, idl[u], idr[v], y);\n\t\t\tif (son[v]) T.add(1, 1, n, id[son[v]], id[son[v]], y);\n\t\t\tif (fa[u]) T.add(1, 1, n, id[fa[u]], id[fa[u]], y);\n\t\t\tfor (int o : vec) T.add(1, 1, n, o, o, x - y); \n\t\t} else {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\tInfo ans = T.query(1, 1, n, id[x]);\n\t\t\tprintf(\"%d\\n\", ty == 1 ? ans.cur : ans.mx);\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n\n","categories":["Problem"],"tags":["线段树","树链剖分"]},{"title":"「UOJ #207」共价大爷游长沙 - LCT","url":"/2019/01/01/%E3%80%8CUOJ-207%E3%80%8D%E5%85%B1%E4%BB%B7%E5%A4%A7%E7%88%B7%E6%B8%B8%E9%95%BF%E6%B2%99-LCT/","content":"\n给你一棵$n$个点的树，需要支持4种操作：\n\n* 在路径集合中加入一条路径\n* 在路径集合中删除一条路径\n* 删一条边加一条边\n* 查询一条边是否被集合中所有路径经过\n\n$n\\le100000, m\\le300000$\n\n<!--more-->\n\n### Links\n\n[UOJ207](http://uoj.ac/problem/207)\n\n\n\n### Solution\n\n这道题好巧妙啊\n\n不难发现，如果某一条边$(x,y)$要满足被集合中所有路径经过，就要满足以$x$为根时，对于集合中每一条路经有且仅有一个端点在$y$的子树中\n\n于是可以给每条路径随机一个权值，每加入一条路径，就将两个端点的点权异或上这个权值\n\n用`LCT`维护子树权值异或和，每次询问对应子树内的权值异或和是否等于当前所有路径的权值异或和\n\n\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\n\ninline void proc_status()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) <<endl;\n}\n\ntemplate <typename T> T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\nconst int Maxn = 1e5 + 100, Maxm = 3e5 + 100;\n\nint N, M;\nstruct point { int x, y, z; }  Point[Maxm];\n\nnamespace LCT\n{\n#define ls Tree[x].ch[0]\n#define rs Tree[x].ch[1]\n\tstruct tree\n\t{\n\t\tint fa, ch[2], rev, val, sum, sum_v;\n\t\t// sum维护的子树信息，sum_v维护的虚子树信息，val是本身权值\n\t} Tree[Maxn];\n\tint Stack[Maxn], top;\n\n\tinline int is_root (int x) { return Tree[Tree[x].fa].ch[0] != x && Tree[Tree[x].fa].ch[1] != x; }\n\tinline int judge (int x) { return Tree[Tree[x].fa].ch[1] == x; }\n\tinline void push_up (int x) { Tree[x].sum = Tree[ls].sum ^ Tree[rs].sum ^ Tree[x].val ^ Tree[x].sum_v; }\n\tinline void push_down (int x) { if (Tree[x].rev) swap(ls, rs), Tree[ls].rev ^= 1, Tree[rs].rev ^= 1, Tree[x].rev = 0; }\n\tinline void connect (int x, int f, int dir) { Tree[x].fa = f, Tree[f].ch[dir] = x; }\n\tinline void rotate (int x)\n\t{\n\t\tint f = Tree[x].fa, anc = Tree[f].fa, dirx = judge(x), dirf = judge(f);\n\t\tif (!is_root(f)) Tree[anc].ch[dirf] = x; Tree[x].fa = anc;\n\t\tconnect (Tree[x].ch[dirx ^ 1], f, dirx);\n\t\tconnect (f, x, dirx ^ 1);\n\t\tpush_up (f), push_up(x);\n\t}\n\tinline void splay (int x)\n\t{\n\t\tStack[++top] = x; for (int y = x; !is_root(y); y = Tree[y].fa) Stack[++top] = Tree[y].fa;\n\t\twhile (top) push_down (Stack[top--]);\n\t\tfor (; !is_root(x); rotate(x)) if (!is_root(Tree[x].fa)) rotate (judge(Tree[x].fa) == judge(x) ? Tree[x].fa : x);\n\t}\n\tinline void access (int x)\n\t{\n\t\tfor (int y = 0; x; y = x, x = Tree[x].fa)\n\t\t{\n\t\t\tsplay (x);\n\t\t\tTree[x].sum_v ^= Tree[y].sum, Tree[x].sum_v ^= Tree[rs].sum;\n\t\t\trs = y, push_up(x);\n\t\t}\n\t}\n\tinline void make_root (int x) { access(x), splay(x), Tree[x].rev ^= 1; }\n\tinline void split (int x, int y) { make_root(x), access(y), splay(y); }\n\tinline void link (int x, int y) { make_root(x), make_root(y), Tree[x].fa = y, Tree[y].sum_v ^= Tree[x].sum; }\n\tinline void cut (int x, int y) { split(x, y); Tree[x].fa = Tree[y].ch[0] = 0; push_up(y); }\n\tinline int query (int x, int y) { split(x, y); return Tree[x].sum; }\n\tinline void modify (int x, int val) { make_root(x), Tree[x].val ^= val, push_up(x); }\n}\n\ninline void Solve ()\n{\n\tfor (int i = 1; i < N; ++i) LCT :: link (read<int>(), read<int>());\n\tint sum_val = 0, point_cnt = 0;\n\twhile (M--)\n\t{\n\t\tint op = read<int>();\n\t\tif (op == 1) LCT :: cut (read<int>(), read<int>()), LCT :: link (read<int>(), read<int>());\n\t\telse if (op == 2)\n\t\t{\n\t\t\tint x = rand() % (int)(1e9) + 1;\n\t\t\tPoint[++point_cnt].x = read<int>(), Point[point_cnt].y = read<int>(), Point[point_cnt].z = x;\n\t\t\tLCT :: modify (Point[point_cnt].x, x), LCT :: modify (Point[point_cnt].y, x);\n\t\t\tsum_val ^= x;\n\t\t}\n\t\telse if (op == 3)\n\t\t{\n\t\t\tint id = read<int>();\n\t\t\tLCT :: modify (Point[id].x, Point[id].z), LCT :: modify (Point[id].y, Point[id].z);\n\t\t\tsum_val ^= Point[id].z;\n\t\t}\n\t\telse printf(\"%s\\n\", LCT :: query (read<int>(), read<int>()) == sum_val ? \"YES\" : \"NO\");\n\t}\n}\n\ninline void Input ()\n{\n\tread<int>(), N = read<int>(), M = read<int>();\n\tsrand(N + M);\n}\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"A.in\", \"r\", stdin);\n\tfreopen(\"A.out\", \"w\", stdout);\n#endif\n\tInput();\n\tSolve();\n\treturn 0;\n}\n\n```\n\n","categories":["Problem"],"tags":["数据结构","LCT"]},{"title":"「NOI2014」魔法森林 - LCT","url":"/2018/12/31/%E3%80%8CNOI2014%E3%80%8D%E9%AD%94%E6%B3%95%E6%A3%AE%E6%9E%97-LCT/","content":"\n给定一个$n$个点，$m$条边的无向图，每条边都有权值$a_i,b_i$，求一条从点$1$到点$n$的路径，使得这条路径上边的$a_i,b_i$最大值之和最小。\n\n$2 \\leq n \\leq 5 \\times 10^4, 0 \\leq m \\leq 1 \\times 10^5$\n\n<!--more-->\n\n### Links\n\n[Luogu P2387](https://www.luogu.org/problemnew/show/P2387)\n\n\n\n### Solution\n\n考虑枚举$a_i$的最大值，即把边按$a_i$从小到大排序，然后用`LCT`维护$b_i$的最小生成树，每次对答案` Chkmin`即可\n\n\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\n\ninline void proc_status()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) <<endl;\n}\n\ntemplate <typename T> T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\nconst int Maxn = 50000 + 100, Maxm = 100000 + 100;\n\nint N, M;\n\nstruct edge { int x, y, a, b; } E[Maxm]; \n\ninline int cmp (edge u, edge v) { return u.a < v.a; }\n\nnamespace DSU\n{\n\tint fa[Maxn];\n\tinline void init (int maxn) { for (int i = 1; i <= maxn; ++i) fa[i] = i; }\n\tinline int find (int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); }\n\tinline void link (int x, int y ) { fa[find(x)] = find(y); }\n}\n\nstruct tree { int fa, ch[2], rev, max, val; } Tree[Maxm << 3]; \n\nnamespace LCT\n{\n#define ls (Tree[x].ch[0])\n#define rs (Tree[x].ch[1])\n\tint Stack[Maxm >> 3], top;\n\n\tinline int is_root (int x) { return Tree[Tree[x].fa].ch[0] != x && Tree[Tree[x].fa].ch[1] != x; }\n\tinline int judge (int x) { return Tree[Tree[x].fa].ch[1] == x; }\n\tinline void connect (int x, int f, int dir) { Tree[x].fa = f; Tree[f].ch[dir] = x; }\n\tinline void push_up (int x)\n\t{\n\t\tTree[x].max = Tree[x].val;\n\t\tif (E[Tree[ls].max].b > E[Tree[x].max].b) Tree[x].max = Tree[ls].max;\n\t\tif (E[Tree[rs].max].b > E[Tree[x].max].b) Tree[x].max = Tree[rs].max;\n\t}\n\tinline void push_down (int x) { if (Tree[x].rev) swap(ls, rs), Tree[ls].rev ^= 1, Tree[rs].rev ^= 1, Tree[x].rev = 0; }\n\tinline void rotate (int x)\n\t{\n\t\tint f = Tree[x].fa, anc = Tree[f].fa, dirx = judge(x), dirf = judge(f);\n/**/\tif (!is_root(f)) Tree[anc].ch[dirf] = x; Tree[x].fa = anc;\n\t\tconnect (Tree[x].ch[dirx ^ 1], f, dirx);\n\t\tconnect (f, x, dirx ^ 1);\n\t\tpush_up(f), push_up(x);\n\t}\n\tinline void splay (int x)\n\t{\n\t\tStack[++top] = x; for (int y = x; !is_root(y); y = Tree[y].fa) Stack[++top] = Tree[y].fa;\n\t\twhile (top) push_down (Stack[top--]);\n\t\tfor (; !is_root(x); rotate(x)) if (!is_root(Tree[x].fa)) rotate (judge(x) == judge(Tree[x].fa) ? Tree[x].fa : x);\n\t}\n\n\tinline void access (int x) { for (int y = 0; x; y = x, x = Tree[x].fa) splay(x), rs = y, push_up(x); }\n\tinline void make_root (int x) { access (x), splay (x), Tree[x].rev ^= 1; }\n\tinline void split (int x, int y) { make_root(x), access (y), splay (y); }\n\tinline void link (int x, int y) { make_root(x), Tree[x].fa = y; }\n\tinline void cut (int x, int y) { split(x, y); Tree[x].fa = Tree[y].ch[0] = 0; push_up(y); }\n\tinline int query (int x, int y) { split(x, y); return Tree[y].max; }\n\tinline void update (int x, int y, int pos)\n\t{\n\t\tint id = query (x, y);\n\t\tif (E[pos].b < E[id].b)\n\t\t{\n\t\t\tcut (E[id].x, id + N), cut (id + N, E[id].y);\n\t\t\tlink (E[pos].x, pos + N), link (pos + N, E[pos].y);\n\t\t}\n\t}\n}\n\ninline void Solve ()\n{\n\tDSU :: init (N);\n\tsort(E + 1, E + M + 1, cmp);\n\tint ans = 0x3f3f3f3f;\n\tfor (int i = 1; i <= M; ++i)\n\t{\n\t\tint x = E[i].x, y = E[i].y;\n\t\tTree[i + N].val = Tree[i + N].max = i;\n\t\tif (DSU :: find(x) != DSU :: find(y))\n\t\t{\n\t\t\tDSU :: link(x, y);\n\t\t\tLCT :: link (x, i + N), LCT :: link (i + N, y);\n\t\t}\n\t\telse LCT :: update (x, y, i);\n\t\tif (DSU :: find(1) == DSU :: find(N)) Chkmin(ans, E[i].a + E[LCT :: query(1, N)].b);\n\t}\n\tcout<<(ans == 0x3f3f3f3f ? -1 : ans)<<endl;\n}\n\ninline void Input ()\n{\n\tN = read<int>(), M = read<int>();\n\tfor (int i = 1; i <= M; ++i) E[i].x = read<int>(), E[i].y = read<int>(), E[i].a = read<int>(), E[i].b = read<int>();\n}\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"A.in\", \"r\", stdin);\n\tfreopen(\"A.out\", \"w\", stdout);\n#endif\n\tInput();\n\tSolve();\n\treturn 0;\n}\n\n```\n\n\n\n### Debug\n\n* 69L： `rotate`又写错！！！`is_root(f)`写成`is_root(x)`，`dirf`写成`dirx`\n\n","categories":["Problem"],"tags":["数据结构","LCT"]},{"title":"「WC2006」水管局长 - LCT","url":"/2018/12/31/%E3%80%8CWC2006%E3%80%8D%E6%B0%B4%E7%AE%A1%E5%B1%80%E9%95%BF-LCT/","content":"\n给定一个$n$个点$m$条边的图，有$q$次操作：\n\n1. 询问$x$到$y$所有路径中，路径上最大边权的最小值\n2. 删去一条边\n\n$n\\le 1000 ~ m,q\\le10^5$\n\n<!--more-->\n\n### Links\n\n[Luogu P4172](https://www.luogu.org/problemnew/show/P4172)\n\n\n\n### Solution\n\n把询问倒过来就变成`LCT`维护最小生成树模板题，做法见[这篇blog](https://hk-cnyali.com/2018/12/27/LCT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/)\n\n但是还是有很多细节写错。。。\n\n\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\n\ninline void proc_status()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) <<endl;\n}\n\ntemplate <typename T> T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\nconst int Maxn = 1000 + 100, Maxm = 100000 + 100;\n\nint N, M, Q;\nvector <int> Ans;\n\nstruct node\n{\n\tint x, y, z, op;\n}Edge[Maxm], Query[Maxm];\nmap <pii, int> S;\n\nstruct tree\n{\n\tint fa, ch[2], rev, max, val;\n}Tree[Maxm << 3];\n\nnamespace LCT\n{\n#define ls (Tree[x].ch[0])\n#define rs (Tree[x].ch[1])\n\tint Stack[Maxm], top;\n\n\tinline int is_root (int x) { return Tree[Tree[x].fa].ch[0] != x && Tree[Tree[x].fa].ch[1] != x; }\n\tinline int judge (int x) { return Tree[Tree[x].fa].ch[1] == x; }\n\tinline void connect (int x, int f, int dir) { Tree[x].fa = f, Tree[f].ch[dir] = x; }\n\tinline void push_up (int x) \n\t{ \n\t\tTree[x].max = Tree[x].val; \n\t\tif (Edge[Tree[ls].max].z > Edge[Tree[x].max].z) Tree[x].max = Tree[ls].max;\n\t\tif (Edge[Tree[rs].max].z > Edge[Tree[x].max].z) Tree[x].max = Tree[rs].max;\n\t}\n\tinline void push_down (int x) { if (Tree[x].rev) swap(ls, rs), Tree[ls].rev ^= 1, Tree[rs].rev ^= 1, Tree[x].rev = 0; }\n\tinline void rotate (int x)\n\t{\n\t\tint f = Tree[x].fa, anc = Tree[f].fa, dirx = judge(x), dirf = judge(f);\n/**/\tif (!is_root(f)) Tree[anc].ch[dirf] = x; Tree[x].fa = anc;\n\t\tconnect (Tree[x].ch[dirx ^ 1], f, dirx);\n\t\tconnect (f, x, dirx ^ 1);\n/**/\tpush_up(f), push_up(x);\n\t}\n\tinline void splay (int x) \n\t{\n\t\tStack[++top] = x; for (int y = x; !is_root(y); y = Tree[y].fa) Stack[++top] = Tree[y].fa;\n/**/\twhile (top) push_down (Stack[top--]);\n\t\tfor (; !is_root(x); rotate (x)) if (!is_root(Tree[x].fa)) rotate (judge(x) == judge(Tree[x].fa) ? Tree[x].fa: x);\n\t}\n\n\tinline void access (int x) { for (int y = 0; x; y = x, x = Tree[x].fa) splay(x), rs = y, push_up(x); }\n\tinline void make_root (int x) { access (x), splay (x), Tree[x].rev ^= 1; }\n\tinline void split (int x, int y) { make_root(x), access(y), splay(y); }\n\tinline void link (int x, int y) { make_root(x); Tree[x].fa = y; }\n\tinline void cut (int x, int y) { split(x, y); Tree[x].fa = Tree[y].ch[0] = 0; push_up(y); }\n/**/inline int query (int x, int y) { split(x, y); return Tree[y].max; }\n\tinline void update (int x, int y)\n\t{\n\t\tint id = query(x, y), pos = S[mp(x, y)];\n\t\tif (Edge[pos].z < Edge[id].z)\n\t\t{\n\t\t\tcut (Edge[id].x, id + N), cut (id + N, Edge[id].y);\n\t\t\tlink (Edge[pos].x, pos + N), link (pos + N, Edge[pos].y);\n\t\t}\n\t}\n}\n\nnamespace DSU\n{\n\tint fa[Maxn];\n\tinline void init (int maxn) { for (int i = 1; i <= maxn; ++i) fa[i] = i; }\n\tinline int find (int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); }\n\tinline void link (int x, int y) { fa[find(x)] = find(y); }\n}\n\ninline void Solve ()\n{\n\tDSU :: init (N);\n\tfor (int i = 1; i <= M; ++i) \n\t\tif (!Edge[i].op)\n\t\t{\n\t\t\tif (DSU :: find(Edge[i].x) != DSU :: find(Edge[i].y))\n\t\t\t{\n\t\t\t\tLCT :: link (Edge[i].x, i + N), LCT :: link (i + N, Edge[i].y);\n\t\t\t\tDSU :: link (Edge[i].x, Edge[i].y);\n\t\t\t}\n\t\t\telse LCT :: update (Edge[i].x, Edge[i].y);\n\t\t}\n\tfor (int i = Q; i >= 1; --i)\n\t{\n\t\tif (Query[i].op == 1) Ans.pb(Edge[LCT :: query (Query[i].x, Query[i].y)].z);\n\t\telse LCT :: update (Query[i].x, Query[i].y);\n\t}\n\tfor (int i = Ans.size() - 1; i >= 0; --i) printf(\"%d\\n\", Ans[i]);\n}\n\ninline int cmp (node a, node b) { return a.z < b.z; }\n\ninline void Input ()\n{\n\tN = read<int>(), M = read<int>(), Q = read<int>();\n\n\tfor (int i = 1; i <= M; ++i)\n\t{\n\t\tEdge[i].x = read<int>(), Edge[i].y = read<int>(), Edge[i].z = read<int>();\n\t\tS[mp(Edge[i].x, Edge[i].y)] = S[mp(Edge[i].y, Edge[i].x)] = i;\n\t\tTree[N + i].val = Tree[N + i].max = i;\n\t}\n\n\tfor (int i = 1; i <= Q; ++i)\n\t{\n\t\tQuery[i].op = read<int>(), Query[i].x = read<int>(), Query[i].y = read<int>();\n\t\tif (Query[i].op == 2) Edge[S[mp(Query[i].x, Query[i].y)]].op = 1;\n\t}\n}\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"A.in\", \"r\", stdin);\n\tfreopen(\"A.out\", \"w\", stdout);\n#endif\n\tInput();\n\tSolve();\n\treturn 0;\n}\n\n\n```\n\n\n\n### Debug\n\n* 67L：`is_root(f)`写成`is_root(x)`\n* 70L：忘记 `push_up`\n* 75L：写成`push_down(top--)`\n* 84L：返回值写错，返回的最大值而不是最大值的编号","categories":["Problem"],"tags":["数据结构","LCT"]},{"title":"「HNOI2010」弹飞绵羊 - LCT","url":"/2018/12/30/%E3%80%8CHNOI2010%E3%80%8D%E5%BC%B9%E9%A3%9E%E7%BB%B5%E7%BE%8A-LCT/","content":"\nLostmonkey在地上沿着一条直线摆上$n$个装置，每个装置设定初始弹力系数$k_i$。当绵羊达到第$i$个装置时，它会往后弹$k_i$步，达到第$i+k_i$个装置，若不存在第$i+k_i$个装置，则绵羊被弹飞。绵羊想知道当它从第$i$个装置起步时，被弹几次后会被弹飞。\n\n为了使得游戏更有趣，Lostmonkey可以修改某个弹力装置的弹力系数，任何时候弹力系数均为正整数。\n\n$n\\le 200000,m\\le 100000$\n\n<!--more-->\n\n### Links\n\n[Luogu P3203](https://www.luogu.org/problemnew/show/P3203)\n\n[BZOJ2002](https://www.lydsy.com/JudgeOnline/problem.php?id=2002)\n\n\n\n### Solution\n\n[此题分块做法](http://hk-cnyali.com/2018/10/24/%E3%80%8CHNOI2010%E3%80%8D%E5%BC%B9%E9%A3%9E%E7%BB%B5%E7%BE%8A-%E5%88%86%E5%9D%97/)\n\n每个点有且仅有一条出边，可以看作是树上的父亲边\n\n新建一个$n+1$的节点，表示到它就结束\n\n就转化成动态维护每个点到$n+1$的路径长度\n\n`LCT`裸题，每次暴力`link`和`cut`，再维护一下`Splay`里的`size`（相当于是链的长度，而并非真正的子树信息）即可\n\n\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\n\ninline void proc_status()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) <<endl;\n}\n\ntemplate <typename T> T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\nconst int Maxn = 2e5 + 100;\n\nint N, M, A[Maxn];\n\nnamespace LCT\n{\n#define ls (Tree[x].ch[0])\n#define rs (Tree[x].ch[1])\n\tstruct tree\n\t{\n\t\tint fa, ch[2], rev, size;\n\t}Tree[Maxn];\n\n\tint Stack[Maxn], top;\n\n\tinline int is_root (int x) { return Tree[Tree[x].fa].ch[0] != x && Tree[Tree[x].fa].ch[1] != x; }\n\tinline int judge_dir (int x) { return Tree[Tree[x].fa].ch[1] == x; }\n\tinline void push_up (int x) { Tree[x].size = Tree[ls].size + Tree[rs].size + 1; }\n\tinline void push_down (int x) { if (Tree[x].rev) swap(ls, rs), Tree[ls].rev ^= 1, Tree[rs].rev ^= 1, Tree[x].rev = 0; }\n\tinline void connect (int x, int f, int dir) { Tree[x].fa = f, Tree[f].ch[dir] = x; }\n\tinline void rotate (int x)\n\t{\n\t\tint f = Tree[x].fa, anc = Tree[f].fa, dirx = judge_dir(x), dirf = judge_dir(f); \n\t\tif (!is_root(f)) Tree[anc].ch[dirf] = x; Tree[x].fa = anc;\n\t\tconnect (Tree[x].ch[dirx ^ 1], f, dirx);\n\t\tconnect (f, x, dirx ^ 1);\n/**/\tpush_up(f), push_up(x);\n\t}\n\tinline void splay (int x)\n\t{\n/**/\tStack[++top] = x; for (int y = x; !is_root(y); y = Tree[y].fa) Stack[++top] = Tree[y].fa;\n\t\twhile (top) push_down (Stack[top--]);\n\t\tfor (; !is_root(x); rotate(x)) if (!is_root(Tree[x].fa)) rotate (judge_dir(x) == judge_dir(Tree[x].fa) ? Tree[x].fa : x);\n\t}\n\tinline void access (int x) { for (int y = 0; x; y = x, x = Tree[x].fa) splay (x), rs = y, push_up (x); }\n\tinline void make_root (int x) { access (x), splay (x), Tree[x].rev ^= 1; }\n\tinline void link (int x, int y) { make_root(x); Tree[x].fa = y; }\n/**/inline void cut (int x, int y) { make_root(x), access(y), splay(y); Tree[x].fa = Tree[y].ch[0] = 0; push_up(y); }\n\tinline int query (int x) { make_root(N + 1), access(x), splay(x); return Tree[x].size; }\n}\n\ninline void Solve ()\n{\n\tfor (int i = 1; i <= N; ++i)\n\t\tif (i + A[i] <= N) LCT :: link (i, i + A[i]);\n\t\telse LCT :: link (i, N + 1);\n\tM = read<int>();\n\twhile (M--)\n\t{\n\t\tint op = read<int>(), x = read<int>() + 1;\n\t\tif (op == 1) printf(\"%d\\n\", LCT :: query (x) - 1);\n\t\telse \n\t\t{\n\t\t\tint k = read<int>();\n\t\t\tif (x + A[x] <= N) LCT :: cut (x, x + A[x]);\n\t\t\telse LCT :: cut (x, N + 1);\n\t\t\tA[x] = k;\n\t\t\tif (x + A[x] <= N) LCT :: link (x, x + A[x]);\n\t\t\telse LCT :: link (x, N + 1);\n\t\t}\n\t}\n}\n\ninline void Input ()\n{\n\tN = read<int>();\n\tfor (int i = 1; i <= N; ++i) A[i] = read<int>();\n}\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"A.in\", \"r\", stdin);\n\tfreopen(\"A.out\", \"w\", stdout);\n#endif\n\tInput();\n\tSolve();\n\treturn 0;\n}\n\n```\n\n\n\n### Debug\n\n* 58L, 69L：一定要记得`push_up`！！！\n* 62L：一定要记得`push_down`！！！","categories":["Problem"],"tags":["数据结构","LCT","省选"]},{"title":"LCT学习笔记","url":"/2018/12/27/LCT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"\n动态维护树上一些问题的数据结构，前置技能需要`Splay`\n\n~~这个东西好像全世界都会了，就我没写过~~\n\n本文大多数内容都是整理~~抄~~自网上各种博客和hyj的课件\n\n<!--more-->\n\n## 基础知识\n\n### 引入\n\n`Link-Cut-Tree`，简称`LCT`\n\n学完树链剖分后，我们发现很多树上操作问题都可以用树剖解决。可是如果树的形态不断改变，即需要支持加边、删边操作，就需要用到`LCT`了\n\n\n\n#### 实链剖分\n\n类似于轻重链剖分，对于每个点将其与某个儿子的边划为实边，其余的划为虚边\n\n实链剖分中**虚实儿子会不断改变**，因此我们用`Splay`来维护，每条实链对应一个`Splay`\n\n所以其实`LCT`的本质就是利用树剖的思想，把整棵树拆成一条条实链，通过`Splay`维护实链，从而动态维护树上信息\n\n\n\n#### 性质\n\n* 每一个`Splay`维护的是一条从上到下按在原树中深度严格递增的路径， 其内部是以深度为关键字排序\n* 每个节点包含且仅包含于一个`Splay`中\n* 每个节点与它实边相连的点在同一个`Splay`中，实边包含在`Splay`当中；虚边总是由一棵`Splay`中的根连向另一棵`Splay`中最深的节点。连向的节点记录父亲，连出的节点不记录儿子（认父不认子）\n\n\n\n### 基本操作\n\n#### $access(x)$\n\n* 作用：把$x$到原树根节点的路径上**打通**，经过的边全部变成实边，使得原树根与$x$在同一`Splay`中，且$x$是这条路径的一个端点，以维护当前点到原树根的链上的信息\n\n  > 19.3.29UPD\n  >\n  > 注意：一定是**打通**，实际上$x$并没有旋到根的位置\n\n* 实现：重复以下步骤直至$x$与原树的根联通：\n  1. 把$x$点`splay`到当前`Splay`的根\n  2. 改变虚实儿子：把$x$到父亲的实边变成虚边，把父亲连向自己的边变成实边\n  3. `push_up`\n  4. 跳到父亲\n\n> access = splay + change_child + push_up\n\n\n\n#### $make\\_root(x)$\n\n* 作用：把$x$变成原树的根\n\n* 实现：\n\n  1. 先`access(x)`，由于`LCT`的性质，$x$此时在当前`Splay`中深度最大，只有左儿子\n\n  2. 翻转$x$所在的整棵`Splay`，相当于翻转了$x$到原树根的路径，使得当前点只有右儿子，变成深度最小，即为根\n\n     具体实现时，先`splay(x)`，然后只需直接打翻转标记\n  \n  >19.5.29UPD\n  >\n  >为什么要`splay()`？\n  >\n  >实际上`access(x)`时，`x`是没有旋到根的，只是把路径打通。。。\n\n> make_root = access + splay + reverse\n\n\n\n#### $find\\_root(x)$\n\n* 作用：找一个点所在原树的根\n* 实现：`access(x)`并`splay(x)`后，当前`Splay`最左边的点即为原树的根，最后再`splay`一下保证复杂度\n* 注意：\n  1. `find_root`的常数比较大，如果只有加边没有删边操作的话，可以用`DSU`代替此操作\n  2. **在往左走的时候一定要记得`push_down`，且一开始就要`push_down`一下**\n\n>find_root = access + splay + go_left_child + splay\n\n\n\n#### $split(x,y)$\n\n* 作用：将两个点之间的路径放到一个`Splay`中，获取这条链上的信息\n\n* 实现：`make_root(x)`使得$x$成为原树的根，再`access(y)`，最后`splay(y)`\n\n  最后`splay(y)`是用来更新信息的，同时保证`Splay`的复杂度\n\n> split(x, y) = make_root(x) + access(y) + splay(y)\n\n\n\n#### $link(x, y)$\n\n* 作用：连$x − y$的边（这里默认把$y$连到$x$上）\n* 实现：`make_root(x)`后，先判断`find_root(y)`是否等于$x$，如果是则说明已经相连，否则从$x$ 向$y$连一条轻边。\n\n> link(x, y) = make_root(x) + (fa[x] = y)\n\n\n\n#### $cut(x, y)$\n\n* 作用：断开$x − y$的边（这里默认把$y$与父亲$x$的边断掉）\n\n* 实现：判断$x$和$y$之间是否真的存在一条边；若存在，直接切断\n\n  这里实现上有点复杂，解释一下这个代码吧\n\n  ```cpp\n  make_root(x);\n  if (find_root(y) == x && Tree[y].fa == x && !ls(y))\n  {\n      Tree[y].fa = rs(x) = 0;\n      push_up(x);\n  }\n  ```\n\n  因为如果$x$和$y$在同一个联通块中，那么纵使在`find_root(y)`的开始把$y$`splay`到根，最后又把$x$旋回到根了。所以在执行完`find_root(y)==x`这条语句后当前`Splay`的根仍然是$x$\n\n> cut(x, y) = make_root(x) + (f[y] = right_child[x] = 0)\n\n\n\n### 注意点\n\n1. `LCT`中的`Splay`和普通`Splay`的区别：\n   * 在`rotate`时要判断`if(!is_root(f))`，因为有可能$f$已经为当前`Splay`的根，如果不判断的话就会把它向父亲的虚边变实，而这并不是我们所期望的\n   * 在`splay`中循环条件由`while(Tree[x].fa != y)`变成了`while(!is_root(x)`\n   * `splay`中需要先从根`push_down`到当前点，再`rotate`\n\n2. `push_down`一般写法与线段树的有点区别：当前点如果有翻转标记的话，它的左右儿子是还没有被翻转的，在标记下传的同时进行翻转。因此在`find_root`往左儿子走之前就要`push_down`一下。其实也就是**每访问一个点之前就要`push_down`！**\n\n3. UPD 19.3.31\n\n   `LCT`中`make_root`是一个重要的操作，除了`access`之外的所有操作都建立在`make_root`之上\n\n***\n\n至此，`LCT`的基本操作就学习~~口胡~~完啦\n\n~~我是不会告诉你我到现在还没有开始码的~~\n\n\n\n## 应用\n\n### 模拟\n\n用来模拟题目中类似的过程，往往在里面再套上一个数据结构来维护一些信息\n\n### 维护联通性\n\n直接按照题目`link`与`cut`\n\n查询两点连通性：`find_root`，如果没有`cut`的话可以直接用`DSU`\n\n\n\n### 维护链上信息\n\n要修改原树中$u$到$v$的路径上的信息\n\n直接`split(u,v)`，然后在`Splay`中操作，利用`push_down`的lazy标记完成所有点的改变\n\n\n\n### 维护生成树\n\n维护一个图的最小或最大生成树\n\n因为`LCT`无法维护边权，所以考虑化边为点。原图中一条边的连接，在新图中变为两条边，即：\n\n原点——新点——原点\n\n原点不带权，新点带权，其权值为原来的边权\n\n`LCT`维护一下链上最大值和次大值，每次直接连边，或是`split`更新答案\n\n\n\n### 维护边双\n\n加边的时候，如果这两个点已经联通，那么这条边加入后就一定会形成一个环，因此这个环里的所有点就处在同一个边双里\n\n用类似缩点的方法，遇到环，则新建一个点代表这个边双，把这个环里的所有点的父亲指向新点\n\n凡要用到一个点就`x = fa[x]`，相当于踏入这个环就踏进这个新点\n\n这个操作用`DSU`实现就好\n\n\n\n### 维护子树信息（只能维护，无法修改）\n\n我们发现，在`LCT`中都是维护的链上信息，那么如何维护原树子树信息呢？\n\n不难发现，`原树子树信息 = 虚子树 + 实子树 + 自身信息`\n\n于是相当于需要多维护一个虚子树信息\n\n对于每个父亲与自己不在同一`Splay`中的点，把自己的信息加入到自己存的父亲的虚儿子信息库\n\n如果维护信息是可减的，一个数组存，更新是 $O(1)$\n\n如果维护信息不可减（如min，max），就需要堆或者其它数据结构维护,复杂度多一个$\\log$\n\n相对于原来的`LCT`，发生改变的操作有`push_up`，`access`，`link`\n\n变化的原因：\n\n* `push_up`：要多维护虚子树的信息\n* `access`：在改变**虚边**实边时，$x$的虚子树信息会变化，所以要修改\n* `link`：在把$x$向$y$连**虚边**的时候，$y$的虚子树信息会变化，同时因为每个点的子树信息要算上虚子树信息，所以所有$y$祖先的子树信息都会变化，需要暴力把所有祖先修改，很麻烦。但是我们可以先直接`make_root(y)`，这样$y$就没有祖先了 \n\n可以发现，需要修改的地方都是**虚边**改变了的地方，根本原因是`push_up`时只维护了总子树信息，并没有维护虚儿子信息。所以需要手动修改\n\n***\n\n至此，`LCT`的基本功能又学习~~口胡~~完啦\n\n~~我是不会告诉你我到现在还是没有开始码的~~\n\n\n\n## 模板([Luogu P3690](https://www.luogu.org/problemnew/show/P3690))\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\n\ninline void proc_status()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) <<endl;\n}\n\ntemplate <typename T> T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\nconst int Maxn = 3e5 + 100;\n\nint N, M;\n\nnamespace LCT\n{\n#define ls (Tree[x].ch[0])\n#define rs (Tree[x].ch[1])\n\tstruct tree\n\t{\n\t\tint ch[2], fa, rev, sum, val;\n\t}Tree[Maxn];\n\tint Stack[Maxn], top;\n\n\tinline int is_root (int x) { return (Tree[Tree[x].fa].ch[0] != x) && (Tree[Tree[x].fa].ch[1] != x); }\n\n\tinline int judge_dir (int x) { return x == Tree[Tree[x].fa].ch[1]; }\n\n\tinline void push_up (int x) { Tree[x].sum = Tree[ls].sum ^ Tree[rs].sum ^ Tree[x].val; }\n\n\tinline void push_down (int x) { if (Tree[x].rev) swap(ls, rs), Tree[ls].rev ^= 1, Tree[rs].rev ^= 1, Tree[x].rev = 0; }\n\n\tinline void connect (int x, int f, int dir) { Tree[x].fa = f, Tree[f].ch[dir] = x; }\n\n\tinline void rotate (int x)\n\t{\n/**/\tint f = Tree[x].fa, anc = Tree[f].fa, dirx = judge_dir(x), dirf = judge_dir(f);\n\t\tTree[x].fa = anc; if (!is_root(f)) Tree[anc].ch[dirf] = x;\n\t\tconnect (Tree[x].ch[dirx ^ 1], f, dirx);\n\t\tconnect (f, x, dirx ^ 1);\n\t\tpush_up(f), push_up (x);\n\t}\n\n\tinline void splay (int x)\n\t{\n\t\tStack[++top] = x; for (int y = x; !is_root(y); y = Tree[y].fa) Stack[++top] = Tree[y].fa;\n\t\twhile (top) push_down (Stack[top--]);\n\t\tfor (; !is_root(x); rotate(x)) if (!is_root(Tree[x].fa)) rotate (judge_dir(x) == judge_dir(Tree[x].fa) ? Tree[x].fa : x);\n\t}\n\n/**/inline void access (int x) { for (int y = 0; x; y = x, x = Tree[x].fa) splay (x), rs = y, push_up (x); }\n\n\tinline void make_root (int x) { access (x), splay (x), Tree[x].rev ^= 1; }\n\n\tinline int find_root (int x) { access (x), splay (x); push_down (x); while (ls) x = ls, push_down (x); splay (x); return x; }\n\tinline void split (int x, int y) { make_root (x), access (y), splay (y); }\n\n/**/inline void link (int x, int y) { make_root (x); if (find_root (y) == x) return ; Tree[x].fa = y; }\n\n\tinline void cut (int x, int y) { make_root (x); if (find_root (y) == x && Tree[y].fa == x && !Tree[y].ch[0]) Tree[y].fa = rs = 0, push_up (x); }\n\n\tinline int query (int x, int y) { split (x, y); return Tree[y].sum; }\n\n\tinline void modify (int x, int y) { access (x), splay(x); Tree[x].val = y; push_up(x); }\n}\n\ninline void Solve ()\n{\n\twhile (M--)\n\t{\n\t\tint op = read<int>(), x = read<int>(), y = read<int>();\n\t\tif (!op) printf(\"%d\\n\", LCT :: query (x, y));\n\t\tif (op == 1) LCT :: link (x, y);\n\t\tif (op == 2) LCT :: cut (x, y);\n\t\tif (op == 3)  LCT :: modify (x, y);\n\t}\n}\n\ninline void Input ()\n{\n\tN = read<int>(), M = read<int>();\n\tfor (int i = 1; i <= N; ++i) LCT :: Tree[i].val = read<int>();\n}\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"A.in\", \"r\", stdin);\n\tfreopen(\"A.out\", \"w\", stdout);\n#endif\n\tInput();\n\tSolve();\n\treturn 0;\n}\n\n```\n\n","categories":["Algorithm"],"tags":["数据结构","Splay","LCT"]},{"title":"「PKUWC2018」随机算法 - 状压dp","url":"/2018/12/27/%E3%80%8CPKUWC2018%E3%80%8D%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95-%E7%8A%B6%E5%8E%8Bdp/","content":"\n给定一张$n$个点$m$条边的图，按照以下算法求最大独立集\n\n1. 等概率随机一个 $1\\ldots n$的排列 $p[1\\ldots n]$\n2. 维护答案集合 $S$ ，一开始 $S$ 为空集，之后按照 $i=1\\ldots n$的顺序，检查 $\\{p[i]\\}\\cup S$是否是一个独立集，如果是的话就令 $S=\\{p[i]\\}\\cup S$\n3. 最后得到一个独立集 $S$ 作为答案。\n\n求这个算法的正确率，答案对$998244353$取模\n\n$n\\le 20$\n\n<!--more-->\n\n### Links\n\n[LOJ2540](https://loj.ac/problem/2540)\n\n\n\n### Solution\n\n又是一个假概率题，先算出方案数，最后除以$n!$\n\n首先可以$O(n3^n)$暴力dp，每个点有三种状态：考虑过且在独立集中，考虑过且不在独立集中，没考虑过\n\n考虑优化这个dp，把前两种状态合并起来，设$dp[i][state]$表示当前独立集大小为$i$，考虑/没考虑的状态为$state$的方案数\n\n因为对于每个接下来要加入独立集中的点$k(k\\notin state)$，显然与它有连边的点都不能加入独立集中，也就是必须要和这个点一起考虑，才能保证无后效性\n\n因此选完$k$后就必须紧接着选择$w_k$，但$w_k$的内部排列方式可能不同，于是要乘上一个排列数\n\n记$w_k$为与$k$相邻的所有点(**包括它自己**)的集合，那么有\n$$\ndp[i][state] * A_{n-|s|-1}^{|w_k-w_k\\cap state| - 1} \\rightarrow dp[i + 1][state \\cup w_k]\n$$\n\n时间复杂度$O(2^nn^2)$\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\n\ninline void proc_status()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) <<endl;\n}\n\ntemplate <typename T> T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\nconst int Maxn = 21 + 10, Maxs = (1 << 20) + 10000, Mod = 998244353;\n\nint N, M;\nint e, Begin[Maxn], To[Maxn << 2], Next[Maxn << 2];\nint W[Maxn], Dp[Maxn][Maxs], fac[Maxn], ifac[Maxn];\nint Cnt[Maxs];\n\ninline int Pow (int a, int b)\n{\n\tint ans = 1;\n\twhile (b) { if (b & 1) ans = 1ll * ans * a % Mod; a = 1ll * a * a % Mod; b >>= 1; }\n\treturn ans;\n}\n\ninline void add_edge (int x, int y) { To[++e] = y; Next[e] = Begin[x]; Begin[x] = e; }\n\ninline int Calc_P (int n, int m) { return 1ll * fac[n] * ifac[n - m] % Mod; }\n\ninline void Add (int &a, int b) { a += b; if (a >= Mod) a -= Mod; }\n\ninline void Solve ()\n{\n\tint ALL = (1 << N) - 1;\n\tfor (int i = 1; i <= N; ++i)\n\t{\n\t\tW[i] = 1 << (i - 1);\n\t\tfor (int j = Begin[i]; j; j = Next[j])\n\t\t\tW[i] |= (1 << (To[j] - 1));\n\t}\n\tfor (int i = 0; i <= ALL; ++i) Cnt[i] = __builtin_popcount(i);\n\n\tDp[0][0] = 1;\n\tfor (int i = 0; i <= N; ++i)\n\t{\n\t\tfor (int state = 0; state <= ALL; ++state)\n\t\t{\n\t\t\tif (!Dp[i][state]) continue;\n\t\t\tfor (int k = 1; k <= N; ++k)\n\t\t\t{\n\t\t\t\tif ((1 << (k - 1)) & state) continue;\n\t\t\t\tint cnt = Cnt[W[k] ^ (W[k] & state)];\n\t\t\t\tAdd (Dp[i + 1][state | W[k]], 1ll * Dp[i][state] * Calc_P(N - Cnt[state] - 1, cnt - 1) % Mod);\n//\t\t\t\tcout<<state<<\" \"<<(state | W[k])<<\" \"<<Dp[i][state]<<\" \"<<Calc_P(N - Cnt[state] - 1, cnt)<<endl;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = N; i >= 0; --i)\n\t\tif (Dp[i][ALL]) \n\t\t{\n\t\t\tcout<<1ll * Dp[i][ALL] * ifac[N] % Mod<<endl;\n\t\t\treturn ;\n\t\t}\n}\n\ninline void Input ()\n{\n\tN = read<int>(), M = read<int>();\n\twhile (M--)\n\t{\n\t\tint x = read<int>(), y = read<int>();\n\t\tadd_edge (x, y);\n\t\tadd_edge (y, x);\n\t}\n}\n\ninline void Init (int maxn)\n{\n\tfac[0] = 1;\n\tfor (int i = 1; i <= maxn; ++i) fac[i] = 1ll * fac[i - 1] * i % Mod;\n\tifac[maxn] = Pow(fac[maxn], Mod - 2);\n\tfor (int i = maxn - 1; i >= 0; --i) ifac[i] = 1ll * ifac[i + 1] * (i + 1) % Mod;\n}\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"A.in\", \"r\", stdin);\n\tfreopen(\"A.out\", \"w\", stdout);\n#endif\n\tInit(20);\n\tInput();\n\tSolve();\n\treturn 0;\n}\n\n```\n\n","categories":["Problem"],"tags":["动态规划","状态压缩"]},{"title":"「PKUWC2018」Slay the Spire - 贪心 + 动态规划","url":"/2018/12/26/%E3%80%8CPKUWC2018%E3%80%8DSlay-the-Spire-%E8%B4%AA%E5%BF%83-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","content":"\n有 $2n$ 张牌，每张牌上都写着一个数字$w_i$，一共有两种类型的牌，每种类型各 $n$ 张：\n\n1. 攻击牌：打出后对对方造成等于牌上的数字的伤害。\n2. 强化牌：打出后，假设该强化牌上的数字为 $x$，则其他剩下的**攻击牌**的数字都会乘上 $x$。**保证强化牌上的数字都大于 1**。\n\n现在等概率随机从卡组中抽出 $m$ 张牌，最多打出 $k$ 张牌，求在最优出牌策略下期望造成的伤害$\\times \\binom{2n}{m}~\\mathrm{mod}998244353$的值\n\n$n\\le 3000$\n\n<!--more-->\n\n### Links\n\n[LOJ2538](https://loj.ac/problem/2538)\n\n\n\n### Solution\n\n发现这道题显然和期望并没有什么关系，就是求所有情况的伤害之和\n\n先考虑最优策略是什么\n\n贪心考虑不难发现，要尽量多打强化牌，且强化牌足够多的话只打出一张攻击牌（强化牌上的数字大于1且是整数，所以至少是两倍）。具体来说，如果抽的$m$张牌中有$a$张强化牌，那么\n\n1. 若$a<k$：打出$a$张强化牌和前$k-a$大的攻击牌\n2. 若$a\\ge k$：打出$k-1$大的强化牌和最大的一张攻击牌\n\n------\n\n考虑dp，设$F[x][y]​$表示选了$x​$张强化牌，打出$y​$张的倍率和，$G[x][y]​$表示选了$x​$张攻击牌，打出$y​$张的原始伤害和，那么上面两种情况就分别对应$F[a][a] * G[m-a][k-a]​$和$F[a][k-1] * G[m-a][1]​$\n\n注意到打出的牌都是最大的某几张，那么是个套路，可以把原数组排序后再dp\n\n设$f[i][j]$表示在前$i$张强化牌中，总共打出$j$张强化牌,第$i$张必选的倍率和，$g[i][j]$类似，那么有\n$$\nF[x][y] = \\sum_{i=1}^{n}f[i][y] * \\binom{n-i}{x-y}\\\\\nG[x][y] = \\sum_{i=1}^{n}g[i][y] * \\binom{n-i}{x-y}\n$$\n接下来考虑计算$f、g$\n$$\n\\begin{aligned}\nf[i][j] &= w_i * \\sum_{p=1}^{i-1}f[p][j-1]\\\\\ng[i][j] &= w_i * \\binom{i-1}{j-1}+\\sum_{p=1}^{i-1}g[p][j-1]\n\\end{aligned}\n$$\n下面的式子乘的组合数是前面的方案数的总和，因为每种方案都会加上$w_i$。还需要注意$g[0][0]=1$\n\n\n\n### Summary\n\n怎么说呢，dp题一直都是自己不擅长的，还是因为题目做少了。\n\n比如像这道题，看上去很复杂，但实际上思维难度并不高。每一步思路都很清晰，只需要一步一步转化问题，按着思路往下推就能做出来了\n\n可是自己做题时往往不敢去设dp方程，哪怕设出来了也只是想个大概，不敢继续往下推，觉得自己是错的；也不喜欢把已经推出来了的东西或者dp式子写下来，仔细分析。这就导致了做题的时候粗略想两下感觉做不出就去看题解\n\n这个习惯一定得改，对待每道题都要当是考试，把自己能想到的做法都要去尝试，静下心推式子\n\n\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\n\ninline void proc_status()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) <<endl;\n}\n\ntemplate <typename T> T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\nconst int Maxn = 3e3 + 100, Mod = 998244353;\n\nint N, M, K, A[Maxn], B[Maxn];\nint fac[Maxn], ifac[Maxn];\n\ninline int Pow (int a, int b)\n{\n\tint ans = 1;\n\twhile (b) { if (b & 1) ans = 1ll * ans * a % Mod; a = 1ll * a * a % Mod; b >>= 1; }\n\treturn ans;\n}\n\ninline int C (int n, int m) { return 1ll * fac[n] * ifac[m] % Mod * ifac[n - m] % Mod; }\n\nint f[Maxn][Maxn], g[Maxn][Maxn], Sum[Maxn];\n\ninline void Add (int &a, int b) { a += b; if (a >= Mod) a -= Mod; }\n\ninline int F (int x, int y)\n{\n\tint ans = 0;\n\tfor (int i = 0; i <= N; ++i) Add (ans, 1ll * f[i][y] * C(N - i, x - y) % Mod);\n\treturn ans;\n}\n\ninline int G (int x, int y)\n{\n\tint ans = 0;\n\tfor (int i = 1; i <= N; ++i) Add (ans, 1ll * g[i][y] * C(N - i, x - y) % Mod);\n\treturn ans;\n}\n\ninline void Solve ()\n{\n\tsort(A + 1, A + N + 1, greater <int> ());\n\tsort(B + 1, B + N + 1, greater <int> ());\n\tmemset(Sum, 0, sizeof Sum);\n\tf[0][0] = 1;\n\tfor (int i = 1; i <= N; ++i)\n\t{\n\t\tfor (int j = 1; j <= i; ++j) Add (Sum[j], f[i - 1][j]);\n\t\tf[i][1] = A[i];\n\t\tfor (int j = 2; j <= i; ++j) f[i][j] = 1ll * A[i] * Sum[j - 1] % Mod;\n\t}\n\n\tmemset(Sum, 0, sizeof Sum);\n\tfor (int i = 1; i <= N; ++i)\n\t{\n\t\tfor (int j = 1; j <= i; ++j) Add (Sum[j], g[i - 1][j]);\n\t\tg[i][1] = B[i];\n\t\tfor (int j = 2; j <= i; ++j) g[i][j] = (1ll * B[i] * C(i - 1, j - 1) % Mod + Sum[j - 1]) % Mod;\n\t}\n\n\tint ans = 0;\n\tfor (int a = 0; a <= min(N, M); ++a)\n\t{\n\t\tif (a < K) Add (ans, 1ll * F(a, a) * G(M - a, K - a) % Mod);\n\t\telse Add (ans, 1ll * F(a, K - 1) * G(M - a, 1) % Mod);\n\t}\n\tcout<<ans<<endl;\n}\n\ninline void Input ()\n{\n\tN = read<int>(), M = read<int>(), K = read<int>();\n\tfor (int i = 1; i <= N; ++i) A[i] = read<int>();\n\tfor (int i = 1; i <= N; ++i) B[i] = read<int>();\n}\n\ninline void Init (int maxn)\n{\n\tfac[0] = 1;\n\tfor (int i = 1; i <= maxn; ++i) fac[i] = 1ll * fac[i - 1] * i % Mod;\n\tifac[maxn] = Pow(fac[maxn], Mod - 2);\n\tfor (int i = maxn - 1; i >= 0; --i) ifac[i] = 1ll * ifac[i + 1] * (i + 1) % Mod;\n}\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"A.in\", \"r\", stdin);\n\tfreopen(\"A.out\", \"w\", stdout);\n#endif\n\tInit(3000);\n\tint Testcase = read<int>();\n\twhile (Testcase--)\n\t{\n\t\tInput();\n\t\tSolve();\n\t}\n\treturn 0;\n}\n\n```\n\n","categories":["Problem"],"tags":["动态规划","贪心"]},{"title":"线段树分治思想","url":"/2018/12/26/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%88%86%E6%B2%BB%E6%80%9D%E6%83%B3/","content":"\n一个巧妙地处理一类数据结构需要支持删除（也就是修改操作只会在某一段时间内产生影响），且可以离线问题的算法\n\n<!--more-->\n\n## Algorithm\n\n可以发现，如果用来维护答案的数据结构支持删除的话，就可以直接做了\n\n但如果这个数据结构不支持删除，只能撤销操作，就可以考虑线段树分治\n\n---\n\n考虑按时间建线段树，即线段树的下标为时间\n\n那么先把所有操作在线段树上拆开打标记，可以发现每个操作最多打$\\log$个标记\n\n最后在线段树上$dfs$，遇到标记的话就修改，离开时撤销\n\n到达叶子时就能处理叶子所在时间的答案了\n\n这个东西的本质就是一个数据结构在线段树所形成的$dfs$树上跑，而$dfs$树也就相当于一个栈，于是就只需要撤销，能巧妙地代替删除操作\n\n","tags":["线段树","数据结构","线段树分治"]},{"title":"「六省联考2017」分手是祝愿 - 期望 + 动态规划","url":"/2018/12/26/%E3%80%8C%E5%85%AD%E7%9C%81%E8%81%94%E8%80%832017%E3%80%8D%E5%88%86%E6%89%8B%E6%98%AF%E7%A5%9D%E6%84%BF-%E6%9C%9F%E6%9C%9B-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","content":"\n有$n$个灯，状态为$a_i$，按$i$后$i$的约数都改变状态，最后要使得所有灯都关上。\n\n如果当前最优策略$\\le k$直接用最优策略，否则随机按一个灯。\n\n求期望步数$\\cdot n! ~ \\mathrm{mod}~100003$\n\n$n\\le 100000$\n\n<!--more-->\n\n### Links\n\n[Luogu P3750](https://www.luogu.org/problemnew/show/P3750)\n\n\n\n### Solution\n\n不难发现，最优策略就是贪心地从编号大的往编号小的走，碰到一个开着的灯就灭掉，正确性很显然\n\n那么接下来考虑$>k$的时候如何dp\n\n直接考虑设$dp[i]$表示最优策略下还有$i$步结束的期望步数\n$$\ndp[i]=\n\\begin{cases}\ni &(i <= k)\\\\\n1 + \\frac{i}{n}dp[i-1]+\\frac{n-i}{n}dp[i+1]&(k<i\\le n)\n\\end{cases}\n$$\n这是因为最优策略实际上与操作顺序无关，那么就有$\\frac{i}{n}$的概率改对，使得最小步数-1，$\\frac{n-i}{n}$的概率改错，使得最小步数+1\n\n但是这个dp当$k=0$的时候就有问题了\n\n考虑改变$dp$数组的定义，维护差分，即$dp[i]$表示最优策略下从$i$步到$i-1$步的期望步数\n$$\ndp[i]=\n\\begin{cases}\n1 &(i <= k)\\\\\n\\frac{i}{n}+\\frac{n-i}{n}(dp[i+1]+dp[i]+1)&(k<i\\le n)\n\\end{cases}\n$$\n化简一下下面这个式子就能直接算了\n\n\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\n\ninline void proc_status()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) <<endl;\n}\n\ntemplate <typename T> T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\nconst int Maxn = 100000 + 100, Mod = 1e5 + 3;\n\nint N, K, A[Maxn], Dp[Maxn];\n\ninline int Pow (int a, int b)\n{\n\tint ans = 1;\n\twhile (b) { if (b & 1) ans = 1ll * ans * a % Mod; a = 1ll * a * a % Mod; b >>= 1; }\n\treturn ans;\n}\n\ninline void Solve ()\n{\n\tint cnt = 0;\n\tfor (int i = N; i >= 1; --i)\n\t{\n\t\tif (!A[i]) continue;\n\t\t++cnt;\n\t\tfor (int j = 1; j * j <= i; ++j)\n\t\t{\n\t\t\tif (i % j) continue;\n\t\t\tA[j] ^= 1;\n\t\t\tif (j * j != i) A[i / j] ^= 1;\n\t\t}\n\t}\n\tif (cnt <= K)\n\t{\n\t\tfor (int i = 2; i <= N; ++i) cnt = 1ll * cnt * i % Mod;\n\t\tcout<<cnt<<endl;\n\t\treturn ;\n\t}\n\n\tDp[N] = 1;\n\tfor (int i = N - 1; i >= 1; --i) Dp[i] = (1 + 1ll * (N - i) * (1 + Dp[i + 1]) % Mod * Pow(i, Mod - 2) % Mod) % Mod;\n\n\tint ans = K;\n\tfor (int i = cnt; i > K; --i) (ans += Dp[i]) %= Mod;\n\tfor (int i = 2; i <= N; ++i) ans = 1ll * ans * i % Mod;\n\tcout<<ans<<endl;\n}\n\ninline void Input ()\n{\n\tN = read<int>(), K = read<int>();\n\tfor (int i = 1; i <= N; ++i) A[i] = read<int>();\n}\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"A.in\", \"r\", stdin);\n\tfreopen(\"A.out\", \"w\", stdout);\n#endif\n\tInput();\n\tSolve();\n\treturn 0;\n}\n\n```\n\n","categories":["Problem"],"tags":["动态规划","概率和期望","省选"]},{"title":"「HNOI2013」游走 - 高斯消元 + 概率和期望","url":"/2018/12/25/%E3%80%8CHNOI2013%E3%80%8D%E6%B8%B8%E8%B5%B0-%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83-%E6%A6%82%E7%8E%87%E5%92%8C%E6%9C%9F%E6%9C%9B/","content":"\n一个$n$个点$m$条边的无向连通图 \n\n小Z在该图上进行随机游走，初始时小Z在$1​$号顶点，每一步小Z以相等的概率随机选择当前顶点的某条边，沿着这条边走到下一个顶点，获得等于这条边的编号的分数。当小Z到达$n​$号顶点时游走结束，总分为所有获得的分数之和。 \n\n现在，请你对这$m$条边进行编号，使得小Z获得的总分的期望值最小。\n\n$n\\le500$\n\n<!--more-->\n\n### Links\n\n[Luogu P3232](https://www.luogu.org/problemnew/show/P3232)\n\n### Solution\n\n首先，根据排序不等式（或者贪心思想）可以发现，期望经过最多次数越多，分配的权值就要越小\n\n那么转化成求每条边的期望经过次数\n\n再转化一下，转化成求每个点的期望经过次数，即\n$$\np(x,y)=\\frac{p[x]}{deg[x]}+\\frac{p[y]}{deg[y]}\n$$\n因为对于这条边上的两个点，都有度数分之一的概率走这条边\n\n而每个点期望经过次数就是相邻点的期望除以它的度数，即\n$$\np[x] = \\frac{\\sum_{y}p[y]}{deg[x]} + [x==1]\n$$\n\n\n发现这个期望相互之间会有影响，高斯消元求解即可\n\n需要注意的几个点：\n\n* 因为起点一开始第一次并不是从任何一个节点转移过来的，因此需要+1\n* 因为到了终点就会停止，所以与终点相连的边不需要考虑\n\n* 高斯消元找系数最大项是为了更方便判断无解（因为如果找不到系数$>0$的就无解）\n\n  似乎也可以减小精度误差，但并没搞清楚原理，就按方便判无解记住吧\n\n* 浮点数比大小：（以前一直没搞清楚）\n\n  $$\n  a<b \\Rightarrow a-b<-eps\\\\\n  a\\le b \\Rightarrow a-b<eps\n  $$\n\n  感性理解一下的话就是如果$a<b$，那么相对于很小$eps$而言，$a$和$b$的差是远远大于它的，所以是$<-eps$；而如果$a=b$的话，有可能$a$比$b$大一点点，但只要在$eps$误差范围内就能接受，所以是$<eps$\n\n\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\n\ninline void proc_status()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) <<endl;\n}\n\ntemplate <typename T> T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\nconst int Maxn = 500 + 20, eps = 1e-8;\n\nint N, M, e, Begin[Maxn], To[Maxn * Maxn], Next[Maxn * Maxn];\nint deg[Maxn];\npii Edge[Maxn * Maxn];\n\ninline void add_edge (int x, int y) { To[++e] = y; Next[e] = Begin[x]; Begin[x] = e; ++deg[x]; }\n\ndouble P[Maxn];\n\nnamespace Gauss\n{\n\tdouble A[Maxn][Maxn];\n\n\tinline void work ()\n\t{\n\t\tfor (int i = 1; i < N; ++i)\n\t\t{\n\t\t\tint pos = i;\n\t\t\tfor (int j = i + 1; j < N; ++j) if (fabs(A[j][i]) - fabs(A[pos][i]) > eps) pos = j;\n\t\t\tswap(A[pos], A[i]);\n\t\t\tfor (int j = i + 1; j <= N; ++j) A[i][j] /= A[i][i];\n\t\t\tA[i][i] = 1;\n\t\t\tfor (int j = i + 1; j < N; ++j)\n\t\t\t{\n\t\t\t\tfor (int k = i + 1; k <= N; ++k) A[j][k] -= A[j][i] * A[i][k];\n\t\t\t\tA[j][i] = 0;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = N - 1; i >= 1; --i)\n\t\t{\n\t\t\tfor (int j = i + 1; j < N; ++j) A[i][N] -= A[i][j] * P[j];\n\t\t\tP[i] = A[i][N] / A[i][i];\n\t\t}\n\t}\n\t\n\tinline void init ()\n\t{\n\t\tA[1][N] = 1;\n\t\tfor (int i = 1; i < N; ++i)\n\t\t{\n\t\t\tA[i][i] = 1;\n\t\t\tfor (int j = Begin[i]; j; j = Next[j])\n\t\t\t{\n\t\t\t\tint y = To[j];\n\t\t\t\tif (y != N) A[i][y] = -1.0 / deg[y];\n\t\t\t}\n\t\t}\n\t}\n}\n\ndouble Ans[Maxn * Maxn];\n\ninline void Solve ()\n{\n\tGauss :: init();\n\tGauss :: work();\n\tfor (int i = 1; i <= M; ++i)\n\t{\n\t\tif (Edge[i].x != N) Ans[i] += P[Edge[i].x] / deg[Edge[i].x];\n\t\tif (Edge[i].y != N) Ans[i] += P[Edge[i].y] / deg[Edge[i].y];\n\t}\n\tsort(Ans + 1, Ans + M + 1);\n\tdouble ans = 0;\n\tfor (int i = 1; i <= M; ++i)\n\t\tans += Ans[i] * (M - i + 1);\n\tprintf(\"%.3lf\\n\", ans);\n}\n\ninline void Input ()\n{\n\tN = read<int>(), M = read<int>();\n\tfor (int i = 1; i <= M; ++i)\n\t{\n\t\tint x = read<int>(), y = read<int>();\n\t\tEdge[i].x = x, Edge[i].y = y;\n\t\tadd_edge (x, y);\n\t\tadd_edge (y, x);\n\t}\n}\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"A.in\", \"r\", stdin);\n\tfreopen(\"A.out\", \"w\", stdout);\n#endif\n\tInput();\n\tSolve();\n\treturn 0;\n}\n\n```\n\n\n\n### Debug\n\n* $m$最大可能到$maxn * maxn$，一开始开小了","categories":["Problem"],"tags":["概率和期望","高斯消元","省选"]},{"title":"「PKUWC2018」Minimax - 线段树合并","url":"/2018/12/24/%E3%80%8CPKUWC2018%E3%80%8DMinimax-%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%90%88%E5%B9%B6/","content":"\n给你一棵 $n$ 个结点的二叉树，定义结点 $x$ 的权值为：\n\n1. 若 $x$ 没有子结点，那么它的权值会在输入里给出，**保证这类点中每个结点的权值互不相同**。\n\n2. 若 $x$ 有子结点，那么它的权值有 $p_x$ 的概率是它的子结点的权值的最大值，有 $1-p_x$的概率是它的子结点的权值的最小值。\n\n假设 $1$ 号结点的权值有 $m$ 种可能性，**权值第 $i$ 小**的可能性的权值是 $V_i$，它的概率为 $D_i$，求：\n$$\n(\\sum_{i=1}^{m}i\\cdot V_i\\cdot D_i^2)~ \\mathrm{mod}~998244353\n$$\n$n\\le 3*10^5, w_i\\le10^9$\n\n<!--more-->\n\n### Links\n\n[LOJ2537](https://loj.ac/problem/2537)\n\n### Solution\n\n首先考虑$n^2$dp，设$dp[x][i]$表示$x$号点取到排名为$i$权值的概率\n\n通过枚举两个儿子的权值直接转移是$O(n^3)$的，用前缀和优化就变成$O(n^2)$的了\n\n转移式为\n$$\n\\begin{aligned}\ndp[x][i] = &\\sum_{son=0}^{1}dp[ch[x][son]][i] \\times Pre[son\\oplus 1][i-1]\\times p[x]\\\\\n+&dp[ch[x][son]][i]\\times Suf[son\\oplus1][i + 1]\\times(1-p[x])\n\\end{aligned}\n$$\n然后考虑优化\n\n通过观察dp方程可以发现这是一个很经典的套路\n\n注意到转移实际上有两个限制，一是合并子树信息，二是与权值排名大小有关的一个限制\n\n因此可以用线段树合并来优化，需要维护一个区间乘标记\n\n代码中的$sumx,sumy$就是分别维护两棵子树的$Pre[][]\\times p[x]+Suf[][]\\times(1-p[x])$\n\n一个这么傻逼的地方我理解了好久，对线段树合并的理解还是不太够啊。。。\n\n\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\n\ninline void proc_status()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) <<endl;\n}\n\ntemplate <typename T> T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\nconst int Maxn = 3e5 + 100, Mod = 998244353;\n\ninline int Pow (int a, int b)\n{\n\tint ans = 1;\n\twhile (b) { if (b & 1) ans = 1ll * ans * a % Mod; a = 1ll * a * a % Mod; b >>= 1; }\n\treturn ans;\n}\n\nint N, inv = Pow(10000, Mod - 2);\nint ch[Maxn][3], son[Maxn], fa[Maxn], P[Maxn], A[Maxn], Hash[Maxn];\nint Root[Maxn * 20], sum_leaf;\n\nnamespace SEG\n{\n#define ls Tree[root].ch[0]\n#define rs Tree[root].ch[1]\n#define lson ls, l, mid\n#define rson rs, mid + 1, r\n\tint node_cnt;\n\tstruct tree\n\t{\n\t\tint ch[2], sum, tag;\n\t}Tree[Maxn * 20];\n\n\tinline void push_up (int root) { Tree[root].sum = (Tree[ls].sum + Tree[rs].sum) % Mod; }\n\n\tinline void push_down (int root)\n\t{\n\t\tif (Tree[root].tag <= 1) return ;\n\t\tTree[ls].tag = 1ll * Tree[ls].tag * Tree[root].tag % Mod;\n\t\tTree[ls].sum = 1ll * Tree[ls].sum * Tree[root].tag % Mod;\n\t\tTree[rs].tag = 1ll * Tree[rs].tag * Tree[root].tag % Mod;\n\t\tTree[rs].sum = 1ll * Tree[rs].sum * Tree[root].tag % Mod;\n\t\tTree[root].tag = 1;\n\t}\n\n\tinline void update (int &root, int l, int r, int x, int val)\n\t{\n\t\tif (!root) root = ++node_cnt, Tree[root].tag = 1;\n\t\tif (l == r) { Tree[root].sum = val; return ; }\n\t\tint mid = l + r >> 1;\n\t\tpush_down(root);\n\t\tif (x <= mid) update (lson, x, val);\n\t\telse update (rson, x, val);\n\t\tpush_up(root);\n\t}\n\n\tinline int merge (int x, int y, int sumx, int sumy, int p)\n\t{\n\t\tif (!y) { Tree[x].sum = 1ll * Tree[x].sum * sumy % Mod; Tree[x].tag = 1ll * Tree[x].tag * sumy % Mod; return x; }\n\t\tif (!x) { Tree[y].sum = 1ll * Tree[y].sum * sumx % Mod; Tree[y].tag = 1ll * Tree[y].tag * sumx % Mod; return y; }\n\t\tpush_down(x), push_down (y);\n\t\tint xl = Tree[Tree[x].ch[0]].sum, xr = Tree[Tree[x].ch[1]].sum, yl = Tree[Tree[y].ch[0]].sum, yr = Tree[Tree[y].ch[1]].sum;\n\t\tTree[x].ch[0] = merge (Tree[x].ch[0], Tree[y].ch[0], (sumx + 1ll * (1 - p + Mod) % Mod * xr % Mod) % Mod, (sumy + 1ll * (1 - p + Mod) % Mod * yr % Mod) % Mod, p);\n\t\tTree[x].ch[1] = merge (Tree[x].ch[1], Tree[y].ch[1], (sumx + 1ll * p * xl % Mod) % Mod, (sumy + 1ll * p * yl % Mod) % Mod, p);\n\t\tpush_up(x);\n\t\treturn x;\n\t}\n\n\tinline int query (int root, int l, int r)\n\t{\n\t\tif (l == r) return 1ll * l * Hash[l] % Mod * Tree[root].sum % Mod * Tree[root].sum % Mod;\n\t\tint mid = l + r >> 1;\n\t\tpush_down(root);\n\t\treturn (query (lson) + query(rson)) % Mod;\n\t}\n}\n\ninline void dfs (int x)\n{\n\tif (ch[x][0]) dfs(ch[x][0]);\n\tif (ch[x][1]) dfs(ch[x][1]);\n\tif (!son[x]) SEG :: update (Root[x], 1, sum_leaf, A[x], 1);\n\telse if (son[x] == 1) Root[x] = Root[ch[x][0]];\n\telse Root[x] = SEG :: merge (Root[ch[x][0]], Root[ch[x][1]], 0, 0, P[x]);\n}\n\ninline void Solve ()\n{\n\tdfs(1);\n\tprintf(\"%d\\n\", SEG :: query (Root[1], 1, sum_leaf));\n}\n\ninline void Input ()\n{\n\tN = read<int>();\n\tfor (int i = 1; i <= N; ++i) fa[i] = read<int>(), ch[fa[i]][son[fa[i]]++] = i;\n\tfor (int i = 1; i <= N; ++i)\n\t{\n\t\tif (!son[i]) A[i] = Hash[++sum_leaf] = read<int>();\n\t\telse P[i] = 1ll * read<int>() * inv % Mod;\t\n\t}\n\n\tsort(Hash + 1, Hash + sum_leaf + 1);\n\tfor (int i = 1; i <= N; ++i) A[i] = lower_bound(Hash + 1, Hash + sum_leaf + 1, A[i]) - Hash;\n}\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"A.in\", \"r\", stdin);\n\tfreopen(\"A.out\", \"w\", stdout);\n#endif\n\tInput();\n\tSolve();\n\treturn 0;\n}\n\n```\n\n","categories":["Problem"],"tags":["线段树合并","概率和期望"]},{"title":"组合相关基础知识学习笔记","url":"/2018/12/23/%E7%BB%84%E5%90%88%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"\n其实是一些很基础的东西\n\n<!--more-->\n\n## 组合数\n\n### 定义\n\n定义 $\\binom{n}{m}$ 为在将 $n$ 个元素中取出 $m$ 个元素的方案数，显然有\n$$\n\\binom{n}{m} = \\binom{n-1}{m-1} + \\binom{n-1}{m}\\\\\n\\binom{n}{m} = \\frac{n^{\\underline{m}}}{m!}=\\frac{n!}{m!(n-m)!}\n$$\n\n### 一些性质\n\n#### 基本组合恒等式\n\n> $$\n> \\sum_{i=0}^{n}\\binom{n}{m}=2^n\n> $$\n>\n\n$n$个物品选或不选有$2^n$种方案，等于选$0,1,...,n$种方案之和\n\n> $$\n> \\binom{n}{m}=\\frac{n}{m}\\binom{n-1}{m-1}\\\\\n> \\binom{n}{m}=\\frac{n-m+1}{m}\\binom{n}{m-1}\n> $$\n>\n\n按定义展开即可\n> $$\n> \\binom{n}{m}=\\sum_{i=0}^{n-1}\\binom{i}{m-1}\n> $$\n>\n\n考虑固定编号最大的，再在剩下的里面取$m-1$个\n\n>$$\n>\\binom{n+k+1}{n}=\\sum_{i=0}^{n}\\binom{i+k}{i}\n>$$\n>\n\n杨辉三角斜行的性质，画个杨辉三角就能看出来了\n\n> $$\n> \\binom{n}{m}=\\sum_{i=0}^{m}\\binom{m}{i}\\binom{n-m}{m-i}\n> $$\n>\n\n枚举前$m$个物品选了几个\n\n\n\n#### Lucas定理\n\n待填坑\n\n\n\n## 斯特林数\n\n### 第一类斯特林数\n\n1. 定义：$n\\brack m$表示将$n$个物品分成$m$个无序环的方案数\n   $$\n   {n\\brack m}={n - 1\\brack m-1}+(n-1){n-1\\brack m}\n   $$\n   考虑第$n$个物品可以单独放进一个环，或者放在另外任意一个物品后面\n\n2. 生成函数:","categories":["Algorithm"],"tags":["数学","斯特林数","组合数学","二项式定理","Lucas定理"]},{"title":"「PKUWC2018」随机游走 - Min-Max容斥 + 期望","url":"/2018/12/22/%E3%80%8CPKUWC2018%E3%80%8D%E9%9A%8F%E6%9C%BA%E6%B8%B8%E8%B5%B0-Min-Max%E5%AE%B9%E6%96%A5-%E6%9C%9F%E6%9C%9B/","content":"\n给定一棵 $n$ 个结点的树，你从点 $x$ 出发，每次等概率随机选择一条与所在点相邻的边走过去。\n\n有 $Q$ 次询问，每次询问给定一个集合 $S$，求如果从 $x$ 出发一直随机游走，直到点集 $S$ 中所有点都至少经过一次的话，期望游走几步。\n\n特别地，点 $x$（即起点）视为一开始就被经过了一次。\n\n答案对 $998244353$取模。\n\n$n\\le18, Q\\le5000$\n\n<!--more-->\n\n### Links\n\n[LOJ2542](https://loj.ac/problem/2542)\n\n### Solution\n\n发现最后一个点的访问时间就是访问$S$中点的时间的最大值\n\n这个可以$\\mathrm{Min-Max}$容斥，转化为求第一次访问$S$中点的时间\n\n先枚举一个集合$S$，然后考虑树形Dp，设$dp[x]$表示从$x$出发，第一次访问$S$中节点的期望步数（到今天这道题才真正理解期望要倒着推是什么意思）\n\n1. 若$x\\in S$：$dp[x] = 0$\n\n2. 若$x\\notin S$：设$d[x]$表示$x$的度数\n   $$\n   \\begin{aligned}\n   dp[x]&=\\frac{1}{d[x]}(dp[fa[x]]+1+\\sum_{y} dp[y] + 1)\\\\\n   &=\\frac{1}{d[x]}dp[fa[x]] + \\frac{1}{d[x]}(\\sum_{y}dp[y]) + 1\n   \\end{aligned}\n   $$\n   注意到在树形dp的时候是从儿子推到父亲，也就是说，这个式子中$dp[y]$可以看成已知量\n\n   那么就可以表示成$dp[x]=A[x]*dp[fa[x]] + B[x]$的形式（$A[x], B[x]$是已知量）\n\n   代入得到\n   $$\n   \\begin{aligned}\n   dp[x]&=\\frac{1}{d[x]}dp[fa[x]] + \\frac{1}{d[x]}(\\sum_{y}A[y]*dp[x]+B[y]) + 1\n   \\end{aligned}\n   $$\n   通过一些简单的推式子可以得到\n   $$\n   \\begin{cases}\n   A[x] = \\frac{1}{d[x]-\\sum_{y}A[y]}\\\\\n   B[x] = \\frac{(\\sum_{y}B[y]) + d[x]}{d[x] - \\sum_{y}A[y]}\n   \\end{cases}\n   $$\n   然后就能不断往上dp了\n\n需要注意的是，计算答案时不能每次询问$O(3^n)$枚举子集，需要类似高维前缀和的方法$O(n*2^n)$预处理出\n\n\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\n\ninline void proc_status()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) <<endl;\n}\n\ntemplate <typename T> T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\nconst int Maxn = 18 + 10, Maxs = (1 << 18) + 100, Mod = 998244353;\n\nint N, Q, root;\nint e, Begin[Maxn], To[Maxn << 1], Next[Maxn << 1];\nint A[Maxn], B[Maxn];\n\ninline void add_edge (int x, int y) { To[++e] = y; Next[e] = Begin[x]; Begin[x] = e; }\n\nint S;\n\ninline void Add (int &a, int b) { a += b; if (a >= Mod) a -= Mod; }\n\ninline int Pow (int a, int b)\n{\n\tint ans = 1;\n\twhile (b) { if (b & 1) ans = 1ll * ans * a % Mod; a = 1ll * a * a % Mod; b >>= 1; }\n\treturn ans;\n}\n\ninline void dfs (int x, int f)\n{\n\tif ((1 << (x - 1)) & S) { A[x] = B[x] = 0; return ; }\n\n\tint sum1 = 0, sum2 = 0, deg = 0;\n\tfor (int i = Begin[x]; i; i = Next[i])\n\t{\n\t\tint y = To[i];\n\t\t++deg;\n\t\tif (y == f) continue;\n\t\tdfs(y, x);\n\t\tAdd (sum1, A[y]);\n\t\tAdd (sum2, B[y]);\n\t}\n\tA[x] = Pow((deg - sum1 + Mod) % Mod, Mod - 2);\n\tB[x] = 1ll * (sum2 + deg) % Mod * Pow((deg - sum1 + Mod) % Mod, Mod - 2) % Mod;\n}\n\nint Ans[Maxs], bit[Maxs];\n\ninline void Solve ()\n{\n\tint ALL = (1 << N) - 1;\n\tfor (S = 0; S <= ALL; ++S)\n\t{\n\t\tdfs(root, 0);\n\t\tbit[S] = bit[S >> 1] + (S & 1);\n\t\tAns[S] = (bit[S] & 1) ? B[root] : (Mod - B[root]);\n\t}\n\tfor (int i = 1; i <= N; ++i)\n\t\tfor (int state = 0; state <= ALL; ++state)\n\t\t\tif (state & (1 << (i - 1))) Add (Ans[state], Ans[state ^ (1 << (i - 1))]);\n\n\twhile (Q--)\n\t{\n\t\tint k = read<int>(), x = 0;\n\t\twhile (k--) x |= (1 << (read<int>() - 1));\n\t\tprintf(\"%d\\n\", Ans[x]);\n\t}\n}\n\ninline void Input ()\n{\n\tN = read<int>(), Q = read<int>(), root = read<int>();\n\tfor (int i = 1; i < N; ++i)\n\t{\n\t\tint x = read<int>(), y = read<int>();\n\t\tadd_edge (x, y);\n\t\tadd_edge (y, x);\n\t}\n}\n\nint main()\n{\n#ifdef hk_cnyali\n\tfreopen(\"A.in\", \"r\", stdin);\n\tfreopen(\"A.out\", \"w\", stdout);\n#endif\n\tInput();\n\tSolve();\n\treturn 0;\n}\n\n```\n\n","categories":["Problem"],"tags":["容斥","状态压缩","概率和期望","Min-Max容斥"]},{"title":"「PKUSC2018」最大前缀和 - 状压Dp","url":"/2018/12/22/%E3%80%8CPKUSC2018%E3%80%8D%E6%9C%80%E5%A4%A7%E5%89%8D%E7%BC%80%E5%92%8C-%E7%8A%B6%E5%8E%8BDp/","content":"\n给你一个长度为$n$的序列$a$，求它每一种排列的最大前缀和的和，对998244353取模\n\n$n\\le 20$\n\n<!--more-->\n\n### Links\n\n[LOJ6433](https://loj.ac/problem/6433)\n\n### Solution\n\n不难发现，设最大前缀和的位置为$p$，则在$p$前面的那一段所有后缀和都$>0$，$p$后面的那一段所有前缀和都$\\le 0$\n\n用状压dp分别计算这两种情况的方案数，记$sum[i]$为状态$i$包含所有$a_i$的和\n\n1. 第一种情况考虑从后往前逐一加数，若状态$i$满足$sum[i] > 0$，那么可以往前添加一个不在$i$中的数\n\n2. 第二种情况直接往后添加数，和1类似\n\n答案就是$\\sum_{i} sum[i]*f[i]*g[ALL - i]$\n\n\n\n### Summary\n\n这道题并不难，但却想了挺久的时间\n\n想题的时候抓不到题目的关键信息和重要性质，导致不知道从哪里下手，而且也想不太清楚\n\n这还需要大量的做题、思考来弥补\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\n\ninline void proc_status()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) <<endl;\n}\n\ntemplate <typename T> T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\nconst int Maxn = 20 + 10, Maxs = (1 << 20) + 100, Mod = 998244353;\n\nint N, A[Maxn];\nint f[Maxs], g[Maxs];\nLL Sum[Maxs];\n\ninline void Add (int &a, int b) { a += b; if (a >= Mod) a -= Mod; }\n\ninline void Solve ()\n{\n\tint ALL = (1 << N) - 1;\n\tfor (int i = 0; i <= ALL; ++i) for (int j = 1; j <= N; ++j) if ((1 << (j - 1)) & i) Sum[i] += A[j];\n\tfor (int i = 1; i <= N; ++i) f[1 << (i - 1)] = 1;\n\tg[0] = 1;\n\tfor (int i = 0; i <= ALL; ++i)\n\t{\n\t\tif (Sum[i] > 0)\n\t\t{\n\t\t\tfor (int j = 1; j <= N; ++j) if (!((1 << (j - 1)) & i)) Add (f[i | (1 << (j - 1))], f[i]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (int j = 1; j <= N; ++j) if ((1 << (j - 1)) & i) Add (g[i], g[i ^ (1 << (j - 1))]);\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i <= ALL; ++i)\n\t\tAdd (ans, 1ll * (Sum[i] + Mod) * f[i] % Mod * g[ALL ^ i] % Mod);\n\tcout<<ans<<endl;\n}\n\ninline void Input ()\n{\n\tN = read<int>();\n\tfor (int i = 1; i <= N; ++i) A[i] = read<int>();\n}\n\nint main()\n{\n#ifdef hk_cnyali\n\tfreopen(\"A.in\", \"r\", stdin);\n\tfreopen(\"A.out\", \"w\", stdout);\n#endif\n\tInput();\n\tSolve();\n\treturn 0;\n}\n\n```\n\n","categories":["Problem"],"tags":["动态规划","状态压缩"]},{"title":"「ZJOI2016」小星星 - 容斥 + 状压dp","url":"/2018/12/21/%E3%80%8CZJOI2016%E3%80%8D%E5%B0%8F%E6%98%9F%E6%98%9F-%E5%AE%B9%E6%96%A5-%E7%8A%B6%E5%8E%8Bdp/","content":"\n给你一个$n$个点$m$条边的图和一棵$n$个点的树，求给树上的点重新标号，标号不能重复，且标号后树上每条边对应在图中都存在的方案数\n\n$n\\le 17, m\\le \\frac{n*(n-1)}{2}$\n\n<!--more-->\n\n### Links\n\n[Luogu P3349](https://www.luogu.org/problemnew/show/P3349)\n\n[BZOJ4455](https://www.lydsy.com/JudgeOnline/problem.php?id=4455)\n\n\n\n### Solution\n\n考虑树形Dp\n\n容易想到设$dp[x][i]$表示给树上$i$号点标$j$号的方案数\n\n但是由于标号不能重复，所以必须要再记一维$state$，表示$i$的子树的标号集合为$state$，这样才能转移。但是由于这样做需要枚举子集，复杂度不能接受，因此需要优化\n\n注意到，因为有标号不重复（也就是树和图的点需要一一对应）这个条件的限制，才需要枚举子集\n\n那么可以考虑容斥，把这个限制去掉，也就是说有多个点能标同一个标号，这样就很好dp了\n\n先在最外层$2^n$枚举一个标号集合$S$，还是设$dp[x][i]$表示给树上$x$号点标$i$号的方案数，那么每次枚举一个$i\\in S$，暴力枚举$x$的儿子$y$，并且暴力找出$i$在图中所有相邻的点$k$，用$dp[y][k]$去更新$dp[x][i]$的答案即可\n\n\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\n\ninline void proc_status()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) <<endl;\n}\n\ntemplate <typename T> T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\nconst int Maxn = 17 + 10, Maxm = Maxn * Maxn * 2, Maxs = (1 << 17) + 100;\n\nint N, M;\n\nstruct Graph\n{\n\tint e, Begin[Maxn], To[Maxm], Next[Maxm];\n\tinline void add_edge (int x, int y) { To[++e] = y; Next[e] = Begin[x]; Begin[x] = e; }\n}G1, G2;\n\nint A[Maxn], cnt;\nLL Dp[Maxn][Maxn];\n\ninline void dfs (int x, int f)\n{\n\tfor (int i = G2.Begin[x]; i; i = G2.Next[i]) if (G2.To[i] != f) dfs(G2.To[i], x);\n\n\tfor (int i = 1; i <= cnt; ++i)\n\t{\n\t\tDp[x][A[i]] = 1;\n\t\tfor (int j = G2.Begin[x]; j; j = G2.Next[j])\n\t\t{\n/**/\t\tint y = G2.To[j];\n\t\t\tif (y == f) continue ;\n\t\t\tLL sum = 0;\n\t\t\tfor (int k = G1.Begin[A[i]]; k; k = G1.Next[k]) sum += Dp[y][G1.To[k]];\n\t\t\tDp[x][A[i]] *= sum;\n\t\t\tif (!sum) break ;\n\t\t}\n\t}\n}\n\ninline void Solve ()\n{\n\tint ALL = (1 << N);\n\tLL ans = 0;\n\tfor (int state = 0; state < ALL; ++state)\n\t{\n\t\tcnt = 0, memset(Dp, 0, sizeof Dp);\n\t\tfor (int i = 1; i <= N; ++i) if ((1 << (i - 1)) & state) A[++cnt] = i;\n\t\tdfs(1, 0);\n\t\tLL sum = 0;\n\t\tfor (int i = 1; i <= cnt; ++i) sum += Dp[1][A[i]];\n\t\tif ((N - cnt) & 1) ans -= sum;\n\t\telse ans += sum;\n\t}\n\tcout<<ans<<endl;\n}\n\ninline void Input ()\n{\n\tN = read<int>(), M = read<int>();\n\tfor (int i = 1; i <= M; ++i) { int x = read<int>(), y = read<int>(); G1.add_edge (x, y), G1.add_edge (y, x); }\n\tfor (int i = 1; i < N; ++i) { int x = read<int>(), y = read<int>(); G2.add_edge (x, y), G2.add_edge (y, x); }\n}\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"A.in\", \"r\", stdin);\n\tfreopen(\"A.out\", \"w\", stdout);\n#endif\n\tInput();\n\tSolve();\n\treturn 0;\n}\n\n```\n\n\n\n### Debug\n\n* 54L：$j$写成$i$\n\n","categories":["Problem"],"tags":["容斥","动态规划","状态压缩","省选"]},{"title":"「BZOJ3622」已经没有什么好害怕的了 - 容斥 + 二项式反演 + 动态规划","url":"/2018/12/20/%E3%80%8CBZOJ3622%E3%80%8D%E5%B7%B2%E7%BB%8F%E6%B2%A1%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%AE%B3%E6%80%95%E7%9A%84%E4%BA%86-%E5%AE%B9%E6%96%A5-%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%8F%8D%E6%BC%94-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","content":"\n给你两个长度为$n$的序列$a, b$，数之间两两不同\n\n求把它们两两匹配后满足$a_i>b_i$的对数比$a_i<b_i$的对数恰好多$k$对的方案数\n\n$n,k\\le 2000$\n\n<!--more-->\n\n### Links\n\n[BZOJ3622](https://www.lydsy.com/JudgeOnline/problem.php?id=3622)\n\n[Luogu P4859](https://www.luogu.org/problemnew/show/P4859)\n\n### Solution\n\n首先题目显然能够转化为求$a_i>b_i$的对数恰好为$\\frac{k+n}{2}$的方案，方便起见，下文均用$k$表示原来的$\\frac{k+n}{2}$\n\n发现**恰好**并不好求，那么可以转化为**至少**，考虑如何求至少$k$对的方案数\n\n设$dp[i][j]$表示处理到$a$的第$i$个，已经确定了$j$对$a_i>b_i$的方案数\n\n将两个数组从小到大排序，设$Pos[i]$表示$b$中$<a_i$的最靠后的数的下标，则有\n$$\ndp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1] * (Pos[i] - j + 1)\n$$\n前一项是第$i$个不匹配的方案数，后一项是第$i$个匹配的方案数\n\n>  这里需要解释一下后面的$(Pos[i] - j + 1)$：\n>\n> 由于已经把数组排好序了，所以$a$中的第$i$个数能够在$b$中匹配到的数，一定会包括$<i$的能匹配的数，即它前面的能匹配的集合一定是它能匹配集合的一个子集\n>\n> 之前已经选出了$j-1$个数，那么还剩$Pos[i]-(j-1)$个数能选\n>\n> 这就是要把数组排序的原因，算是一个套路了吧\n\n不难发现，$dp[n][i] $乘上剩下$n-i$个数随便放的方案数$(n-i)!$就是至少$i$对的方案数\n\n设$f_i$为恰好$i$对的方案数，$g_i$为至少$i$对的方案数，由二项式反演（也叫广义容斥原理）得：\n$$\n\\begin{aligned}\ng_k&=\\sum_{i=k}^{n}{i\\choose k}f_i\\\\\nf_k&=\\sum_{i=k}^{n}(-1)^{i-k}{i\\choose k}g_i\n\\end{aligned}\n$$\n\n> *P.S. 这个形式的二项式反演并不是很会证，不过用容斥的思想感性理解记忆还是可以的*\n\n直接用$g_i=dp[n][i]*(n-i)!$代入即可\n\n\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\n\ninline void proc_status()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) <<endl;\n}\n\ntemplate <typename T> T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\nconst int Maxn = 2000 + 100, Mod = 1e9 + 9;\n\nint N, K, A[Maxn], B[Maxn], Pos[Maxn], Dp[Maxn][Maxn];\nint fac[Maxn], ifac[Maxn];\n\ninline void Add (int &a, int b) { a += b; if (a >= Mod) a -= Mod; }\n\ninline int Pow (int a, int b)\n{\n\tint ans = 1;\n\twhile (b) { if (b & 1) ans = 1ll * ans * a % Mod; a = 1ll * a * a % Mod; b >>= 1; }\n\treturn ans;\n}\n\ninline int C (int n, int m) { return 1ll * fac[n] * ifac[m] % Mod * ifac[n - m] % Mod; }\n\ninline void Solve ()\n{\n\tif ((N + K) & 1) { puts(\"0\"); return ; }\n\tK = (N + K) >> 1;\n\n\tsort(A + 1, A + N + 1), sort(B + 1, B + N + 1);\n\tfor (int i = 1; i <= N; ++i) Pos[i] = lower_bound(B + 1, B + N + 1, A[i]) - B - 1;\n\n\tDp[0][0] = 1;\n\tfor (int i = 1; i <= N; ++i)\n\t{\n\t\tDp[i][0] = 1;\n/**/\tfor (int j = 1; j <= i; ++j)\n\t\t\tDp[i][j] = (Dp[i - 1][j] + 1ll * Dp[i - 1][j - 1] * max(0, Pos[i] - j + 1) % Mod) % Mod;\n\t}\n\n\tint ans = 0;\n\tfor (int i = K; i <= N; ++i)\n\t{\n\t\tif ((i - K) & 1) Add (ans, Mod - 1ll * C(i, K) * Dp[N][i] % Mod * fac[N - i] % Mod);\n\t\telse Add (ans, 1ll * C(i, K) * Dp[N][i] % Mod * fac[N - i] % Mod);\n\t}\n\tcout<<ans<<endl;\n}\n\ninline void Input ()\n{\n\tN = read<int>(), K = read<int>();\n\tfor (int i = 1; i <= N; ++i) A[i] = read<int>();\n\tfor (int i = 1; i <= N; ++i) B[i] = read<int>();\n}\n\ninline void Init ()\n{\n\tfac[0] = 1;\n\tfor (int i = 1; i <= 2000; ++i) fac[i] = 1ll * fac[i - 1] * i % Mod;\n\tifac[2000] = Pow (fac[2000], Mod - 2);\n\tfor (int i = 2000 - 1; i >= 0; --i) ifac[i] = 1ll * ifac[i + 1] * (i + 1) % Mod;\n}\n\nint main()\n{\n#ifdef hk_cnyali\n\tfreopen(\"A.in\", \"r\", stdin);\n\tfreopen(\"A.out\", \"w\", stdout);\n#endif\n\tInput();\n\tInit();\n\tSolve();\n\treturn 0;\n}\n\n```\n\n\n\n### Debug\n\n* 60L：$i$打成$K$。。。\n\n","categories":["Problem"],"tags":["数学","反演","容斥","动态规划","二项式反演"]},{"title":"「51nod1238」最小公倍数之和V3 - 莫比乌斯反演 + 欧拉函数 + 杜教筛","url":"/2018/12/20/%E3%80%8C51nod1238%E3%80%8D%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0%E4%B9%8B%E5%92%8CV3-%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94-%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0-%E6%9D%9C%E6%95%99%E7%AD%9B/","content":"\n求\n$$\n\\sum_{i=1}^{n}\\sum_{j=1}^{n}\\mathrm{lcm}(i,j)\n$$\n$n\\le 10^{10}$\n\n<!--more-->\n\n### Links\n\n[51nod 1238](http://www.51nod.com/Challenge/Problem.html#!#problemId=1238)\n\n### Solution\n\n> 注：以下所有（其实也包括之前的几篇文章）$S(n)=\\sum_{i=1}^n i$\n\n$$\n\\begin{aligned}\n&\\sum_{i=1}^{n}\\sum_{j=1}^{n}\\mathrm{lcm}(i,j)\\\\\n=&\\sum_{i=1}^{n}\\sum_{j=1}^{n}\\frac{ij}{\\gcd(i,j)}\\\\\n=&\\sum_{d=1}^{n}\\frac{1}{d}\\sum_{i=1}^{n}\\sum_{j=1}^{n}ij[\\gcd(i,j)=d]\\\\\n=&\\sum_{d=1}^{n}d\\sum_{i=1}^{\\lfloor\\frac{n}{d}\\rfloor}\\sum_{j=1}^{\\lfloor\\frac{n}{d}\\rfloor}ij[\\gcd(i,j)=1]\n\\end{aligned}\n$$\n\n化到这一步之后，我硬刚用$\\mu$推了两天时间，尝试了各种方法，最终也只能推出来各种比线性低一点点的玄学复杂度的做法，根本跑不过\n\n因此事实证明，这道题必须用$\\varphi$做，刚好也算是积累了一个$\\varphi$的套路\n\n这个套路长这样：\n$$\n\\sum_{i=1}^{n}i[\\gcd(i,n)=1]=\\frac{\\varphi(n)n+[n=1]}{2}\n$$\n\n>  ~~感性~~证明：\n>\n>  不难发现，若$\\gcd(i,n)=1$，则$\\gcd(n-i,n)=1$（若$n-i$与$n$有公共因子，则$n-(n-i)=i$与$n$也有公共因子，矛盾）\n>\n>  那么任何一对这样的数对答案的贡献就是$n$，而总共有$\\frac{\\varphi}{2}$对，因此得证\n>\n>  Update 12.23\n>\n>  来一发理性证明\n>  $$\n>  \\begin{aligned}\n>  &\\sum_{i=1}^{n}i[gcd(i,n)=1]\\\\\n>  =&\\sum_{d|n}\\mu(d)\\sum_{i=1}^{\\frac{n}{d}}id\\\\\n>  =&\\sum_{d|n}\\mu(d)\\frac{n(\\frac{n}{d}+1)}{2}\\\\\n>  =&\\frac{n}{2}(\\sum_{d|n}\\mu(d)\\frac{n}{d}+\\sum_{d|n}\\mu(d))\\\\\n>  =&\\frac{n}2([n==1]+\\varphi(n))\n>  \\end{aligned}\n>  $$\n>\n\n有了这个套路，就可以接着上一步化式子了\n$$\n\\begin{aligned}\nans&=\\sum_{d=1}^{n}d\\left\\{(2\\sum_{i=1}^{\\lfloor\\frac{n}{d}\\rfloor}i\\sum_{j=1}^{i}j[\\gcd(i,j)=1])-1 \\right\\}\\\\\n&=\\sum_{d=1}^{n}d\\left\\{(2\\sum_{i=1}^{\\lfloor\\frac{n}{d}\\rfloor}i*\\frac{i*\\varphi(i)+[i=1]}{2})-1 \\right\\}\\\\\n&=\\sum_{d=1}^{n}d\\sum_{i=1}^{\\lfloor\\frac{n}{d}\\rfloor}i^2\\varphi(i)\\\\\n&=\\sum_{i=1}^{n}\\varphi(i)i^2S(\\lfloor\\frac{n}{i}\\rfloor)\n\\end{aligned}\n$$\n\n\ntmd就和[这道题](https://hk-cnyali.com/2018/12/17/%E3%80%8CLuogu-P3768%E3%80%8D%E7%AE%80%E5%8D%95%E7%9A%84%E6%95%B0%E5%AD%A6%E9%A2%98-%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94-%E6%9D%9C%E6%95%99%E7%AD%9B/)几乎一模一样了\n\n~~我tm还傻逼地用$\\mu$搞了两天~~\n\n\n\n### Summary\n\n这一道题带来收获还挺多的\n\n首先是那个关于$\\varphi$的套路：$\\sum_{i=1}^{n}i[\\gcd(i,n)=1]=\\frac{\\varphi(n)n+[n=1]}{2}$\n\n其次就是在推假的$\\mu$做法的时候，发现的一些东西：\n\n对于一个这样的式子$\\sum_{d=1}^{n}...\\sum_{g=1}^{\\lfloor\\frac{n}{d}\\rfloor}...$\n\n在化式子的时候，既可以考虑把枚举倍数转化成枚举约数，也可以直接交换$d$和$g$的位置\n\n这就取决于里面的东西是与$dg$相关的比较多还是与$d$或$g$相关的比较多\n\n还有一个小收获是证明了个$(\\mathrm{Id}^2\\mu)*\\mathrm{Id}^2=\\mathrm{Id}$，不知道以后有没有可能用得到\n\n\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/hash_policy.hpp>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\n\ninline void proc_status()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) <<endl;\n}\n\ninline LL read ()\n{\n\tLL sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\nconst int Maxn = 1e7 + 100, Mod = 1e9 + 7;\n\nLL N, inv2, inv6;\nint Phi[Maxn], Not_Prime[Maxn], Prime[Maxn], prime_cnt;\n__gnu_pbds :: gp_hash_table<LL, int> F;\nLL FF[Maxn];\n\ninline void Add (LL &a, LL b) { a += b; if (a >= Mod) a -= Mod; }\n\ninline LL Pow (LL a, int b)\n{\n\tLL ans = 1;\n\twhile (b) { if (b & 1) ans = 1ll * ans * a % Mod; a = 1ll * a * a % Mod; b >>= 1; }\n\treturn ans;\n}\n\ninline LL Calc_S (LL x)\n{\n\tx %= Mod;\n\tLL sum = 1ll * x * (x + 1) % Mod * inv2 % Mod;\n\treturn sum;\n}\n\ninline LL Calc_G (LL x)\n{\n\tx %= Mod;\n\treturn x * (x + 1) % Mod * (2 * x + 1) % Mod * inv6 % Mod;\n}\n\ninline LL Calc_F (LL n)\n{\n\tif (n <= Maxn - 5) return FF[n];\n\tif (F[n]) return F[n];\n\tLL ans = 1ll * Calc_S(n) * Calc_S(n) % Mod, sum1, sum2, sum;\n\tfor (LL l = 2, r; l <= n; l = r + 1)\n\t{\n\t\tr = n / (n / l);\n\t\tsum1 = Calc_G(l - 1), sum2 = Calc_G(r);\n\t\tsum = Calc_F(n / l);\n\t\tAdd (ans, Mod - sum * (sum2 - sum1 + Mod) % Mod);\n\t}\n\treturn F[n] = ans;\n}\n\ninline void Solve ()\n{\n\tLL sum1, sum2, sum, ans = 0;\n\tfor (LL l = 1, r; l <= N; l = r + 1)\n\t{\n\t\tr = N / (N / l);\n\t\tsum1 = Calc_F(l - 1), sum2 = Calc_F(r);\n\t\tsum = Calc_S(N / l);\n\t\tAdd (ans, sum * (sum2 - sum1 + Mod) % Mod);\n\t}\n\tcout<<ans<<endl;\n}\n\ninline void Input ()\n{\n\tN = read();\n}\n\ninline void Init ()\n{\n\tinv2 = Pow(2, Mod - 2), inv6 = Pow(6, Mod - 2);\n\n\tPhi[1] = 1;\n\tfor (int i = 2; i <= min(N, 1ll * Maxn - 5); ++i)\n\t{\n\t\tif (!Not_Prime[i])\n\t\t{\n\t\t\tPrime[++prime_cnt] = i;\n\t\t\tPhi[i] = i - 1;\n\t\t}\n\t\tfor (int j = 1; j <= prime_cnt && Prime[j] * i <= min(N, 1ll * Maxn - 5); ++j)\n\t\t{\n\t\t\tNot_Prime[i * Prime[j]] = 1;\n\t\t\tif (!(i % Prime[j])) { Phi[i * Prime[j]] = Phi[i] * Prime[j]; break; }\n\t\t\telse Phi[i * Prime[j]] = Phi[i] * (Prime[j] - 1);\n\t\t}\n\t}\n\t\n\tfor (LL i = 1; i <= min(N, 1ll * Maxn - 5); ++i) FF[i] = Phi[i] * i % Mod * i % Mod;\n\tfor (LL i = 1; i <= min(N, 1ll * Maxn - 5); ++i) Add (FF[i], FF[i - 1]);\n}\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"A.in\", \"r\", stdin);\n\tfreopen(\"A.out\", \"w\", stdout);\n#endif\n\tInput();\n\tInit();\n\tSolve();\n\treturn 0;\n}\n\n```\n\n","categories":["Problem"],"tags":["数学","数论","欧拉函数","莫比乌斯反演","杜教筛"]},{"title":"「CQOI2015」选数 - 杜教筛 + 莫比乌斯反演","url":"/2018/12/18/%E3%80%8CCQOI2015%E3%80%8D%E9%80%89%E6%95%B0-%E6%9D%9C%E6%95%99%E7%AD%9B-%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/","content":"\n求在区间$[L,H]$中任意取$n$个数，它们的最大公约数恰好为$k$的方案数$\\mathrm{mod}~10^9+7$的值\n\n$n,k\\le 10^9, L\\le H\\le10^9, H-L\\le 10^5$\n\n<!--more-->\n\n### Links\n\n[Luogu P3172](https://www.luogu.org/problemnew/show/P3172)\n\n### Solution\n\n设$f(k)$表示区间内选$n$个恰好$\\gcd$为$k$的数的方案数，$F(k)$表示区间内选$n$个$k|\\gcd$（即$\\gcd$为$k$的倍数）的数的方案数\n\n由题意很容易得到$F(k)=(\\lfloor \\frac{H}{k}\\rfloor - \\lfloor\\frac{L-1}{k}\\rfloor)^n$\n\n又因为\n$$\nF(k)=\\sum_{k|d}f(d)\n$$\n由莫比乌斯反演可知\n$$\n\\begin{aligned}\nf(k)=&\\sum_{k|d}F(d)\\mu(\\frac{d}{k})\\\\\n=&\\sum_{i=1}^{\\lfloor\\frac{H}{k}\\rfloor}F(ik)\\mu(i)\\\\\n=&\\sum_{i=1}^{\\lfloor\\frac{H}{k}\\rfloor}\\mu(i)(\\lfloor \\frac{H}{ik}\\rfloor - \\lfloor\\frac{L-1}{ik}\\rfloor)^n\n\\end{aligned}\n$$\n换元，令$H=\\lfloor\\frac{H}{k}\\rfloor,L=\\lfloor\\frac{L-1}{k}\\rfloor$，则有\n$$\nans=\\sum_{i=1}^{H}\\mu(i)(\\lfloor\\frac{H}{i}\\rfloor-\\lfloor\\frac{L}{i}\\rfloor)^n\n$$\n很显然，直接杜教筛+整除分块即可\n\n\n\n### Summary\n\n这个第一步容斥反演的套路很常见，见到类似的这种问题时要往容斥反演上想\n\n\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/hash_policy.hpp>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\n\ninline void proc_status()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) <<endl;\n}\ntemplate <typename T> T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\nconst int Maxn = 5e6 + 100, Mod = 1000000007;\n\nint N, K, L, H;\nint Prime[Maxn], Not_Prime[Maxn], prime_cnt;\nLL Mu[Maxn];\n__gnu_pbds :: gp_hash_table <int, LL> FMu;\n\ninline void Add (LL &a, int b) { a += b; if (a >= Mod) a -= Mod; }\n\ninline int Pow (int a, int b)\n{\n\tint ans = 1;\n\twhile (b)\n\t{\n\t\tif (b & 1) ans = 1ll * ans * a % Mod;\n\t\ta = 1ll * a * a % Mod;\n\t\tb >>= 1;\n\t}\n\treturn ans;\n}\n\ninline LL Calc_Mu (int n)\n{\n\tif (n <= Maxn - 5) return Mu[n];\n\tif (FMu[n]) return FMu[n];\n\tLL ans = 1;\n\tfor (int l = 2, r; l <= n; l = r + 1)\n\t{\n\t\tr = n / (n / l);\n\t\tAdd (ans, Mod - 1ll * (r - l + 1) * Calc_Mu(n / l) % Mod);\n\t}\n\treturn FMu[n] = ans;\n}\n\ninline void Solve ()\n{\n\tH /= K, L = (L - 1) / K;\n\tLL ans = 0;\n\tfor (int l = 1, r; l <= H; l = r + 1)\n\t{\n/**/\tif (L && L / l) r = min(H / (H / l), L / (L / l));\n\t\telse r = H / (H / l);\n\t\tAdd (ans, 1ll * (Calc_Mu(r) - Calc_Mu(l - 1) + Mod) % Mod * Pow((H / l - L / l), N) % Mod);\n\t}\n\tprintf(\"%lld\\n\", ans);\n}\n\ninline void Input ()\n{\n\tN = read<int>(), K = read<int>(), L = read<int>(), H = read<int>();\n}\n\ninline void Init ()\n{\n\tMu[1] = Not_Prime[1] = 1;\n\tfor (int i = 2; i <= Maxn - 5; ++i)\n\t{\n\t\tif (!Not_Prime[i]) Prime[++prime_cnt] = i, Mu[i] = Mod - 1;\n\t\tfor (int j = 1; j <= prime_cnt && i * Prime[j] <= Maxn - 5; ++j)\n\t\t{\n\t\t\tNot_Prime[i * Prime[j]] = 1;\n\t\t\tif (!(i % Prime[j])) { Mu[i * Prime[j]] = 0; break; }\n\t\t\tMu[i * Prime[j]] = Mod - Mu[i];\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= Maxn - 5; ++i) Add (Mu[i], Mu[i - 1]);\n}\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"A.in\", \"r\", stdin);\n\tfreopen(\"A.out\", \"w\", stdout);\n#endif\n\tInit();\n\tInput();\n\tSolve();\n\treturn 0;\n}\n\n```\n\n\n\n### Debug\n\n* 73L: 要特判一下$L=0,\\lfloor \\frac{L}{l}\\rfloor=0$的情况\n\n","categories":["Problem"],"tags":["数学","数论","整除分块","省选","莫比乌斯反演","杜教筛"]},{"title":"「SDOI2015」约数个数和 - 莫比乌斯反演","url":"/2018/12/18/%E3%80%8CSDOI2015%E3%80%8D%E7%BA%A6%E6%95%B0%E4%B8%AA%E6%95%B0%E5%92%8C-%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/","content":"\n求\n$$\n\\sum_{i=1}^{n}\\sum_{j=1}^m\\mathrm{d}(ij)\n$$\n其中$\\mathrm{d}(n)$表示$n$的约数个数\n\n多组数据，数据组数$\\le 50000, n,m\\le 50000$\n\n<!--more-->\n\n### Links\n\n[Luogu P3327](https://www.luogu.org/problemnew/show/P3327)\n\n### Solution\n\n首先有一个结论\n$$\n\\mathrm{d}(ij)=\\sum_{x|i}\\sum_{y|j}[gcd(x,y)==1]\n$$\n（这个结论的感性理解见[数论函数初探](https://hk-cnyali.com/2018/12/16/%E6%95%B0%E8%AE%BA%E5%87%BD%E6%95%B0%E5%88%9D%E6%8E%A2/)）\n\n直接代入，得到\n$$\n\\begin{aligned}\n&\\sum_{i=1}^{n}\\sum_{j=1}^{m}\\mathrm{d}(ij)\\\\\n=&\\sum_{i=1}^{n}\\sum_{j=1}^{m}\\sum_{x|i}\\sum_{y|j}[gcd(x,y)==1]\\\\\n=&\\sum_{x=1}^{n}\\sum_{y=1}^m\\lfloor\\frac{n}{x}\\rfloor\\lfloor\\frac{m}{y}\\rfloor[\\gcd(x,y)=1]\\\\\n=&\\sum_{x=1}^{n}\\sum_{y=1}^m\\lfloor\\frac{n}{x}\\rfloor\\lfloor\\frac{m}{y}\\rfloor\\sum_{d|\\gcd(x,y)}\\mu(d)\\\\\n=&\\sum_{d=1}^{\\min(n,m)}\\mu(d)\\sum_{x=1}^{\\lfloor\\frac{n}{d}\\rfloor}\\lfloor\\frac{n}{dx}\\rfloor\\sum_{y=1}^{\\lfloor\\frac{m}{d}\\rfloor}\\lfloor\\frac{m}{dy}\\rfloor\n\\end{aligned}\n$$\n后面那一坨，我们可以设$f(n)=\\sum_{i=1}^{n}\\lfloor\\frac{n}{i}\\rfloor$，那么有\n$$\nans=\\sum_{d=1}^{\\min(n,m)}\\mu(d)f(\\lfloor\\frac{n}{d}\\rfloor)f(\\lfloor\\frac{m}{d}\\rfloor)\n$$\n那么$O(n\\sqrt n)$整除分块预处理$f(n)$后，即可单次$O(\\sqrt n)$整除分块算答案了\n\n\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\n\ninline void proc_status()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) <<endl;\n}\n\ninline int read ()\n{\n\tint sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\nconst int Maxn = 5e4 + 100;\n\nint N, M;\nint Prime[Maxn], Not_Prime[Maxn], prime_cnt, Mu[Maxn], Sum_Mu[Maxn];\nLL f[Maxn];\n\ninline void Solve ()\n{\n\tLL ans = 0;\n\tfor (int l = 1, r; l <= min(N, M); l = r + 1)\n\t{\n\t\tr = min(N / (N / l), M / (M / l));\n\t\tans += 1ll * (Sum_Mu[r] - Sum_Mu[l - 1]) * f[N / l] * f[M / l];\n\t}\n\tprintf(\"%lld\\n\", ans);\n}\n\ninline void Input ()\n{\n\tN = read(), M = read();\n}\n\ninline void Init ()\n{\n\tMu[1] = Not_Prime[1] = 1;\n\tfor (int i = 2; i <= Maxn - 5; ++i)\n\t{\n\t\tif (!Not_Prime[i])\n\t\t{\n\t\t\tPrime[++prime_cnt] = i;\n\t\t\tMu[i] = -1;\n\t\t}\n\t\tfor (int j = 1; j <= prime_cnt && i * Prime[j] <= Maxn - 5; ++j)\n\t\t{\n\t\t\tNot_Prime[i * Prime[j]] = 1;\n\t\t\tif (!(i % Prime[j])) { Mu[i * Prime[j]] = 0; break; }\n\t\t\telse Mu[i * Prime[j]] = -Mu[i];\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= Maxn - 5; ++i)\n\t\tfor (int l = 1, r; l <= i; l = r + 1)\n\t\t{\n\t\t\tr = i / (i / l);\n\t\t\tf[i] += 1ll * (r - l + 1) * (i / l);\n\t\t}\n\n\tfor (int i = 1; i <= Maxn - 5; ++i) Sum_Mu[i] = Sum_Mu[i - 1] + Mu[i];\n}\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"A.in\", \"r\", stdin);\n\tfreopen(\"A.out\", \"w\", stdout);\n#endif\n\tInit();\n\tint Test_Case = read();\n\twhile (Test_Case--)\n\t{\n\t\tInput();\n\t\tSolve();\n\t}\n\treturn 0;\n}\n\n```\n\n","categories":["Problem"],"tags":["数学","数论","整除分块","省选","莫比乌斯反演"]},{"title":"「HAOI2011」Problem b - 莫比乌斯反演","url":"/2018/12/18/%E3%80%8CHAOI2011%E3%80%8DProblem-b-%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/","content":"\n给出多组$a,b,c,d,k$，求\n$$\n\\sum_{i=a}^{b}\\sum_{j=c}^{d}[\\gcd(i,j)==k]\n$$\n数据组数$\\le50000, a,b,c,d,k\\le50000$\n\n<!--more-->\n\n### Links\n\n[Luogu P2522](https://www.luogu.org/problemnew/show/P2522)\n\n### Solution\n\n一开始先容斥一下，就转化成[「BZOJ1101」ZAP-Queries - 莫比乌斯反演 + 整除分块入门](https://hk-cnyali.com/2018/03/24/Luogu-P3455-BZOJ1101-ZAP-Queries-%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94-%E6%95%B4%E9%99%A4%E5%88%86%E5%9D%97%E5%85%A5%E9%97%A8/)这道题了\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\n\ninline void proc_status()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) <<endl;\n}\n\ninline int read ()\n{\n\tint sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\nconst int Maxn = 5e4 + 100;\n\nint a, b, c, d, K;\nint Prime[Maxn], Not_Prime[Maxn], prime_cnt, Mu[Maxn], Sum_Mu[Maxn];\n\ninline LL Calc (int n, int m)\n{\n\tn /= K, m /= K;\n\tint N = min(n, m);\n\tLL ans = 0;\n\tfor (int l = 1, r; l <= N; l = r + 1)\n\t{\n\t\tr = min(n / (n / l), m / (m / l));\n\t\tans += 1ll * (n / l) * (m / l) * (Sum_Mu[r] - Sum_Mu[l - 1]);\n\t}\n\treturn ans;\n}\n\ninline void Solve ()\n{\n\tprintf(\"%lld\\n\", Calc(b, d) - Calc(b, c - 1) - Calc (a - 1, d) + Calc(a - 1, c - 1));\n}\n\ninline void Input ()\n{\n\ta = read(), b = read(), c = read(), d = read(), K = read();\n}\n\ninline void Init ()\n{\n\tMu[1] = Not_Prime[1] = 1;\n\tfor (int i = 2; i <= Maxn - 5; ++i)\n\t{\n\t\tif (!Not_Prime[i])\n\t\t{\n\t\t\tPrime[++prime_cnt] = i;\n\t\t\tMu[i] = -1;\n\t\t}\n\t\tfor (int j = 1; j <= prime_cnt && i * Prime[j] <= Maxn - 5; ++j)\n\t\t{\n\t\t\tNot_Prime[i * Prime[j]] = 1;\n\t\t\tif (!(i % Prime[j])) { Mu[i * Prime[j]] = 0; break; }\n\t\t\telse Mu[i * Prime[j]] = -Mu[i];\n\t\t}\n\t}\n\tfor (int i = 1; i <= Maxn - 5; ++i) Sum_Mu[i] = Sum_Mu[i - 1] + Mu[i];\n}\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"A.in\", \"r\", stdin);\n\tfreopen(\"A.out\", \"w\", stdout);\n#endif\n\tInit();\n\tint Testcase = read();\n\twhile (Testcase--)\n\t{\n\t\tInput();\n\t\tSolve();\n\t}\n\treturn 0;\n}\n\n```\n\n","categories":["Problem"],"tags":["数学","数论","整除分块","省选","莫比乌斯反演"]},{"title":"「Luogu P3768」简单的数学题 - 莫比乌斯反演 + 杜教筛","url":"/2018/12/17/%E3%80%8CLuogu-P3768%E3%80%8D%E7%AE%80%E5%8D%95%E7%9A%84%E6%95%B0%E5%AD%A6%E9%A2%98-%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94-%E6%9D%9C%E6%95%99%E7%AD%9B/","content":"\n求\n$$\n(\\sum_{i=1}^{n}\\sum_{j=1}^{n}ij\\gcd(i,j)) mod~p\n$$\n\n\n$n\\le 10^{10}, p\\le 1.1\\times10^9$\n\n<!--more-->\n\n### Links\n\n[Luogu P3768](https://www.luogu.org/problemnew/show/P3768)\n\n### Solution\n\n首先化下式子\n$$\n\\begin{aligned}\n&\\sum_{i=1}^{n}\\sum_{j=1}^{n}ij\\gcd(i,j)\\\\\n=&\\sum_{i=1}^{n}\\sum_{j=1}^{n}ij\\sum_{d|\\gcd(i,j)}\\varphi(d)\\\\\n=&\\sum_{d=1}^{n}\\varphi(d)(\\sum_{i=1}^{\\lfloor \\frac{n}{d} \\rfloor }id)^2\\\\\n=&\\sum_{d=1}^{n}\\varphi(d)d^2S(\\lfloor \\frac{n}{d} \\rfloor )^2\n\\end{aligned}\n$$\n\n其中$S(n)=\\sum_{i=1}^ni$\n\n可以发现，后半部分$S(\\lfloor \\frac{n}{d} \\rfloor)^2$显然是可以整除分块的\n\n那么，我们就是要快速计算某一段$\\varphi(d)d^2$的和\n\n即需要快速计算$f(i)=\\varphi(d)d^2$的前缀和\n\n考虑如何构造杜教筛\n$$\n\\begin{aligned}\n\\sum_{d|n}\\varphi(d)d^2(\\frac{n}{d})^2&=n^2\\sum_{d|n}\\varphi(d)=n^3\\\\\n\\Rightarrow f*\\mathrm{Id}^2&=\\mathrm{Id}^3\n\\end{aligned}\n$$\n由于$\\sum_{i=1}^ni^3=(\\sum_{i=1}^ni)^2$可以快速计算\n\n所以杜教筛的式子长这样：\n$$\nF(n)=(\\frac{n(n+1)}{2})^2-\\sum_{i=2}^ni^2F(\\lfloor\\frac{n}{i}\\rfloor)\n$$\n\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/hash_policy.hpp>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\n\ninline void proc_status()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) <<endl;\n}\n\ninline LL read ()\n{\n\tLL sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\nconst int Maxn = 1e7 + 100;\n\nLL N, Mod, inv2, inv6;\nint Phi[Maxn], Not_Prime[Maxn], Prime[Maxn], prime_cnt;\n__gnu_pbds :: gp_hash_table<int, LL> F;\nLL FF[Maxn];\n\ninline void Add (LL &a, LL b) { a += b; if (a >= Mod) a -= Mod; }\n\ninline LL Pow (LL a, int b)\n{\n\tLL ans = 1;\n\twhile (b) { if (b & 1) ans = 1ll * ans * a % Mod; a = 1ll * a * a % Mod; b >>= 1; }\n\treturn ans;\n}\n\ninline LL Calc_S (LL x)\n{\n\tx %= Mod;\n\tLL sum = 1ll * x * (x + 1) % Mod * inv2 % Mod;\n\treturn 1ll * sum * sum % Mod;\n}\n\ninline LL Calc_G (LL x)\n{\n\tx %= Mod;\n\treturn x * (x + 1) % Mod * (2 * x + 1) % Mod * inv6 % Mod;\n}\n\ninline LL Calc_F (LL n)\n{\n\tif (n <= Maxn - 5) return FF[n];\n\tif (F[n]) return F[n];\n\tLL ans = Calc_S(n), sum1, sum2, sum;\n\tfor (LL l = 2, r; l <= n; l = r + 1)\n\t{\n\t\tr = n / (n / l);\n\t\tsum1 = Calc_G(l - 1), sum2 = Calc_G(r);\n\t\tsum = Calc_F(n / l);\n/**/\tAdd (ans, Mod - sum * (sum2 - sum1 + Mod) % Mod);\n\t}\n\treturn F[n] = ans;\n}\n\ninline void Solve ()\n{\n\tLL sum1, sum2, sum, ans = 0;\n\tfor (LL l = 1, r; l <= N; l = r + 1)\n\t{\n\t\tr = N / (N / l);\n\t\tsum1 = Calc_F(l - 1), sum2 = Calc_F(r);\n\t\tsum = Calc_S(N / l);\n\t\tAdd (ans, sum * (sum2 - sum1 + Mod) % Mod);\n\t}\n\tcout<<ans<<endl;\n}\n\ninline void Input ()\n{\n\tMod = read(), N = read();\n}\n\ninline void Init ()\n{\n\tinv2 = Pow(2, Mod - 2), inv6 = Pow(6, Mod - 2);\n\n\tPhi[1] = 1;\n\tfor (int i = 2; i <= min(N, 1ll * Maxn - 5); ++i)\n\t{\n\t\tif (!Not_Prime[i])\n\t\t{\n\t\t\tPrime[++prime_cnt] = i;\n\t\t\tPhi[i] = i - 1;\n\t\t}\n\t\tfor (int j = 1; j <= prime_cnt && Prime[j] * i <= min(N, 1ll * Maxn - 5); ++j)\n\t\t{\n\t\t\tNot_Prime[i * Prime[j]] = 1;\n/**/\t\tif (!(i % Prime[j])) { Phi[i * Prime[j]] = Phi[i] * Prime[j]; break; }\n\t\t\telse Phi[i * Prime[j]] = Phi[i] * (Prime[j] - 1);\n\t\t}\n\t}\n\t\n/**/for (LL i = 1; i <= min(N, 1ll * Maxn - 5); ++i) FF[i] = Phi[i] * i % Mod * i % Mod;\n/**/for (LL i = 1; i <= min(N, 1ll * Maxn - 5); ++i) Add (FF[i], FF[i - 1]);\n}\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"A.in\", \"r\", stdin);\n\tfreopen(\"A.out\", \"w\", stdout);\n#endif\n\tInput();\n\tInit();\n\tSolve();\n\treturn 0;\n}\n\n```\n\n\n\n### Debug\n\n* 73L：把减号写成加号\n* 111L：把$Prime[j]$写成$j$\n* 116、117L：求这个函数前缀和的时候要分两步算，一开始直接一步算的。。。\n\n","categories":["Problem"],"tags":["数学","数论","欧拉函数","莫比乌斯反演","杜教筛"]},{"title":"数论函数初探","url":"/2018/12/16/%E6%95%B0%E8%AE%BA%E5%87%BD%E6%95%B0%E5%88%9D%E6%8E%A2/","content":"\n数论函数这一块一直迷迷糊糊似懂非懂，最近花了点时间补了补基础知识\n\n写这篇博客花了整整一下午的时间，希望哪天不记得的时候再翻这篇博客会有收获吧\n\n<!--more-->\n\n## 前置知识\n\n### 求和符号$\\sum$\n\n$$\n\\begin{aligned}\n\\sum_{i}f(i)+g(i)&=\\sum_{i}f(i)+\\sum_{i}g(i) \\\\\n\\sum_{i}\\sum_{j}f(i)g(j)&=\\sum_{j}\\sum_{i}f(i)g(j)=(\\sum_{i}f(i))*(\\sum_{j}g(j)) \\\\\n\\sum_{i}k*f(i)&=k*\\sum_{i}f(i)\n\\end{aligned}\n$$\n### 枚举约数转化为枚举倍数\n$$\n\\sum_{i=1}^{n}\\sum_{d|i}f(d)=\\sum_{d=1}^{n}\\sum_{i=1}^{\\lfloor \\frac{n}{d}\\rfloor}f(d)=\\sum_{d=1}^{n}\\lfloor \\frac{n}{d}\\rfloor f(d)\n$$\n## 数论函数\n\n### 积性函数\n\n1. 定义(最基本性质)： $\\forall gcd(a, b) = 1$，满足 $f (ab) = f (a) f (b) $的函数。若去掉互质的条件仍满足，则为完全积性函数\n\n2. 性质：若 $f (x), g (x)$是积性函数,那么以下函数皆为积性函数\n\n   * $h(x) = f (x^p )$\n   * $h(x) = f^p (x)$\n   * $h(x) = f (x)g (x)$\n   * $h(x) = \\sum_{d|x}f (d)g (\\frac{x}{d})$\n\n3. 常见积性函数：(令 $n = p_1^{a_1} p_2^{a_2} \\cdots p_k^{a_k}$)\n   - 单位元: $\\epsilon(n) = [n = 1]$\n   - 恒等函数：$1(n) = 1 $\n   - 单位函数：$\\mathrm{Id}(n) = n$\n   - 莫比乌斯函数: $\\mu(n) = [\\max(a_1, a_2, ..., a_k) \\leq 1] (-1)^k$\n   - 欧拉函数:$\\varphi(n)=\\sum_{i=1}^n[(i,n)=1]$\n   - 约数个数函数: $\\mathrm{d}(n) = \\sum_{d|n} 1$\n   - 约数和函数: $\\sigma(n) = \\sum_{d|n} d$\n   - 刘维尔函数: $\\lambda(n) = (-1)^k$\n\n### 线性筛\n\n我们还是令 $x = p_1^{a_1} *p_2^{a_2} ... p_k^{a_k}$ ， 则根据积性函数的性质有 $f(x) = f(p_1^{a_1} ) \\times f(\\frac{x}{p_1^{a_1}})$ 这个$p_1$即为$x$的最小质因子\n\n因此，对于任意的积性函数，若 $f (p^a )$ ($p$为质数) 可以快速求出，那么就可以线性筛.\n\n例如：\n* $\\varphi(p^a) =p^a\\times \\frac{p-1}{p}$\n\n  > 此处的证明：\n  >\n  > $\\varphi(p^a)$表示小于$p^a$的数中与$p^a$互质的数\n  >\n  > 它等于$p^a$减去与$p^a$不互质的数\n  >\n  > 显然，与$p^a$不互质的数一共有$p^{a-1}$个，它们分别是$1\\times p,2\\times p, 3\\times p, ... p^{a-1}\\times p$\n  >\n  > 所以$\\varphi(p^a)=p^a-p^{a-1}=p^a\\times\\frac{p-1}{p}$\n\n* $\\mu(p^a) =-1[a=1]$\n\n* $\\mathrm{d}(p^a)=a+1$\n\n* $\\sigma(p^a)=\\sum_{i=0}^ap^i$\n\n[具体$\\varphi$的线性筛](https://hk-cnyali.com/2018/01/04/%E7%BA%BF%E6%80%A7%E7%AD%9B%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/)\n\n### 狄利克雷卷积\n\n1. 定义： $(f * g)(n) = \\sum_{d|n} f(d) g(\\frac{n}{d})$\n\n2. 性质：\n\n   交换律：$f*g=g*f$\n\n   结合律：$(f*g)*h=f*(g*h)$\n\n   分配律：$f*(g+h)=f*g+f*h$\n\n   单位元：$f*\\epsilon=\\epsilon * f=f$\n\n3. 常见关系：\n\n   - $\\mu * 1 = \\epsilon$(即$[n=1]=\\sum_{d|n}\\mu(d)$)\n   - $\\mathrm{Id} = \\varphi * 1 \\Rightarrow \\varphi = \\mu * \\mathrm{Id}$(即$n=\\sum_{d|n}\\varphi(d)$，$\\varphi(n)=\\sum_{d|n}\\frac{n}{d}\\mu(d)$)\n   - $\\mathrm{d} = 1 * 1 \\Rightarrow 1 = \\mu * \\mathrm{d}$\n   - $\\sigma = \\mathrm{Id} * 1 \\Rightarrow \\mathrm{Id} = \\mu * \\sigma$\n\n   下面三个式子没那么容易一眼看出来，但是仔细推一推也是比较好理解的\n\n   - $\\sigma = \\varphi * \\mathrm{d}$\n\n   - $\\mathrm{d}(ij) = \\sum_{x | i} \\sum_{y | j} [\\mathrm{gcd}(x, y) = 1]$\n\n   - $\\sigma(ij) = \\sum_{x | i} \\sum_{y | j} [\\mathrm{gcd}(\\frac{i}{x}, y) = 1]xy$\n\n     > 2018.12.18 Update\n     >\n     > 还是感性证明一下这个式子吧\n     >\n     > 首先，这个式子大致的意思是选$i$的一个约数和$j$的一个约数相乘\n     >\n     > 虽然得到的数一定是$ij$的约数，但是显然这样会算重\n     >\n     > 感性理解一下$[gcd(\\frac{i}{x},y)=1]$这个条件实际上就是要满足对于任意一个质因子$p$，若在$y$中出现的话，$x$中就必须要取完\n     >\n     > 换句话说，如果$p$在最后的约数中的次数小于在$i$中的次数的话，那它只能在$x$中出现，$y$中不能出现；而如果大于在$i$中的次数的话，那么在$x$中的次数就必须等于在$i$中的次数\n     >\n     > 可以发现，这样做的话，相当于是$p$这个质因子按照先从$i$再从$j$的顺序进行选取，这样就保证了不会算重\n\n   - $\\sum_{i=1}^n \\mu^2(i) = \\sum_{i=1}^{\\lfloor\\sqrt{n}\\rfloor} \\mu(i) \\lfloor \\frac{n}{i^2} \\rfloor$(最后这个暂时没看太懂。。。)\n\n\n### 欧拉函数$\\varphi$\n\n1. 定义：$\\varphi(n)=\\sum_{i=1}^n[(i,n)=1]$\n\n   另外一种计算方法：$\\varphi(n)=n*\\prod\\limits_{i}(1-\\frac{1}{p_i})$ （$p_i$为$n$的质因子）\n\n   > 19.3.2 UPD\n   > 关于这个计算方法的证明\n   >\n   > 由上面线性筛的部分我们知道$\\varphi(p^a)=p^a\\times \\frac{p-1}{p}$，且$\\varphi(n) = \\varphi(p_1^{a_1})\\times \\varphi(p_2^{a_2})\\times...\\times\\varphi(p_k^{a_k})$\n   >\n   > 所以$\\varphi(n) = p_1^{a_1}p_2^{a_2}...p_k^{a_k}\\times\\prod\\limits_{i=1}^{k}(1-\\frac{1}{p_i}) = n*\\prod\\limits_{i=1}^{k}(1-\\frac{1}{p_i})$\n\n2. 性质：$n=\\sum_{d|n}\\varphi(d)$\n\n   >  感性证明：\n   >\n   > 考虑所有分母为$n$，分子为$1,2,..,n$的这$n$个分数\n   >\n   > 将分数约分后，分子分母是互质的，且分母是整除$n$的，且分数互不相同\n   >\n   > 对于每个不同的分母$x$，一定会有$\\varphi(x)$个分子与其对应，于是得证\n   >\n   > 例如$n=6$时：\n   > $$\n   > \\frac{1}{6},\\frac{2}{6},\\frac{3}{6},\\frac{4}{6},\\frac{5}{6},\\frac{6}{6}\n   > $$\n   > 约分后是\n   > $$\n   > \\frac{1}{6},\\frac{1}{3},\\frac{1}{2},\\frac{2}{3},\\frac{5}{6},\\frac{1}{1}\n   > $$\n   > 其中$\\varphi(1)=1, \\varphi(2)=1, \\varphi(3)=2,\\varphi(6)=2$\n\n3. 运用（常见套路）：\n$$\n   \\sum_{i}\\sum_{j}gcd(i,j)=\\sum_{i}\\sum_{j}\\sum_{d|gcd(i,j)}\\varphi(d)\n$$\n\n\n\n\n\n### 莫比乌斯函数$\\mu$\n\n1. 定义：$\\mu(n) = [\\max(a_1, a_2, ..., a_k) \\leq 1] (-1)^k$\n\n2. 性质：$[n=1]=\\sum_{d|n}\\mu(d)$\n\n   >证明：\n   >\n   >1. 显然$n=1$时$\\sum_{d|n}\\mu(d)=1$\n   >\n   >2. $n\\ne1$时\n   >   $$\n   >   \\begin{aligned}\n   >   \\sum_{d|n}\\mu(d)&=\\mu(1)+\\mu(p_1)+\\mu(p_2)+...+\\mu(p_1p_2)+...+\\mu(p_1p_2...p_k)\\\\\n   >   &=\\sum_{i=0}^kC_k^i(-1)^i\\\\\n   >   &=0\n   >   \\end{aligned}\n   >   $$\n   >    最后一步是由二项式定理得到\n   >\n   >   ($\\sum_{i=0}^kC_k^i(-1)^i1^{k-i}=(1-1)^n=0$)\n\n3. 运用（常见套路）：\n$$\n\\sum_{i}\\sum_{j}[gcd(i,j)==1]=\\sum_{i}\\sum_{j}\\sum_{d|gcd(i,j)}\\mu(d)\n$$\n\n\n### 莫比乌斯反演\n\n~~其实主要内容上面都已经证明过了~~\n\n1. 定义：$f(n)=\\sum_{d|n}g(d) \\Rightarrow g(n)=\\sum_{d|n}\\mu(d)f(\\frac{n}{d})$\n\n2. 从卷积角度理解：\n$$\n\\begin{aligned}\n\\because \\mu*1&=\\epsilon\\\\\n\\therefore \\mu*f=1*g*\\mu&=\\epsilon*g=g\n\\end{aligned}\n$$\n3. 扩展：\n$$\n\\begin{aligned}\nf(n) = \\sum_{d|n} g(d) &\\Rightarrow g(n) = \\sum_{d|n} \\mu(\\frac{n}{d}) f(d) \\\\\nf(n) = \\sum_{n|d} g(d) &\\Rightarrow g(n) = \\sum_{n|d} \\mu(\\frac{d}{n}) f(d)\n\\end{aligned}\n$$\n\n\n\n\n## 整除分块\n\n容易发现，当 $i = 1 ... n$ 时，$\\lfloor \\frac{n}{i} \\rfloor$ 只有 $O(\\sqrt{n})$ 种不同的取值\n\n这个性质经常被用来优化复杂度\n\n具体操作是，如果当$i\\in[l,r]$时的答案相同，那么当$i=l$时一次性算出这段区间的答案，然后令$i=r+1$，不断重复操作\n\n举个最简单的例子：\n\n求$\\sum_{i=1}^n \\lfloor \\frac{n}{i}\\rfloor$\n\n注意到，当$i=l$时，贡献为$\\lfloor \\frac{n}{l}\\rfloor$，而贡献为$\\lfloor \\frac{n}{l}\\rfloor$的最大的$i$显然等于$\\lfloor \\frac{n}{\\lfloor \\frac{n}{l}\\rfloor}\\rfloor$\n\n即$i\\in[l, \\lfloor \\frac{n}{\\lfloor \\frac{n}{l}\\rfloor}\\rfloor]$时，答案都为$\\lfloor \\frac{n}{l}\\rfloor$\n\n那么把这部分答案$O(1)$算出来，再令$i=\\lfloor \\frac{n}{\\lfloor \\frac{n}{l}\\rfloor}\\rfloor+1$，重复此过程即可\n\n因为$\\lfloor \\frac{n}{i}\\rfloor$的取值是$O(\\sqrt n)$的，所以复杂度时$O(\\sqrt n)$的\n\n\n\n## 杜教筛\n\n杜教筛主要是用来快速求一些数论函数的前缀和\n\n上面内容都理解了的话，杜教筛其实是非常简单的\n\n### Description\n\n求某个数论函数$f$的前缀和$F$\n\n$n\\le 10^9$\n\n### Solution\n\n首先构造$h=f*g$（$g$是一个任意的数论函数），设$H$为$h$的前缀和函数\n\n开始疯狂推式子\n$$\n\\begin{aligned}\nH(n)&=\\sum_{i=1}^n\\sum_{d|i}f(d)g(\\lfloor \\frac{i}{d}\\rfloor)\\\\\n&=\\sum_{i=1}^n\\sum_{d|i}g(d)f(\\lfloor \\frac{i}{d}\\rfloor)\\\\\n&=\\sum_{d=1}^ng(d)\\sum_{d|i}f(\\lfloor \\frac{i}{d}\\rfloor)\\\\\n&=\\sum_{d=1}^ng(d)\\sum_{i=1}^{\\lfloor \\frac{n}{d}\\rfloor}f(i)\\\\\n&=\\sum_{d=1}^ng(d)F(\\lfloor \\frac{n}{d}\\rfloor)\\\\\n\n\n\\end{aligned}\n$$\n\n$$\n\\Rightarrow F(n)g(1)=H(n)-\\sum_{i=2}^{n}g(i)F(\\lfloor \\frac{n}{i}\\rfloor)\n$$\n\n>  稍微解释一下上面式子怎么推的：\n>\n> 第一步：积性函数的交换律\n>\n> 第二步：把$d$提出来，枚举因数转化为枚举倍数\n>\n> 第三步：把枚举$i$转化为直接枚举$\\lfloor \\frac{i}{d}\\rfloor$\n>\n> 第四步：根据$F$的定义代入\n>\n> 第五步：令$d=1$，代入\n\n通过观察最后这个式子可以发现，后面部分可以整除分块，求$F$的话可以小范围线性筛预处理(大约$10^7$的表)，大范围递归记忆化\n\n那么只要$H(n)$能快速计算，就能做到低于线性（大约$O(n^{\\frac{2}{3}})$）的复杂度了(复杂度并不会证)\n\n具体的，对于求不同的$f$，往往选择使得$H$更快更好求的函数$h$\n\n比如:\n\n* 筛$\\mu$：$g=1$，利用$\\epsilon=1*\\mu$，此时$F(n)=1-\\sum_{i=2}^{n}F(\\lfloor \\frac{n}{i}\\rfloor)$\n\n* 筛$\\varphi$：$g=1$，利用$\\mathrm{Id}=1 * \\varphi$，此时$F(n)=\\frac{n(n+1)}{2}-\\sum_{i=2}^{n}F(\\lfloor \\frac{n}{i}\\rfloor)$\n\n\n\n## 代码及例题\n\n[「BZOJ1101」ZAP-Queries](https://hk-cnyali.com/2018/03/24/Luogu-P3455-BZOJ1101-ZAP-Queries-%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94-%E6%95%B4%E9%99%A4%E5%88%86%E5%9D%97%E5%85%A5%E9%97%A8/)\n\n[「Luogu P3768」简单的数学题](https://hk-cnyali.com/2018/12/17/%E3%80%8CLuogu-P3768%E3%80%8D%E7%AE%80%E5%8D%95%E7%9A%84%E6%95%B0%E5%AD%A6%E9%A2%98-%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94-%E6%9D%9C%E6%95%99%E7%AD%9B/)","categories":["Algorithm"],"tags":["数学","数论","线性筛","莫比乌斯反演","杜教筛"]},{"title":"「HNOI2018」寻宝游戏 - 思维","url":"/2018/12/05/%E3%80%8CHNOI2018%E3%80%8D%E5%AF%BB%E5%AE%9D%E6%B8%B8%E6%88%8F-%E6%80%9D%E7%BB%B4/","content":"\n给你$n$个长度为$m$的$01$串\n\n你可以在每个串前面加一个运算符$\\lor$或$\\land$\n\n每次询问一个长度为$m$的$01$串，问有多少总操作序列能得到这个串\n\n$n\\le1000, m\\le 5000, q\\le 1000$\n\n<!--more-->\n\n### Links\n\n[Luogu P4424](https://www.luogu.org/problemnew/show/P4424)\n\n### Solution\n\n按位考虑\n\n通过观察发现，只有形如$|1$或$\\&0$这样的运算才会改变这一位的答案\n\n即最终结果是$1$的充要条件就是最后一个$|1$的位置要在最后一个$\\&0$的后面\n\n于是把操作序列转化成一个$01$序列$|\\rightarrow0, \\&\\rightarrow1$\n\n容易发现，在确定这一位最终结果的过程，实际上就是比较操作序列和原串的字典序的过程\n\n那么就很好做了。按字典序排序，对于每个询问找到其对应的上下界（最后一个$0$出现的位置和第一个$1$出现的位置），直接统计答案即可\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\n\ninline void proc_status()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) <<endl;\n}\n\ninline int read ()\n{\n\tint sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\nconst int Maxn = 1000 + 100, Maxm = 5000 + 100, Mod = 1e9 + 7;\n\nint N, M, Q;\nint A[Maxm][Maxn], Sum[Maxm], Rank[Maxm];\n\ninline int cmp (int a, int b)\n{\n\tfor (int i = 1; i <= N; ++i)\n\t\tif (A[a][i] > A[b][i]) return 0;\n\t\telse if (A[a][i] < A[b][i]) return 1;\n\treturn 0;\n}\n\ninline void Add (int &a, int b) { a += b; if (a >= Mod) a -= Mod; }\n\ninline void Solve ()\n{\n\tstatic int Pow[Maxn];\n\tPow[0] = 1; for (int i = 1; i <= N; ++i) Pow[i] = 1ll * Pow[i - 1] * 2 % Mod;\n\n\tfor (int i = 1; i <= M; ++i) reverse (A[i] + 1, A[i] + N + 1);\n\tfor (int i = 1; i <= M; ++i) Rank[i] = i;\n\tsort(Rank + 1, Rank + M + 1, cmp);\n\n\tfor (int i = 1; i <= M; ++i)\n\t\tfor (int j = 1; j <= N; ++j) \n\t\t\tAdd (Sum[i], A[Rank[i]][j] * Pow[N - j]);\n\tSum[M + 1] = Pow[N];\n\n\twhile (Q--)\n\t{\n\t\tstatic char S[Maxm];\n\t\tint pos1 = 0, pos2 = M + 1;\n\t\tscanf(\"%s\", S + 1);\n\n\t\tfor (int i = M; i >= 1; --i) if (S[Rank[i]] == '0') {pos1 = i; break; }\n\t\tfor (int i = 1; i <= M; ++i) if (S[Rank[i]] == '1') {pos2 = i; break; }\n\n\t\tprintf(\"%d\\n\", pos1 <= pos2 ? (Sum[pos2] - Sum[pos1] + Mod) % Mod : 0);\n\t}\n}\n\n\ninline void Input ()\n{\n\tN = read(), M = read(), Q = read();\n\tfor (int i = 1; i <= N; ++i)\n\t{\n\t\tstatic char S[Maxm];\n\t\tscanf(\"%s\", S + 1);\n\t\tfor (int j = 1; j <= M; ++j)\n\t\t\tA[j][i] = S[j] - '0';\n\t}\n}\n\nint main()\n{\n#ifdef hk_cnyali\n\tfreopen(\"A.in\", \"r\", stdin);\n\tfreopen(\"A.out\", \"w\", stdout);\n#endif\n\tInput();\n\tSolve();\n\treturn 0;\n}\n\n```\n\n","categories":["Problem"],"tags":["省选"]},{"title":"「HNOI2018」转盘 - 线段树","url":"/2018/12/04/%E3%80%8CHNOI2018%E3%80%8D%E8%BD%AC%E7%9B%98-%E7%BA%BF%E6%AE%B5%E6%A0%91/","content":"\n一个$n$元环，在$0$时刻从任意一个位置出发，每一秒可以选择往后或者留在原地\n\n每个点有个参数$T_i$，当你走到$i$的时间$t\\ge T_i$时就可以把$i$标记\n\n求把整个环上的点都标记最小需要多长时间，需要支持$T_i$修改,强制在线\n\n$3\\le n\\le 10^5, 0\\le m\\le 10^5, 0\\le T_i/T_x\\le 10^5$\n\n<!--more-->\n\n### Links\n\n[Luogu P4425](https://www.luogu.org/problemnew/show/P4425)\n\n### Solution\n\n感性考虑一下可以发现最优方案肯定是现在所选起点停留足够长时间再往后直接走一圈\n\n破环为链后实际上是求$\\min_{i=1}^{n} \\{\\max_{j=i}^{i+n-1} \\{T_j-(j-i+1)+n\\}\\}$\n\n可以转化成$\\min_{i=1}^{n} \\{\\max_{j=i}^{2n} \\{T_j-j\\}+i+n-1\\}$\n\n设$a_j=T_j-j$，化简得到$\\min_{i=1}^{n} \\{\\max_{j=i}^{2n} \\{a_j\\}+i\\}+n-1$\n\n考虑用线段树维护这个东西\n\n对于当前根$root$对应的区间$[L,R]$，考虑如何维护$val[root]=\\min_{i=L}^{mid} \\{\\max_{j=i}^{R} \\{a_j\\}+i\\}$\n\n定义$query(L,R,suf)$计算$\\min_{i=L}^{R} \\{\\max\\{\\max_{j=i}^{R} \\{a_j\\},suf\\}+i\\}$\n\n那么有$val[root] = query(L, mid, max[rson])$ （其中$max[root]$表示区间最大值）\n\n考虑如何计算$query(L,R,suf)$\n\n可以发现，若$suf\\le max[rson]$，则$val[root]$就等于左儿子的答案，于是只需要递归右儿子\n\n否则$mid+1+suf$就等于右儿子的答案，此时只需要递归左儿子\n\n（以上两个结论都很好证明，直接带到原式中观察一下就能发现是对的）\n\n那么就能在$O(\\log n)$的时间内求出$query$的值了\n\n总复杂度$O(n\\log ^2n)$\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\n\ninline void proc_status()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) <<endl;\n}\n\ninline int read ()\n{\n\tint sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\nconst int Maxn = 2e5 + 100;\n\nint N, M, P, A[Maxn];\n\nnamespace SEG\n{\n#define ls Tree[root << 1]\n#define rs Tree[root << 1 | 1]\n#define lson root << 1, l, mid\n#define rson root << 1 | 1, mid + 1, r\n\tstruct tree\n\t{\n\t\tint val, max;\n\t}Tree[Maxn << 2];\n\n\tinline int query (int root, int l, int r, int suf)\n\t{\n\t\tif (l == r) return Tree[root].val = max (Tree[root].max, suf) + l;\n\t\tint mid = l + r >> 1;\n\t\tif (suf <= rs.max) return min (Tree[root].val, query (rson, suf));\n\t\treturn min(query (lson, suf), suf + mid + 1);\n\t}\n\n\tinline void push_up (int root, int l, int r, int mid)\n\t{\n\t\tTree[root].max = max(ls.max, rs.max);\n\t\tTree[root].val = query (lson, rs.max);\n\t}\n\n\tinline void build (int root, int l, int r)\n\t{\n\t\tif (l == r)\n\t\t{\n\t\t\tTree[root].max = A[l], Tree[root].val = A[l] + l;\n\t\t\treturn ;\n\t\t}\n\t\tint mid = l + r >> 1;\n\t\tbuild (lson), build (rson);\n\t\tpush_up (root, l, r, mid);\n\t}\n\n\tinline void update (int root, int l, int r, int x)\n\t{\n\t\tif (l == r)\n\t\t{\n\t\t\tTree[root].max = A[l], Tree[root].val = A[l] + l;\n\t\t\treturn ;\n\t\t}\n\t\tint mid = l + r >> 1;\n\t\tif (x <= mid) update (lson, x);\n\t\telse update (rson, x);\n\t\tpush_up (root, l, r, mid);\n\t}\n}\n\ninline void Solve ()\n{\n/**/SEG :: build (1, 1, N << 1);\n\tint ans = SEG :: Tree[1].val + N - 1;\n\tcout<<ans<<endl;\n\twhile (M--)\n\t{\n\t\tint x = read(), y = read();\n\t\tif (P) x ^= ans, y ^= ans;\n\t\tA[x] = y - x, A[x + N] = y - x - N;\n\t\tSEG :: update (1, 1, N << 1, x), SEG :: update (1, 1, N<< 1, x + N);\n\t\tprintf(\"%d\\n\", ans = SEG :: Tree[1].val + N - 1);\n\t}\n}\n\ninline void Input ()\n{\n\tN = read(), M = read(), P = read();\n\tfor (int i = 1; i <= N; ++i) A[i] = read() - i, A[i + N] = A[i] - N;\n}\n\nint main()\n{\n#ifdef hk_cnyali\n\tfreopen(\"A.in\", \"r\", stdin);\n\tfreopen(\"A.out\", \"w\", stdout);\n#endif\n\tInput();\n\tSolve();\n\treturn 0;\n}\n\n```\n\n### Debug\n\n* 89L, 97L: `n<<1`写成`1<<n`。。。","categories":["Problem"],"tags":["线段树","数据结构","省选"]},{"title":"「HNOI2018」排列 - 贪心 + 堆 + 并查集","url":"/2018/12/02/%E3%80%8CHNOI2018%E3%80%8D%E6%8E%92%E5%88%97-%E8%B4%AA%E5%BF%83-%E5%A0%86-%E5%B9%B6%E6%9F%A5%E9%9B%86/","content":"\n给你一个序列$a$\n\n定义$a$的一个排列$p$合法需要满足$\\forall j\\le k$，不存在$a_{p_j}=p_k$\n\n定义一个排列的权值是$\\sum i*w_{p_i}​$\n\n求最大权值\n\n$1\\le n \\le 500000,0 \\le a_i \\le n,1 \\le w_i \\le 10^9 ,\\sum w_i \\le 1.5\\times10^{13}$\n\n<!--more-->\n\n### Links\n\n[Luogu P4437](https://www.luogu.org/problemnew/show/P4437)\n\n### Solution\n\n首先可以发现，若$a_j=k​$，则$k​$一定要排在$j​$之前\n\n所以把所有$a_j \\rightarrow j​$连边，最后的图如果有环则无解，否则就是一颗树\n\n那么题目转化为一棵树，按照某种顺序 $p_1 , ..., p_n​$ 依次选取所有点, 满足每个点的父亲比自己先选, 在此基础上最大化 $\\sum i * w_{p_i} ​$.\n\n考虑直接贪心，对于当前剩余权值最小的点，选了它的父亲后一定马上就会选它，然后就把它和它父亲缩成一个连通块\n\n那么当前剩下的所有连通块中，应该先选哪个呢？\n\n考虑两个连通块设$i,j$，那么$i$比$j$优则需要满足\n\n$w_i*len_i+w_j*(len_i+len_j) > w_j * s_j + w_i * (len_i + len_j)$（$w$表示该连通块中所有点权值和，$len$表示点数）\n\n即$\\frac{w_i}{len_i} < \\frac{w_j}{len_j}$\n\n因此按照$\\frac{w_i}{len_i}$从小到大选，用可删除堆+并查集维护即可\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\n\ninline void proc_status()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) <<endl;\n}\n\ninline int read ()\n{\n\tint sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\nconst int Maxn = 5e5 + 100;\n\nint N, A[Maxn], W[Maxn];\nint e, Begin[Maxn], To[Maxn << 1], Next[Maxn << 1];\nint Vis[Maxn], cnt;\n\ninline void add_edge (int x, int y) { To[++e] = y; Next[e] = Begin[x]; Begin[x] = e; }\n\ninline void dfs (int x)\n{\n\tif (Vis[x]) { puts(\"-1\"); exit(0); }\n\t++cnt;\n\tVis[x] = 1;\n\tfor (int i = Begin[x]; i; i = Next[i])\n\t{\n\t\tint y = To[i];\n\t\tdfs(y);\n\t}\n}\n\nstruct node\n{\n\tLL w, len;\n\tint id;\n\tinline int operator < (const node &a) const\n\t{\n\t\tif (a.w * len == w * a.len) return a.id < id;\n\t\treturn a.w * len < w * a.len;\n\t}\n\tinline int operator == (const node &a) const\n\t{\n\t\treturn ((a.w == w) && (a.len == len) && (a.id == id));\n\t}\n};\n\nstruct Heap\n{\n\tpriority_queue <node> a, b;\n\n\tinline void del () { while (!b.empty() && a.top() == b.top()) a.pop(), b.pop(); }\n\n\tinline void pop () { del(); a.pop(); }\n\n\tinline void erase (node k) { b.push(k); }\n\n\tinline node top () { del(); return a.top(); }\n\n\tinline int empty () { del(); return a.empty(); }\n\n\tinline void push (node k) { a.push(k); }\n}Q;\n\nLL ans;\n\nnamespace DSU\n{\n\tint fa[Maxn];\n\tLL w[Maxn], len[Maxn];\n\tinline void init () { for (int i = 1; i <= N; ++i) fa[i] = i, w[i] = W[i], len[i] = 1, Q.push((node){w[i], len[i], i}); }\n\n\tinline int find (int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); }\n\n\tinline void link (int x, int y)\n\t{\n\t\tif (y) Q.erase((node){w[y], len[y], y});\n\t\tans += w[x] * len[y];\n\t\tw[y] += w[x], len[y] += len[x], fa[x] = y;\n/**/\tw[x] = len[x] = 0;\n\t\tif (y) Q.push((node){w[y], len[y], y});\n\t}\n}\n\ninline void Solve ()\n{\n\tdfs(0);\n\tif (cnt <= N) { puts(\"-1\"); return ; }\n\n\tDSU :: init();\n/**/while (!Q.empty())\n\t{\n\t\tint x = Q.top().id, y = DSU :: find(A[x]); Q.pop();\n\t\tDSU :: link (x, y);\n\t}\n\tcout<<ans<<endl;\n}\n\ninline void Input ()\n{\n\tN = read();\n\tfor (int i = 1; i <= N; ++i) A[i] = read(), add_edge (A[i], i);\n\tfor (int i = 1; i <= N; ++i) ans += (W[i] = read());\n}\n\nint main()\n{\n#ifdef hk_cnyali\n\tfreopen(\"A.in\", \"r\", stdin);\n\tfreopen(\"A.out\", \"w\", stdout);\n#endif\n\tInput();\n\tSolve();\n\treturn 0;\n}\n\n```\n\n","categories":["Problem"],"tags":["并查集","堆","贪心","省选"]},{"title":"「HNOI2018」游戏 - 拓扑排序","url":"/2018/12/01/%E3%80%8CHNOI2018%E3%80%8D%E6%B8%B8%E6%88%8F-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/","content":"\n有$n$个房间排成一列，编号为$1,2,...,n$相邻的房间之间都有一道门。其中一部分们上锁（因此需要有对应的钥匙才能开门），其余的门都能直接打开。\n\n现在小G告诉了小H每把锁的钥匙在哪个房间里**（每把锁有且只有一把钥匙与之对应）**，并作出$p$次指示：\n\n第$i$次让小H从第$S_i$个房间出发到$T_i$个房间里。但是小G有时会故意在指令中放入死路，而小H也不想浪费多余的体力去尝试，于是想事先调查清楚每次的指令是否会存在一条通路。\n\n$1\\le n,p\\le 10^6,0\\le m <n,1\\le x,y,S_i,T_i < n$，保证$x$不重复\n\n<!--more-->\n\n### Links\n\n[Luogu P4436](https://www.luogu.org/problemnew/show/P4436)\n\n### Solution\n\n容易发现，从一个房间开始后得到的这个可达区间一定是连续的一段，且一开始的锁把序列变成了几段，最暴力的想法是对于每一段，暴力地一左一右的扩展段\n\n考虑优化掉一些重复转移，如果这个钥匙在这个门的右边，则只有右边的这段能扩展左边这段；否则右边的永远不可能更新到左边。即如果钥匙在门的右边，则先扩展左边这段再扩展右边；否则先扩展右边\n\n按这个拓扑序暴力更新答案，复杂度$O(n+m)$\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\n\ninline void proc_status()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) <<endl;\n}\n\ninline int read ()\n{\n\tint sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\nconst int Maxn = 1e6 + 100;\n\nint N, M, P, Pos[Maxn];\nint L[Maxn], R[Maxn], Belong[Maxn];\nint e, Begin[Maxn], To[Maxn << 1], Next[Maxn << 1], deg[Maxn];\n\ninline void add_edge (int x, int y) { To[++e] = y; Next[e] = Begin[x]; Begin[x] = e; ++deg[y]; }\n\ninline void Solve ()\n{\n\tint cnt = 1; L[1] = R[1] = 1;\n\tfor (int i = 2; i <= N; ++i)\n\t{\n\t\tif (Pos[i - 1])\n\t\t{\n\t\t\tL[++cnt] = i;\n\t\t\tif (Pos[i - 1] <= i - 1) add_edge (cnt, cnt - 1);\n\t\t\telse add_edge (cnt - 1, cnt);\n\t\t}\n\t\tR[cnt] = i;\n\t}\n\n\tfor (int i = 1; i <= cnt; ++i) for (int j = L[i]; j <= R[i]; ++j) Belong[j] = i;\n\n\tstatic queue <int> Q;\n\tfor (int i = 1; i <= cnt; ++i) if (!deg[i]) Q.push(i);\n\twhile (!Q.empty())\n\t{\n\t\tint x = Q.front(), fl = 1; Q.pop();\n\t\twhile (fl)\n\t\t{\n\t\t\tfl = 0;\n\t\t\tint pos1 = Pos[L[x] - 1], pos2 = Pos[R[x]];\n\t\t\twhile (L[x] <= pos1 && pos1 <= R[x]) fl = 1, L[x] = L[Belong[L[x] - 1]], pos1 = Pos[L[x] - 1], pos2 = Pos[R[x]];\n\t\t\twhile (L[x] <= pos2 && pos2 <= R[x]) fl = 1, R[x] = R[Belong[R[x] + 1]], pos2 = Pos[R[x]];\n\t\t\twhile (L[x] <= pos1 && pos1 <= R[x]) fl = 1, L[x] = L[Belong[L[x] - 1]], pos1 = Pos[L[x] - 1], pos2 = Pos[R[x]];\n\t\t}\n\t\tfor (int i = Begin[x]; i; i = Next[i])\n\t\t{\n\t\t\tint y = To[i];\n\t\t\t--deg[y];\n\t\t\tif (!deg[y]) Q.push(y);\n\t\t}\n\t}\n\n//\tfor (int i = 1; i <= cnt; ++i) cout<<L[i]<<\" \"<<R[i]<<endl;\n\n\twhile (P--)\n\t{\n\t\tint x = read(), y = read();\n\t\tif (L[Belong[x]] <= y && y <= R[Belong[x]]) puts(\"YES\");\n\t\telse puts(\"NO\");\n\t}\n}\n\ninline void Input ()\n{\n\tN = read(), M = read(), P = read();\n\tfor (int i = 1; i <= M; ++i)\n\t{\n\t\tint x = read(), y = read();\n\t\tPos[x] = y;\n\t}\n}\n\nint main()\n{\n#ifdef hk_cnyali\n\tfreopen(\"A.in\", \"r\", stdin);\n\tfreopen(\"A.out\", \"w\", stdout);\n#endif\n\tInput();\n\tSolve();\n\treturn 0;\n}\n\n```\n\n","categories":["Problem"],"tags":["暴力","拓扑排序","省选"]},{"title":"「HNOI2017」单旋 - 线段树 + set","url":"/2018/11/27/%E3%80%8CHNOI2017%E3%80%8D%E5%8D%95%E6%97%8B-%E7%BA%BF%E6%AE%B5%E6%A0%91-set/","content":"\n维护一颗初始为空的单旋Splay，需要支持五种操作：\n\n1. 插入一个值并查询此节点深度\n2. 查询最小值节点的深度并将其单旋至根\n3. 查询最大值节点的深度并将其单旋至根\n4. 查询最小值节点的深度，将其单旋至根后删除\n5. 查询最大值节点的深度，将其单旋至根后删除\n\n根的深度为1\n\n$m \\le 100000$\n\n<!--more-->\n\n### Links\n\n[Luogu P3721](https://www.luogu.org/problemnew/show/P3721)\n\n### Solution\n\n这道题只要稍微手玩一下找找规律还是比较容易想到的\n\n由于这颗树性质以及查询、修改的东西都比较神奇，可以发现（以下均以最小值为例）把最小值$x$旋至根深度实际上只是将$x$的右子树的所有节点深度-1，再将除$x$之外的所有节点的深度+1；父子关系也只有$x$和$root​$之间有变化（具体见代码）\n\n有了这个性质就非常好维护了\n\n直接用set维护每个点的前驱后继，用线段树维护每个点深度。在具体实现（处理$fa[]$数组）上稍微有一些细节。\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\n\ninline void proc_status()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) <<endl;\n}\n\ninline int read ()\n{\n\tint sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\nconst int Maxn = 1e5 + 100;\n\nint N, M, B[Maxn], root, ch[Maxn][2], fa[Maxn];\npii A[Maxn];\n\nset <int> S;\nset <int> :: iterator it;\n\nnamespace SEG\n{\n#define ls Tree[root << 1]\n#define rs Tree[root << 1 | 1]\n#define lson root << 1, l, mid\n#define rson root << 1 | 1, mid + 1, r\n\tstruct tree\n\t{\n\t\tint sum, tag;\n\t}Tree[Maxn << 2];\n\n\tinline void push_up (int root) { Tree[root].sum = ls.sum + rs.sum; }\n\n\tinline void push_down (int root, int l, int r, int mid)\n\t{\n\t\tif (!Tree[root].tag) return ;\n\t\tls.tag += Tree[root].tag;\n\t\trs.tag += Tree[root].tag;\n\t\tls.sum += Tree[root].tag * (mid - l + 1);\n\t\trs.sum += Tree[root].tag * (r - mid);\n\t\tTree[root].tag = 0;\n\t}\n\n\tinline void update (int root, int l, int r, int x, int y, int z)\n\t{\n\t\tif (x <= l && r <= y) { Tree[root].sum += z * (r - l + 1); Tree[root].tag += z; return ; }\n\t\tint mid = l + r >> 1;\n\t\tpush_down (root, l, r, mid);\n\t\tif (x <= mid) update (lson, x, y, z);\n\t\tif (y > mid) update (rson, x, y, z);\n\t\tpush_up (root);\n\t}\n\n\tinline void modify (int root, int l, int r, int x, int z)\n\t{\n\t\tif (l == r) { Tree[root].sum = z; Tree[root].tag = 0; return ; }\n\t\tint mid = l + r >> 1;\n\t\tpush_down (root, l, r, mid);\n\t\tif (x <= mid) modify (lson, x, z);\n\t\telse modify (rson, x, z);\n\t\tpush_up (root);\n\t}\n\n\tinline int query (int root, int l, int r, int x)\n\t{\n\t\tif (l == r)\treturn Tree[root].sum;\n\t\tint mid = l + r >> 1;\n\t\tpush_down (root, l, r, mid);\n\t\tif (x <= mid) return query (lson, x);\n\t\telse return query (rson, x);\n\t}\n}\n\ninline void link (int x, int f, int dir) { ch[f][dir] = x; fa[x] = f;}\n\ninline int Insert (int x)\n{\n\tit = S.insert(x).x;\n\tif (!root) { root = x; SEG :: modify (1, 1, N, x, 1); return 1; }\n\tif (it != S.begin())\n\t{\n\t\tif (!ch[*(--it)][1]) link (x, *it, 1);\n\t\t++it;\n\t}\n\tif (!fa[x]) link (x, *(++it), 0);\n\tint ans = SEG :: query (1, 1, N, fa[x]) + 1;\n\tSEG :: modify (1, 1, N, x, ans);\n\treturn ans;\n}\n\ninline int Query_min ()\n{\n\tint x = *S.begin(), ans = SEG :: query (1, 1, N, x);\n\tif (x == root) return 1;\n\tif (fa[x] != x + 1) SEG :: update (1, 1, N, x + 1, fa[x] - 1, -1);\n\tSEG :: update (1, 1, N, 1, N, 1);\n\tlink (ch[x][1], fa[x], 0), link (root, x, 1);\n\troot = x;\n\tSEG :: modify (1, 1, N, x, 1);\n\treturn ans;\n}\n\ninline int Query_max ()\n{\n\tint x = *S.rbegin(), ans = SEG :: query (1, 1, N, x);\n\tif (x == root) return 1;\n\tif (fa[x] != x - 1) SEG :: update (1, 1, N, fa[x] + 1, x - 1, -1);\n\tSEG :: update (1, 1, N, 1, N, 1);\n\tlink (ch[x][0], fa[x], 1), link (root, x, 0);\n\troot = x;\n\tSEG :: modify (1, 1, N, x, 1);\n\treturn ans;\n}\n\ninline void Del_min ()\n{\n\tSEG :: update (1, 1, N, 1, N, -1);\n\tS.erase(root);\n\troot = ch[root][1], fa[root] = 0;\n}\n\ninline void Del_max ()\n{\n\tSEG :: update (1, 1, N, 1, N, -1);\n\tS.erase(root);\n\troot = ch[root][0], fa[root] = 0;\n}\n\ninline void Solve ()\n{\n\tfor (int i = 1; i <= M; ++i)\n\t{\n\t\tif (A[i].x == 1) printf(\"%d\\n\", Insert (A[i].y));\n\t\telse if (A[i].x == 2) printf(\"%d\\n\", Query_min());\n\t\telse if (A[i].x == 3) printf(\"%d\\n\", Query_max());\n\t\telse if (A[i].x == 4) printf(\"%d\\n\", Query_min()), Del_min();\n\t\telse if (A[i].x == 5) printf(\"%d\\n\", Query_max()), Del_max();\n\t}\n}\n\ninline void Input ()\n{\n\tM = read();\n\tfor (int i = 1; i <= M; ++i)\n\t{\n\t\tA[i].x = read();\n\t\tif (A[i].x == 1) A[i].y = B[++N] = read();\n\t}\n\tsort(B + 1, B + N + 1), N = unique (B + 1, B + N + 1) - B - 1;\n\tfor (int i = 1; i <= M; ++i) if (A[i].x == 1) A[i].y = lower_bound (B + 1, B + N + 1, A[i].y) - B;\n}\n\nint main()\n{\n#ifdef hk_cnyali\n\tfreopen(\"A.in\", \"r\", stdin);\n\tfreopen(\"A.out\", \"w\", stdout);\n#endif\n\tInput();\n\tSolve();\n\treturn 0;\n}\n\n```\n\n","categories":["Problem"],"tags":["线段树","数据结构","set","模拟","省选"]},{"title":"「NOIp2018」保卫王国 - 倍增","url":"/2018/11/26/%E3%80%8CNOIp2018%E3%80%8D%E4%BF%9D%E5%8D%AB%E7%8E%8B%E5%9B%BD-%E5%80%8D%E5%A2%9E/","content":"\n一颗$n$个节点的树，可以花$p_i$代价把$i$点染色，要求任2个相邻点至少有1个被染色。\n\n$m$组询问，每次强制两个点的状态(染/不染)，求出每次的最小花费。\n\n$n,m,p_i\\le 100000$\n\n<!--more-->\n\n### Links\n\n[Luogu P5024](https://www.luogu.org/problemnew/show/P5024)\n\n### Solution\n\n暴力dp：$f[i][0/1]$表示以$i$为根的子树中所有节点，$i$号点不选/选，所花费的最小代价\n\n考虑在此基础上再多记录一些东西\n\n* $g[i][0/1]$表示以$i$号点不选/选，整棵树的最小代价\n\n  这个东西可以通过$f$求出\n\n* $dp[i][j][0/1][0/1]$表示$i$号点向上跳$2^j$的父亲$f$的子树去掉以$i$为根的子树后，$i$号点不选/选，$f$号点不选/选，所花费的最小代价（这里的去掉是指当作这个子树不存在，而并不仅仅是把子树的答案减掉）\n\n  这个东西可以通过倍增预处理出来\n\n接下来，询问就很好处理了，分两种情况讨论：\n\n* 一个点为另一个点的祖先：直接把较深的节点$a$跳到另一个点$b$的儿子处，然后讨论一下$b$的选择情况\n\n* 否则，先把两个点都跳到它们$lca$的儿子节点处，然后讨论$lca$的选择情况\n\n然后用预处理出的$f$、$g$、$dp$算答案即可（具体见代码）\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmin (T &a, T b) {return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmax (T &a, T b) {return a < b ? a = b, 1 : 0; }\n\ninline int read ()\n{\n\tint sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\nconst int Maxn = 1e5 + 100;\nconst LL inf = 11000000000;\n\nint N, M, A[Maxn];\nint e, Begin[Maxn], To[Maxn << 1], Next[Maxn << 1];\n\ninline void add_edge (int x, int y) { To[++e] = y; Next[e] = Begin[x]; Begin[x] = e; }\n\nint a, val1, b, val2;\nint anc[Maxn][22], dep[Maxn];\nLL f[Maxn][2], g[Maxn][2];\n\nstruct mat\n{\n\tLL a[2][2];\n}Dp[Maxn][20];\n\ninline void dfs1 (int x, int father)\n{\n\tanc[x][0] = father;\n\tdep[x] = dep[father] + 1;\n\tfor (int i = 1; i <= 17; ++i) anc[x][i] = anc[anc[x][i - 1]][i - 1];\n\tfor (int i = Begin[x]; i; i = Next[i])\n\t{\n\t\tint y = To[i];\n\t\tif (y == father) continue;\n\t\tdfs1(y, x);\n\t\tf[x][0] += f[y][1];\n\t\tf[x][1] += min(f[y][0], f[y][1]);\n\t}\n\tf[x][1] += A[x];\n}\n\ninline void dfs2 (int x)\n{\n\tfor (int i = Begin[x]; i; i = Next[i])\n\t{\n\t\tint y = To[i];\n\t\tif (y == anc[x][0]) continue;\n\t\tDp[y][0].a[0][0] = inf;\n\t\tDp[y][0].a[1][0] = f[x][0] - f[y][1];\n\t\tDp[y][0].a[0][1] = Dp[y][0].a[1][1] = f[x][1] - min(f[y][0], f[y][1]);\n\t\tLL sum = g[x][1] - min(f[y][0], f[y][1]);\n\t\tg[y][0] = f[y][0] + sum;\n\t\tg[y][1] = f[y][1] + min(sum, g[x][0] - f[y][1]);\n\t\tdfs2(y);\n\t}\n}\n\ninline mat merge (const mat &A, const mat &B)\n{\n\tmat C;\n\tmemset(C.a, 0x3f, sizeof C.a);\n\tfor (int a = 0; a < 2; ++a)\n\t\tfor (int b = 0; b < 2; ++b)\n\t\t\tfor (int c = 0; c < 2; ++c)\n\t\t\t\tChkmin(C.a[a][b], A.a[a][c] + B.a[c][b]);\n\treturn C;\n}\n\ninline void Solve ()\n{\n\tdfs1(1, 0);\n\tg[1][0] = f[1][0];\n\tg[1][1] = f[1][1];\n\tdfs2(1);\n\tfor (int j = 1; j <= 17; ++j)\n\t{\n\t\tfor (int i = 1; i <= N; ++i)\n\t\t\tDp[i][j] = merge (Dp[i][j - 1], Dp[anc[i][j - 1]][j - 1]);\n\t}\n\twhile (M--)\n\t{\n\t\ta = read(), val1 = read(), b = read(), val2 = read();\n\t\tif (dep[a] < dep[b]) swap(a, b), swap(val1, val2);\n\t\tif (!val1 && !val2 && anc[a][0] == b) { puts(\"-1\"); continue; }\n\t\t\n\t\tmat A, B;\n\t\tmemset(A.a, 0x3f, sizeof A.a), memset(B.a, 0x3f, sizeof B.a);\n\t\tA.a[val1][val1] = f[a][val1], B.a[val2][val2] = f[b][val2];\n\n\t\tfor (int i = 17; i >= 0; --i) \n\t\t\tif (dep[anc[a][i]] > dep[b]) \n\t\t\t\tA = merge (A, Dp[a][i]), a = anc[a][i];\n\n\t\tif (anc[a][0] == b)\n\t\t{\n\t\t\tif (!val2) printf(\"%lld\\n\", g[b][0] - f[a][1] + A.a[val1][1]);\n\t\t\telse printf(\"%lld\\n\", g[b][1] - min(f[a][0], f[a][1]) + min(A.a[val1][0], A.a[val1][1]));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (dep[a] > dep[b]) A = merge (A, Dp[a][0]), a = anc[a][0];\n\t\t\tfor (int i = 17; i >= 0; --i)\n\t\t\t\tif (anc[a][i] != anc[b][i])\n\t\t\t\t{\n\t\t\t\t\tA = merge (A, Dp[a][i]), B = merge (B, Dp[b][i]);\n\t\t\t\t\ta = anc[a][i], b = anc[b][i];\n\t\t\t\t}\n\n\t\t\tint lca = anc[a][0];\n\t\t\tLL sum0 = g[lca][0] - f[a][1] - f[b][1];\n\t\t\tLL sum1 = g[lca][1] - min(f[a][0], f[a][1]) - min(f[b][0], f[b][1]);\n\t\t\tsum0 += A.a[val1][1] + B.a[val2][1];\n\t\t\tsum1 += min(A.a[val1][0], A.a[val1][1]) + min(B.a[val2][0], B.a[val2][1]);\n\t\t\tprintf(\"%lld\\n\", min(sum0, sum1));\n\t\t}\n\t}\n}\n\ninline void Input ()\n{\n\tN = read(), M = read();\n\tchar type[3];\n\tscanf(\"%s\", type);\n\tfor (int i = 1; i <= N; ++i) A[i] = read();\n\tfor (int i = 1; i < N; ++i)\n\t{\n\t\tint x = read(), y = read();\n\t\tadd_edge (x, y);\n\t\tadd_edge (y, x);\n\t}\n}\n\nint main()\n{\n#ifdef hk_cnyali\n\tfreopen(\"defense.in\", \"r\", stdin);\n\tfreopen(\"defense.out\", \"w\", stdout);\n#endif\n\tInput();\n\tSolve();\n\treturn 0;\n}\n\n```\n\n","categories":["Problem"],"tags":["动态规划","倍增"]},{"title":"「NOIp2018」赛道修建 - 二分答案 + 贪心","url":"/2018/11/26/%E3%80%8CNOIp2018%E3%80%8D%E8%B5%9B%E9%81%93%E4%BF%AE%E5%BB%BA-%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88-%E8%B4%AA%E5%BF%83/","content":"\n从一颗$n$个节点的带权树中选出$m$条互不相交的链，使得这$m$条链中长度最小的链长度最大，求这个最大值。\n\n$m <  n\\le 500000$\n\n<!--more-->\n\n### Links\n\n[Luogu P5021](https://www.luogu.org/problemnew/show/P5021)\n\n### Solution\n\n显然二分答案，考虑check\n\n显然对于每一个节点$x$，$x$的儿子所剩的链能在$x$处匹配就在$x$处匹配，否则找出一条不能匹配的最长的链传到它的父亲上去。\n\n匹配的过程用two pointers扫一下，再套一个二分找出在这个前提下能上传的最长链即可。\n\n$O(n\\log^2 n)$\n\n### Code\n\n（考场代码，有点丑。。。） \n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmin (T &a, T b) {return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmax (T &a, T b) {return a < b ? a = b, 1 : 0; }\n\ninline int read ()\n{\n\tint sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\nconst int Maxn = 50000 + 100;\n\nint N, M;\nint e, Begin[Maxn], To[Maxn << 1], Next[Maxn << 1], W[Maxn << 1];\n\ninline void add_edge (int x, int y, int z)\n{\n\tTo[++e] = y;\n\tNext[e] = Begin[x];\n\tBegin[x] = e;\n\tW[e] = z;\n}\n\nint sum_w, Dp[Maxn], ans;\nvector <int> vec[Maxn];\n\ninline void dfs (int x, int f, int ans_now)\n{\n\tfor (int i = Begin[x]; i; i = Next[i])\n\t{\n\t\tint y = To[i];\n\t\tif (y == f) continue;\n\t\tdfs(y, x, ans_now);\n\t\tDp[y] += W[i];\n\t\tif (Dp[y] >= ans_now)\n\t\t{\n\t\t\t++ans;\n\t\t\tDp[y] = 0;\n\t\t}\n\t\tvec[x].pb(Dp[y]);\n\t}\n\tif (!vec[x].size()) return ;\n\tsort(vec[x].begin(), vec[x].end());\n\tint l = 0, r = (int)vec[x].size() - 1, res = 0;\n\tint sum1 = 0, ans1 = 0;\n\twhile (r >= 0)\n\t{\n\t\twhile (l < r && res + vec[x][r] < ans_now) Chkmax(sum1, res), res = vec[x][l], ++l;\n\t\tif (res + vec[x][r] < ans_now) { Chkmax(sum1, vec[x][r]); break;}\n\t\tres = 0; ++ans1; --r;\n\t\tif (l > r) break ;\n\t}\n\n\tif (vec[x].size() == 1) { ans += ans1; Dp[x] = sum1; return ; }\n\n\tint ll = 0, rr = vec[x].size() - 1, anss = sum1;\n\twhile (ll <= rr)\n\t{\n\t\tint mid = ll + rr >> 1;\n\t\tint l2 = 0, r2 = (int)vec[x].size() - 1;\n\t\tres = 0;\n\t\tint tmp = vec[x][mid];\n\t\tvec[x][mid] = 0;\n\t\tint sum2 = 0, ans2 = 0;\n\t\tif (l2 == mid) ++l2;\n\t\tif (r2 == mid) --r2;\n\t\twhile (r2 >= 0)\n\t\t{\n\t\t\twhile (l2 < r2 && (res + vec[x][r2] < ans_now || l2 == mid))\n\t\t\t{\n\t\t\t\tChkmax(sum2, res);\n\t\t\t\tif (l2 != mid) res = vec[x][l2];\n\t\t\t\t++l2;\n\t\t\t}\n\t\t\tif (res + vec[x][r2] < ans_now) { Chkmax(sum2, vec[x][r2]); break;}\n\t\t\tres = 0; ++ans2; --r2;\n\t\t\tif (r2 == mid) --r2;\n\t\t\tif (l2 > r2) break;\n\t\t}\n\t\tvec[x][mid] = tmp;\n\t\tif (ans2 == ans1) ll = mid + 1, anss = tmp;\n\t\telse rr = mid - 1;\n\t}\n\t\n\tans += ans1, Dp[x] = anss;\n}\n\ninline int Check (int ans_now)\n{\n\tmemset(Dp, 0, sizeof Dp);\n\tfor (int i = 1; i <= N; ++i) vec[i].clear();\n\tans = 0;\n\tdfs(1, 0, ans_now);\n\treturn ans >= M;\n}\n\ninline void Solve ()\n{\n\tint l = 0, r = sum_w, Ans = 0;\n\twhile (l <= r)\n\t{\n\t\tint mid = l + r >> 1;\n\t\tif (Check(mid)) Ans = mid, l = mid + 1;\n\t\telse r = mid - 1;\n\t}\n\tcout<<Ans<<endl;\n}\n\ninline void Input ()\n{\n\tN = read(), M = read();\n\tfor (int i = 1; i < N; ++i)\n\t{\n\t\tint x = read(), y = read(), z = read();\n\t\tadd_edge (x, y, z);\n\t\tadd_edge (y, x, z);\n\t\tsum_w += z;\n\t}\n}\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"track.in\", \"r\", stdin);\n\tfreopen(\"track.out\", \"w\", stdout);\n#endif\n\tInput();\n\tSolve();\n\treturn 0;\n}\n```\n\n","categories":["Problem"],"tags":["二分答案","贪心","NOIp"]},{"title":"NOIp2018游记&总结","url":"/2018/11/21/NOIp2018%E6%B8%B8%E8%AE%B0-%E6%80%BB%E7%BB%93/","content":"\n还得更加努力啊\n\n<!--more-->\n\n## 游记\n\n### Day$-\\infty$\n\n考前几天状态似乎并不是很好,最后一天的模拟考考的非常差,突然间就失去了很多信心,好在及时调整了状态.\n\n最后几天就一直在复习历年真题,奶今年的题目(详见[NOIp专题个人分析及考前总结](https://hk-cnyali.com/2018/11/04/NOIp%E8%80%83%E9%A2%98%E4%B8%AA%E4%BA%BA%E5%88%86%E6%9E%90%E5%8F%8A%E8%80%83%E5%89%8D%E6%80%BB%E7%BB%93/)).\n\n### Day0\n\n上午搞了动员大会,从中午一直到晚上一直在打2k online,把王朝模式几百年没变动过的阵容换了个库里+哈登的后卫组合,手感不错,三分还射得挺准的.晚上实在没忍住看了集明星大侦探,奇妙的是看了集电视心居然就静下来了(否则可能第二天满脑子都是哈登无解的后撤步)\n\n晚上11:00睡的觉,没有像去年一样紧张得睡不着,今年反倒轻松了一些.\n\n> 稳一点,尽力发挥出自己的水平就行.都知道我水平最多也就那样,对自己期望别太高.\n\n\n\n### Day1\n\n今年很良心,给了30mins的时间进考场配配置,大约花了15mins把所有配置都配好,静下心等待发密码.\n\n打开题面后先看的T1,乍一看感觉是`NOIp2013 Day2T1`原题,前一天刚做过.直接敲了脑子里还有点印象的正解(到现在都不是太懂那个贪心是怎么回事),过了大样例.又写了$O(n^2)$的暴力拍,拍上之后看了一眼时间,8:35.感觉非常虚,花了5mins认真一个字一个字重新审题,期间差点认为`首尾相连`是指形成一个环...\n\n总之T1还是非常虚,后来还至少零零碎碎花了将近20mins来重新审题意.\n\n---\n\n然后看后两题,T2看了一眼以为是数学题不太可做,就先看的T3.\n\n>  树上问题+最小值最大\n\n居然今年又考了这种树上问题! 考前刚好复习了很多相关题型,激动了几秒后开始想如何check.一开始想的是直接把每个点的儿子中剩余路径最长的去跟最短的一一匹配,最后把其中不能匹配的最大的一条边传上去就行,用个two pointers做.想到之后并没有直接开始打,手玩了下样例好像没问题就开始写.\n\n写完之后调了一些细节就过了前两个样例,但是第三个死活过不去.此时似乎才9:30不到,并不虚.在草稿纸写写画画了10mins左右后发现是传上去的边不一定是最优的,然后就贪心地想直接把最大的那条边判一下能不能传上去.改了之后过了所有样例.并且花了大约10mins证明了这个贪心是对的.(当然是伪证,当时脑抽)\n\n期间想过要不要写个暴力拍下,但是想了很久发现不会写暴力,于是写了个最暴力的暴力(一分都没有的那种),跟个傻逼样的在拍.只能跑$n\\le6$的当然什么都拍不出...\n\n---\n\n10:10开的T2,发现只会暴力,写完之后发现爆搜+剪枝能过所有样例,后来又换了个$Tna_i^2$的暴力,有稳的80分.\n\n此时是10:30,信心满满地去上了趟厕所,感觉自己今天考得挺好,开始各种得意.\n\nT2一直陷在数学题的坑里,居然没有认真看看自己暴力代码,就是一个背包问题.\n\n最后一个半小时什么都没干,除了各种检查文件名,检查题意,检查空间内存,然后发现都没有问题...\n\n出考场前美滋滋估分$100+80+100=280$\n\n---\n\n出考场后整个人都炸了.\n\n首先是发现T2就是个傻逼完全背包,紧接着T3的做法被cxr大佬无情hack掉.我tm考场上怎么就没想到再套一个二分去看上传哪条边呢...\n\n于是估分变成了$100+80+80=260$\n\n---\n\n晚上在洛谷上测了下,295,并没有什么可信度,想要明天翻盘.\n\n\n\n### Day2\n\n虽然Day1考的很差,但是并没有影响到第二天的心态.T1开始以为是傻逼题,过不去样例之后发现少看到了必须把子树都走完的条件.写了个树的部分分,然后发现好像直接枚举断边是对的就随便写了个$O(n^2 \\log n)$的,没加什么优化,9:20左右过了大样例.\n\n---\n\n然后花了90mins左右的时间刚T2,最后却只有50分,这可能是整场比赛最大的一个败笔吧.\n\n考场上一直以为这是一道状压Dp题,在往状压上想,死活想不出,最擅长找规律的我居然根本没往找规律上去想\n\n10:30的时候写了个假状压,能过$n\\le2$的点,只有30分.此时心态几乎爆炸,一心想着要写正解或者很高的部分分,脑子却一片混乱,这简直和去年Day1心态一模一样.\n\n到了10:45,还是什么都想不清楚,果断弃疗,重新调整心态,带着一丝不甘心写暴力.\n\n虽然现在看来的确还是有一丝丝不甘心(找规律至少能拿65,总分就能上500),但是这个决定在当时已经犯错的前提下无疑是非常明智的.\n\n>  $afo$ 与功成名就真的之差那一瞬间调整的心态，多写那么几分的暴力 ——[zjp-shadow's blog](https://www.cnblogs.com/zjp-shadow/p/9943572.html)\n\n---\n\n11:00开始想T3,先写了44分暴力,写完后突然感觉T1有点虚,算了算复杂度发现跑不过.但是感觉预处理sort一遍,复杂度$O(n^2)$的做法有点麻烦,就匆匆忙忙加了个优化:只枚举环上的边,随机数据下似乎表现不错.\n\n幸好拍上之后还肉眼检查了一下,发现找环找错,忘记把最后那条横叉边算进去了.发现这个错误的时候吓出了一身冷汗.\n\n最后半个小时的时候想到了T3询问保证$a = 1,x = 1$的做法,然而一直调到比赛结束并没有调出来\n\n---\n\nDay2期望得分:$88$~$100 + 50 + 44=182$~$194$,大众分都没上\n\n总成绩波动挺大,成绩完全被数据强度所支配,最高$494$,最低$442$,只希望有个$470$就行\n\n### Day$\\infty$\n\n最终成绩$100+100+95+100+50+44=489$ 这个运气真的没得话讲\n\n看到成绩的时候激动了大半天,但是今年数据实在是太水了,Day1T2和Day2T1都是暴力水过的(要是CCF没换少爷机可能Day2T1还会被卡),Day1T3错误算法还能拿到95分\n\n\n\n## 总结\n\n表面上这次考得不错,但还是能够反映出许多问题的:\n\n1. 即使是运气爆表可还是上不了500,与长郡的大佬们还有很大差距.尤其是接下来越来越难的考试,差距会更大.**实力不够**依旧是目前的主要问题,接下来还得更加努力.\n2. **基础不扎实**,虽然这一点并没有在最终成绩上体现出.解决这个问题的最好办法只有不断刷题,查漏补缺.要认真对待每一道题,不管是难是易.即使是简单题,如果自己的思路没有正解优美、简单、巧妙,也要去学习更加优秀的做法.\n3. 关于做题方面:做题的时候容易陷在一种思路中,如果一道题朝某一方面想很久都不会的话,应该尝试换个思路.两天的第二题都是这个问题导致没有做出来.并且乱搞/骗分能力还差了点,这些都需要在平时做题/考试中多积累经验.\n\n当然，还是有几个做得比较好，以后需要注意继续保持的地方：\n\n1. **较好的考试策略和习惯**,以及**考场上的心态调整**.\n2. 认真**想清楚细节**之后再开始写代码.\n\n抛开这次成绩不谈,在去年联赛到现在的这一年中,从平时的刷题、考试,以及自己的状态来看,较去年而言还是有比较大的提升的.但显而易见的是,自己如果有gzy sxy cxr他们那么努力的话,考出来的分数绝对远不止如此.\n\n总的来说,NOIp2018还是不错的,算是给高中的OI生涯开了个好头吧.\n\n希望接下来的考试都能有这么好的运气.\n\n当然,还得更加努力啊\n","categories":["Summary"],"tags":["Summary","NOIp"]},{"title":"求解模线性方程组 - ex_gcd","url":"/2018/11/06/%E6%B1%82%E8%A7%A3%E6%A8%A1%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84-ex-gcd/","content":"\n求解$x$满足\n$$\n\\begin{cases}\nx &\\equiv r_1 ~(mod~m_1) \\\\\nx &\\equiv r_2 ~(mod~m_2) \\\\\n&...\\\\\nx &\\equiv r_3 ~(mod~m_3)\n\\end{cases}\n$$\n\n\n<!--more-->\n\n### Solution\n\n可以利用`ex_gcd`合并模线性方程组\n\n假设现在我们合并前两个方程组:\n$$\n\\begin{cases}\nx \\equiv r_1 ~(mod~m_1) \\\\\nx \\equiv r_2 ~(mod~m_2)\n\\end{cases}\n$$\n展开得到:\n$$\n\\begin{cases}\nx =m_1 k_1 + r_1 \\\\\nx =m_2 k_2 + r_2\n\\end{cases}\n$$\n联立得到:\n$$\nm_1 k_1 + r_1 = m_2 k_2 + r_2\n\n$$\n\n$$\nm_1 k_1 - m_2 k_2 = r_2 - r_1\n$$\n\n\n\n令$a=m_1, b = m_2, c = r_2 - r1$,那么就变成了$ax+by=c$的形式\n\n用扩欧即可求出$k_1$的最小非负整数解(无解也很好判)\n\n再把求得的解带入之前的方程即能得到$x=x_0$的一个特解\n\n那么事实上这个$x_0$就能作为新的方程的$R$了,而新的方程的$M$很显然是${lcm}(m_1,m_2)$\n\n> 我们知道$k_1$与其相邻解的间距为$\\frac{m_2}{\\gcd(m1,m2)}$,又因为$x=m_1k_1+r_1$,所以$x$相邻解的间距为$\\frac{m_1m_2}{\\gcd(m_1,m_2)}={lcm}(m1,m2)$\n\n至此,我们就将两个方程组合并成新的一个方程$x\\equiv R(mod~M)$\n\n不断重复上述过程,即能合并所有方程组了\n\n\n\n### Something\n\n这里提一下一个一直没搞清楚的问题.\n\n在用扩欧求最小非负整数解时,需要把gcd都除干净.\n\n即要`a/=gcd, b/=gcd, c/=gcd`,这样才能求出最小非负整数解\n\n这是因为对于$ax+by=\\gcd(a,b)$这个方程而言,相邻$x$的解的间距其实是$\\frac{b}{\\gcd(a,b)}$,而并非$b$\n\n**但是,~~通过写错还能A掉的实践经验可以得出~~在合并模线性方程组时,除不除gcd得到的结果是一样的.**\n\n------\n\n(注:以下内容为本人研究写错的做法最后答案是对的的原因,与此算法没有什么太大关系)\n\n考虑原方程$m_1k_1-m_2k_2=gcd(m_1,m_2)$的解$k_1$与除完gcd之后的方程$\\frac{m_1}{gcd}k_1-\\frac{m_2}{gcd}k_2=1$的解$k_1'$\n\n显然,$k_1$正确的间距是$\\frac{m_2}{gcd}$,但在原方程直接求非负整数解时,间距被误算成了$m_2$\n\n那么$k_1$和$k_1'$的差$\\Delta$会是$\\frac{m_2}{gcd}$的若干倍\n\n带入$x=m_1k_1+r_1$中可以发现最终正确答案$x$与错误答案$x'$的差会是$\\frac{m_1m_2}{gcd}$的若干倍,即是${ lcm}(m_1,m_2)$的若干倍\n\n所以最后在模${ lcm}(m_1,m_2)$意义下这两个答案是相同的\n\n\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\n\ninline void proc_status()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) <<endl;\n}\n\ninline LL read ()\n{\n\tLL sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\nconst int Maxn = 1e5 + 10;\n\nint N;\nLL A[Maxn], B[Maxn];\n\ninline LL ex_gcd (LL a, LL b, LL &x, LL &y)\n{\n\tif (!b) { x = 1, y = 0; return a; }\n\tLL g = ex_gcd(b, a % b, x, y);\n\tLL tmp = x;\n\tx = y, y = tmp - a / b * y;\n\treturn g;\n}\n\ninline LL Mult (LL a, LL b, LL Mod)\n{\n\ta = (a % Mod + Mod) % Mod;\n\tb = (b % Mod + Mod) % Mod;\n\tLL ans = 0;\n\twhile (b)\n\t{\n\t\tif (b & 1) ans = (ans + a) % Mod;\n\t\ta = (a + a) % Mod;\n\t\tb >>= 1;\n\t}\n\treturn ans;\n}\n\ninline void Solve ()\n{\n\tfor (int i = 2; i <= N; ++i)\n\t{\n\t\tLL x, y;\n\t\tLL a = A[i], b = A[1], c = B[1] - B[i], g = __gcd(a, b);\n\t\tif (c % g) return ;\n\t\ta /= g, b /= g, c /= g;\n\t\tex_gcd (a, b, x, y);\n\t\tx = ((Mult(x, c, b)) % b + b) % b;\n\t\tA[1] = A[i] / __gcd(A[1], A[i]) * A[1];\n\t\tB[1] = (B[i] + A[i] * x) % A[1];\n\t}\n\tcout<<B[1]<<endl;\n}\n\ninline void Input ()\n{\n\tN = read();\n\tfor (int i = 1; i <= N; ++i) A[i] = read(), B[i] = read();\n}\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"a.in\", \"r\", stdin);\n\tfreopen(\"a.out\", \"w\", stdout);\n#endif\n\tInput();\n\tSolve();\n\treturn 0;\n}\n\n```\n\n","categories":["Algorithm"],"tags":["数学","数论","ex_gcd"]},{"title":"NOIp专题个人分析及考前总结","url":"/2018/11/04/NOIp%E8%80%83%E9%A2%98%E4%B8%AA%E4%BA%BA%E5%88%86%E6%9E%90%E5%8F%8A%E8%80%83%E5%89%8D%E6%80%BB%E7%BB%93/","content":"\nNOIp2018考前的一些总结和骚话,不用管它...\n\n<!--more-->\n\n## NOIp一些专题\n\n### 模拟/搜索\n\n把重要的信息在题目中标注或在草稿纸上写下来.\n\n还没想清楚的时候就**一定不要**开始写代码,最后如果花的时间过长又没调出来要及时调整好心态.该放弃的时候就写好暴力放弃吧\n\n### Dp \n\n>  **状压** 字符串 期望概率 背包 **记搜** topsort 区间Dp??? 数位Dp??? 斜率优化??? 数据结构优化???\n\nDp一直以来是我比较弱的部分,但似乎近几年的题并没有出很难的Dp题.(flag)考试的时候如果一些题目完全没有头绪就可以往Dp方面想.\n\n大胆设状态,一开始可以多设几维状态,然后不断优化.\n\n对于一些比较难的Dp,状态转移方程要在草稿纸上写好,**一定要考虑清楚Dp的边界!!!**\n\n状压Dp拿部分分很重要\n\n### 树上问题 \n\n>  二分答案 **倍增** LCA **差分** 线段树合并\n\n近几年的树上问题基本都放在了T3的位置,不过幸好都做的差不多了,发现考来考去也就那么几种考法.去年没考树上问题,奶一口今年会考\n\n遇到树上问题如果实在想不出来,可以多~~猜猜~~找找性质,考虑贪心/二分答案.\n\n如果想到大概的做法,但是没想清楚怎么维护的话,可以考虑差分/线段树合并等技巧\n\n### 数学 \n\n> **找规律** 解一元二次方程 组合数 **扩欧** 质数 线性筛??? 高斯消元??? 矩阵快速幂???\n\n数学实在是弱啊,希望千万不要考去年Day1T1那种结论题了.\n\n以前考过的数学方面的题并不是太难,实在不会就找规律猜结论吧...\n\n### 数据结构 \n\n>  并查集 堆 树状数组 线段树 (平衡树) 分块???\n\nNOIp范围内的数据结构也就那些比较基础的东西,而且一般来说数据结构题的部分分都比较多,比较好拿.如果不能够A掉的话就一定要把部分分拿满\n\n码代码的时候一定要静下心来,不要求快,稳一点,否则查错会很痛苦,而且很容易造成心态爆炸\n\n> **注意:线段树中查询千万不要Chkmin,Chkmax!!!!**\n\n### 图论 \n\n>  最短路 生成树 倍增 **tarjan** 缩点 dfs bfs\n\n图论好像没怎么考过,考过的都比较基础.\n\n考前把最短路,最小生成树,tarjan都复习好,奶一口今年会考tarjan\n\n### 其他 \n\n> 贪心 **二分** 高精度 差分/前缀和 乱搞??? 三分??? bitset??? meet in middle???\n\n这些就是一些常用~~骗分~~优化技巧吧\n\n---\n\n### 字符串??? \n\n> Hash Kmp AC自动机\n\n字符串从来没考过,今年会考吗?\n\n猜测要考的话也应该能用Hash做(毕竟第一次考)\n\n### 网络流??? \n\n>  二分图匹配 最大流 费用流\n\n这个东西也没考过,不过二分图匹配考的可能性比较大.\n\n把Dinic板子准备好,费用流不大可能考吧....\n\n\n\n## 考试注意事项\n\n### 考前\n\n目标: 保400, 争取450+,~~反正做梦都上不了500的~~.\n\n> 虽然说目标定的这么多,但真正考试的时候还是先把暴力写满,万一题目太难淦不出来又没写暴力就真完蛋\n\n考前再看一遍[Debug注意事项](https://hk-cnyali.com/Debug/),一定不能犯低级错误.\n\n### 考试\n\n进考场马上做的几件事情:\n\n* `xmodmap -e 'clear Lock' -e 'keycode 0x42 = Escape'`\n\n* 调整控制台首选项:半透明、字体及大小(`Ubuntu Mono 16`)(暂定)\n\n* 配vimrc:\n\n  ![11-6-1](/images/11-6-1.png)\n\n```\nautocmd BufNewFile *.cpp 0r ~/template.cpp\nset fdm=indent\nset autochdir\nset autoread\nset autoindent\nset smartindent\nset cindent\n\nset ts=4\nset sts=4\nset sw=4\n\nset nocompatible\nset nobackup\nset nowritebackup\nset noswapfile\n\nset mouse=a\nset backspace=eol,indent,start\nsyntax on\nset number\ncolor slate\n\nmap <C-h> 7h\nmap <C-j> 7j\nmap <C-k> 7k\nmap <C-l> 7l\nmap <C-a> ggvG$\n\nmap <F9> :call Run()<CR>\nmap <C-F9> :call Run_O2()<CR>\nmap <F5> :call Debug()<CR>\nmap <C-F5> :call Debug_O2()<CR>\nmap <F12> :call Fp()<CR>\n\nfunc! Run()\n​\texec \"wall\"\n​\texec \"!g++ % -o %<\"\n​\texec \"!time ./%<\"\nendfunc\n\nfunc! Run_O2()\n​\texec \"wall\"\n​\texec \"!g++ % -o %< -O2\"\n​\texec \"!time ./%<\"\nendfunc\n\nfunc! Debug()\n​\texec \"wall\"\n​\texec \"!g++ % -o %< -Wall -Wextra -Wshadow -fsanitize=address -ftrapv\"\n​\texec \"!time ./%<\"\nendfunc\n\nfunc! Debug_O2()\n​\texec \"wall\"\n​\texec \"!g++ % -o %< -O2 -Wall -Wextra -Wshadow -fsanitize=address -ftrapv\"\n​\texec \"!time ./%<\"\nendfunc\n\nfunc! Fp()\n​\texec \"40vsp %<.out\"\n​\texec \"new %<.in\"\nendfunc\n```\n\n\n* 写template缺省源:\n\n  ```cpp\n  #include <bits/stdc++.h>\n  \n  #define x first\n  #define y second\n  #define y1 Y1\n  #define y2 Y2\n  #define mp make_pair\n  #define pb push_back\n  \n  using namespace std;\n  \n  typedef long long LL;\n  typedef pair<int, int> pii;\n  \n  template <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\n  template <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\n  \n  inline void proc_status()\n  {\n  \tifstream t (\"/proc/self/status\");\n  \tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) <<endl;\n  }\n  \n  inline int read ()\n  {\n  \tint sum = 0, fl = 1; char ch = getchar();\n  \tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n  \tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n  \treturn sum * fl;\n  }\n  \n  inline void Solve ()\n  {\n  }\n  \n  inline void Input ()\n  {\n  }\n  \n  int main()\n  {\n  \tfreopen(\".in\", \"r\", stdin);\n  \tfreopen(\".out\", \"w\", stdout);\n  \tInput();\n  \tSolve();\n  \treturn 0;\n  }\n  \n  ```\n\n* 写好每道题的gen,check,静下心等待发题\n\n拿到题目不要慌,一般来说NOIp题面都很长,静下心来读题,在题面里标注重点.\n\n花30min把三道题都看完,大概口胡一下简单题/难题部分分的做法,按难度顺序开题.\n\n想题/码代码的时候尽量不要收到其他人的影响,专注于自己的做题,不要去管其他人. 码代码的时候冷静一点,求稳而非求快.**不要图快而定义非常多暂时性的,无实际意义的变量名(如tmp tmpp tmppp),这样会导致调试浪费大量时间**\n\n不管有没有发大样例,暴力能不能写,都要自己造gen,测极限数据.(**自己多造一点强数据,想办法卡自己的程序)**\n\n用 `-fsanitize=undefined/address` 看看有没有爆 `int` 以及数组,看 `/proc/self/status` 有没有炸空间.\n\n**一定不能在一道题上花太多时间,哪怕是会做但是没调出来也要及时放弃,少点分总比爆零好!!!**\n\n### 考后\n\nDay1不管考的怎么样,都不要影响到Day2的心态,毕竟有yyc去年的神奇翻盘经历摆在那里(~~可是我并没有那么强~~)\n\n\n\n## 11.21 Update\n\n发现西除了树上问题+二分答案奶中了之外,其他都没奶中啊,不过幸好考前搞了下树上问题,不然就凉了\n\n而且居然一道傻逼Dp题没做出来\n\n似乎这次考试花在检查+造数据+拍的时间上太多了,结果还有很多有可能拿到的分没有拿到.但是正因为如此,所有题目加起来才挂5分(数据实在是太水了...)\n\n其他的问题放游记里写吧","categories":["Summary"],"tags":["Summary","NOIp"]},{"title":"「NOIp2012」疫情控制 - 二分答案 + 倍增 + 贪心","url":"/2018/11/01/%E3%80%8CNOIp2012%E3%80%8D%E7%96%AB%E6%83%85%E6%8E%A7%E5%88%B6-%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88-%E5%80%8D%E5%A2%9E-%E8%B4%AA%E5%BF%83/","content":"\n给出一棵$n$个节点的带权树,有$m$个军队在某些结点上,使这个结点的子树都被覆盖.可以移动军队到某个结点(**不能为根节点**),要求让所有叶子节点都被覆盖.最小化移动军队用时的最大值.\n\n$n,m\\le 50000$\n\n<!--more-->\n\n### Links\n\n[Luogu P1084](https://www.luogu.org/problemnew/show/P1084)\n\n### Solution\n\n很显然考虑二分答案\n\n设当前答案为$ans$,考虑如何$check$\n\n可以发现,每个军队一定都会贪心地尽量往上提.因为越往上覆盖范围越广,且包含下面的范围.\n\n那么如果某个军队到根节点之后还能继续走,那么就有可能走到根节点的其他某个**儿子**上(再向下走肯定不优)\n\n处理出两个数组:$Rest[]$存走到根节点后还能继续走的那一部分的长度,$Left[]$存目前还不能被覆盖的**根节点的儿子节点**到根的距离\n\n此时,我们就是需要判断用$Rest[]$是否能够覆盖$Left[]$\n\n排个序贪心选即可\n\n> 注意: 具体实现上有点麻烦.对于某一个在Rest中的点,它不一定是覆盖根节点当前的这个儿子(即最后它所处的位置不一定在现在到根的那条路径上),因为它可能可以覆盖其他儿子使得策略更优\n\n这道题乍一看好像挺简单,结果调了我一天,最后发现是最后一步贪心有问题.......\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\n\ninline void proc_status()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) <<endl;\n}\n\ninline int read ()\n{\n\tint sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\nconst int Maxn = 50000 + 100;\n\nint N, M;\nint e, Begin[Maxn], To[Maxn << 1], Next[Maxn << 1], W[Maxn << 1];\nint A[Maxn], r_sum;\nint dep[Maxn], anc[22][Maxn];\n\ninline void add_edge (int x, int y, int z) { To[++e] = y; Next[e] = Begin[x]; Begin[x] = e; W[e] = z; }\n\ninline void dfs_pre (int x, int f)\n{\n\tfor (int i = 1; i <= 20; ++i) anc[i][x] = anc[i - 1][anc[i - 1][x]];\n\tfor (int i = Begin[x]; i; i = Next[i])\n\t{\n\t\tint y = To[i];\n\t\tif (y == f) continue;\n\t\tanc[0][y] = x;\n\t\tdep[y] = dep[x] + W[i];\n\t\tdfs_pre (y, x);\n\t}\n}\n\nvector <pii> Rest, Left;\n\nint Vis[Maxn];\n\ninline void dfs (int x, int f)\n{\n\tif (Vis[x]) return ;\n\tint tmp = 1, fl = 0;\n\tfor (int i = Begin[x]; i; i = Next[i])\n\t{\n\t\tint y = To[i];\n\t\tif (y == f) continue;\n\t\tfl = 1;\n\t\tdfs(y, x);\n\t\ttmp &= Vis[y];\n\t}\n\tif (fl) Vis[x] = tmp;\n}\n\ninline int Check (int now_ans)\n{\n\tRest.clear(), Left.clear();\n\tfor (int i = 1; i <= N; ++i) Vis[i] = 0;\n\tfor (int i = 1; i <= M; ++i)\n\t{\n\t\tint tmp = A[i];\n\t\tif (now_ans < dep[tmp])\n\t\t{\n\t\t\tint x = tmp, now = now_ans;\n\t\t\tfor (int j = 20; j >= 0; --j)\n\t\t\t{\n\t\t\t\tint fa = anc[j][x];\n\t\t\t\tif (fa && dep[x] - dep[fa] <= now)\n\t\t\t\t{\n\t\t\t\t\tnow -= dep[x] - dep[fa];\n\t\t\t\t\tx = fa;\n\t\t\t\t}\n\t\t\t}\n\t\t\tVis[x] = 1;\n\t\t}\n\t}\n\tdfs(1, 0);\n\tfor (int i = 1; i <= M; ++i)\n\t{\n\t\tint tmp = A[i];\n\t\tif (now_ans >= dep[tmp])\n\t\t{\n\t\t\tint x = tmp;\n\t\t\tfor (int j = 20; j >= 0; --j) if (anc[j][x] > 1) x = anc[j][x];\n\t\t\tRest.pb(mp(now_ans - dep[tmp], x));\n\t\t}\n\t}\n\tfor (int i = Begin[1]; i; i = Next[i])\n\t{\n\t\tint x = To[i];\n\t\tif (!Vis[x]) Left.pb(mp(W[i], x));\n\t}\n\tsort(Rest.begin(), Rest.end());\n\tsort(Left.begin(), Left.end());\n\tint j = 0;\n\tif (!Left.size()) return 1;\n\tfor (int i = 0; i < Rest.size(); ++i)\n\t{\n\t\tif (!Vis[Rest[i].y]) Vis[Rest[i].y] = 1;\n\t\telse if (Rest[i].x >= Left[j].x) Vis[Left[j].y] = 1;\n\t\twhile (j < Left.size() && Vis[Left[j].y]) ++j;\n\t}\n\treturn j >= Left.size();\n}\n\ninline void Solve ()\n{\n\tdfs_pre(1, 0);\n\tint l = 0, r = r_sum, ans = -1;\n\twhile (l <= r)\n\t{\n\t\tint mid = l + r >> 1;\n\t\tif (Check(mid)) r = mid - 1, ans = mid;\n\t\telse l = mid + 1;\n\t}\n\tcout<<ans<<endl;\n}\n\ninline void Input ()\n{\n\tN = read();\n\tfor (int i = 1; i < N; ++i)\n\t{\n\t\tint x = read(), y = read(), z = read();\n\t\tadd_edge (x, y, z);\n\t\tadd_edge (y, x, z);\n\t\tr_sum += z;\n\t}\n\tM = read();\n\tfor (int i = 1; i <= M; ++i) A[i] = read();\n}\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"blockade.in\", \"r\", stdin);\n\tfreopen(\"blockade.out\", \"w\", stdout);\n#endif\n\tInput();\n\tSolve();\n\treturn 0;\n}\n\n```\n\n","categories":["Problem"],"tags":["二分答案","贪心","倍增","二分","NOIp"]},{"title":"「NOIp2016」天天爱跑步 - 树上差分","url":"/2018/10/31/%E3%80%8CNOIp2016%E3%80%8D%E5%A4%A9%E5%A4%A9%E7%88%B1%E8%B7%91%E6%AD%A5-%E6%A0%91%E4%B8%8A%E5%B7%AE%E5%88%86/","content":"\n一棵 $n$ 个节点的树以及 $m $条有向路径.每个点 $i$ 都有一个权值 $w_i$.如果某条路径包含了 $i$ 号节点,并且 $i$ 号节点是该路径上的第 $w_i$ 个节点的话就会对$i$的答案产生贡献.\n\n求每个点的答案\n\n$n,m\\le 300000$\n\n<!--more-->\n\n### Solution\n\n静下心来好好想一想,其实这是一道并没有那么难的题...\n\n考虑把一条路径拆成两部分,一段向上一段向下\n\n对于点$x$来说,一条从$s$到$t$,长度为$len_i$的路径$i$要被算贡献需要满足:\n\n1. 若$x$处于向上的一段中,则$dep_x + w_x = dep_s$\n2. 若$x$处于向下的一段中,则$w_x-dep_x = len_i-dep_t$\n\n这两个东西都很好用一个桶维护,通过树上差分求出.具体实现在$s/t$的位置计算贡献,$lca$的位置消掉贡献即可\n\n表示看网上各种题解都没看懂...\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\ntemplate <typename T> inline int Chkmax (T &a, T b) {return a < b ? a = b, 1 : 0;}\ntemplate <typename T> inline int Chkmin (T &a, T b) {return a > b ? a = b, 1 : 0;}\n\ninline int read ()\n{\n\tint sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\nconst int Maxn = 3e5 + 100;\n\nint N, M;\nint e, Begin[Maxn], To[Maxn << 1], Next[Maxn << 1], W[Maxn];\npii E[Maxn];\n\ninline void add_edge (int x, int y) { To[++e] = y; Next[e] = Begin[x]; Begin[x] = e; }\n\nint dep[Maxn], anc[22][Maxn];\n\ninline void dfs_pre (int x)\n{\n\tdep[x] = dep[anc[0][x]] + 1;\n\tfor (int i = 1; i <= 20; ++i) anc[i][x] = anc[i - 1][anc[i - 1][x]];\n\tfor (int i = Begin[x]; i; i = Next[i])\n\t{\n\t\tint y = To[i];\n\t\tif (y == anc[0][x]) continue;\n\t\tanc[0][y] = x;\n\t\tdfs_pre (y);\n\t}\n}\n\ninline int get_lca (int x, int y)\n{\n\tif (dep[x] < dep[y]) swap(x, y);\n\tfor (int i = 20; i >= 0; --i) if (dep[anc[i][x]] >= dep[y]) x = anc[i][x];\n\tif (x == y) return x;\n\tfor (int i = 20; i >= 0; --i) if (anc[i][x] != anc[i][y]) x = anc[i][x], y = anc[i][y];\n\treturn anc[0][x];\n}\n\nvector <int> vec1[Maxn], vec2[Maxn];\nint buc[Maxn], Ans[Maxn];\n\ninline void dfs_up (int x)\n{\n\tint sum = buc[dep[x] + W[x]];\n\tfor (int i = 0; i < vec1[x].size(); ++i) ++buc[vec1[x][i]];\n\tfor (int i = Begin[x]; i; i = Next[i])\n\t{\n\t\tint y = To[i];\n\t\tif (y == anc[0][x]) continue;\n\t\tdfs_up (y);\n\t}\n\tAns[x] += buc[dep[x] + W[x]] - sum;\n\tfor (int i = 0; i < vec2[x].size(); ++i) --buc[vec2[x][i]];\n}\n\ninline int dis (int x, int y, int k) { return dep[x] + dep[y] - 2 * dep[k]; }\n\ninline void dfs_down (int x)\n{\n\tint sum = buc[W[x] - dep[x]];\n\tfor (int i = 0; i < vec1[x].size(); ++i) ++buc[vec1[x][i]];\n\tfor (int i = Begin[x]; i; i = Next[i])\n\t{\n\t\tint y = To[i];\n\t\tif (y == anc[0][x]) continue;\n\t\tdfs_down (y);\n\t}\n\tfor (int i = 0; i < vec2[x].size(); ++i) --buc[vec2[x][i]];\n\tAns[x] += buc[W[x] - dep[x]] - sum;\n}\n\ninline void Solve ()\n{\n\tdfs_pre (1);\n\tfor (int i = 1; i <= M; ++i)\n\t{\n\t\tint k = get_lca (E[i].x, E[i].y);\n\t\tvec1[E[i].x].pb(dep[E[i].x]);\n\t\tvec2[k].pb(dep[E[i].x]);\n\t}\n\tdfs_up (1);\n\tmemset(buc, 0, sizeof buc);\n\tfor (int i = 1; i <= N; ++i) vec1[i].clear(), vec2[i].clear();\n\tfor (int i = 1; i <= M; ++i)\n\t{\n\t\tint k = get_lca (E[i].x, E[i].y), sum = dis(E[i].x, E[i].y, k) - dep[E[i].y];\n\t\tvec1[E[i].y].pb(sum);\n\t\tvec2[k].pb(sum);\n\t}\n\tdfs_down (1);\n\tfor (int i = 1; i <= N; ++i) printf(\"%d \", Ans[i]);\n\tputs(\"\");\n}\n\ninline void Input ()\n{\n\tN = read(), M = read();\n\tfor (int i = 1; i < N; ++i)\n\t{\n\t\tint x = read(), y = read();\n\t\tadd_edge (x, y);\n\t\tadd_edge (y, x);\n\t}\n\tfor (int i = 1; i <= N; ++i) W[i] = read();\n\tfor (int i = 1; i <= M; ++i) E[i].x = read(), E[i].y = read();\n}\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"running.in\", \"r\", stdin);\n\tfreopen(\"running.out\", \"w\", stdout);\n#endif\n\tInput();\n\tSolve();\n\treturn 0;\n}\n\n```\n\n","categories":["Problem"],"tags":["差分","NOIp","树上差分"]},{"title":"「NOIp2013」货车运输 - 最小生成树 + 倍增","url":"/2018/10/31/%E3%80%8CNOIp2013%E3%80%8D%E8%B4%A7%E8%BD%A6%E8%BF%90%E8%BE%93-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91-%E5%80%8D%E5%A2%9E/","content":"\n$n$个点$m$条边的无向带权图,$q$次询问$(x,y)$,每次询问求$x$到$y$所有的路径中最小权值的最大值\n\n$n\\le 10000, m \\le 50000, q\\le 30000$\n\n<!--more-->\n\n### Links\n\n[Luogu P1967](https://www.luogu.org/problemnew/show/P1967#sub)\n\n### Solution\n\n这题好裸啊...\n\n显然答案一定在最大生成树上\n\n倍增/树剖维护任意两点路径最小值即可\n\n要注意算答案的时候的各种奇奇怪怪的边界情况,每次写这种树上倍增维护最大值的都会写挂几次...\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) <<endl;\n}\n\ntemplate <typename T> inline int Chkmin (T &a, T b) {return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmax (T &a, T b) {return a < b ? a = b, 1 : 0; }\n\ninline int read ()\n{\n\tint sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar())\tsum = (sum << 3) + (sum << 1) + ch - '0'; \n\treturn sum * fl;\n}\n\nconst int Maxn = 10000 + 10, Maxm = 50000, inf = 0x3f3f3f3f;\n\nint N, M, Q;\n\nstruct edge\n{\n\tint x, y, z;\n}E[Maxm];\n\ninline int cmp (edge a, edge b) { return a.z > b.z; }\n\nnamespace DSU\n{\n\tint fa[Maxn];\n\tinline void init () { for (int i = 1; i <= N; ++i) fa[i] = i; }\n\tinline int find (int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); }\n\tinline void link (int x, int y) { fa[find(y)] = find(x); }\n}\n\nint e, Begin[Maxn], To[Maxm << 1], Next[Maxm << 1], W[Maxm << 1];\n\ninline void add_edge (int x, int y, int z) { To[++e] = y; Next[e] = Begin[x]; Begin[x] = e; W[e] = z; }\n\nint anc[22][Maxn], dep[Maxn], Min[22][Maxn];\n\ninline void dfs (int x)\n{\n\tdep[x] = dep[anc[0][x]] + 1;\n\tfor (int i = 1; i <= 20; ++i)\n\t{\n\t\tanc[i][x] = anc[i - 1][anc[i - 1][x]];\n\t\tMin[i][x] = min(Min[i - 1][x], Min[i - 1][anc[i - 1][x]]);\n\t}\n\tfor (int i = Begin[x]; i; i = Next[i])\n\t{\n\t\tint y = To[i];\n\t\tif (y == anc[0][x]) continue ;\n\t\tMin[0][y] = W[i];\n\t\tanc[0][y] = x;\n\t\tdfs(y);\n\t}\n}\n\ninline int Get_ans (int x, int y)\n{\n\tint ans = inf;\n\tif (dep[x] < dep[y]) swap(x, y);\n\tfor (int i = 20; i >= 0; --i)\n\t\tif (dep[anc[i][x]] >= dep[y]) Chkmin(ans, Min[i][x]), x = anc[i][x];\n\tif (x == y) return ans;\n\tChkmin (ans, min(Min[0][x], Min[0][y]));\n\tfor (int i = 20; i >= 0; --i)\n\t\tif (anc[i][x] != anc[i][y]) Chkmin(ans, Min[i][x]), Chkmin(ans, Min[i][y]), x = anc[i][x], y = anc[i][y];\n\tChkmin (ans, min(Min[0][x], Min[0][y]));\n\treturn ans;\n}\n\ninline void Solve ()\n{\n\tsort (E + 1, E + M + 1, cmp);\n\tDSU :: init();\n\n\tfor (int i = 1; i <= M; ++i)\n\t{\n\t\tint x = E[i].x, y = E[i].y, z = E[i].z;\n\t\tif (DSU :: find(x) == DSU :: find(y)) continue;\n\t\tadd_edge (x, y, z);\n\t\tadd_edge (y, x, z);\n\t\tDSU :: link (x, y);\n\t}\n\t\n\tfor (int s = 1; s <= N; ++s)\n\t\tif (!dep[s])\n\t\t{\n\t\t\tfor (int i = 0; i <= 20; ++i) Min[i][s] = inf;\n\t\t\tdfs(s);\n\t\t}\n\n\tQ = read();\n\twhile (Q--)\n\t{\n\t\tint x = read(), y = read();\n\t\tif (DSU :: find(x) != DSU :: find(y)) printf(\"-1\\n\");\n\t\telse printf(\"%d\\n\", Get_ans(x, y));\n\t}\n}\n\ninline void Input ()\n{\n\tN = read(), M = read();\n\tfor (int i = 1; i <= M; ++i) E[i].x = read(), E[i].y = read(), E[i].z = read();\n}\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"truck.in\", \"r\", stdin);\n\tfreopen(\"truck.out\", \"w\", stdout);\n#endif\n\tInput();\n\tSolve();\n\treturn 0;\n}\n```\n\n","categories":["Problem"],"tags":["倍增","最小生成树"]},{"title":"「NOIp2015」运输计划 - 二分答案 + 树上差分","url":"/2018/10/31/%E3%80%8CNOIp2015%E3%80%8D%E8%BF%90%E8%BE%93%E8%AE%A1%E5%88%92-%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88-%E6%A0%91%E4%B8%8A%E5%B7%AE%E5%88%86/","content":"\n给出一棵$n$个点有边权的树和树上$m$条路径，清零一条边的边权使得$m$条路径的最大值最小\n\n$n,m\\le 300000$\n\n<!--more-->\n\n### Links\n\n[Luogu P2680](https://www.luogu.org/problemnew/show/P2680)\n\n### Solution\n\n显然答案具有单调性,考虑二分答案\n\n设当前二分的答案为$ans$,考虑如何$check$\n\n可以发现我们需要判断是否存在一条长度至少为$length_{max} - ans$的边,使得它被所有$length > ans$的边经过\n\n这个东西直接树上差分即可\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ninline int read ()\n{\n\tint sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\nconst int Maxn = 1000000 + 100;\n\nint N, M, e, Begin[Maxn], To[Maxn << 1], Next[Maxn << 1], W[Maxn << 1];\nint dep[Maxn], Dep[Maxn], anc[22][Maxn], Dis[Maxn];\npii Q[Maxn];\n\ninline void add_edge (int x, int y, int z)\n{\n\tTo[++e] = y;\n\tNext[e] = Begin[x];\n\tBegin[x] = e;\n\tW[e] = z;\n}\n\ninline void dfs_pre (int x)\n{\n\tdep[x] = dep[anc[0][x]] + 1;\n\tfor (int i = 1; i <= 20; ++i) anc[i][x] = anc[i - 1][anc[i - 1][x]];\n\tfor (int i = Begin[x]; i; i = Next[i])\n\t{\n\t\tint y = To[i];\n\t\tif (y == anc[0][x]) continue; \n\t\tanc[0][y] = x;\n\t\tDep[y] = Dep[x] + W[i];\n\t\tdfs_pre(y);\n\t}\n}\n\ninline int get_lca (int x, int y)\n{\n\tif (dep[x] < dep[y]) swap(x, y);\n\tfor (int i = 20; i >= 0; --i) if (dep[anc[i][x]] >= dep[y]) x = anc[i][x];\n\tif (x == y) return x;\n\tfor (int i = 20; i >= 0; --i) if (anc[i][x] != anc[i][y]) x = anc[i][x], y = anc[i][y];\n\treturn anc[0][x];\n}\n\ninline int get_dis (int x, int y) { return Dep[x] + Dep[y] - 2 * Dep[get_lca(x, y)]; }\n\nint delta[Maxn], now_sum, flag, cnt;\n\ninline void dfs (int x, int f)\n{\n\tif (flag) return ;\n\tfor (int i = Begin[x]; i; i = Next[i])\n\t{\n\t\tint y = To[i];\n\t\tif (y == f) continue;\n\t\tdfs(y, x);\n\t\tif (delta[y] == cnt && W[i] >= now_sum)\n\t\t{\n\t\t\tflag = 1;\n\t\t\treturn ;\n\t\t}\n\t\tdelta[x] += delta[y];\n\t}\n}\n\ninline void Mark (int x, int y)\n{\n\t++delta[x];\n\t++delta[y];\n\tdelta[get_lca(x, y)] -= 2;\n}\n\ninline int Check (int now_ans)\n{\n\tflag = 0;\n\tmemset(delta, 0, sizeof delta);\n\tint Max = 0;\n\tcnt = 0;\n\tfor (int i = 1; i <= M; ++i) if (Dis[i] > now_ans) ++cnt,Mark(Q[i].x, Q[i].y), Chkmax(Max, Dis[i]);\n\tnow_sum = Max - now_ans;\n\tdfs(1, 0);\n\treturn flag;\n}\n\ninline void Solve ()\n{\n\tdfs_pre(1);\n\tfor (int i = 1; i <= M; ++i) Q[i].x = read(), Q[i].y = read(), Dis[i] = get_dis(Q[i].x, Q[i].y);\n\tint l = 0, r = 3e8, ans = 0;\n\twhile (l <= r)\n\t{\n\t\tint mid = l + r >> 1;\n\t\tif (Check(mid)) r = mid - 1, ans = mid;\n\t\telse l = mid + 1;\n\t}\n\tcout<<ans<<endl;\n}\n\n\ninline void Input ()\n{\n\tN = read(), M = read();\n\tfor (int i = 1; i < N; ++i)\n\t{\n\t\tint x = read(), y = read(), z = read();\n\t\tadd_edge (x, y, z);\n\t\tadd_edge (y, x, z);\n\t}\n}\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"transport.in\", \"r\", stdin);\n\tfreopen(\"transport.out\", \"w\", stdout);\n#endif\n\tInput();\n\tSolve();\n\treturn 0;\n}\n\n```\n\n","categories":["Problem"],"tags":["二分答案","差分","二分","NOIp","树上差分"]},{"title":"「NOIp模拟赛10-27」c - 树状数组","url":"/2018/10/29/%E3%80%8CNOIp%E6%A8%A1%E6%8B%9F%E8%B5%9B10-27%E3%80%8Dc-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/","content":"","categories":["Problem"],"tags":["数据结构","树状数组"]},{"title":"「NOIp2018模拟赛10-25N」graph - 启发式合并 + 最小生成树 + pb_ds","url":"/2018/10/29/%E3%80%8CNOIp2018%E6%A8%A1%E6%8B%9F%E8%B5%9B10-25N%E3%80%8Dgraph-%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91-pb-ds/","content":"","categories":["Problem"],"tags":["启发式合并","最小生成树","pb_ds"]},{"title":"10-29模拟赛 Summary","url":"/2018/10/29/10-29%E6%A8%A1%E6%8B%9F%E8%B5%9B-Summary/","content":"","categories":["Summary"],"tags":["Summary","动态规划","贪心","差分"]},{"title":"「Ynoi2018」五彩斑斓的世界 - 分块","url":"/2018/10/26/%E3%80%8CYnoi2018%E3%80%8D%E4%BA%94%E5%BD%A9%E6%96%91%E6%96%93%E7%9A%84%E4%B8%96%E7%95%8C-%E5%88%86%E5%9D%97/","content":"\n一个长为$n$的序列$a$,有$m$次操作\n\n1. 把区间$[l,r]$中大于$x$的数减去$x$\n\n2. 查询区间$[l,r]$中$x$的出现次数\n\n所有输入的数$\\in[1,100000]$\n\n<!--more-->\n\n### Links\n\n[Luogu P4117](https://www.luogu.org/problemnew/show/P4117)\n\n[BZOJ5143](https://www.lydsy.com/JudgeOnline/problem.php?id=5143))\n\n### Something\n\n实在是一道分块~~毒瘤~~神题啊\n\n调了一晚上+一上午最后发现是一个数组开小了,但是又没RE...\n\n而且这道题还卡空间...\n\n### Solution\n\n首先发现各种数据结构都不好维护这个东西\n\n那么考虑分块\n\n考虑修改操作的本质就是让区间中的数不断减小至0,\n\n感性考虑一下如果在每个块里暴力把大于$x$的数都减$x$,只要当$x$比较小,大于$x$的数比较多的话复杂度就会爆炸\n\n实际上,对于大于$x$的数比较多的情况,可以把整块全减去$x$,再把小于等于$x$的部分加上一个$x$,这个操作是等价的\n\n那么大概的思路就有了,具体实现可以记$Pos[x][i]$表示在第$x$个块中权值为$i$的点第一次出现的位置,那么可以用并查集不断向前合并,合并过程中记录$Size[i]$表示当前块内$a_i$出现次数. 还需要记$Max[x]$块内最大值和$Tag[x]$标记\n\n修改时对于第$i$个块分类讨论:\n\n1. 若$Max[i] \\le x$: 不用考虑\n2. 若$x < Max[i] \\le 2 * x$: 从$x+1$到$Max[i]$枚举,将每个存在的数$y$用并查集连到$y-x$上. \n3. 若$Max[i] > 2 * x$: 将整个块减$x$，再将小于等于$x$的部分加$x$.\n\n理性分析,2,3步都通过花费$O(x)$的时间使块内极差减小了$x$,因此总复杂度有保证\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\n\ninline void proc_status()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) <<endl;\n}\n\ninline int read ()\n{\n\tint sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\nconst int Maxn = 100000 + 100, Block_Cnt = 333 + 26;\n\nint N, M, A[Maxn], Val[Maxn], Block_Size;\nshort Belong[Maxn];\nint L[Block_Cnt], R[Block_Cnt], block_cnt, Max[Block_Cnt], Tag[Block_Cnt], Size[Maxn];\nint fa[Maxn], Pos[Block_Cnt][Maxn];\n\ninline int find (int x) { return x == fa[x] ? x : fa[x] = find(fa[x]); }\n\ninline void Rebuild (int x)\n{\n\tint i;\n\tfor (i = L[x]; i <= R[x]; ++i) A[i] = Val[find(i)], Pos[x][A[i]] = 0;\n\tfor (i = L[x]; i <= R[x]; ++i) fa[i] = i, Size[i] = 1;\n\n\tfor (i = L[x]; i <= R[x]; ++i)\n\t{\n\t\tif (!Pos[x][A[i]]) Pos[x][A[i]] = i, Val[i] = A[i];\n\t\telse Size[Pos[x][A[i]]] += Size[i], fa[i] = Pos[x][A[i]];\n\t}\n\n\twhile (!Pos[x][Max[x]]) --Max[x];\n}\n\ninline void Init ()\n{\n\tint i;\n\tfor (i = 1; i <= N; ++i) Belong[i] = (i - 1) / Block_Size + 1, fa[i] = i, Chkmax(Max[Belong[i]], A[i]);\n\tblock_cnt = Belong[N];\n\tfor (i = 1; i <= block_cnt; ++i) L[i] = R[i - 1] + 1, R[i] = i * Block_Size;\n\tChkmin (R[block_cnt], N);\n\n\tfor (i = 1; i <= block_cnt; ++i) Rebuild(i);\n}\n\ninline int Query (int l, int r, int val)\n{\n\tint x = Belong[l], y = Belong[r], ans = 0, i, j;\n\tfor (i = l; i <= R[x] && i <= r; ++i) if (Val[find(i)] - Tag[x] == val) ++ans;\n\tif (x != y) for (i = L[y]; i <= r; ++i) if (Val[find(i)] - Tag[y] == val) ++ans;\n\n\tfor (i = x + 1; i < y; ++i)\n\t\tif (val + Tag[i] <= 100000)\n\t\t\tans += Size[Pos[i][val + Tag[i]]];\n\n\treturn ans;\n}\n\ninline void Update (int l, int r, int val)\n{\n\tint x = Belong[l], y = Belong[r], i, j;\n\tfor (i = L[x]; i <= R[x]; ++i) A[i] = Val[find(i)];\n\tfor (i = L[x]; i <= R[x]; ++i) Pos[x][A[i]] = 0;\n\tfor (i = l; i <= R[x] && i <= r; ++i) if (A[i] - Tag[x] > val) A[i] -= val;\n\tfor (i = L[x]; i <= R[x]; ++i) Val[i] = A[i], fa[i] = i;\n\tRebuild (x);\n\n\tif (x != y)\n\t{\n\t\tfor (i = L[y]; i <= R[y]; ++i) A[i] = Val[find(i)];\n\t\tfor (i = L[y]; i <= R[y]; ++i) Pos[y][A[i]] = 0;\n\t\tfor (i = L[y]; i <= r; ++i) if (A[i] - Tag[y] > val) A[i] -= val;\n\t\tfor (i = L[y]; i <= R[y]; ++i) Val[i] = A[i], fa[i] = i;\n\t\tRebuild (y);\n\t}\n\n\tfor (i = x + 1; i < y; ++i)\n\t{\n\t\tif (2 * val <= Max[i] - Tag[i])\n\t\t{\n\t\t\tfor (j = Tag[i] + 1; j <= Tag[i] + val; ++j)\n\t\t\t{\n\t\t\t\tif (!Pos[i][j]) continue;\n\t\t\t\tif (!Pos[i][j + val])\n\t\t\t\t\tPos[i][j + val] = Pos[i][j], Val[Pos[i][j]] = j + val, Pos[i][j] = 0;\n\t\t\t\telse\n\t\t\t\t\tSize[Pos[i][j + val]] += Size[Pos[i][j]], fa[Pos[i][j]] = Pos[i][j + val], Pos[i][j] = 0;\n\t\t\t}\n\t\t\tTag[i] += val;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (j = Tag[i] + val + 1; j <= Max[i]; ++j)\n\t\t\t{\n\t\t\t\tif (!Pos[i][j]) continue;\n\t\t\t\tif (!Pos[i][j - val])\n\t\t\t\t\tPos[i][j - val] = Pos[i][j], Val[Pos[i][j]] = j - val, Pos[i][j] = 0;\n\t\t\t\telse\n\t\t\t\t\tSize[Pos[i][j - val]] += Size[Pos[i][j]], fa[Pos[i][j]] = Pos[i][j - val], Pos[i][j] = 0;\n\t\t\t}\n\n\t\t\twhile (!Pos[i][Max[i]]) --Max[i];\n\t\t}\n\t}\n}\n\ninline void Solve ()\n{\n\tInit();\n\tint op, x, y, z;\n\twhile (M--)\n\t{\n\t\top = read(), x = read(), y = read(), z = read();\n\t\tif (op == 1) Update (x, y, z);\n\t\telse printf(\"%d\\n\", Query (x, y, z));\n\t}\n}\n\ninline void Input ()\n{\n\tN = read(), M = read();\n\tBlock_Size = sqrt(N);\n\tint i;\n\tfor (i = 1; i <= N; ++i) A[i] = Val[i] = read();\n}\n\nint main()\n{\n#ifdef hk_cnyali\n\tfreopen(\"A.in\", \"r\", stdin);\n\tfreopen(\"A.out\", \"w\", stdout);\n#endif\n\tInput();\n\tSolve();\n\treturn 0;\n}\n```\n\n","categories":["Problem"],"tags":["分块","数据结构","毒瘤"]},{"title":"「Luogu P3396」哈希冲突 - 根号平衡","url":"/2018/10/24/%E3%80%8CLuogu-P3396%E3%80%8D%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81-%E6%A0%B9%E5%8F%B7%E5%B9%B3%E8%A1%A1/","content":"\n给出一个长度为$n$正整数序列`value[]`,B君会把这些数据存进hash池.第`value[k]`会被存进`(k%p)`这个池.B君会给定许多个`p`和`x`,询问在模`p`时,`x`这个池内**数的总和**.\n\n另外,B君会随时更改`value[k]`.每次更改立即生效.\n\n$n,m\\le 150000,1\\le value[i]\\le 1000$($m$为询问+修改数)\n\n<!--more-->\n\n### Links\n\n[Luogu P3396](https://www.luogu.org/problemnew/show/P3396)\n\n### Solution\n\n把$p \\le \\sqrt n$的答案预处理出来,对于$p > \\sqrt n$的询问每次暴力查询即可\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\n\ninline void proc_status()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) <<endl;\n}\n\ninline int read ()\n{\n\tint sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\nconst int Maxn = 150000 + 100, Limit = 400 + 26;\n\nint N, M, A[Maxn], Ans[Limit + 26][Limit + 26];\n\ninline void Init ()\n{\n\tfor (int i = 1; i <= N; ++i) for (int j = 1; j <= Limit; ++j) Ans[j][i % j] += A[i];\n}\n\ninline int Bf_Query (int x, int y)\n{\n\tint ans = 0;\n\tfor (int i = y; i <= N; i += x) ans += A[i];\n\treturn ans;\n}\n\ninline void Update (int x, int y)\n{\n\tfor (int i = 1; i <= Limit; ++i)\n\t\tAns[i][x % i] += y - A[x];\n\tA[x] = y;\n}\n\ninline void Solve ()\n{\n\tInit();\n\twhile (M--)\n\t{\n\t\tchar Str[3];\n\t\tscanf(\"%s\", Str);\n\t\tint x = read(), y = read();\n\t\tif (Str[0] == 'A')\n\t\t{\n\t\t\tif (x <= Limit) printf(\"%d\\n\", Ans[x][y]);\n\t\t\telse printf(\"%d\\n\", Bf_Query(x, y));\n\t\t}\n\t\telse Update (x, y);\n\t}\n}\n\ninline void Input ()\n{\n\tN = read(), M = read();\n\tfor (int i = 1; i <= N; ++i) A[i] = read();\n}\n\nint main()\n{\n#ifdef hk_cnyali\n\tfreopen(\"A.in\", \"r\", stdin);\n\tfreopen(\"A.out\", \"w\", stdout);\n#endif\n\tInput();\n\tSolve();\n\treturn 0;\n}\n```\n\n","categories":["Problem"],"tags":["数据结构","根号平衡"]},{"title":"「BZOJ3343」教主的魔法 - 分块","url":"/2018/10/24/%E3%80%8CBZOJ3343%E3%80%8D%E6%95%99%E4%B8%BB%E7%9A%84%E9%AD%94%E6%B3%95-%E5%88%86%E5%9D%97/","content":"\n一个长度为$n$的数列$a_i$,有$q$次操作:\n\n* $M~l~r~w$: $[l,r]$内所有数加上$v$\n\n* $A~l~r~c$:询问$[l,r]$内大于等于$c$的数的数量\n\n$n\\le 1000000,q\\le 3000,1\\le w\\le 1000,1\\le c\\le 1,000,000,000$\n\n<!--more--> \n\n### Links\n\n[Luogu P2801](https://www.luogu.org/problemnew/show/P2801)\n\n[BZOJ3343](https://www.lydsy.com/JudgeOnline/problem.php?id=3343)\n\n### Solution\n\n第一道中规中矩的分块模板题\n\n每个块记个$Tag$标记即可\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\n\ninline void proc_status()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) <<endl;\n}\n\ninline int read ()\n{\n\tint sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\nconst int Maxn = 1000000 + 100, Block_Size = 1000 + 26, Block_Cnt = Maxn / Block_Size + 26;\n\nint N, Q, A[Maxn], B[Maxn], Tag[Block_Cnt];\nint Belong[Maxn], L[Block_Cnt], R[Block_Cnt], block_cnt;\n\ninline void Init ()\n{\n\tfor (int i = 1; i <= N; ++i) Belong[i] = (i - 1) / Block_Size + 1;\n\tblock_cnt = Belong[N];\n\tfor (int i = 1; i <= block_cnt; ++i) L[i] = (i - 1) * Block_Size + 1, R[i] = i * Block_Size;\n\tChkmin (R[block_cnt], N);\n\n\tfor (int i = 1; i <= N; ++i) B[i] = A[i];\n\tfor (int i = 1; i <= block_cnt; ++i) sort(B + L[i], B + R[i] + 1);\n}\n\ninline void Rebuild (int x)\n{\n\tfor (int i = L[x]; i <= R[x]; ++i) A[i] += Tag[x], B[i] = A[i];\n\tTag[x] = 0;\n\tsort(B + L[x], B + R[x] + 1);\n}\n\ninline int Query (int l, int r, int v)\n{\n\tint x = Belong[l], y = Belong[r], ans = 0;\n\tRebuild(x);\n\tfor (int i = l; i <= R[x] && i <= r; ++i) if (A[i] >= v) ++ans;\n\tif (x != y)\n\t{\n\t\tRebuild(y);\n\t\tfor (int i = L[y]; i <= r; ++i) if (A[i] >= v) ++ans;\n\t}\n\tfor (int i = x + 1; i < y; ++i) ans += R[i] - (lower_bound (B + L[i], B + R[i] + 1, v - Tag[i]) - B) + 1;\n\treturn ans;\n}\n\ninline void Update (int l, int r, int v)\n{\n\tint x = Belong[l], y = Belong[r];\n\tRebuild(x);\n\tfor (int i = l; i <= R[x] && i <= r; ++i) A[i] += v;\n\tRebuild(x);\n\tif (x != y)\n\t{\n\t\tRebuild(y);\n\t\tfor (int i = L[y]; i <= r; ++i) A[i] += v;\n\t\tRebuild(y);\n\t}\n\tfor (int i = x + 1; i < y; ++i) Tag[i] += v;\n}\n\ninline void Solve ()\n{\n\tInit();\n\twhile (Q--)\n\t{\n\t\tchar Str[3];\n\t\tscanf(\"%s\", Str);\n\t\tint l = read(), r = read(), v = read();\n\t\tif (Str[0] == 'M') Update (l, r, v);\n\t\telse printf(\"%d\\n\", Query (l, r, v));\n\t}\n}\n\ninline void Input ()\n{\n\tN = read(), Q = read();\n\tfor (int i = 1; i <= N; ++i) A[i] = read();\n}\n\nint main()\n{\n#ifdef hk_cnyali\n\tfreopen(\"A.in\", \"r\", stdin);\n\tfreopen(\"A.out\", \"w\", stdout);\n#endif\n\tInput();\n\tSolve();\n\treturn 0;\n}\n```\n\n","categories":["Problem"],"tags":["分块","数据结构"]},{"title":"「HNOI2010」弹飞绵羊 - 分块","url":"/2018/10/24/%E3%80%8CHNOI2010%E3%80%8D%E5%BC%B9%E9%A3%9E%E7%BB%B5%E7%BE%8A-%E5%88%86%E5%9D%97/","content":"\nLostmonkey在地上沿着一条直线摆上$n$个装置，每个装置设定初始弹力系数$k_i$。当绵羊达到第$i$个装置时，它会往后弹$k_i$步，达到第$i+k_i$个装置，若不存在第$i+k_i$个装置，则绵羊被弹飞。绵羊想知道当它从第$i$个装置起步时，被弹几次后会被弹飞。\n\n为了使得游戏更有趣，Lostmonkey可以修改某个弹力装置的弹力系数，任何时候弹力系数均为正整数。\n\n$n\\le 200000,m\\le 100000$\n\n<!--more-->\n\n### Links\n\n[Luogu P3203](https://www.luogu.org/problemnew/show/P3203)\n\n[BZOJ2002](https://www.lydsy.com/JudgeOnline/problem.php?id=2002)\n\n### Description\n\n### Solution\n\n并不会LCT,于是考虑分块\n\n对于每个点暴力处理出$Step[i]$表示跳到下一个块需要的次数和$Pos[i]$表示跳到下一个块的位置\n\n对于修改的点暴力重构块就行了\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\n\ninline void proc_status()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) <<endl;\n}\n\ninline int read ()\n{\n\tint sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\nconst int Maxn = 200000 + 100, Block_Size = 520, Block_Cnt = Maxn / Block_Size + 26;\n\nint N, M, A[Maxn], Step[Maxn], Pos[Maxn];\nint Belong[Maxn], block_cnt, L[Block_Cnt], R[Block_Cnt];\n\ninline void dfs (int x, int right)\n{\n/**/if (Step[x]) return ;\n\tint to = x + A[x];\n\tif (to > right) { Pos[x] = to; Step[x] = 1; return ;}\n\tdfs (to, right);\n\tif (Belong[x] == Belong[to]) { Pos[x] = Pos[to]; Step[x] = Step[to] + 1; }\n\telse Pos[x] = to, Step[x] = 1;\n}\n\ninline void Init ()\n{\n\tfor (int i = 1; i <= N; ++i) Belong[i] = (i - 1) / Block_Size + 1;\n\tblock_cnt = Belong[N];\n\tfor (int i = 1; i <= block_cnt; ++i) L[i] = (i - 1) * Block_Size + 1, R[i] = i * Block_Size;\n\tChkmin (R[block_cnt], N);\n\tfor (int i = 1; i <= N; ++i) if (!Step[i]) dfs(i, N);\n}\n\ninline int Query (int x)\n{\n\tint ans = 0;\n\twhile (x <= N) ans += Step[x], x = Pos[x];\n\treturn ans;\n}\n\ninline void Modify (int pos, int val)\n{\n\tA[pos] = val;\n\tfor (int i = L[Belong[pos]]; i <= R[Belong[pos]]; ++i) Step[i] = Pos[i] = 0;\n\tfor (int i = L[Belong[pos]]; i <= R[Belong[pos]]; ++i) if (!Step[i]) dfs(i, R[Belong[pos]]);\n}\n\ninline void Solve ()\n{\n\tM = read();\n\tInit();\n\twhile (M--)\n\t{\n\t\tint op = read(), x = read() + 1;\n\t\tif (op == 1) printf(\"%d\\n\", Query (x));\n\t\telse\n\t\t{\n\t\t\tint y = read();\n\t\t\tModify (x, y);\n\t\t}\n\t}\n}\n\ninline void Input ()\n{\n\tN = read();\n\tfor (int i = 1; i <= N; ++i) A[i] = read();\n}\n\nint main()\n{\n#ifdef hk_cnyali\n\tfreopen(\"A.in\", \"r\", stdin);\n\tfreopen(\"A.out\", \"w\", stdout);\n#endif\n\tInput();\n\tSolve();\n\treturn 0;\n}\n```\n\n### Debug\n\n* 39L: 一开始忘记加这一行,愉快地疯狂TLE","categories":["Problem"],"tags":["分块","数据结构","省选"]},{"title":"10-18N~10-23","url":"/2018/10/23/10-18N-10-23/","content":"","categories":["Problem"],"tags":["分块","动态规划","构造","数据结构","堆","计数","概率和期望","平衡树","Splay"]},{"title":"10-15~10-18","url":"/2018/10/18/10-15-10-18/","content":"","categories":["Problem"],"tags":["动态规划","tarjan","缩点","线段树","数据结构","单调队列","主席树","圆方树","点双","倍增"]},{"title":"国庆集训Summary","url":"/2018/10/08/%E5%9B%BD%E5%BA%86%E9%9B%86%E8%AE%ADSummary/","content":"\n被七天安排得超级满的国庆集训折磨得死去活来,总体来看还是不错的,就稍微总结一下吧\n\n![10-8-2](/images/10-8-2.png)\n\n> 凉凉,刚才突然被安排要讲课,讲树上相关问题,我一个菜鸡能讲些什么啊.../抱头痛哭\n\n<!--more-->\n\n这几天总体状态还不错,除了第一天不知道考出了个什么狗屎之外其他的分数还看得.\n\n知识点方面还是要不断加强不断完善,实际上考的知识点基本不算超纲,或多或少都接触过.但是因为做题量太少和平时积累不够的原因,考试的时候总是想不到,或者说大概有想法但是思路很乱,要么就是代码调不出来.这些问题都反映出平时自己刷题还是太少了,代码能力和思维能力都太弱,还有很大的进步空间.尤其是一些比较基础的,实际上不是很难,但却没有特定套路的思维题,我往往需要很长时间才能想出来.这个问题还是通过继续刷Atcoder解决吧.\n\n\n\n然后考试策略和心态问题的话,以后每次考试一定要把暴力先写好,哪怕只有几分,暴力没写的话对心态影响挺大的,而且因为没对拍导致炸分的事情也不只犯了一次两次. 考试的时候也不要去关心别人做题情况,不要因为别人一开始就敲代码而打乱了自己的节奏.还是要对自己有信心一点,毕竟这几天考试也考到过前几名.\n\n\n\n待会儿要是还想到什么再来加吧,先准备讲课的事去...\n\n烦躁...","tags":["Summary"]},{"title":"10-07模拟赛 Summary","url":"/2018/10/08/10-07%E6%A8%A1%E6%8B%9F%E8%B5%9B-Summary/","content":"","categories":["Summary"],"tags":["容斥","Summary","计数","set"]},{"title":"10-06模拟赛 Summary","url":"/2018/10/06/10-06%E6%A8%A1%E6%8B%9F%E8%B5%9B-Summary/","content":"","categories":["Summary"],"tags":["Summary","数据结构","树状数组","三分"]},{"title":"10-05模拟赛 Summary","url":"/2018/10/05/10-05%E6%A8%A1%E6%8B%9F%E8%B5%9B-Summary/","content":"","categories":["Summary"],"tags":["Summary","线段树","数据结构","堆","贪心"]},{"title":"10-05 树杂题 笔记","url":"/2018/10/04/10-05-%E6%A0%91%E6%9D%82%E9%A2%98-%E7%AC%94%E8%AE%B0/","content":"\n感觉罗大神两天讲题的听课体验都挺好的啊\n\n今天最后两题有点神仙，暂时还没放上来，完全消化了再填坑吧\n\n<!--more-->\n\n### 「CF911F」\n\n#### Description\n\n给定一棵 $n$ 个节点的树，你可以进行 $n - 1$ 次操作，每次操作步骤如下： \n\n* 选择 $u, v$ 两个度数为 $1$ 的节点。 \n* 将 $u, v$ 之间的距离加到 $ans$ 上。 \n* 将 $u$ 从树上删除。  \n\n求一个操作序列使得 $ans$ 最大。\n\n#### Solution\n\n先把直径拿出来，将直径外的点一个一个的和直径中的某一个端点配对并删掉。最后再将直径删掉。\n\n这个做法显然是对的。。。\n\n\n\n### 「CF1051F」\n\n#### Description\n\n给定一张$n$ 个点 $m$ 条边的带权无向联通图，$q$ 次询问，每次询问 $u_i$ 到 $v_i$ 的最短路长度。 \n\n$n, q \\le 10^5 , m - n \\le 20$ \n\n#### Solution\n\n首先随便搞一棵生成树，把这些非树边边的端点标记为特殊点。\n\n对于每一个询问，如果最短路只经过生成树上的边，就可以直接计算。 \n\n否则一定经过了一个特殊点，把所有特殊点预处理出最短路，然后枚举这个特殊点，然后更新答案就行了 \n\n\n\n### 「CF1042F」\n\n#### Description\n\n给定一棵 $n$ 个节点的树，定义叶子是度数为 $1$ 的节点，点集 $S$ 是好的如果满足任意两个 $S$ 中的点之间的距离 $\\le k$\n\n现在要求将所有叶子分成若干不相交的好的集合，请问最少分成多少个好的集合。 \n\n$n, k \\le 10^6$ \n\n#### Solution\n\n先随便选一个不是叶子的根，然后可以自底向上贪心。 \n\n设 $f_p$ 表示 $p$ 为根的子树内已完成的好的集合的数量，$g_p$ 表示未完成的集合中离 $p$ 最远的叶子的距离。\n\n（实际上这里指的未完成的集合是指集合内距离都$\\le k$，如果大于$k$则必须再新加入一个集合）\n\n考虑如何计算$f_p、g_p$\n\n首先将所有儿子的 $f$ 先求和，然后将所有儿子的 $g$ 排序，不断检查 一下最大的 $g$ 和次大的 $g$ 相加是否大于 $k$，如果大于，那么就将最大的 $g$ 删掉， 并把 $f_p$ 加上 1，循环过程。否则就令 $g_p$ 等于最大的 $g$ 加 $1$并跳出。 \n\n\n\n### 「CF1025D」\n\n#### Description\n\n给定$n$ 个节点，每个节点上有一个数字，要求用这些节点构建一棵二叉搜索树，满足有边相邻的两个节点上的数字互质。\n\n$ n \\le 600$ \n\n#### Solution\n\n先排序，考虑Dp\n\n设 $f[i][j][k]$ 表示第 $i$ 个点到第$ j$ 个点，以 $k$ 为根是否可行。 \n\n转移的时候查看是否存在 $u \\in [i, k - 1]$ 满足$ f[i][k - 1][u] = 1$ 且 $u$ 上的数字和 $k$ 上 的数字互质，右边类似。\n\n这样就是 $O(n^4 )$ 的。 注意到上面的做法有一些重复运算。\n\n于是设$ L[i][j] $表示是否存在 $k \\in [i, j]$ 满足 $f[i][j][k] = 1 $且 $k$ 上的数字和$ j + 1 $上的数字互质，类似地定义 $R[i][j]$\n\n于是复杂度就被降为 $O(n^3 )$ \n\n\n\n### 「CF955F」\n\n#### Description\n\n给定一棵以 $1$ 号点为根的树。若满足以下条件，则认为节点 $p$ 处有一个 $k$ 叉高度 为 $m$ 的堆： \n\n* 若 $m = 1$，则 $p$ 本身就是一个 $k$ 叉高度为 $1$ 的堆。 \n* 若 $m > 1$，则 $p$ 需要有至少 $k$ 个儿子满足在儿子处有一个 $k$ 叉高度为 $m - 1$ 的堆。 \n\n令 $dp[k][p]$ 表示在 $p$ 处 $k$ 叉堆的最大高度，求 $\\sum_{i=1}^{n} \\sum_{j=1}^{n} dp[i][j]$ \n\n$n \\le 3 * 10^5$ \n\n#### Solution\n\n如果固定 $k$，求所有的 $dp[p][k]$ 只需要dfs 整棵树，对于某个点 $p$，若其子节点数 $< k$，则 $dp[p][k] = 1$，否则 = 子节点 的 dp 值中第 $k$ 大的值 $+1$ 。运用 nth_element 可以做到 $O(n)$。这样总复杂度就是 $O(n^2 )$ \n\n观察到对于 $k > 1​$，有 $dp[p][k] \\le \\log(n)​$，所以可以考虑对 $dp ​$值分段计算。 \n\n设 $f[p][x] $表示满足 $dp[p][k] \\le x$ 的最大的 $k$。 \n\n$f$ 只有 $n\\log(n)$ 个状态，计算 $f$ 的时间复杂度是 $O(n\\log^2 (n))$，计算出 f 后就可以轻松得到答案了。 \n\n\n\n### 来历不明的题\n\n#### Description\n\n给定一棵 $n$ 个点的带边权树，$m$ 次询问，每次询问给出两个值 $p, k$，求以下值：\n\n$\\sum_{q| dis(p,q)\\le k} dis(q, p)$\n\n\n\n#### Solution\n\n动态点分治（点分树）裸题\n\n首先点分治，把分治结构建好。\n\n 每个分治中心要记录当前分治区域所有点到分治中心的距离，以及分别记录每个分 治子区域中的所有点到分治中心的距离，以及当前分治中心到其分治祖先的距离。 \n\n每次查询时在每个分治中心根据以上信息查询就可以了。 ","categories":["Note"],"tags":["笔记","动态规划","最短路","贪心"]},{"title":"10-04 图论杂题 笔记","url":"/2018/10/04/10-04-%E5%9B%BE%E8%AE%BA%E6%9D%82%E9%A2%98-%E7%AC%94%E8%AE%B0/","content":"\n今天讲课的内容还是比较和蔼可亲的,听课体验较好.除了最后一道神仙题(没放上来)之外其他的题都比较可做,不是太难. \n\n<!--more-->\n\n### 「CF1037D」\n\n#### Description\n\n一个 $n$ 个点 $m$ 条边的无向连通图从 $1$ 号点开始 $bfs$,可能得到的 $bfs$ 序有很多,取决于出边的访问顺序。\n\n现在给出一个 $1$ 到 $n$ 的排列,判断是否可能是一个 $bfs$ 序。\n\n$n, m \\le 2 * 10^5$\n\n#### Solution\n\n一个巧妙的做法:\n\n对于每个节点,令其权值为在给定序列中的位置。\n\n然后从 $1$ 号点开始正常的 $bfs$,出边的访问顺序按照权值从小到大访问。\n\n最后将得到的 $bfs$ 序与给定序列比较,若完全一致则是合法的。\n\n也就是说假定给定的$bfs$是合法的,按照这个来$bfs$再验证\n\n\n\n### 「CF901D」\n\n#### Description\n\n一个 $n$个点 $m$ 条边的无向连通图中每个点都有一个权值\n\n现在要求给每条边定一个权值,满足每个点的权值等于所有相连的边权之和,权值可负。\n\n#### Solution\n\n这道题和[「CF990F」Flow Control - 构造](https://hk-cnyali.com/2018/07/09/Educational-Codeforces-Round-45-F-Flow-Control-%E6%9E%84%E9%80%A0/)有点像,但是还是有细微差别\n\n先随便构造一棵生成树跑一遍,但这时根节点可能还不满足条件\n\n考虑其他的边,一条非树边会形成一个环。\n\n* 如果是偶环,那么无论这条非树边怎么变,都不会对根节点产生影响。\n* 如果是奇环,那么如果给这条非树边增加或减少权值,根节点会发生 $2$ 的权值变\n  化,具体是加还是减由路径长度奇偶性决定\n\n\n\n### 「CF894E」\n\n#### Description\n\n给定一个 $n$ 个点 $m$ 条边的有向带权图,对于一条边权为 $w$ 的边,经过时将获得 $w$的收益,之后$w=\\lfloor \\frac{w}{2}\\rfloor$\n\n请问从 $1$ 号点出发随便走最多能获得多少收益。\n\n#### Solution\n\n一个强连通分量内部所有的边肯定可以被走到底。\n\n所以缩点后 dp 就行了\n\n\n\n### 「CF859E」\n\n#### Description\n\n有 $m$ 个人,$n$ 张椅子,第 $i$ 个人只能坐在第 $u_i$ 或第$v_i$ 张椅子上。\n\n求有多少种方案满足没有人坐在同一张椅子上。\n\n#### Solution\n\n这种题有点套路啊...\n\n把椅子作为点,人作为边,变成一个图,每个连通块可以分开考虑。\n\n假设某个连通块中有 $v$ 个点,$e$ 条边,由于连通,有 $v - 1 \\le e$,并且若 $e > v$ 则无解,所以 $e$ 只有 $v - 1$ 和 $v$ 两种取值。\n\n* 假如 $e = v - 1$,那么该连通块有 $v$ 种方案:考虑枚举每个点不放的情况,其他的点都可以唯一确定。\n* 假如 $e = v$ 且环长 $> 1$,那么该连通块有 $2$ 种方案:考虑环上的一条边,这条边的放法确定后其他的都可以唯一确定。\n\n\n\n### 「CF852D」\n\n#### Description\n\n给定一个 $v$ 个点 $e$ 条边的带权无向图,在图上有 $n$ 个人,第 $i$ 个人位于点 $x_i$ ,一个人通过一条边需要花费这条边的边权的时间。现在每个人可以自由地走。求最短多少时间后满足结束后有人的节点数 $\\ge m$\n$n, v \\le 500$\n\n#### Solution\n\n先$ floyd$ 预处理出两两之间的距离。\n\n然后可以二分答案。二分答案之后,每个人向能走到的点连边。\n\n可以发现合法的条件就是最大匹配数 $\\ge m$,跑二分图匹配就可以了。\n\n\n\n### 「CF850D」\n\n#### Description\n\n一个竞赛图的度数集合是由该竞赛图中每个点的出度所构成的**集合**。\n\n现给定一个 $m$ 个元素的**集合**,第 $i$ 个元素是 $a_i$ 判断其是否是一个竞赛图的度数**集合**,如果是,找到点数最小的满足条件的竞赛图。\n\n$m, a_i \\le 30,a_i$ 互不相同\n\n#### Solution\n\n首先给出结论:\n\n假如给出每个点的出度,那么这些点能形成一个竞赛图当且仅当排序后的序列 $d_1 , d_2 , d_3 , ... , d_n$ 满足对于所有 $k < n$ 有  $\\sum_{i=1}^kd_i \\ge \\frac{k\\cdot (k-1)}{2}$且$\\sum_{i=1}^nd_i=\\frac{n\\cdot (n-1)}{2}$\n\n证明很简单,对于竞赛图的任意点集 $S$,都必须满足$\\sum_{i\\in S}d_i\\ge \\frac{|S|\\cdot (|S|-1)}{2}$\n\n(因为对于竞赛图的一个部分,它其中的点肯定两两有连边,并且这中间的点还有连出去的边,所以是大于等于)\n\n所以 $n$ 的大小是 $O(max(a_i ))$ 级别的。\n\n那么就可以 $dp$ 了,先将给定集合中的元素从小到大排序,便于剪枝。\n\n设 $f[i][j][sum]$ 表示考虑完前 $i$ 个元素,当前图中已经有$ j$ 个点了,度数之和为$sum$转移时枚举下一个元素出现了几次就行了。\n\n\n\n### 「CF845G」\n\n#### Description\n\n给定一个 $n$ 个点 $m$ 条边的带权无向连通图。\n\n从 $1$ 号点出发,初始花费是 $0$,每经过一条边花费就会异或上这条边的权值,当你到达 $n$ 号点时可以选择停下来。\n\n求停下来时的最小花费。\n\n$n, m \\le 10 ^5$\n\n#### Solution\n\n这道题前半部分还是很巧妙的,只可惜还不会线性基,只是大概了解,也暂时不打算学\n\n假设 $s$ 和 $t $是两条 $1$ 到 $n$ 的路径,$C$ 是图中所有环的集合。那么 $t$ 的权值一定可以通过 $s$ 的权值异或上 $C$ 中一些环的权值来得到。\n\n那先随便搞一棵生成树,然后对于每条非树边,都形成了一个环,这些环构成的集合是 $D$\n\n那么 $C$ 中的每个环的权值都可以通过 $F$ 中的一些环的权值异或和来得到。\n\n于是只要求出 $D$ 的线性基,然后随便搞一条路径在线性基上跑一下。\n\n\n\n### T8\n\n算了...","categories":["Note"],"tags":["笔记","动态规划","tarjan","缩点","构造","二分答案","二分图匹配"]},{"title":"10-04模拟赛 Summary","url":"/2018/10/04/10-04%E6%A8%A1%E6%8B%9F%E8%B5%9B-Summary/","content":"","categories":["Summary"],"tags":["数学","Summary","动态规划","并查集","meet in middle","堆"]},{"title":"10-03模拟赛 Summary","url":"/2018/10/03/10-03%E6%A8%A1%E6%8B%9F%E8%B5%9B-Summary/","content":"","categories":["Summary"],"tags":["Summary","动态规划","差分","状态压缩","概率和期望","暴力"]},{"title":"10-02 OI中的数学方法 笔记","url":"/2018/10/02/10-02-OI%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%A6%E6%96%B9%E6%B3%95-%E7%AC%94%E8%AE%B0/","content":"\n一些OI中~~NOIp范围内~~的数学知识(中间差分序列、插值部分有点掉线啊...)\n\n<!--more-->\n\n## 一、数论相关\n\n### gcd的一些性质\n\n1. $$\\gcd(x^a-1, x^b-1) = x^{\\gcd(a, b)} - 1$$\n\n2. $$\\gcd(fib_a, fib_b) = fib_{\\gcd(a, b)}$$\n\n   事实上第二个性质只要形如$f_i = af_{i-1} + bf_{i-2}$($a,b$互质)这样的递推式就成立\n\n\n### 欧拉定理\n\n若$gcd(a,p)=1$则有$ a^{\\varphi(p)} \\equiv 1 (mod~p)$\n\n拓展(一般情况): \n$$\na^{t} \\equiv a^{\\min(t,\\, t ~mod~ \\varphi(p) + \\varphi(p))} (mod~p)\n$$\n\n\n### 同余方程\n\n形如:$x \\equiv a_i (mod~{p_i})$\n\n* 中国剩余定理: \n\n  若$p_i$两两互质,存在通解$x$:\n  $$\n  \\begin{aligned}\n  P &= \\prod_{i} p_i \\\\ \\\\\n  P_i &= \\frac{P}{p_i} \\\\ \\\\\n  T_i &= P_i^{-1} ~mod~p_i \\\\ \\\\\n  x &\\equiv \\sum_{i} a_iT_iP_i (mod~P)\n  \\end{aligned}\n  $$\n\n\n\n\n\n\n\n\n* 拓展形式(合并线性同余方程):\n  $$\n  \\begin{aligned}\n  x &\\equiv a_1 (mod~{p_1}) \\\\\n  x &\\equiv a_2 (mod~{p_2}) \\\\\n  x &= a_1 + k_1p_1 = a_2 + k_2p_2 \\\\\n  \\end{aligned}\n  $$\n  令$t=gcd(p_1,p_2)$,则:\n  $$\n  \\begin{aligned}\n  a_1 + k_1\\frac{p_1}{t}t& = a_2 + k_2\\frac{p_2}{t}t \\\\\n  k_1\\frac{p_1}{t}&\\equiv \\frac{a_2 - a_1}{t} (mod~{\\frac{p_2}{t}})\\\\\n  k_1 &\\equiv \\frac{a_2 - a_1}{t} \\times (\\frac{p_1}{t})^{-1} (mod~{\\frac{p_2}{t}}) \\\\\n  x &\\equiv a_1 + p_1 \\left(\\frac{a_2 - a_1}{t} \\times (\\frac{p_1}{t})^{-1}~mod~ \\frac{p_2}{t} \\right) (mod~{\\frac{p_1p_2}{t}})\n  \\end{aligned}\n  $$\n\n\n\n\n\n\n\n\n\n\n## 二、积性函数\n\n### 基础知识\n\n令$n=p_1^{e_1}p_2^{e_2}...p_k^{e_k}$\n\n$\\epsilon(n) = [n = 1]$\n\n$\\mathrm{1}(n) = 1$\n\n$\\mathrm{Id}(n) = n$ \n\n$\\mu(n) = [\\max(e_1, e_2, \\cdots, e_k) \\le 1] (-1)^k$\n\n$\\varphi(n) = n\\prod_{i=1}^{k} (1 - \\frac{1}{p_i})$ \n\n$\\mathrm{d}(n) = \\sum_{d|n} 1$  约数个数\n\n$\\sigma(n) = \\sum_{d|n} d$  约数和\n\n$\\lambda(n) = (-1)^k$  刘维尔函数($\\mu$是一种特殊的刘维尔函数) 可做容斥\n\n\n\n### Dirichlet卷积\n\n$(f*g)(n) = \\sum_{d|n} f(d) g(\\frac{n}{d})$\n\n$\\mu * 1 = \\epsilon$\n\n$\\mathrm{Id} = \\varphi * 1 \\Rightarrow \\varphi = \\mathrm{Id} * \\mu$\n\n$\\mathrm{d} = 1 * 1 \\Rightarrow 1 = \\mu * \\mathrm{d}$\n\n$\\sigma = \\mathrm{Id} * 1 \\Rightarrow \\mathrm{Id} = \\mu * \\sigma \\Rightarrow \\sigma = \\varphi * \\mathrm{d}$\n\n这三个右边的式子可以通过左边的式子两边同时卷上$\\mu$得到($\\epsilon$卷任何函数等于其本身)\n\n$d(ij) = \\sum_{x|i}\\sum_{y|j} [\\gcd(x, y) = 1]$\n\n$\\sigma(ij) = \\sum_{x|i}\\sum_{y|j} [\\gcd(x, y) = 1] \\frac{iy}{x}$\n\n满足交换律, 结合律, 两个积性函数的卷积也是积性的\n\n\n\n## 三、组合数学\n\n### Lucas定理\n\n$$\n{n\\choose m} = {\\lfloor\\frac{n}{p}\\rfloor\\choose \\lfloor\\frac{m}{p}\\rfloor} \\times {n~mod~p\\choose m~mod~p}~(mod~ p)~|~p~is~prime\n$$\n\n### 基本组合恒等式\n\n$$\n\\begin{aligned}\n& \\sum_{i=0}^{n} {n \\choose i} = 2 ^ n \\\\\n& \\sum_{i=0}^{n} {i \\choose x} = {n+1 \\choose x+1} \\\\\n& \\sum_{i=0}^{n} {k+i \\choose i} = {k+n+1 \\choose n} \\\\\n& \\sum_{i=0}^{m} {m \\choose i} {n-m \\choose m-i} = {n \\choose m}\n\\end{aligned}\n$$\n\n\n\n## 四、Stirling数\n\n### 第一类Stirling数\n\n1. 定义:  $\\begin{bmatrix} n \\\\ m \\end{bmatrix}$ 表示将$n$ 个物品分为 $m$ 个无序非空环的方案数.\n2. 递推式: \n\n$$\\begin{bmatrix} n \\\\ m \\end{bmatrix} = \\begin{bmatrix} n-1 \\\\ m-1 \\end{bmatrix} + (n-1)\\begin{bmatrix} n-1 \\\\ m \\end{bmatrix}$$\n\n3. 生成函数:\n   $$\n   \\begin{aligned}\n   & x^{\\overline{n}} = \\sum_{i=0}^{n} \\begin{bmatrix} n \\\\ i \\end{bmatrix} x^i \\\\\n   & x^{\\underline{n}}= \\sum_{i=0}^{n} (-1)^{n-i} \\begin{bmatrix} n \\\\ i \\end{bmatrix} x^i \n   \\end{aligned}\n   $$\n\n\n\n\n\n\n\n\n### 第二类Stirling数\n\n1. 定义: $ \\left\\{ \\begin{aligned} &n \\\\ &m \\end{aligned} \\right\\}$ 表示将 $n$个物品分成 $m$ 个无序非空集合的方案数.\n\n2. 递推式:\n\n   $$ \\left\\{ \\begin{aligned} &n \\\\ &m \\end{aligned} \\right\\} = \\left\\{ \\begin{aligned} &n-1 \\\\ &m-1 \\end{aligned} \\right\\} + m\\left\\{ \\begin{aligned} n&-1 \\\\ &m \\end{aligned} \\right\\}$$\n\n3. 生成函数:\n   $$\n   \\begin{aligned}\n   & x^n = \\sum_{i=0}^{n} \\left\\{ \\begin{aligned} &n \\\\ &i \\end{aligned} \\right\\} x^{\\underline{i}} \\\\\n   & m!\\left\\{ \\begin{aligned} &n \\\\ &m \\end{aligned} \\right\\} = \\sum_{i=0}^{m} (-1)^{m-i} {m \\choose i} i^n\n   \\end{aligned}\n   $$\n\n\n\n\n\n\n\n\n\n## 五、差分序列\n\n定义 $\\Delta^{k} f(n)$ 为 $f(n)$ 的 $k$ 阶差分序列, 并且:\n\n$$\\Delta^{k} f(n) = \n\\begin{cases}\nf(n), & \\mathrm{k = 0} \\\\\n\\Delta^{k-1} f(n+1) - \\Delta^{k-1} f(n), & \\mathrm{otherwise}\n\\end{cases}$$\n\n\n\n容易发现差分序列的具有线性性, 特别地, 多项式:\n\n$$f(x) = \\{0, 0, 0, \\cdots, 1\\} \\mid x \\in [0, n]$$\n\n它的差分序列长这样:\n$$\n\\begin{aligned}\n\\{&0,0,0,0,\\cdot\\cdot\\cdot,1\\}\\\\\n\\{&0,0,0,\\cdot\\cdot\\cdot,1 \\}\\\\\n\\{&0,0,\\cdot\\cdot\\cdot,1 \\}\\\\\n\\{&0,\\cdot\\cdot\\cdot,1 \\}\\\\\n\\{&\\cdot\\cdot\\cdot\\}\\\\\n\\{&1\\}\n\\end{aligned}\n$$\n\n\n其第一列是 $\\{0, 0, 0, \\cdots, 1\\}$ , 事实上这个多项式就是 \n\n$$\\frac{1}{n!} \\prod_{i=0}^{n-1} (x - i) = {x \\choose n}$$.\n\n\n\n## 六、插值\n\n已知一个 $n$ 次多项式的 $n+1$ 个点值, 求这个多项式的系数表示.\n\n### 牛顿差值\n\n求出多项式的 $n$ 阶差分序列第一列 $\\{c_i\\}$, 可以将多项式表示成: \n$$f(x) = \\sum_{i=0}^{n} c_i {x \\choose i}$$\n\n### 拉格朗日插值\n\n考虑构造一个经过所有给定点的多项式:\n$$\n\\begin{aligned}\n    g_i(x) = \\prod_{j=0, j \\neq i}^{n} \\frac{x - x_j}{x_i - x_j} \\\\\n    f(x) = \\sum_{i=0}^{n} y_ig_i(x)\n\\end{aligned}\n$$\n\n## 七、自然数幂和\n\n求:$f_k(n) = \\sum_{i=0}^{n} i^k$\n\n### Solution\n\n直接用第二类斯特林数展开:\n$$\n\\begin{aligned}\nf_k(n) &= \\sum_{i=0}^{n} \\sum_{j=0}^{k}  \\left\\{ \\begin{aligned} &k \\\\ &j \\end{aligned} \\right\\} i^{\\underline{j}} \\\\\n&= \\sum_{j=0}^{k}  \\left\\{ \\begin{aligned} &k \\\\ &j\\end{aligned} \\right\\} j! \\sum_{i=0}^{n} {i \\choose j} \\\\\n&= \\sum_{j=0}^{k}  \\left\\{ \\begin{aligned} &k\\\\ &j\\end{aligned} \\right\\} j! {n + 1 \\choose j + 1}\n\\end{aligned}\n$$\n这样的时间复杂度是$O(k^2)$的,考虑继续优化\n\n通过上一个方法我们知道 $f_k(n)$ 是一个关于 $n$ 的 $k+1$ 次多项式, \n于是直接拉格朗日插值即可, 并且由于系数的特殊性质, 可以做到 $O(k)$.\n\n\n\n## 八、容斥与反演\n\n> Min-Max容斥\n\n$$\\max(S) = \\sum_{T \\subseteq S, T \\neq \\varnothing} {(-1) ^ {|T|-1}} \\min(T) $$\n\n>  gcd-lcm容斥(Min-Max容斥的拓展)\n\n$$\\mathrm{lcm}(S) = \\prod_{T \\subseteq S, T \\neq \\varnothing} \\gcd(T) ^ {(-1) ^ {|T|-1}}$$\n\n>  二项式反演\n\n$$\n\\begin{aligned}\n                f(n) &= \\sum_{i=0}^{n} {n \\choose i} g(i)\\\\\n\\Leftrightarrow g(n) &= \\sum_{i=0}^{n} (-1)^{n-i} {n \\choose i} f(i)\n\\end{aligned}\n$$\n\n>  Stirling反演\n\n$$\n\\begin{aligned}\n                f(n) &= \\sum_{i=0}^{n} \\left\\{ \\begin{aligned} &n \\\\ &i \\end{aligned} \\right\\} g(i) \\\\\n\\Leftrightarrow g(n) &= \\sum_{i=0}^{n} (-1)^{n-i} \\begin{bmatrix} n \\\\ i \\end{bmatrix} f(i) \n\\end{aligned}\n$$\n\n\n\n## 九、题目选讲\n\n### 「BZOJ4833」\n\n#### Description\n\n已知:\n$$\n\\begin{aligned}\nf(n) &= \n\\begin{cases}     \n0, & {n = 0} \\\\     \n1, & {n = 1} \\\\   \n2f(n-1) + f(n-2), & {otherwise} \n\\end{cases} \\\\ \\\\\ng(n) &= \\mathrm{lcm}(f(1), f(2), \\cdots, f(n)) \n\\end{aligned}\n$$\n求:\n\n$$\\sum_{i=1}^{n} g(i) \\times i$$\n\n$n \\le 10^6$\n\n#### Solution\n\n首先由前面提到关于gcd的结论,有 $\\gcd(f(i), f(j)) = f(\\gcd(i, j))$\n\n根据 Min-Max 容斥有:\n$$\n\\begin{aligned}\ng(n) &= \\prod_{T \\subseteq S, T \\neq \\varnothing} \\gcd(T)^{(-1)^{|T|+1}} \\\\\n&= \\prod_{T \\subseteq S, T \\neq \\varnothing} f(\\gcd(T))^{(-1)^{|T|+1}} \n\\end{aligned}\n$$\n构造$h$满足$f(n) = \\prod_{d|n} h(d)$,代入得到\n$$\n\\begin{aligned}\n g(n) &= \\prod_{d=1}^{n} h(d)^{\\sum_{T \\subseteq S, T \\neq \\varnothing} [d \\mid gcd(T)] (-1)^{|T|+1}} \\\\\n&= \\prod_{d=1}^{n} h(d)\n\\end{aligned}\n$$\n\n(最后这一步还是有点没想清楚,想通了再来填这个坑吧)\n\n> 10.8 Update:\n>\n> 这个地方其实是因为所有含$d$这个因子的数所构成的所有集合的gcd显然都是能被$d$整除的,那么这些数构成的集合中,每个数都有选或不选两种方案,一种贡献是1,一种贡献是-1,但是因为$T$不能为空集,因此要减去空集的贡献$-1$,因此那个上面指数部分就是$1$\n\n通过广义莫比乌斯反演可以得到:\n$$\nh(n)=\\prod_{d|n}f(d)^{\\mu(\\frac{n}{d})}\n$$\n总时间复杂度$O(n\\log n)$\n\n\n\n剩下两道题还没看,坑待填","categories":["Note"],"tags":["笔记","数学","数论","gcd","欧拉函数","CRT","卷积","反演","斯特林数","插值","容斥"]},{"title":"「CF1051G」Distinctification - 线段树合并 + 并查集","url":"/2018/10/02/%E3%80%8CCF1051G%E3%80%8DDistinctification-%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%90%88%E5%B9%B6-%E5%B9%B6%E6%9F%A5%E9%9B%86/","content":"\n一个长度为 $n$ 序列, 每个位置有 $a_i, b_i$ 两个参数,且$b_i$ 互不相同, 你可以进行任意次如下的两种操作:\n\n1. 若存在 $j \\neq i$ 满足 $a_j = a_i$, 则可以花费 $b_i$ 的代价令 $a_i$ 加一.\n2. 若存在 $j$ 满足 $a_j + 1 = a_i$, 则可以花费 $-b_i$ 的代价令 $a_i$ 减一.\n\n定义一个序列的权值为将序列中所有 $a_i$ 变得互不相同所需的最小代价.求给定序列的每一个前缀的权值.\n\n$n, a_i \\le 2 \\times 10^5, 1 \\le b_i \\le n$\n\n<!--more-->\n\n### Link\n\n[CF 1051G](http://codeforces.com/contest/1051/problem/G)\n\n### Solution\n\n考虑所有 $a_i$ 互不相同的时候怎么做\n\n若存在 $a_i + 1 = a_j$, 则可以花费 $b_i-b_j$ 的代价交换两个 $a_i$. 显然最优方案会将序列中所有 $a_i$ 连续的子段操作成按 $b_i$ 降序的.\n\n如果有 $a_i$ 相同, 则可以先将所有 $a_i$ 变成互不相同的再进行排序, 但是这时可能会扩大值域使得原本不连续的两个区间合并到一起,于是我们需要维护一个支持合并的数据结构.\n\n我们用并查集维护每个值域连续的块,并在每个并查集的根上维护一个以 $b$ 为关键字的值域线段树,每次合并两个联通块时, 合并他们对应的线段树即可维护答案.\n\n考虑如何具体维护线段树\n\n可以发现某个前缀的答案就是最终$a_ib_i$的前缀和减去一开始的$a_ib_i$的前缀和\n\n因为不管中间如何变化,对于每一个$i$,它最终的贡献一定是$(a_{new}- a_{old}) * b_i$\n\n一开始的前缀和可以直接前缀和统计,那么我们就只需要维护不断变化的$\\sum{a_ib_i}$\n\n并且因为$a_i$是连续的,可以假设$a_i$都是从1开始的,最后答案再加上$(a_i - 1) * sum$\n\n因此线段树里只需要统计每个值乘比它大的数的个数\n\n某个节点的答案就是左右子树的答案和加上左子树的$sum$乘上右子树的$size$\n\n总体来说这道题前面一部分还是比较好理解的,具体维护线段树这里搞了好久才搞懂\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ninline int read ()\n{\n\tint sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\nconst int Maxn = 4e5 + 100;\n\nint N, A[Maxn], B[Maxn], Root[Maxn];\nLL Sum[Maxn], ans;\n\nstruct tree\n{\n\tint ch[2], size;\n/**/LL sum, val;\n}Tree[Maxn * 30];\n\nnamespace SEG\n{\n#define ls Tree[Tree[root].ch[0]]\n#define rs Tree[Tree[root].ch[1]]\n#define lson Tree[root].ch[0], l, mid\n#define rson Tree[root].ch[1], mid + 1, r\n\n\tint node_cnt;\n\n\tinline void push_up (int root)\n\t{\n\t\tTree[root].sum = ls.sum + rs.sum;\n\t\tTree[root].size = ls.size + rs.size;\n\t\tTree[root].val = ls.val + rs.val + 1ll * ls.sum * rs.size;\n\t}\n\n\tinline void build (int &root, int l, int r, int x)\n\t{\n\t\tif (!root) root = ++node_cnt;\n\t\tif (l == r)\n\t\t{\n\t\t\tTree[root].sum = Tree[root].val = x, Tree[root].size = 1;\n\t\t\treturn ;\n\t\t}\n\t\tint mid = l + r >> 1;\n\t\tif (x <= mid) build (lson, x);\n\t\telse build (rson, x);\n\t\tpush_up (root);\n\t}\n\n\tinline int merge (int x, int y)\n\t{\n\t\tif (!x || !y) return x | y;\n\t\tint now = x;\n\t\tTree[now].ch[0] = merge (Tree[x].ch[0], Tree[y].ch[0]);\n\t\tTree[now].ch[1] = merge (Tree[x].ch[1], Tree[y].ch[1]);\n\t\tif (!Tree[now].ch[0] && !Tree[now].ch[1])\n\t\t{\n\t\t\tTree[now].val = Tree[x].val + Tree[y].val + 1ll * Tree[y].sum * Tree[x].size;\n\t\t\tTree[now].sum = Tree[x].sum + Tree[y].sum;\n\t\t\tTree[now].size = Tree[x].size + Tree[y].size;\n\t\t}\n\t\telse push_up (now);\n\t\treturn now;\n\t}\n\n\tLL query (int x) { return Tree[Root[x]].val + 1ll * (x - 1) * Tree[Root[x]].sum; }\n#undef lson\n#undef rson\n#undef ls\n#undef rs\n}\n\nnamespace DSU\n{\n\tint fa[Maxn];\n\tinline void init (int maxn) { for (int i = 1; i <= maxn; ++i) fa[i] = i; }\n\tinline int find (int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); }\n\tinline void link (int x, int y)\n\t{\n\t\tint fx = find(x), fy = find(y);\n\t\tfa[fy] = fx;\n\t\tans -= SEG :: query (fx) + SEG :: query (fy);\n\t\tRoot[fx] = SEG :: merge (Root[fx], Root[fy]);\n\t\tans += SEG :: query (fx);\n\t}\n}\n\ninline void Input ()\n{\n\tN = read();\n\tDSU :: init(4e5);\n\tfor (int i = 1; i <= N; ++i)\n\t{\n\t\tA[i] = read(), B[i] = read();\n\t\tSum[i] = Sum[i - 1] + 1ll * A[i] * B[i];\n\t\tA[i] = DSU :: find(A[i]), DSU :: fa[A[i]] = A[i] + 1;\n\t\tSEG :: build (Root[A[i]], 1, (int)(4e5), B[i]);\n\t}\n}\n\nint Vis[Maxn];\n\ninline void Solve ()\n{\n\tDSU :: init(4e5);\n\tfor (int i = 1; i <= N; ++i)\n\t{\n\t\tans += SEG :: query (A[i]);\n\t\tif (Vis[A[i] + 1]) DSU :: link (A[i], A[i] + 1);\n\t\tif (Vis[A[i] - 1]) DSU :: link (A[i] - 1, A[i]);\n\t\tVis[A[i]] = 1;\n\t\tprintf(\"%lld\\n\", ans - Sum[i]);\n\t}\n}\n\nint main()\n{\n#ifdef hk_cnyali\n\tfreopen(\"G.in\", \"r\", stdin);\n\tfreopen(\"G.out\", \"w\", stdout);\n#endif\n\tInput();\n\tSolve();\n\treturn 0;\n}\n\n```\n\n### Debug\n\n* 33L: sum和val要开long long\n","categories":["Problem"],"tags":["Codeforces","线段树","数据结构","线段树合并","并查集"]},{"title":"10-02模拟赛 Summary","url":"/2018/10/02/10-02%E6%A8%A1%E6%8B%9F%E8%B5%9B-Summary/","content":"","categories":["Summary"],"tags":["数学","Summary","动态规划","单调栈","莫队","线段树","数据结构","线段树合并"]},{"title":"10-01杂题选讲 笔记","url":"/2018/10/02/10-01%E6%9D%82%E9%A2%98%E9%80%89%E8%AE%B2%20%E7%AC%94%E8%AE%B0/","content":"\n<!--more-->\n\n## 「CF1016E」\n\n平面上有一个点光源, 以每秒一个单位的速度从 $(x_0, y)$ 沿直线走到 $(x_1, y)$, $y < 0$, \n$x$ 轴上有 $n$ 条线段会遮挡光线, $x$ 轴上方有 $q$ 个点, 你需要计算出每个点能够被光线直射的总时间.\n\n$n, q \\le 10^5$\n\n### Solution\n\n求时间就是求总长度,且长度经过相似转以后一定是一段连续的空隙长度和\n\n前缀和+二分处理,最后整体乘上相似比\n\n\n\n## 「CF992E」\n\n以前做过:[「CF992E」 Nastya and King-Shamans - 线段树](https://hk-cnyali.com/2018/07/01/Codeforces-Round-489-E-Nastya-and-King-Shamans-%E7%BA%BF%E6%AE%B5%E6%A0%91/)\n\n\n\n## 「CF1019E」\n\n有一棵 $n$ 个点的树, 每条边有两个参数 $a_i, b_i$ , \n在时刻 $t$ 一条边的长度为 $a_{i}t + b_i$, \n现在你需要求出在 $t = {0, 1, \\cdots , m-1}$ 这些时刻树的直径是多少.\n\n### Solution\n\n首先$a_i$一定单调不降,变化过程可以用斜率优化维护\n\n考虑边分治,合并信息要用到**闵可夫斯基和**\n\n闵可夫斯基和:\n\n* 定义:给出两个点集A,B,求点集$C=\\{a+b | a\\in A, b\\in B\\}$的凸包\n* 解法:求出A,B的凸包,找到A,B一组相加后在凸包上的点,向后按照相邻向量的极角序合并\n\n\n\n## 「CF1028F」\n\n给一个初始为空的整点集, 现在有 $n$ 次操作:\n\n- $1\\,\\, x\\,\\, y$ 向点集中插入点 $(x, y)$.\n- $2\\,\\, x\\,\\, y$ 从点集中删除点 $(x, y)$.\n- $3\\,\\, x\\,\\, y$ 问至少需添加多少点满足图像关于 $(0, 0), (x, y)$ 连线对称.\n\n$n \\le 2 \\times 10^5, 0 \\le x, y \\le 10^5$\n\n### Solution\n\n互相对称的两点到原点距离显然相同,即在同一个圆的圆周上\n\n因为点是整点,圆上整点很少,大约只有$O(\\sqrt{n})$\n\n维护每个圆上点的集合,每加入或删除一个点就计算这个点和其他点的对称中心并统计答案\n\n复杂度约为$O(n\\sqrt n \\log n)$,但很难达到上界\n\n\n\n## 「CF995E」\n\n给出三个数 $u, v, p​$, 你可以对 $u​$ 进行若干次如下操作:\n\n1. $u \\leftarrow u+1~mod~ p$\n2. $u \\leftarrow u - 1~mod~p$\n3. $u \\leftarrow u^{p-2}~mod~p$\n\n求一种不超过 $200$ 步的方案使得 $u$ 最终变成 $v$.\n\n$0 \\le u, v < p \\le 10^9 + 9, p$ 是质数\n\n### Solution\n\n双向bfs,因为图相当于随机,搜前$\\sqrt p$个状态的值,再倒着搜$\\sqrt p$个状态 \n\n根据生日悖论 $\\sqrt p$次就能找到解(约$4*10^{-5}$的概率找不到)\n\n\n\n## 「CF1051G \n\nLink:[「CF1051G」Distinctification - 线段树合并 + 并查集](https://hk-cnyali.com/2018/10/02/%E3%80%8CCF1051G%E3%80%8DDistinctification-%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%90%88%E5%B9%B6-%E5%B9%B6%E6%9F%A5%E9%9B%86/)","categories":["Note"],"tags":["Codeforces","笔记"]},{"title":"10-01模拟赛 Summary","url":"/2018/10/01/10-01%E6%A8%A1%E6%8B%9F%E8%B5%9B-Summary/","content":"","categories":["Summary"],"tags":["Summary","分块","动态规划","最短路"]},{"title":"「NOI2010」超级钢琴 - 主席树 + 堆","url":"/2018/09/30/%E3%80%8CNOI2010%E3%80%8D%E8%B6%85%E7%BA%A7%E9%92%A2%E7%90%B4-%E4%B8%BB%E5%B8%AD%E6%A0%91-%E5%A0%86/","content":"\n给一个长度为 $n$ 的序列 $\\{a_i\\}$，定义一个区间 $[l,r]$的价值为这个区间中数的总和。求区间长度在 $[L,R]$之间的所有区间中，价值最大 $k$ 的个区间的价值总和。\n\n$n\\le 500,000, k\\le 500,000, -1000\\le a_i\\le 1000, 1\\le L\\le R\\le n$\n\n<!--more-->\n\n### Link\n\n[Luogu P2048](https://www.luogu.org/problemnew/show/P2048)\n\n[BZOJ 2006](https://www.lydsy.com/JudgeOnline/problem.php?id=2006)\n\n### Solution\n\n首先预处理一下前缀和,枚举区间的右端点,可以得到一个可行的左端点区间\n\n最有可能成为前$k$大的，显然是这个区间里前缀和尽可能小的\n\n考虑将最小的那个先算进去，如果可以是前$k$大，再找第二小的，如此反复...\n\n用堆来处理这个过程，主席树处理区间第$k$小\n\n只是细节有点难调...\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ninline int read ()\n{\n    int sum = 0, fl = 1; char ch = getchar();\n    for (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n    for (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n    return sum * fl;\n}\n\nconst int Maxn = 500000 + 100;\n\nint N, K, L, R, Root[Maxn];\nLL Sum[Maxn], A[Maxn];\n\nnamespace SEG\n{\n    int node_cnt = 0;\n    struct tree\n    {\n        int ls, rs, sum;\n    }Tree[Maxn * 40];\n\n    inline void build (int &now, int l, int r)\n    {\n        now = ++node_cnt;\n        if (l == r) return ;\n        int mid = l + r >> 1;\n        build (Tree[now].ls, l, mid), build (Tree[now].rs, mid + 1, r);\n    }\n\n    inline void insert (int &now, int pre, int l, int r, int x)\n    {\n        now = ++node_cnt;\n        Tree[now].ls = Tree[pre].ls, Tree[now].rs = Tree[pre].rs;\n        Tree[now].sum = Tree[pre].sum + 1;\n        if (l == r) return ;\n        int mid = l + r >> 1;\n        if (x <= mid) insert (Tree[now].ls, Tree[pre].ls, l, mid, x);\n        else insert (Tree[now].rs, Tree[pre].rs, mid + 1, r, x);\n    }\n\n    inline int query (int now, int pre, int l, int r, int k)\n    {\n        if (l == r)\n        {\n/**/        if (Tree[now].sum - Tree[pre].sum) return A[l];\n            return 0;\n        }\n        int sum = Tree[Tree[now].ls].sum - Tree[Tree[pre].ls].sum, mid = l + r >> 1;\n        if (k <= sum) return query (Tree[now].ls, Tree[pre].ls, l, mid, k);\n        return query (Tree[now].rs, Tree[pre].rs, mid + 1, r, k - sum);\n    }\n\n    inline int query (int x, int y, int k)\n    { \n        return query (Root[y], Root[max(0, x - 1)], 1, Maxn, k); \n    }\n}\n\nstruct node\n{\n    LL val;\n    int l, r, k, y;\n    bool operator < (const node &x) const { return x.val > val; }\n};\n\npriority_queue <node> Q;\n\nint main()\n{\n#ifdef hk_cnyali\n    freopen(\"A.in\", \"r\", stdin);\n    freopen(\"A.out\", \"w\", stdout);\n#endif\n    N = read(), K = read(), L = read(), R = read();\n/**/++N;\n    for (int i = 2; i <= N; ++i)\n        A[i] = Sum[i] = Sum[i - 1] + read();\n    sort(A + 1, A + N + 1);\n    int len = unique(A + 1, A + N + 1) - A - 1;\n    SEG :: build (Root[0], 1, Maxn);\n    for (int i = 1; i <= N; ++i)\n    {\n        int pos = lower_bound (A + 1, A + len + 1, Sum[i]) - A;\n        SEG :: insert (Root[i], Root[i - 1], 1, Maxn, pos);\n    }\n    for (int i = L + 1; i <= N; ++i)\n    {\n/**/    int l = max(0, i - R), r = max(0, i - L);\n        Q.push((node){Sum[i] - SEG :: query (l, r, 1), l, r, 1, i});\n    }\n    LL ans = 0;\n    while (K-- && !Q.empty())\n    {\n        node x = Q.top(); Q.pop();\n        ans += x.val;\n        int len_now = x.r - x.l + 1;\n/**/    if (!x.l) len_now--;\n        if (x.k == len_now) continue;\n        Q.push((node){Sum[x.y] - SEG :: query (x.l, x.r, x.k + 1), x.l, x.r, x.k + 1, x.y});\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n\n```\n\n### Debug\n\n* 61L: 如果区间根本不存在值return 0\n\n* 91L: 要在最前面多加一个把$0$的位置++的线段树,因为前缀和也可能是0\n* 104L: 前缀和是减去$sum_{l-1}$而不是$sum_l$\n\n* 113L: 特判一下0的情况...\n\n","categories":["Problem"],"tags":["线段树","数据结构","堆","主席树"]},{"title":"「SDOI2010」地精部落 - Dp","url":"/2018/09/27/%E3%80%8CSDOI2010%E3%80%8D%E5%9C%B0%E7%B2%BE%E9%83%A8%E8%90%BD-Dp/","content":"\n求长度为$n$且$\\forall i\\in [1,n], a_{i-1}<a_i>a_{i+1} ~ or ~a_{i-1}>a_i<a_{i+1}$的排列数量(对$P$取模)\n\n$3\\le n\\le 4200, P \\le 10^9$\n\n<!--more-->\n\n### Link\n\n[Luogu P2467](https://www.luogu.org/problemnew/show/P2467)\n\n\n\n### Solution\n\n首先很容易想到设$dp[i][j][0/1]$表示到第$i$位,第$i$位放$j$这个数,且这个数为谷/峰的方案数\n\n但是显然这个会算重,考虑把$j$换一个定义:在前$i$位中排第$j$位的数,那么就很好转移了\n\n注意开个滚动数组优化空间\n\n\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ninline int read ()\n{\n\tint sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\nconst int Maxn = 4200 + 100;\n\nint N, Mod, Dp[2][Maxn][2];\n\nint main()\n{\n#ifdef hk_cnyali\n\tfreopen(\"A.in\", \"r\", stdin);\n\tfreopen(\"A.out\", \"w\", stdout);\n#endif\n\tN = read(), Mod = read();\n\tDp[1][1][0] = Dp[1][1][1] = 1;\n\tint now = 1;\n\tfor (int i = 2; i <= N; ++i)\n\t{\n\t\tnow ^= 1;\n\t\tint sum = 0;\n\t\tfor (int j = 1; j <= i; ++j)\n\t\t{\n\t\t\t(Dp[now][j][0] = sum) %= Mod;\n\t\t\t(sum += Dp[now ^ 1][j][1]) %= Mod;\n\t\t}\n\t\tsum = 0;\n\t\tfor (int j = i; j >= 1; --j)\n\t\t{\n\t\t\t(sum += Dp[now ^ 1][j][0]) %= Mod;\n\t\t\t(Dp[now][j][1] = sum) %= Mod;\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int i = 1; i <= N; ++i)\n\t\t(ans += Dp[now][i][0] + Dp[now][i][1]) %= Mod;\n\tcout<<ans<<endl;\n\treturn 0;\n}\n\n```\n\n\n\n\n\n","categories":["Problem"],"tags":["动态规划","省选"]},{"title":"9-27模拟赛 Summary","url":"/2018/09/27/9-27%E6%A8%A1%E6%8B%9F%E8%B5%9B-Summary/","content":"","categories":["Summary"],"tags":["数学","Summary","构造","KMP","博弈","搜索","字符串"]},{"title":"「NOIp2017」逛公园 - 最短路 + Dp/记忆化搜索","url":"/2018/09/26/%E3%80%8CNOIp2017%E3%80%8D%E9%80%9B%E5%85%AC%E5%9B%AD-%E6%9C%80%E7%9F%AD%E8%B7%AF-Dp-%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/","content":"\n一张$n$个点$m$条边的简单有向图,求$dis(1,n) \\le MinDis(1,n) + K$的路径数\n\n<!--more-->\n\n### Link\n\n[Luogu P3953](https://www.luogu.org/problemnew/show/P3953)\n\n### Constraints\n\n$N \\le 10^5, M\\le 2 * 10^5, K\\le 50$,存在为0的边\n\n$1 \\le P \\le 10^9,1 \\le a_i,b_i \\le N ,0 \\le c_i \\le 1000$\n\n\n\n### Solution\n\n很显然是一个关于K的Dp\n\n先预处理出$MinDis(x,n)$表示$x$到$n$的最短路\n\n设$Dp[x][k]$表示到第$x$个点,$dis(x,n)\\le MinDis(x,n)+k$的方案数,答案就是$Dp[1][K]$\n\n对于一条边$(x, y, w)$, 它所消耗的$k$为$MinDis(y,n) - MinDis(x,n) + w$\n\n如果$MinDis(y,n) - MinDis(x,n) + w \\le k$\n\n那么$Dp[x][k]+= Dp[y][k - (MinDis(y,n) - MinDis(x,n) + w)]$\n\n直接记忆化搜索即可,对于0环只需要用一个栈记录一下:如果当前搜索的$(x,k)$还在栈中就返回-1\n\n这样做的话因为每个状态最多只会遍历到一次（或者这样理解：在转移的时候k在不断减小），所以时间复杂度是能保证的\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) {return a < b ? a = b, 1 : 0;}\ntemplate <typename T> inline int Chkmin (T &a, T b) {return a > b ? a = b, 1 : 0;}\ninline int read ()\n{\n\tint sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\nconst int Maxn = 100000 + 100, Maxm = 200000 + 100, Maxk = 50 + 10, inf = 0x3f3f3f3f;\n\nint N, M, K, Mod, e, Begin[Maxn], To[Maxm], Next[Maxm], W[Maxm];\nint Dp[Maxn][Maxk], In[Maxn][Maxk];\n\ninline void add_edge (int x, int y, int z) { To[++e] = y; Next[e] = Begin[x]; Begin[x] = e; W[e] = z; }\n\ninline void Init() \n{ \n\te = 0; \n\tmemset(Begin, 0, sizeof Begin); \n\tmemset(Dp, 0, sizeof Dp); \n\tmemset(In, 0, sizeof In); \n}\n\nint Dis[Maxn], Vis[Maxn];\n\nnamespace Dijkstra\n{\n\tint e1, Begin1[Maxn], To1[Maxm], Next1[Maxm], W1[Maxm];\n\tstruct node\n\t{\n\t\tint a, b;\n\t\tbool operator < (const node &x) const { return x.b < b; }\n\t};\n\n\tinline void init() { e1 = 0; memset(Begin1, 0, sizeof Begin1); }\n\n\tinline void add_edge (int x, int y, int z) { To1[++e1] = y; Next1[e1] = Begin1[x]; Begin1[x] = e1; W1[e1] = z; }\n\n\tinline void work (int S)\n\t{\n\t\tstatic priority_queue <node> Q;\n\t\tfor (int i = 1; i <= N; ++i) Dis[i] = inf, Vis[i] = 0;\n\t\tDis[S] = 0; Q.push((node){S, 0});\n\t\twhile (!Q.empty())\n\t\t{\n\t\t\tint x = Q.top().a; Q.pop();\n\t\t\tif (Vis[x]) continue;\n\t\t\tVis[x] = 1;\n\t\t\tfor (int i = Begin1[x]; i; i = Next1[i])\n\t\t\t{\n\t\t\t\tint y = To1[i];\n\t\t\t\tif (Chkmin(Dis[y], Dis[x] + W[i])) Q.push((node){y, Dis[y]});\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline int dfs (int x, int k)\n{\n//\tcout<<x<<\" \"<<k<<endl;\n\tif (In[x][k]) return -1;\n\tif (Dp[x][k]) return Dp[x][k];\n\tIn[x][k] = 1;\n\tif (x == N) Dp[x][k] = 1;\n\tfor (int i = Begin[x]; i; i = Next[i])\n\t{\n\t\tint y = To[i];\n\t\tint tmp = Dis[y] - Dis[x] + W[i];\n\t\tif (tmp <= k)\n\t\t{\n\t\t\tint sum = dfs(y, k - tmp);\n\t\t\tif (sum == -1) return Dp[x][k] = -1;\n\t\t\t(Dp[x][k] += sum) %= Mod;\n\t\t}\n\t}\n\tIn[x][k] = 0;\n\treturn Dp[x][k];\n}\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"park.in\", \"r\", stdin);\n\tfreopen(\"park.out\", \"w\", stdout);\n#endif\n\tint Test = read();\n\twhile (Test--)\n\t{\n\t\tInit();\n\t\tDijkstra :: init();\n\t\tN = read(), M = read(), K = read(), Mod = read();\n\t\tfor (int i = 1; i <= M; ++i)\n\t\t{\n\t\t\tint x = read(), y = read(), z = read();\n\t\t\tadd_edge (x, y, z);\n\t\t\tDijkstra :: add_edge (y, x, z);\n\t\t}\n\t\tDijkstra :: work (N);\n//\t\tfor (int i = 1; i <= N; ++i) cout<<Dis[i]<<\" \";\n//\t\tcout<<endl;\n\t\tprintf(\"%d\\n\", dfs(1, K));\n\t}\n\treturn 0;\n}\n```\n\n","categories":["Problem"],"tags":["动态规划","最短路","记忆化搜索","NOIp"]},{"title":"9-26模拟赛 Summary","url":"/2018/09/26/9-26%E6%A8%A1%E6%8B%9F%E8%B5%9B-Summary/","content":"","categories":["Summary"],"tags":["数学","Summary","构造","贪心","Hash","前缀和","字符串","叉积"]},{"title":"9-25模拟赛 Summary","url":"/2018/09/25/9-25%E6%A8%A1%E6%8B%9F%E8%B5%9B-Summary/","content":"","categories":["Summary"],"tags":["Summary","动态规划","线段树","数据结构","扫描线","乱搞","高精度"]},{"title":"9-24模拟赛 Summary","url":"/2018/09/25/9-24%E6%A8%A1%E6%8B%9F%E8%B5%9B-Summary/","content":"","categories":["Summary"],"tags":["数学","Summary","二分答案","数据结构","并查集","set","暴力","二分","对偶图","乱搞"]},{"title":"9-22模拟赛 Summary","url":"/2018/09/22/9-22%E6%A8%A1%E6%8B%9F%E8%B5%9B-Summary/","content":"","categories":["Summary"],"tags":["Summary","构造","贪心","启发式合并"]},{"title":"9-21模拟赛 Summary","url":"/2018/09/21/9-21%E6%A8%A1%E6%8B%9F%E8%B5%9B-Summary/","content":"","categories":["Summary"],"tags":["数论","Summary","动态规划","构造","乱搞"]},{"title":"9-7模拟赛 Summary","url":"/2018/09/20/9-7%E6%A8%A1%E6%8B%9F%E8%B5%9B-Summary/","content":"","categories":["Summary"],"tags":["Summary","线段树","数据结构","树状数组","网络流","最大流"]},{"title":"9-14模拟赛 Summary","url":"/2018/09/19/9-14%E6%A8%A1%E6%8B%9F%E8%B5%9B-Summary/","content":"","categories":["Summary"],"tags":["容斥","Summary","动态规划","暴力"]},{"title":"9-16模拟赛 Summary","url":"/2018/09/19/9-16%E6%A8%A1%E6%8B%9F%E8%B5%9B-Summary/","content":"","categories":["Summary"],"tags":["Summary","动态规划","前缀和"]},{"title":"关于Dinic...","url":"/2018/09/13/%E5%85%B3%E4%BA%8EDinic/","content":"\n### About Dinic\n\n至今才知道自己写的Dinic是个假的...\n\n一直写的Dinic是单路增广的,实际上多路增广才有正确的复杂度\n\n本来还以为从来没被卡过,实际上在[狼抓兔子](https://hk-cnyali.com/2018/07/24/BZOJ1001-BeiJing2006-%E7%8B%BC%E6%8A%93%E5%85%94%E5%AD%90-%E7%BD%91%E7%BB%9C%E6%B5%81/)里就被卡了\n\n那个时候还无知地以为加的是玄学优化...\n\n好傻逼啊...\n\n<!--more-->\n\n### Template([Hdu 3549](http://acm.hdu.edu.cn/showproblem.php?pid=3549))\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define x1 X1 \n#define x2 X2\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ninline int read ()\n{\n\tint sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\nconst int Maxn = 20, Maxm = 1000 + 10, inf = INT_MAX;\n\nint N, M;\nint e, Begin[Maxn], Next[Maxm * 2], To[Maxm * 2], W[Maxm * 2];\n\ninline void add_edge (int x, int y, int z)\n{\n\tTo[e] = y;\n\tNext[e] = Begin[x];\n\tBegin[x] = e;\n\tW[e++] = z;\n}\n\nnamespace Dinic\n{\n\tint Level[Maxn], Cur[Maxn];\n\n\tinline void init()\n\t{\n\t\te = 0;\n\t\tmemset(Begin, -1, sizeof (Begin));\n\t\tmemset(W, 0, sizeof (W));\n\t}\n\n\tqueue <int> Q;\n\n\tinline int bfs ()\n\t{\n\t\tfor (int i = 1; i <= N; ++i) Level[i] = -1;\n\t\tLevel[1] = 0;\n\t\twhile (!Q.empty()) Q.pop();\n\t\tQ.push(1);\n\t\twhile (!Q.empty())\n\t\t{\n\t\t\tint x = Q.front(); Q.pop();\n\t\t\tfor (int i = Begin[x]; i + 1; i = Next[i])\n\t\t\t{\n\t\t\t\tint y = To[i];\n\t\t\t\tif (W[i] > 0 && Level[y] < 0)\n\t\t\t\t{\n\t\t\t\t\tLevel[y] = Level[x] + 1;\n\t\t\t\t\tQ.push(y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (Level[N] < 0) return 0;\n\t\treturn 1;\n\t}\n\n\tinline int find (int x, int k)\n\t{\n\t\tif (x == N || !k) return k;\n\t\tint tot = 0;\n\t\tfor (int &i = Cur[x]; i + 1; i = Next[i])\n\t\t{\n\t\t\tint y = To[i], sum;\n\t\t\tif (W[i] > 0 && Level[y] == Level[x] + 1 && (sum = find (y, min(k, W[i]))))\n\t\t\t{\n\t\t\t\tW[i] -= sum;\n\t\t\t\tW[i ^ 1] += sum;\n\t\t\t\ttot += sum;\n\t\t\t\tk -= sum;\n\t\t\t\tif (!k) break;\n\t\t\t}\n\t\t}\n\t\treturn tot;\n\t}\n\n\tinline int work ()\n\t{\n\t\tint ans = 0;\n\t\twhile (bfs())\n\t\t{\n\t\t\tfor (int i = 1; i <= N; ++i) Cur[i] = Begin[i];\n\t\t\tans += find(1, inf);\n\t\t}\n\t\treturn ans;\n\t}\n}\n\nint main()\n{\n#ifdef hk_cnyali\n\tfreopen(\"B.in\", \"r\", stdin);\n\tfreopen(\"B.out\", \"w\", stdout);\n#endif\n\tint T = read();\n\tfor (int xz = 1; xz <= T; ++xz)\n\t{\n\t\tscanf(\"%d%d\", &N, &M);\n\t\tDinic :: init();\n\t\twhile (M--)\n\t\t{\n\t\t\tint x, y, z;\n\t\t\tscanf(\"%d%d%d\", &x, &y, &z);\n\t\t\tadd_edge(x, y, z);\n\t\t\tadd_edge(y, x, 0);\n\t\t}\n\t\tprintf(\"Case %d: %d\\n\", xz, Dinic :: work());\n\t}\n\treturn 0;\n}\n```\n\n","categories":["Algorithm"],"tags":["网络流","最大流"]},{"title":"9.10模拟赛 Summary","url":"/2018/09/13/9-10%E6%A8%A1%E6%8B%9F%E8%B5%9B-Summary/","content":"","categories":["Summary"],"tags":["Summary","最短路","建图","乱搞"]},{"title":"2018.9.13","url":"/2018/09/13/2018-9-13/","content":"","categories":["Something"],"tags":["Something"]},{"title":"「NOIp模拟赛9.8」C - 计数 + 树状数组","url":"/2018/09/12/9-8%E6%A8%A1%E6%8B%9F%E8%B5%9B-C-%E8%AE%A1%E6%95%B0-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/","content":"","categories":["Problem"],"tags":["树状数组","计数"]},{"title":"「NOIp模拟赛9-10」illness - 最短路建图","url":"/2018/09/12/9-10%E6%A8%A1%E6%8B%9F%E8%B5%9B-illness-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BB%BA%E5%9B%BE/","content":"","categories":["Problem"],"tags":["最短路","建图"]},{"title":"「AGC022C」Remainder Game - 贪心 + 建图floyd","url":"/2018/09/05/AGC022-C-Remainder-Game-%E8%B4%AA%E5%BF%83-%E5%BB%BA%E5%9B%BEfloyd/","content":"\n题目链接：[传送门](https://beta.atcoder.jp/contests/agc022/tasks/agc022_c)\n\n### Description\n\n给你一个长度为$N$的序列$a_1, a_2,...,a_N$，你可以进行如下操作：\n\n选择一个正整数$k$，对于序列$a$中每一个元素可以选择对$k$取模也可以什么都不干\n\n无论你选择多少个元素对$k$取模，一次操作都要花费$2^k$的代价\n\n问是否能将序列$a$变成序列$b$，如果可以则输出最小代价\n\n\n\n### Constraints\n\n$1\\le N\\le 50, 0\\le a,b \\le 50$\n\n\n\n<!--more-->\n\n\n\n### Sample Input\n\n```\n3\n19 10 14\n0 3 4\n```\n\n\n\n### Sample Output\n\n```\n160\n```\n\n\n\n### Solution\n\n首先显然能够发现一个性质，因为$\\sum_{i=0}^{k}2^i < 2^{k+1}$，因此能通过小于等于$k$的数满足题意，就一定不用$k+1$\n\n那么显然我们就能从大到小枚举$k$，如果只用$k-1$的所有数能满足题意的话$k$就对答案没有贡献，否则就有贡献\n\n接下来考虑如何Check一个答案是否满足题意\n\n显然只需要建图连边，跑一遍floyd检验连通性即可\n\n\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define x1 X1 \n#define x2 X2\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ninline int read ()\n{\n\tint sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\nconst int MaxN = 50 + 5;\n\nint N, A[MaxN], B[MaxN], Dis[MaxN][MaxN];\n\ninline int Check (LL ans)\n{\n\tmemset(Dis, 0, sizeof Dis);\n\tfor (int i = 0; i <= 50; ++i) Dis[i][i] = 1;\n\tfor (int i = 1; i <= 50; ++i) if ((1ll << i) & ans) for (int j = 0; j <= 50; ++j) Dis[j][j % i] = 1;\n\tfor (int k = 0; k <= 50; ++k)\n\t\tfor (int i = 0; i <= 50; ++i)\n\t\t\tfor (int j = 0; j <= 50; ++j)\n\t\t\t\tif (Dis[i][k] && Dis[k][j]) Dis[i][j] = 1;\n\tfor (int i = 1; i <= N; ++i)\n\t\tif (!Dis[A[i]][B[i]]) return 0;\n\treturn 1;\n}\n\nint main()\n{\n#ifdef hk_cnyali\n\tfreopen(\"C.in\", \"r\", stdin);\n\tfreopen(\"C.out\", \"w\", stdout);\n#endif\n\tN = read();\n\tfor (int i = 1; i <= N; ++i) A[i] = read();\n\tfor (int i = 1; i <= N; ++i) B[i] = read();\n\tLL ans = (1ll << 51) - 1; \n\tfor (int i = 50; i >= 0; --i)\n\t{\n\t\tans ^= (1ll << i);\n\t\tif (!Check(ans)) ans ^= (1ll << i);\n\t}\n\tcout<<(ans == ((1ll << 51) - 1) ? -1 : ans)<<endl;\n\treturn 0;\n}\n```\n\n","categories":["Problem"],"tags":["贪心","建图","agc","Atcoder"]},{"title":"暑假总结及接下来一个月计划","url":"/2018/09/04/%E6%9A%91%E5%81%87%E6%80%BB%E7%BB%93%E5%8F%8A%E6%8E%A5%E4%B8%8B%E6%9D%A5%E4%B8%80%E4%B8%AA%E6%9C%88%E8%AE%A1%E5%88%92/","content":"\n### Summary\n\n这个暑假的集训，我相比以前认真了很多，每一次的考试题都认认真真搞懂并且改完了，所以收获了很多。但是正因为如此，也没有什么时间去做自己的题目。我认为在这几个月的集训中，我认为我的的数据结构能力提升了很多，数据结构题做起来也比较得心应手，码代码速度也比以前快了很多，并且基本上不需要调试。但是通过这几个月的集训，我也发现我的Dp能力和思维题、数学题、构造题这些方面还是比较薄弱，以后还需要加强。\n\n### Plan\n\n接下来到联赛前的这几个月，尽量在学校把作业做完，自习课作业做完了的话就在自习课上复习一下以前不是很掌握的算法（字符串相关、数学相关等）巩固基础、学习杨光大佬的笔记，比较难的非noip知识点可以先放一放（线性代数等）。如果晚上不考试的话还是在机房继续刷Atcoder的题，一道题不想一个晚上坚决不看题解；如果有考试的话也要认真对待，每道题都要改好。\n\n","categories":["Summary"],"tags":["Summary","OI历程"]},{"title":"「SCOI2014」方伯伯的OJ - Splay分裂","url":"/2018/08/31/Luogu-P3285-SCOI2014-%E6%96%B9%E4%BC%AF%E4%BC%AF%E7%9A%84OJ-Splay%E5%88%86%E8%A3%82/","content":"\n题目链接：[传送门](https://www.luogu.org/problemnew/show/P3285)\n\n### Description\n\n方伯伯正在做他的Oj。现在他在处理Oj上的用户排名问题。Oj上注册了n个用户，编号为1～n“，一开始他们按照编号排名。\n\n方伯伯会按照心情对这些用户做以下四种操作，修改用户的排名和编号：\n\n1．操作格式为1 x y，意味着将编号为x的用户编号改为y，而排名不变，执行完该操作后需要输出该用户在队列中的位置，数据保证x必然出现在队列中，同时，1是一个当前不在排名中的编号。\n\n2．操作格式为2 x，意味着将编号为x的用户的排名提升到第一位，执行完该操作后需要输出执行该操作前编号为x用户的排名。\n\n3．操作格式为3 x，意味着将编号为x的用户的排名降到最后一位，执行完该操作后需要输出执行该操作前编号为x用户的排名。\n\n4．操作格式为4 k，意味着查询当前排名为k的用户编号，执行完该操作后需要输出当前操作用户的编号。\n\n但同时为了防止别人监听自己的工作，方伯伯对他的操作进行了加密，即将四种操作的格式分别改为了：\n\n- 1 x+a y+a\n- 2 x+a\n- 3 x+a\n- 4 k+a\n- 其中a为上一次操作得到的输出，一开始a=0。\n\n例如：上一次操作得到的输出是5这一次操作的输入为：1 13 15因为这个输入是经过加密后的，所以你应该处理的操作是1 8 10现在你截获了方伯伯的所有操作，希望你能给出结果。\n\n\n\n### Constraints\n\n$n\\le 10^8, m\\le 10^5$\n\n\n\n<!--more-->\n\n\n\n### Solution\n\n以排名或编号建树都不能完美满足所有操作的要求，所以我们同时以排名和编号为序建立两棵平衡树$T_1,T_2$\n\n$T_1$以排名为序，$T_2$以编号为序，$T_2$中保存这个编号在$T_1$中对应的节点编号。\n\n操作一，在$T_2$中找到编号，回到$T_1$中算答案，然后直接更新$T_2$即可。\n\n其他操作类似。\n\n由于$n\\le10^8$，所以要Splay分裂\n\n$T_2$的功能单一，用std::map就好了\n\n\n\n### Code(4.5K)\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define x1 X1 \n#define x2 X2\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) {return a < b ? a = b, 1 : 0;}\ntemplate <typename T> inline int Chkmin (T &a, T b) {return a > b ? a = b, 1 : 0;}\ninline int read ()\n{\n\tint sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\nconst int Maxm = 1e5 + 100;\n\nint N, M, root, cnt;\n\nstruct tree\n{\n\tint ch[2], fa, size, x, y;\n}Tree[Maxm * 40];\n\nmap <int, int> S;\n\nnamespace Splay\n{\n\tinline int judge_dir (int x) { return Tree[Tree[x].fa].ch[1] == x; }\n\tinline void push_up (int root) { Tree[root].size = Tree[Tree[root].ch[0]].size + Tree[Tree[root].ch[1]].size + Tree[root].y - Tree[root].x + 1; }\n\tinline void connect (int x, int f, int dir) { Tree[x].fa = f; Tree[f].ch[dir] = x; }\n\tinline void newnode (int idx, int idy, int f, int dir) { Tree[++cnt].x = idx; Tree[cnt].y = idy; Tree[cnt].size = idy - idx + 1; connect (cnt, f, dir); }\n\tinline void init() { newnode (1, N, 0, 0); root = 1; S[N] = 1; }\n\tinline void rotate (int x)\n\t{ \n\t\tint f = Tree[x].fa, anc = Tree[f].fa, dirx = judge_dir(x), dirf = judge_dir(f); \n\t\tconnect (Tree[x].ch[!dirx], f, dirx); connect (f, x, !dirx); \n\t\tconnect (x, anc, dirf); push_up(f), push_up(x); \n\t}\n\tinline void splay (int x, int y)\n\t{\n\t\twhile (Tree[x].fa != y)\n\t\t{\n\t\t\tint f = Tree[x].fa, anc = Tree[f].fa, dirx = judge_dir(x), dirf = judge_dir(f);\n\t\t\tif (y == anc) rotate(x);\n\t\t\telse if (dirx == dirf) rotate(f), rotate(x);\n\t\t\telse rotate(x), rotate(x);\n\t\t}\n\t\tif (!y) root = x;\n\t}\n\n\tinline void split (int x, int val)\n\t{\n\t\tsplay (x, 0);\n\t\tint size_now = Tree[x].y - Tree[x].x + 1;\n\t\tint L = Tree[x].x, R = Tree[x].y;\n\t\tif (size_now == 1) return ;\n\t\tif (L == val)\n\t\t{\n\t\t\tint tmp = Tree[x].ch[1];\n\t\t\tnewnode (L + 1, R, x, 1); connect (tmp, cnt, 1);\n\t\t\tTree[x].y = Tree[x].x;\n\t\t\tpush_up(cnt), push_up(x); splay (cnt, 0);\n\t\t\tS[L] = x, S[R] = cnt;\n\t\t\treturn ;\n\t\t}\n\t\tif (R == val)\n\t\t{\n\t\t\tint tmp = Tree[x].ch[0];\n\t\t\tnewnode (L, R - 1, x, 0); connect (tmp, cnt, 0);\n\t\t\tTree[x].x = Tree[x].y;\n\t\t\tpush_up(cnt), push_up(x); splay (cnt, 0);\n\t\t\tS[R - 1] = cnt, S[R] = x;\n\t\t\treturn ;\n\t\t}\n\t\tint tmp = Tree[x].ch[1];\n\t\tnewnode (val + 1, R, x, 1); connect (tmp, cnt, 1); push_up(cnt);\n\t\ttmp = Tree[x].ch[0];\n\t\tnewnode (L, val - 1, x, 0); connect (tmp, cnt, 0);\n\t\tTree[x].x = Tree[x].y = val;\n\t\tpush_up(cnt), push_up(x);\n\t\tS[val - 1] = cnt, S[val] = x, S[R] = cnt - 1;\n\t\tsplay (x, 0);\n\t}\n\n\tinline void put (int x, int op)\n\t{\n\t\tsplay (x, 0);\n\t\tint now = Tree[x].ch[0];\n\t\tif (!now) { root = Tree[x].ch[1]; connect (root, 0, 0); goto XZAKIOI; }\n\t\twhile (Tree[now].ch[1]) now = Tree[now].ch[1];\n\t\tsplay (now, x);\n\t\troot = now;\n\t\tconnect (now, 0, 0); connect (Tree[x].ch[1], root, 1);\n\t\tpush_up(root);\nXZAKIOI:;\n\t\tTree[x].ch[0] = Tree[x].ch[1] = Tree[x].fa = 0;\n\t\tnow = root;\n\t\twhile (Tree[now].ch[op]) now = Tree[now].ch[op];\n\t\tsplay(now, 0);\n\t\tconnect (x, now, op);\n\t\tpush_up(x), push_up(now);\n\t\tsplay(x, 0);\n\t}\n\n\tinline int query (int x) { splay(x, 0); int ans = Tree[Tree[x].ch[0]].size + Tree[x].y - Tree[x].x + 1; return ans; }\n\n\tinline int find (int k)\n\t{\n\t\tint now = root;\n\t\twhile (1)\n\t\t{\n\t\t\tint sum = Tree[Tree[now].ch[0]].size + Tree[now].y - Tree[now].x + 1;\n\t\t\tif (Tree[Tree[now].ch[0]].size < k && k <= sum) return Tree[now].x + k - Tree[Tree[now].ch[0]].size - 1;\n\t\t\tif (sum < k) k -= sum, now = Tree[now].ch[1];\n\t\t\telse now = Tree[now].ch[0];\n\t\t}\n\t}\n}\n\nint main()\n{\n#ifdef hk_cnyali\n\tfreopen(\"A.in\", \"r\", stdin);\n\tfreopen(\"A.out\", \"w\", stdout);\n#endif\n\tN = read(), M = read();\n\tSplay :: init();\n\tint ans = 0;\n\twhile (M--)\n\t{\n\t\tint op = read();\n\t\tif (op == 1)\n\t\t{\n\t\t\tint x = read() - ans, y = read() - ans; int pos = S.lower_bound(x) -> y;\n/**/\t\tSplay :: split (pos, x);\n\t\t\tprintf(\"%d\\n\", ans = Splay :: query(pos));\n\t\t\tTree[pos].x = Tree[pos].y = y;\n\t\t\tS[y] = pos;\n\t\t}\n\t\telse if (op == 2 || op == 3)\n\t\t{\n/**/\t\tint val = read() - ans, x = S.lower_bound(val) -> y;\n\t\t\tSplay :: split (x, val);\n\t\t\tprintf(\"%d\\n\", ans = Splay :: query(x));\n\t\t\tSplay :: put(x, op - 2);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint x = read() - ans;\n\t\t\tprintf(\"%d\\n\", ans = Splay :: find(x));\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\n\n\n### Debug\n\n* 147L: x写成pos\n* 154L: lower_bound(val)写成lower_bound(x)\n\n我居然一道这么长的代码只调了这两个小细节就过样例然后A了。。。\n\n虽然说这道题花了我三个晚上的时间想+码\n","categories":["Problem"],"tags":["Splay","省选"]},{"title":"「CSU1811」 Tree Intersection - 启发式合并","url":"/2018/08/31/CSU1811-hncpc2016-I-Tree-Intersection-%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/","content":"\n题目链接：[传送门](http://acm.csu.edu.cn/csuoj/problemset/problem?pid=1811)\n\n### Description\n\n给你一颗$n$个点的树 每个点有一种颜色 问你对于每一条边，去掉这条边之后剩下的两个部分的颜色集合交集的大小\n\n\n\n### Constraints\n\n$n\\le 10^5$\n\n<!--more-->\n\n### Input\n\nThe input contains at most 15 sets. For each set:\n\nThe first line contains an integer $n$ ($2\\le n\\le10^5$).\n\nThe second line contains $n$ integers $c_1,c_2,...,c_n$ ($1\\le c_i\\le n$).\n\nThe i-th of the last $(n-1)$ lines contains$ 2$ integers ai,bi ($1\\le a_i,b_i\\le n$).\n\n\n\n### Output\n\nFor each set,$ (n-1)$ integers $R_1,R_2,...,R_{n-1}$\n\n\n\n### Sample Input\n\n> 4\n>\n> 1 2 2 1\n>\n> 1 2\n>\n> 2 3\n>\n> 3 4\n>\n> 5\n>\n> 1 1 2 1 2\n>\n> 1 3\n>\n> 2 3\n>\n> 3 5\n>\n> 4 5\n\n\n\n### Sample Output\n\n> 1\n>\n> 2\n>\n> 1\n>\n> 1\n>\n> 1\n>\n> 2\n>\n> 1\n\n\n\n### Solution\n\n首先题意可以转化为 求出每个子树内每种颜色出现次数，如果次数等于$0$或者等于这种颜色在整棵树里出现的次数的话显然这个颜色就没有贡献，否则就有贡献\n\n所以我们就可以直接树上启发式合并，用map或者线段树合并都行\n\n\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define x1 X1 \n#define x2 X2\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) {return a < b ? a = b, 1 : 0;}\ntemplate <typename T> inline int Chkmin (T &a, T b) {return a > b ? a = b, 1 : 0;}\ninline int read ()\n{\n\tint sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\nconst int Maxn = 2e5 + 100;\n\nint N, M, e, Begin[Maxn], Next[Maxn << 1], To[Maxn << 1], C[Maxn << 1], Id[Maxn << 1];\nint Sum[Maxn], Ans[Maxn];\nmap <int, int> Cnt[Maxn];\n\ninline void add_edge (int x, int y, int z)\n{\n\tTo[++e] = y;\n\tNext[e] = Begin[x];\n\tBegin[x] = e;\n\tId[e] = z;\n}\n\nvoid dfs (int x, int f, int id)\n{\n\tCnt[x][C[x]] = 1;\n\tif (Sum[C[x]] > 1) Ans[id] ++;\n\tfor (int i = Begin[x]; i; i = Next[i])\n\t{\n\t\tint y = To[i];\n\t\tif (y == f) continue;\n\t\tdfs(y, x, Id[i]);\n\t\tif (Cnt[x].size() < Cnt[y].size()) { swap(Cnt[x], Cnt[y]); Ans[id] = Ans[Id[i]]; }\n\t\tfor (auto now : Cnt[y])\n\t\t{\n\t\t\tif (Cnt[x].count(now.x))\n\t\t\t{\n\t\t\t\tCnt[x][now.x] += now.y;\n\t\t\t\tif (Cnt[x][now.x] == Sum[now.x]) Ans[id] --;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tCnt[x][now.x] = now.y;\n\t\t\t\tif (Cnt[x][now.x] < Sum[now.x]) Ans[id] ++;\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline void Init()\n{\n\tmemset(Begin, 0, sizeof Begin);\n\tmemset(Sum, 0, sizeof Sum);\n\tmemset(Ans, 0, sizeof Ans);\n\te = 0;\n}\n\nint main()\n{\n#ifdef hk_cnyali\n\tfreopen(\"I.in\", \"r\", stdin);\n\tfreopen(\"I.out\", \"w\", stdout);\n#endif\n\twhile (~scanf(\"%d\", &N))\n\t{\n\t\tInit();\n\t\tfor (int i = 1; i <= N; ++i) Cnt[i].clear(), C[i] = read(), Sum[C[i]] ++;\n\t\tfor (int i = 1; i < N; ++i)\n\t\t{\n\t\t\tint x = read(), y = read();\n\t\t\tadd_edge (x, y, i);\n\t\t\tadd_edge (y, x, i);\n\t\t}\n\t\tdfs(1, 0, 0);\n\t\tfor (int i = 1; i < N; ++i) printf(\"%d\\n\", Ans[i]);\n\t}\n\treturn 0;\n}\n\n```\n\n","categories":["Problem"],"tags":["数据结构","启发式合并","map","ACM-ICPC"]},{"title":"「Luogu3765」总统选举 - 线段树 + Splay","url":"/2018/08/29/Luogu-P3765-%E6%80%BB%E7%BB%9F%E9%80%89%E4%B8%BE-%E7%BA%BF%E6%AE%B5%E6%A0%91-Splay/","content":"\n题目链接：[传送门](https://www.luogu.org/problemnew/show/P3765)\n\n### Description\n\n秋之国共有$n$个人，分别编号为$1,2,...,n$ 一开始每个人都投了一票，范围$1-n$，表示支持对应编号的人当总统。\n\n共有$m$次预选，每次选取编号$[l_i,r_i]$内的选民展开小规模预选，在该区间内获得超过区间大小一半的票的人获胜。如果没有人获胜，则由小C钦定一位候选者获得此次预选的胜利（获胜者可以不在该区间内）\n\n每次预选的结果需要公布出来，并且每次会有$k_i$个人决定将票改投向该次预选的获胜者。全部预选结束后，公布最后成为总统的候选人。\n\n\n\n### Constraints\n\n$1\\le n,m\\le 500,000,\\sum k_i\\le 10^6, 1\\le l_i\\le r_i \\le n, 1\\le s_i \\le n$\n\n<!--more-->\n\n\n\n### Input\n\n第一行两个整数$n,m$，表示秋之国人数和预选次数。\n\n第二行$n$个整数，分别表示编号$1-n$的选民投的票。\n\n接下来$m$行，每行先有4个整数，分别表示$l_i,r_i,s_i,k_i$，$s_i$表示若此次预选无人胜选，视作编号为$s_i$的人获得胜利，接下来$k_i$个整数，分别表示决定改投的选民。\n\n\n\n### Output\n\n共$m+1$行，前$m$行表示各次预选的结果，最后一行表示最后成为总统的候选人，若最后仍无人胜选，输出-1。\n\n\n\n### Sample Input\n\n> 5 4\n>\n> 1 2 3 4 5\n>\n> 1 2 1 1 3\n>\n> 5 5 1 2 2 4\n>\n> 2 4 2 0\n>\n> 3 4 2 1 4\n\n\n\n### Sample Output\n\n> 1\n>\n> 5\n>\n> 5\n>\n> 2\n>\n> -1\n\n\n\n### Solution\n\n首先，过半众数的求法在[BZOJ2456](https://www.lydsy.com/JudgeOnline/problem.php?id=2456)就有提到\n\n可以记录val表示当前最可能为众数的那个数，cnt表示这个数当前出现了多少次\n\n碰到一个数，如果它和val相同，则cnt++，否则如果cnt==0那么val=当前这个数，否则cnt--\n\n这个办法可以快速求出过半众数\n\n同理，这个方法也可以扩展到这道题上来，显然val和cnt这两个信息能够合并，我们只需要用线段树维护即可\n\n但是这样求出来的val只是最有可能的那个一个值，无法判断它到底有没有过半\n\n那么就需要用一个Splay来维护每个人的得票信息，具体来说就是每个人开一个Splay，里面存所有选了他的人的信息，然后只需要支持插入删除和查询权值在$l-r$之间的数的个数即可\n\n\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define x1 X1 \n#define x2 X2\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) {return a < b ? a = b, 1 : 0;}\ntemplate <typename T> inline int Chkmin (T &a, T b) {return a > b ? a = b, 1 : 0;}\ninline int read ()\n{\n\tint sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\nconst int Maxn = 500000 + 100;\n\nint N, M;\n\nint A[Maxn];\n\nnamespace SEG\n{\n#define ls Tree[root << 1]\n#define rs Tree[root << 1 | 1]\n#define lson root << 1, l, mid\n#define rson root << 1 | 1, mid + 1, r\n\tstruct tree\n\t{\n\t\tint cnt, val;\n\t}Tree[Maxn << 2];\n\tinline tree merge (tree x, tree y)\n\t{\n\t\ttree tmp;\n\t\tif (x.val == y.val) tmp.cnt = x.cnt + y.cnt;\n\t\telse tmp.cnt = abs(x.cnt - y.cnt);\n\t\ttmp.val = x.cnt > y.cnt ? x.val : y.val;\n/**/\treturn tmp;\n\t}\n\n\tinline void push_up (int root) { Tree[root] = merge (Tree[root << 1], Tree[root << 1 | 1]); }\n\n\tinline void build (int root, int l, int r)\n\t{\n\t\tif (l == r) { Tree[root].cnt = 1, Tree[root].val = A[l]; return ; }\n\t\tint mid = l + r >> 1;\n\t\tbuild (lson), build (rson);\n\t\tpush_up (root);\n\t}\n\n\tinline void modify (int root, int l, int r, int x, int v)\n\t{\n\t\tif (l == r) { Tree[root].val = v; return ; }\n\t\tint mid = l + r >> 1;\n\t\tif (x <= mid) modify (lson, x, v);\n\t\telse modify (rson, x, v);\n\t\tpush_up (root);\n\t}\n\n\tinline tree query (int root, int l, int r, int x, int y)\n\t{\n\t\tif (x <= l && r <= y) return Tree[root];\n\t\tint mid = l + r >> 1; tree ans;\n\t\tif (x > mid) return query (rson, x, y);\n\t\telse if (y <= mid) return query (lson, x, y);\n\t\treturn merge (query (lson, x, y), query (rson, x, y));\n\t}\n#undef ls\n#undef rs\n#undef lson\n#undef rson\n}\n\nstruct tree\n{\n\tint val, ch[2], size, fa;\n}Tree[2000000 + 100];\nint cnt;\n\nstruct Splay\n{\n\tint root;\n\tinline void push_up (int root) { Tree[root].size = Tree[Tree[root].ch[0]].size + Tree[Tree[root].ch[1]].size + 1; }\n\tinline int judge_dir (int x) { return Tree[Tree[x].fa].ch[1] == x; }\n\tinline void connect (int x, int f, int dir) { Tree[x].fa = f; Tree[f].ch[dir] = x; }\n\tinline void newnode (int val, int f, int dir) { Tree[++cnt].size = 1; Tree[cnt].val = val; connect (cnt, f, dir); }\n\n\tinline void rotate (int x)\n\t{\n\t\tint f = Tree[x].fa, anc = Tree[f].fa, dirx = judge_dir(x), dirf = judge_dir(f);\n\t\tconnect (Tree[x].ch[dirx ^ 1], f, dirx);\n\t\tconnect (f, x, dirx ^ 1);\n\t\tconnect (x, anc, dirf);\n\t\tpush_up(f), push_up(x);\n\t}\n\n\tinline void splay (int x, int y)\n\t{\n/**/\twhile (Tree[x].fa != y) /*差点写错...*/\n\t\t{\n\t\t\tint f = Tree[x].fa, dirx = judge_dir(x), dirf = judge_dir(f), anc = Tree[f].fa;\n\t\t\tif (anc == y) rotate(x);\n\t\t\telse if (dirx == dirf) rotate(f), rotate(x);\n\t\t\telse rotate(x), rotate(x);\n\t\t}\n/**/\tif (!y) root = x;\n\t}\n\n\tinline void insert_or_erase (int val)\n\t{\n\t\tif (!root) { newnode (val, 0, 0); root = cnt; return ; }\n\t\tint now = root;\n\t\twhile (1)\n\t\t{\n\t\t\tint dir = Tree[now].val <= val;\n\t\t\tif (Tree[now].val == val)\n\t\t\t{\n\t\t\t\tint x = now;\n\t\t\t\tsplay (x, 0);\n\t\t\t\tif (!Tree[x].ch[0]) { root = Tree[x].ch[1]; Tree[Tree[x].ch[1]].fa = 0; return ; }\n\t\t\t\tnow = Tree[x].ch[0];\n\t\t\t\twhile (Tree[now].ch[1]) now = Tree[now].ch[1];\n\t\t\t\tsplay (now, x); connect (Tree[x].ch[1], now, 1);\n\t\t\t\troot = now; Tree[now].fa = 0;\n\t\t\t\tpush_up(now);\n\t\t\t\treturn ;\n\t\t\t}\n\t\t\tif (!Tree[now].ch[dir]) { newnode (val, now, dir); splay (cnt, 0); return ; }\n\t\t\tnow = Tree[now].ch[dir];\n\t\t}\n\t}\n\n\tinline int find_val (int val)\n\t{\n\t\tint now = root;\n\t\twhile (1)\n\t\t{\n\t\t\tint dir = Tree[now].val < val;\n\t\t\tif (Tree[now].val == val || !Tree[now].ch[dir]) return now;\n\t\t\tnow = Tree[now].ch[dir];\n\t\t}\n\t}\n\n\tinline int query (int l, int r)\n\t{\n\t\tif (!root) return 0;\n\t\tint x = find_val(l);\n\t\tsplay (x, 0);\n\t\tif (Tree[x].val < l && Tree[x].ch[1]) { x = Tree[x].ch[1]; while (Tree[x].ch[0]) x = Tree[x].ch[0]; splay(x, 0); }\n\t\tint tmp = Tree[Tree[x].ch[0]].size + (Tree[x].val < l);\n\t\tx = find_val(r);\n\t\tsplay (x, 0);\n\t\tif (Tree[x].val > r && Tree[x].ch[0]) { x = Tree[x].ch[0]; while (Tree[x].ch[1]) x = Tree[x].ch[1]; splay(x, 0); }\n\t\treturn Tree[Tree[x].ch[0]].size + (Tree[x].val <= r) - tmp;\n\t}\n\n}S[Maxn];\n\nint main()\n{\n#ifdef hk_cnyali\n\tfreopen(\"A.in\", \"r\", stdin);\n\tfreopen(\"A.out\", \"w\", stdout);\n#endif\n\tN = read(), M = read();\n\tfor (int i = 1; i <= N; ++i)\n\t{\n\t\tA[i] = read();\n\t\tS[A[i]].insert_or_erase(i);\n\t}\n\tSEG :: build (1, 1, N);\n\twhile (M--)\n\t{\n\t\tint l = read(), r = read(), s = read(), k = read();\n\t\tint now = SEG :: query (1, 1, N, l, r).val;\n\t\tint sum = S[now].query(l, r);\n\t\tif (sum * 2 <= (r - l + 1)) now = s;\n\t\tprintf(\"%d\\n\", now);\n\t\tfor (int i = 1; i <= k; ++i)\n\t\t{\n\t\t\tint x = read();\n\t\t\tSEG :: modify (1, 1, N, x, now);\n\t\t\tS[A[x]].insert_or_erase(x);\n\t\t\tA[x] = now;\n\t\t\tS[A[x]].insert_or_erase(x);\n\t\t}\n\t}\n\tint now = SEG :: query (1, 1, N, 1, N).val;\n\tint sum = S[now].query(1, N);\n\tif (sum * 2 <= N) cout<<-1<<endl;\n\telse cout<<now<<endl;\n\treturn 0;\n}\n```\n\n\n\n### Debug\n\n* 49L: 记得return东西，一开始忘记return了。。。\n* 110L: 一开始写成了x!=y，不过写着写着就发现了，以后要注意\n* 117L: 要记得设root\n\n","categories":["Problem"],"tags":["线段树","数据结构","Splay"]},{"title":"8.27模拟赛 Summary","url":"/2018/08/28/8-27%E6%A8%A1%E6%8B%9F%E8%B5%9B-Summary/","content":"","categories":["Summary"],"tags":["Summary","构造","数据结构","树状数组","二分","01Trie","Trie","ST表"]},{"title":"「ZJOI2007」报表统计 - set","url":"/2018/08/17/Luogu-P1110-ZJOI2007-%E6%8A%A5%E8%A1%A8%E7%BB%9F%E8%AE%A1-set/","content":"\n题目链接：[传送门](https://www.luogu.org/problemnew/show/P1110)\n\n### Description\n\n在最开始的时候，有一个长度为$N$的整数序列，并且有以下三种操作：\n\n* `INSERT i k`：在原数列的第$i$个元素后面添加一个新元素 $k$ ；如果原数列的第 $i$ 个元素已经添加了若干元素，则添加在这些元素的最后\n\n- `MIN_GAP`：查询相邻两个元素的之间差值（绝对值）的最小值\n- `MIN_SORT_GAP`：查询所有元素中最接近的两个元素的差值（绝对值）\n\n \n\n### Constraints\n\n$N,M\\le500000$,序列内的数$\\le5\\times10^8$\n\n<!--more-->\n\n### Solution\n\n可以写Splay，但是直接set就行\n\n维护两个set：S1存当前加入的所有元素的set；S2存相邻元素的差值\n\n再维护一下每段区间的最前面和最后面的那个值(A[i],B[i])即可\n\n\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define x1 X1 \n#define x2 X2\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) {return a < b ? a = b, 1 : 0;}\ntemplate <typename T> inline int Chkmin (T &a, T b) {return a > b ? a = b, 1 : 0;}\ninline int read ()\n{\n\tint sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\nconst int Maxn = 500000 + 100;\n\nint N, M, A[Maxn], B[Maxn], Ans[Maxn];\n\nmultiset <int> S1, S2;\n\nint main()\n{\n#ifdef hk_cnyali\n\tfreopen(\"A.in\", \"r\", stdin);\n\tfreopen(\"A.out\", \"w\", stdout);\n#endif\n\tN = read(), M = read();\n\tint ans = INT_MAX;\n\tS1.insert(INT_MIN);\n\tS1.insert(INT_MAX);\n\tfor (int i = 1; i <= N; ++i)\n\t{\n\t\tA[i] = B[i] = read();\n\t\tChkmin(ans, min(abs(*(S1.lower_bound(A[i])) - A[i]), abs(*(--S1.lower_bound(A[i])) - A[i])));\n\t\tS1.insert(A[i]);\n\t}\n\tfor (int i = 1; i < N; ++i)\n\t\tS2.insert(abs(A[i] - A[i + 1]));\n\tfor (int i = 1; i <= M; ++i)\n\t{\n\t\tchar s[20];\n\t\tscanf(\"%s\", s);\n\t\tif (s[0] == 'I')\n\t\t{\n\t\t\tint x = read(), y = read();\n\t\t\tChkmin(ans, min(abs(*(S1.lower_bound(y)) - y), abs(*(--S1.lower_bound(y)) - y)));\n\t\t\tS1.insert(y);\n\t\t\tS2.erase(S2.find(abs(A[x + 1] - B[x])));\n\t\t\tS2.insert(abs(A[x + 1] - y)); S2.insert(abs(B[x] - y));\n\t\t\tB[x] = y;\n\t\t}\n\t\telse if (s[4] == 'S')\n\t\t\tprintf(\"%d\\n\", ans);\n\t\telse\n\t\t\tprintf(\"%d\\n\", *S2.begin());\n\t}\n\treturn 0;\n}\n\n```\n\n","categories":["Problem"],"tags":["set","省选"]},{"title":"「NOIp2017」 列队 - Splay分裂","url":"/2018/08/17/Luogu-P3960-NOIp2017-%E5%88%97%E9%98%9F-Splay%E5%88%86%E8%A3%82/","content":"\n题目链接：[传送门](https://www.luogu.org/problemnew/show/P3960)\n\n### Description\n\nSylvia所在的方阵中有$n \\times m$名学生,方阵的行数为 $n$,列数为 $m$。\n\n为了便于管理,教官在训练开始时,按照从前到后,从左到右的顺序给方阵中的学生从 $1$ 到 $n \\times m$ 编上了号码(参见后面的样例)。即:初始时,第 $i$ 行第 $j$ 列的学生的编号是$(i - 1) \\times m + j$\n\n然而在练习方阵的时候,经常会有学生因为各种各样的事情需要离队。在一天中,一共发生了 $q$ 件这样的离队事件。每一次离队事件可以用数对$(x, y) (1\\le x\\le n,1\\le y\\le m)$描述,表示第 $x$ 行第 $y$ 列的学生离队。\n\n在有学生离队后,队伍中出现了一个空位。为了队伍的整齐,教官会依次下达这样的两条指令:\n\n1. 向左看齐。这时第一列保持不动,所有学生向左填补空缺。不难发现在这条指令之后,空位在第 $x$ 行第 $m$ 列。\n2. 向前看齐。这时第一行保持不动,所有学生向前填补空缺。不难发现在这条指令之后,空位在第 $n$ 行第 $m$ 列\n\n教官规定不能有两个或更多学生同时离队。即在前一个离队的学生归队之后,下一个学生才能离队。\n\n因此在每一个离队的学生要归队时,队伍中有且仅有第 $n$ 行第 m 列一个空位,这时这个学生会自然地填补到这个位置。\n\n因为站方阵真的很无聊,所以 Sylvia 想要计算每一次离队事件中,离队的同学的编号是多少。\n\n注意:每一个同学的编号不会随着离队事件的发生而改变,在发生离队事件后方阵中同学的编号可能是乱序的。\n\n\n\n### Constraints\n\n$n,m,q\\le 3\\times10^5$\n\n<!--more-->\n\n### Solution\n\n考虑一次离队就是将这一行的中间某个数删掉加入最后一列的末尾，将最后一列的某个数删掉加入这一行的末尾\n\n显然我们对于每一行和最后一列开一个Splay维护即可\n\n但是如果直接建Splay的话显然会爆空间，我们可以把Splay中的每一个点代表一段连续的区间，然后操作的时候再分裂开来即可\n\n\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define int long long\n#define x first\n#define y second\n#define x1 X1 \n#define x2 X2\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) {return a < b ? a = b, 1 : 0;}\ntemplate <typename T> inline int Chkmin (T &a, T b) {return a > b ? a = b, 1 : 0;}\ninline int read ()\n{\n\tint sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\nconst int Maxn = 3e5 + 100;\n\nint N, M, Q;\nstruct tree\n{\n\tint ch[2], fa, idx, idy, size;\n}Tree[Maxn * 10];\nint cnt_all;\nstruct Splay\n{\n\tint root;\n/**/inline void push_up (int x) { Tree[x].size = Tree[Tree[x].ch[0]].size + Tree[Tree[x].ch[1]].size + Tree[x].idy - Tree[x].idx + 1;}\n\tinline int judge_dir (int x) { return Tree[Tree[x].fa].ch[1] == x; }\n\tinline void connect (int x, int f, int dir) { Tree[x].fa = f; Tree[f].ch[dir] = x; }\n\tinline void newnode (int idx, int idy, int f, int dir)\n\t{\n\t\tTree[++cnt_all].idx = idx; Tree[cnt_all].idy = idy; \n\t\tTree[cnt_all].size = idy - idx + 1;\n\t\tconnect (cnt_all, f, dir);\n\t}\n\tinline void rotate (int x)\n\t{\n\t\tint f = Tree[x].fa, dirx = judge_dir(x), anc = Tree[f].fa, dirf = judge_dir(f);\n\t\tconnect(Tree[x].ch[dirx ^ 1], f, dirx); connect(x, anc, dirf); connect(f, x, dirx ^ 1);\n\t\tpush_up(f), push_up(x);\n\t}\n\tinline void splay (int x, int y)\n\t{\n\t\twhile (Tree[x].fa != y)\n\t\t{\n\t\t\tint f = Tree[x].fa, dirx = judge_dir(x), anc = Tree[f].fa, dirf = judge_dir(f);\n\t\t\tif (anc == y) rotate(x);\n\t\t\telse if (dirx == dirf) rotate(f), rotate(x);\n\t\t\telse rotate(x), rotate(x);\n\t\t}\n\t\tif (!y) root = x;\n\t}\n\tinline void insert (int idx, int idy) \n\t{ \n\t\tif (!root) { newnode (idx, idy, 0, 0); root = cnt_all; return ; }\n\t\tint now = root;\n\t\twhile (Tree[now].ch[1]) now = Tree[now].ch[1];\n\t\tnewnode(idx, idy, now, 1);\n\t\tsplay(cnt_all, 0);\n\t}\n\tinline int find (int k)\n\t{\n\t\tint now = root;\n\t\twhile (1)\n\t\t{\n\t\t\tint tmp = Tree[now].ch[0];\n\t\t\tif (Tree[tmp].size < k && k <= Tree[tmp].size + Tree[now].idy - Tree[now].idx + 1) { splay(now, 0); return now; }\n\t\t\tif (Tree[tmp].size >= k) now = Tree[now].ch[0];\n\t\t\telse k -= Tree[tmp].size + Tree[now].idy - Tree[now].idx + 1, now = Tree[now].ch[1];\n\t\t}\n\t}\n\tinline void del (int x)\n\t{\n\t\tsplay(x, 0);\n\t\tif (!Tree[x].ch[0]) { root = Tree[x].ch[1]; Tree[Tree[x].ch[1]].fa = 0; return ; }\n\t\tint now = Tree[x].ch[0];\n\t\twhile (Tree[now].ch[1]) now = Tree[now].ch[1];\n\t\tsplay(now, x);\n\t\troot = now; Tree[now].fa = 0;\n\t\tconnect(Tree[x].ch[1], now, 1);\n\t\tpush_up(now);\n\t}\n\tinline int split (int pos, int val)\n\t{\n\t\tint x = find(pos);\n\t\tint save = Tree[x].idx + (pos - Tree[Tree[x].ch[0]].size) - 1;\n\t\tif (Tree[x].idx == Tree[x].idy) { del(x); return save; }\n\t\tif (pos != Tree[Tree[x].ch[0]].size + 1)\n\t\t{\n\t\t\tint tmp = Tree[x].idy;\n/**/    \tTree[x].idy = val - 1;\n\t\t\tif (val + 1 > tmp) { push_up(x); return save;}\n\t\t\tif (!Tree[x].ch[1]) { newnode(val + 1, tmp, x, 1); push_up(x); splay(cnt_all, 0); return save; }\n\t\t\tint now = Tree[x].ch[1];\n\t\t\twhile (Tree[now].ch[0]) now = Tree[now].ch[0];\n\t\t\tsplay(now, x);\n\t\t\tnewnode(val + 1, tmp, now, 0);\n\t\t\tpush_up(now), push_up(x);\n\t\t\tsplay(cnt_all, 0);\n\t\t\treturn save;\n\t\t}\n\t\tint tmp = Tree[x].idx;\n\t\tTree[x].idx = val + 1;\n\t\tif (val - 1 < tmp) { push_up(x); return save;}\n\t\tif (!Tree[x].ch[0]) { newnode(tmp, val - 1, x, 0); push_up(x); splay(cnt_all, 0); return save; }\n\t\tint now = Tree[x].ch[0];\n\t\twhile (Tree[now].ch[1]) now = Tree[now].ch[1];\n\t\tsplay(now, x);\n\t\tnewnode(tmp, val - 1, now, 1);\n\t\tpush_up(now), push_up(x);\n\t\tsplay(cnt_all, 0);\n\t\treturn save;\n\t}\n\tinline int query (int pos, int type)\n\t{\n\t\tint x = find(pos), tmp = Tree[x].idx + (pos - Tree[Tree[x].ch[0]].size) - 1;\n\t\tif (type) del(x);\n\t\treturn tmp;\n\t}\n}S[Maxn];\n\ninline int Index (int x, int y) { return (x - 1) * M + y; }\n\nmain()\n{\n#ifdef hk_cnyali\n\tfreopen(\"phalanx.in\", \"r\", stdin);\n\tfreopen(\"phalanx.out\", \"w\", stdout);\n#endif\n\tN = read(), M = read(), Q = read();\n\tfor (int i = 1; i <= N; ++i)\n\t\tS[i].insert(Index(i, 1), Index(i, M - 1)), S[0].insert(Index(i, M), Index(i, M));\n\twhile (Q--)\n\t{\n\t\tint x = read(), y = read();\n/**/\tif (y == M)\n\t\t{\n\t\t\tint tmp = S[0].query(x, 1);\n\t\t\tprintf(\"%lld\\n\", tmp);\n\t\t\tS[0].insert(tmp, tmp);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint tmp1 = S[x].split(y, S[x].query(y, 0)), tmp2 = S[0].query(x, 1);\n\t\t\tprintf(\"%lld\\n\", tmp1);\n\t\t\tS[x].insert(tmp2, tmp2); S[0].insert(tmp1, tmp1);\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\n\n\n### Debug\n\n* 39L: $size$要加上$idy - idx+1$\n* 103L: $val$和$pos$不要搞混，$pos$是询问当前这一行的第$pos$个，$val$是当前询问位置的答案(值)\n* 148L: 要特判$y=M$的情况\n* 要开long long\n\n","categories":["Problem"],"tags":["数据结构","Splay","NOIp"]},{"title":"8.16模拟赛 Summary","url":"/2018/08/16/8-16%E6%A8%A1%E6%8B%9F%E8%B5%9B-Summary/","content":"","categories":["Summary"],"tags":["Summary","最短路","状态压缩","二分","搜索"]},{"title":"8.15模拟赛 Summary","url":"/2018/08/16/8-15%E6%A8%A1%E6%8B%9F%E8%B5%9B-Summary/","content":"","categories":["Summary"],"tags":["Summary","动态规划","线段树","数据结构","暴力"]},{"title":"8-13模拟赛 Summary","url":"/2018/08/15/8-13%E6%A8%A1%E6%8B%9F%E8%B5%9B-Summary/","content":"","categories":["Summary"],"tags":["Summary","二分答案","线段树","数据结构","meet in middle","堆","贪心","状态压缩","two pointers","LCA"]},{"title":"8-12模拟赛 Summary","url":"/2018/08/13/8-12%E6%A8%A1%E6%8B%9F%E8%B5%9B-Summary/","content":"","categories":["Summary"],"tags":["容斥","Summary","动态规划","暴力","前缀和","点分治","two pointers"]},{"title":"8.10模拟赛 Summary","url":"/2018/08/10/8-10%E6%A8%A1%E6%8B%9F%E8%B5%9B-Summary/","content":"","categories":["Summary"],"tags":["Summary","线段树","数据结构","并查集","暴力","NTT"]},{"title":"8.9模拟赛 Summary","url":"/2018/08/09/8-9%E6%A8%A1%E6%8B%9F%E8%B5%9B-Summary/","content":"","categories":["Summary"],"tags":["Summary","动态规划","线段树","数据结构","线段树合并","状态压缩","概率和期望"]},{"title":"8.7模拟赛 Summary","url":"/2018/08/08/8-7%E6%A8%A1%E6%8B%9F%E8%B5%9B-Summary/","content":"","categories":["Summary"],"tags":["容斥","动态规划","线段树","数据结构","状态压缩","欧拉回路"]},{"title":"8.6模拟赛 Summary","url":"/2018/08/06/8-6%E6%A8%A1%E6%8B%9F%E8%B5%9B-Summary/","content":"","categories":["Summary"],"tags":["数论","Summary","动态规划","线段树","数据结构","贪心","概率和期望","矩阵快速幂","矩阵"]},{"title":"8.5模拟赛 Summary","url":"/2018/08/05/8-5%E6%A8%A1%E6%8B%9F%E8%B5%9B-Summary/","content":"","categories":["Summary"],"tags":["Summary","动态规划","线段树","数据结构","贪心","博弈"]},{"title":"8-4模拟赛 Summary","url":"/2018/08/04/8-4%E6%A8%A1%E6%8B%9F%E8%B5%9B-Summary/","content":"","categories":["Summary"],"tags":["Summary","动态规划","二分答案","二分图匹配","线段树","数据结构"]},{"title":"「NOI2008」志愿者招募 - 线性规划单纯形","url":"/2018/08/03/Luogu-P3980-BZOJ1061-NOI2008-%E5%BF%97%E6%84%BF%E8%80%85%E6%8B%9B%E5%8B%9F-%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E5%8D%95%E7%BA%AF%E5%BD%A2/","content":"\n\n\n题目链接：[传送门](https://www.luogu.org/problemnew/show/P3980)\n\n### Description\n\n一个项目需要$N$天完成，第$i$天至少需要$A_i$ 个人。一共有$M$类志愿者可以招募，第$i$类可以从第$S_i$ 天工作到第$T_i$天，招募费用是每人$C_i$ 元。求满足条件的最小费用\n\n\n\n### Constraints\n\n$n\\leq 1000, m \\leq 10000$，题目中其他所涉及的数据均不超过$2^{31}-1$\n\n\n\n<!--more-->\n\n### Solution\n\n这道题原本是一道网络流建模神题，然而确是单纯形裸题\n\n设第$i​$类志愿者招募了$x_i​$人，$a_{i,j}​$表示第$i​$天第$j​$类志愿者能否工作，把$A_i​$看做$b_i​$，$C_i​$看做$c_i​$，那么就是线性规划比较一般的形式了：\n\n最小化$\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\sum_{j=1}^{n} c_jx_j$\n\n满足约束$\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\sum_{j=1}^{n}a_{i,j}x_j \\leq b_i\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ i=1,2,...m$\n\n$\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ x_j \\ge 0\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ j=1,2,...n$\n\n再对偶一下就变成了\n\n最大化$\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\sum_{i=1}^{m} b_iy_i$\n\n满足约束$\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\sum_{i=1}^{m}a_{i,j}y_i \\leq c_j\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ j=1,2,...n$\n\n$\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ y_i \\ge 0\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ i=1,2,...m$\n\n然后直接上单纯形就可以了\n\n单纯形通俗来讲就是通过不断地换元，代入消元来把目标函数$\\sum{c_ix_i}$的系数都变成负数，然后又因为$x_i$非负，就能在$x_i$都取$0$的时候求出最大值了\n\n要注意实际存系数的时候没有把它移项，一些正负号的问题要考虑清楚\n\n2016论文集[浅谈线性规划与对偶问题]上对单纯形的讲解比较细致，这两个也讲的比较好：[线性规划的单纯形法 - CSDN博客](<https://blog.csdn.net/u013632138/article/details/53609635> )、 [线性规划与单纯形算法](<https://wenku.baidu.com/view/ce5784754a7302768f99391d>)\n\n\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define x1 X1 \n#define x2 X2\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) {return a < b ? a = b, 1 : 0;}\ntemplate <typename T> inline int Chkmin (T &a, T b) {return a > b ? a = b, 1 : 0;}\ninline int read ()\n{\n\tint sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\nconst int Maxn = 1000 + 10, Maxm = 10000 + 10;\n\nint N, M;\ndouble A[Maxm][Maxn];\n\nnamespace Simplex\n{\n\tconst double eps = 1e-8;\n\tinline void pivot (int x, int y)\n\t{\n\t\tdouble tmp = A[x][y];\n\t\tfor (int j = 0; j <= N; ++j) A[x][j] /= tmp;\n\t\tfor (int i = 0; i <= M; ++i)\n\t\t\tif (i != x && abs(A[i][y]) > eps)\n\t\t\t{\n\t\t\t\ttmp = A[i][y]; A[i][y] = 0;\n\t\t\t\tfor (int j = 0; j <= N; ++j) A[i][j] -= tmp * A[x][j];\n\t\t\t}\n\t}\n\n\tinline void work ()\n\t{\n\t\twhile (1)\n\t\t{\n\t\t\tint x = 0, y = 0;\n\t\t\tfor (int j = 1; j <= N; ++j) if (A[0][j] > eps) { y = j; break; }\n\t\t\tif (!y) return ;\n\t\t\tdouble Min = 1.0 * 0x3f3f3f3f;\n\t\t\tfor (int i = 1; i <= M; ++i)\n\t\t\t\tif (A[i][y] > eps && A[i][0] / A[i][y] < Min)\n\t\t\t\t\tMin = A[i][0] / A[i][y], x = i;\n\t\t\tif (!x) return ;\n\t\t\tpivot(x, y);\n\t\t}\n\t}\n}\n\nint main()\n{\n#ifdef hk_cnyali\n\tfreopen(\"A.in\", \"r\", stdin);\n\tfreopen(\"A.out\", \"w\", stdout);\n#endif\n\tN = read(), M = read();\n\tfor (int j = 1; j <= N; ++j) scanf(\"%lf\", &A[0][j]);\n\tfor (int i = 1; i <= M; ++i)\n\t{\n\t\tint x = read(), y = read(); A[i][0] = 1.0 * read();\n\t\tfor (int j = x; j <= y; ++j)\n\t\t\tA[i][j] = 1.0;\n\t}\n\tSimplex :: work();\n\tprintf(\"%d\\n\",(int)(-A[0][0]));\n\treturn 0;\n}\n```\n\n","categories":["Problem"],"tags":["线性规划"]},{"title":"「ISIJ2018」table - 括号序列","url":"/2018/08/03/ISIJ-Round1T2-table-%E6%8B%AC%E5%8F%B7%E5%BA%8F%E5%88%97/","content":"\n### Description\n\n你需要将$2*n$个数字填在一个$2$行$n$列的格子中，要求满足对于每一个数都要比它左边和上方的数大，同时会钦定$p$个数$a_i$必须要填在第一行，$q$个数$b_i$必须要填在第二行，求方案数\n\n\n\n### Constraints\n\n$n \\le 10^6\\ \\ a_i,b_i\\le 8000$,保证输入数据有解（出题人原本卡空间，我就懒得去卡了。。。）\n\n\n\n<!--more-->\n\n\n\n### Solution\n\n首先我们可以~~打表~~发现$p=q=0$时，答案就是卡特兰数\n\n通过观察题目性质，我们考虑从小到大，从左至右填格子，那么如果一个状态是合法的，则当前第一行填过的数必须大于等于第二行填过的数\n\n结合$p=q=0$的卡特兰数，很容易想到这就是一个括号序列的问题，钦定的数字就相当于钦定了某一个位置必须是左括号或者右括号\n\n这个经典的问题的话直接$dp$就可以了，设$dp[i][j]$表示考虑到第$i$位，还剩$j$个左括号没匹配的方案数，直接转移即可\n\n但是因为$n \\le 10^6$，我们就只能$dp$到$m=\\max\\{a_i, b_i\\}$的位置，剩下的$n-m$位可以直接计算\n\n我们枚举在前$m$位中还剩$i$个左括号未匹配，在这$n-m$位中用$b$个右括号，$a$个左括号，且左括号数量必须小于等于右括号的数量，那么有\n\n![8-3-1](/images/8-3-1.png)\n\n如上图，数形结合看就是问从$A$点到$B$点不碰到$y=-1$有多少种走法（只↗或↘）\n\n这个~~套路~~问题可以用总的方案数减去碰到$y=-1$的方案数求得\n\n而总的方案数易知为$C_{a+b}^{i+\\frac{a+b-i}{2}}=C_{a+b}^{\\frac{a+b+i}{2}} $\n\n又因为$i+a=b$，化简得$C_{a+b}^{b}$\n\n而碰到$y=-1$的方案数就是从$A$点关于$y=-1$的对称点$A'$到$B$点的方案数，同样方式化简之后为$C_{a+b}^{b+1}$\n\n那么答案即为$\\sum dp[m][i]*(C_{a+b}^{b}-C_{a+b}^{b+1})$\n\n只是要注意每次$i+=2$，$b++$\n\n\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define int long long\n#define x first\n#define y second\n#define x1 X1 \n#define x2 X2\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) {return a < b ? a = b, 1 : 0;}\ntemplate <typename T> inline int Chkmin (T &a, T b) {return a > b ? a = b, 1 : 0;}\ninline int read ()\n{\n\tint sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = sum * 10 + ch - '0';\n\treturn sum * fl;\n}\n\nconst int Maxn = 2e6 + 100, Maxm = 8000 + 10, Mod = 998244353;\n\nint N, M, op[Maxm], Dp[2][Maxm], fac[Maxn], inv[Maxn];\n\ninline int Pow (int a, int b)\n{\n\tint ans = 1;\n\twhile (b)\n\t{\n\t\tif (b & 1) ans = 1ll * ans * a % Mod;\n\t\ta = 1ll * a * a % Mod;\n\t\tb >>= 1;\n\t}\n\treturn ans;\n}\n\ninline void Add (int &x, int y)\n{\n\tx %= Mod, y %= Mod;\n\tif (x < 0) x += Mod; if (y < 0) y += Mod;\n\tx += y;\n\tif (x >= Mod) x -= Mod; if (x < 0) x += Mod;\n}\n\ninline void Init()\n{\n\tfac[0] = 1;\n\tfor (int i = 1; i < Maxn; ++i) fac[i] = 1ll * fac[i - 1] * i % Mod;\n\tinv[Maxn - 1] = Pow(fac[Maxn - 1], Mod - 2);\n\tfor (int i = Maxn - 2; i >= 0; --i) inv[i] = 1ll * inv[i + 1] * (i + 1) % Mod;\n}\n\ninline int C (int n, int m)\n{\n\tif (n < m) return 0;\n\treturn 1ll * fac[n] * inv[m] % Mod * inv[n - m] % Mod;\n}\n\nmain()\n{\n\tfreopen(\"table.in\", \"r\", stdin);\n\tfreopen(\"table.out\", \"w\", stdout);\n\tN = read() * 2;\n\tInit();\n\tint tot = read();\n\twhile (tot--) { int x = read(); Chkmax(M, x); op[x] = 1; }\n\ttot = read();\n\twhile (tot--) { int x = read(); Chkmax(M, x); op[x] = 2; }\n\tDp[0][0] = 1;\n\tint now = 0;\n\tfor (int i = 1; i <= M; ++i)\n\t{\n\t\tnow ^= 1;\n\t\tfor (int j = 0; j <= i; ++j)\n\t\t{\n\t\t\tDp[now][j] = 0;\n\t\t\tif (op[i] != 1) Add (Dp[now][j], Dp[now ^ 1][j + 1]);\n\t\t\tif (op[i] != 2 && j) Add (Dp[now][j], Dp[now ^ 1][j - 1]);\n\t\t}\n\t}\n\tif (N == M) { cout<<Dp[now][0]<<endl; return 0; }\n\tN -= M;\n\tint sum = N + 1 >> 1, ans = 0;\n\tfor (int i = (N & 1); i <= min(N, M) && sum <= N; i += 2)\n\t{\n//\t\tcout<<Dp[now][i]<<\" \"<<C(N, sum) - C(N, sum + 1)<<endl;\n\t\tAdd (ans, 1ll * Dp[now][i] * (C(N, sum) - C(N, sum + 1)) % Mod);\n\t\t++sum;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n```\n\n","categories":["Problem"],"tags":["数学","括号序列"]},{"title":"8-2模拟赛 Summary","url":"/2018/08/02/8-2%E6%A8%A1%E6%8B%9F%E8%B5%9B-Summary/","content":"","categories":["Summary"],"tags":["Summary","tarjan","缩点","二分答案","数据结构","点双","差分","随机"]},{"title":"8.1模拟赛 Summary","url":"/2018/08/01/8-1%E6%A8%A1%E6%8B%9F%E8%B5%9B-Summary/","content":"","categories":["Summary"],"tags":["Summary","动态规划","线段树","数据结构","线段树合并","搜索","IDA*"]},{"title":"「BZOJ1001」狼抓兔子 - 网络流","url":"/2018/07/24/BZOJ1001-BeiJing2006-%E7%8B%BC%E6%8A%93%E5%85%94%E5%AD%90-%E7%BD%91%E7%BB%9C%E6%B5%81/","content":"\n题目链接：[传送门](https://www.lydsy.com/JudgeOnline/problem.php?id=1001)\n\n### Description\n\n左上角点为 $(1,1)$，右下角点为 $(n,m)$，有以下三种类型的道路：\n\n1. $(x, y) \\Leftrightarrow (x + 1, y)$\n2. $(x, y) \\Leftrightarrow (x, y + 1)$\n3. $(x, y) \\Leftrightarrow (x + 1, y + 1)$\n\n道路上的权值表示这条路上最多能够通过的兔子数，道路是无向的。左上角和右下角为兔子的两个窝，开始时所有的兔子都聚集在左上角 $(1,1)$ 的窝里，现在它们要跑到右下解 $(n,m)$ 的窝中去，狼王开始伏击这些兔子。当然为了保险起见，如果一条道路上最多通过的兔子数为 $K$，狼王需要安排同样数量的 $K$ 只狼，才能完全封锁这条道路，你需要帮助狼王安排一个伏击方案，使得在将兔子一网打尽的前提下，参与的狼的数量要最小。因为狼还要去找喜羊羊麻烦.\n\n\n\n### Constraints\n\n$n,m \\leq 1000$\n\n<!--more-->\n\n### Solution\n\n题意就是求最小割\n\n正解是平面图转对偶图，实际上直接暴力上Dinic在加上一点玄学~~(优化)~~居然也能过\n\n相当于是复习一下Dinic板子吧\n\n\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define x1 X1 \n#define x2 X2\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) {return a < b ? a = b, 1 : 0;}\ntemplate <typename T> inline int Chkmin (T &a, T b) {return a > b ? a = b, 1 : 0;}\ninline int read ()\n{\n\tint sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = sum * 10 + ch - '0';\n\treturn sum * fl;\n}\n\nconst int Maxn = 1e6 + 100, Maxm = 6e6 + 100, inf = 0x3f3f3f3f;\n\nint N, M;\n\ninline int id (int x, int y) { return (x - 1) * M + y; }\n\nnamespace Dinic\n{\n\tint e, Begin[Maxn], To[Maxm], Next[Maxm], W[Maxm];\n\tint level[Maxn], Cur[Maxn];\n\n\tinline void init ()\n\t{\n\t\tmemset(Begin, 0, sizeof Begin);\n\t\te = 1;\n\t}\n\n\tinline void add_edge (int x, int y, int z)\n\t{\n//\t\tif (z) cout<<x<<\" \"<<y<<\" \"<<z<<endl;\n\t\tTo[++e] = y;\n\t\tNext[e] = Begin[x];\n\t\tBegin[x] = e;\n\t\tW[e] = z;\n\t}\n\n\tinline int bfs ()\n\t{\n\t\tmemset(level, -1, sizeof level);\n\t\tstatic queue <int> Q;\n\t\tQ.push(1);\n\t\tlevel[1] = 0;\n\t\twhile (!Q.empty())\n\t\t{\n\t\t\tint x = Q.front(); Q.pop();\n\t\t\tfor (int i = Begin[x]; i; i = Next[i])\n\t\t\t{\n\t\t\t\tint y = To[i];\n\t\t\t\tif (W[i] > 0 && level[y] < 0)\n\t\t\t\t{\n\t\t\t\t\tlevel[y] = level[x] + 1;\n\t\t\t\t\tQ.push(y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (level[id(N, M)] < 0) return 0;\n\t\treturn 1;\n\t}\n\n\tinline int find (int x, int now)\n\t{\n\t\tif (x == id(N, M) || !now) return now;\n\t\tint sum = 0;\n\t\tfor (int &i = Cur[x]; i; i = Next[i])\n\t\t{\n\t\t\tint y = To[i];\n\t\t\tif (W[i] > 0 && level[y] == level[x] + 1)\n\t\t\t{\n\t\t\t\tint tmp = find(y, min(now, W[i]));\n\t\t\t\tW[i] -= tmp;\n\t\t\t\tW[i ^ 1] += tmp;\n\t\t\t\tnow -= tmp, sum += tmp;\n\t\t\t\tif (!now) break;\n\t\t\t}\n\t\t}\n\t\tif (!sum) level[x] = -1;\n\t\treturn sum;\n\t}\n\n\tint main()\n\t{\n\t\tint ans = 0, sum;\n\t\twhile (bfs())\n\t\t{\n\t\t\tfor (int i = 1; i <= id(N, M); ++i) Cur[i] = Begin[i];\n\t\t\twhile (sum = find(1, inf)) ans += sum;\n\t\t}\n\t\treturn ans;\n\t}\n}\n\nint main()\n{\n#ifdef hk_cnyali\n\tfreopen(\"A.in\", \"r\", stdin);\n\tfreopen(\"A.out\", \"w\", stdout);\n#endif\n\tN = read(), M = read();\n\tDinic :: init();\n\tfor (int i = 1; i <= N; ++i)\n\t\tfor (int j = 1; j < M; ++j)\n\t\t{\n\t\t\tint x = read();\n\t\t\tDinic :: add_edge (id(i, j), id(i, j + 1), x);\n\t\t\tDinic :: add_edge (id(i, j + 1), id(i, j), x);\n\t\t}\n\tfor (int i = 1; i < N; ++i)\n\t\tfor (int j = 1; j <= M; ++j)\n\t\t{\n\t\t\tint x = read();\n\t\t\tDinic :: add_edge (id(i, j), id(i + 1, j), x);\n\t\t\tDinic :: add_edge (id(i + 1, j), id(i, j), x);\n\t\t}\n\tfor (int i = 1; i < N; ++i)\n\t\tfor (int j = 1; j < M; ++j)\n\t\t{\n\t\t\tint x = read();\n\t\t\tDinic :: add_edge (id(i, j), id(i + 1, j + 1), x);\n\t\t\tDinic :: add_edge (id(i + 1, j + 1), id(i, j), x);\n\t\t}\n\tprintf(\"%d\\n\", Dinic :: main());\n\treturn 0;\n}\n\n```\n\n","categories":["Problem"],"tags":["暴力","网络流","最大流","最小割","乱搞"]},{"title":"「NOIp模拟赛7-23」Find the One - 概率期望","url":"/2018/07/24/7-23-Find-the-One-%E6%A6%82%E7%8E%87%E6%9C%9F%E6%9C%9B/","content":"\n### Description\n\n一个$n * m$的地图，地图中’B’表示小B最初所在的位置；’+’表示空地；’#’表示障碍物(边界也为'')，小B若进入这里则会被遣送会他**原来所在的位置(不是初始位置)**，并耗费1步；’?’代表着未知，它会将小B传送到随机的另外一个’?’处，’?’的数量等于0或大于等于2；G’表示小B大哥的金牌，找到’G’就可能找到他的大哥。当小B选定一个方向时，他只有p的概率能到达他想去的方向，而到达剩下三个方向则分别有$\\frac{1−p}{3}$的概率。小B想尽快找到他的大哥，所以问你最优情况下从’B’到’G’的期望步数是多少。\n\n\n\n###  Constraints\n\n$1\\leq n\\leq m \\leq 20, 0\\leq p \\leq 1$\n\n\n\n<!--more-->\n\n### Solution\n\n设$dis[i][j]$表示**起点在(i,j)**的答案，初始为inf，所有$G$的$dis$值为0\n\n我们从所有的$G$开始bfs，将bfs到的除了#之外的点加入一个vector\n\n那么我们就能处理出一个bfs顺序的vector了（如果搜索到第一个?,那么需要将剩下所有的?都加入）\n\n接下来，我们按照vector的顺序，不断循环更新每个点的$dis$值\n\n* 如果当前字符不是?，那么枚举想去的方向并枚举实际去的方向统计答案\n\n  特别的，如果实际去的方向为#，那么显然还会留在原地\n\n  设最终答案为$ans$，不算留在原地的答案为$sum$，留在原地的概率为$stay$，那么有$ans = ans * stay + sum$，移项后有$ans = \\frac{sum}{1-stay}$，所以我们在算出$sum$后要除以一个$(1 - stay)$\n\n* 如果当前字符为?，那么除了上述过程以外，还需要枚举所有其他的?，新的答案为其他所有?的$dis$值的平均值+1\n\n求出新的答案后，与原有的$dis$值相比较，如果更小则更新。而如果将整个vector遍历之后没有一个值被更新的话，则说明当前已经是最优解，退出循环输出答案即可。\n\n时间复杂度$O(???)$\n\n\n\n### Debug\n\n* 60、61L：边界要设成#，不然后面判断会很复杂\n* 106L：pp一开始写成了int\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define x1 X1 \n#define x2 X2\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) {return a < b ? a = b, 1 : 0;}\ntemplate <typename T> inline int Chkmin (T &a, T b) {return a > b ? a = b, 1 : 0;}\ninline int read ()\n{\n\tint sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = sum * 10 + ch - '0';\n\treturn sum * fl;\n}\n\nconst int Maxn = 20 + 10;\nconst double eps = 1e-5;\n\ninline char safe_getchar()\n{\n\tchar ch = getchar();\n\twhile (ch != '#' && ch != 'B' && ch != '#' && ch != '?' && ch != 'G' && ch != '+') ch = getchar();\n\treturn ch;\n}\n\nvector <pii> gate, vec;\nqueue <pii> Q;\nint N, M, dr[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\nchar A[Maxn][Maxn];\ndouble P, Dis[Maxn][Maxn];\nint Vis[Maxn][Maxn];\n\nint main()\n{\n\tfreopen(\"find.in\", \"r\", stdin);\n\tfreopen(\"find.out\", \"w\", stdout);\n\tN = read(), M = read();\n\tscanf(\"%lf\", &P);\n\tint sx, sy;\n\tfor (int i = 1; i <= N; ++i)\n\t\tfor (int j = 1; j <= M; ++j)\n\t\t{\n\t\t\tDis[i][j] = 1e5;\n\t\t\tA[i][j] = safe_getchar();\n\t\t\tif (A[i][j] == '?') gate.pb(mp(i, j));\n\t\t\telse if (A[i][j] == 'G') Q.push(mp(i, j)), Vis[i][j] = 1, Dis[i][j] = 0.0;\n\t\t\telse if (A[i][j] == 'B') sx = i, sy = j;\n\t\t}\n/**/for (int i = 0; i <= M + 1; ++i) A[0][i] = A[N + 1][i] = '#';\n/**/for (int i = 0; i <= N + 1; ++i) A[i][0] = A[i][M + 1] = '#';\n\twhile (!Q.empty())\n\t{\n\t\tpii x = Q.front(); Q.pop();\n\t\tfor (int i = 0; i < 4; ++i)\n\t\t{\n\t\t\tint dx = x.x + dr[i][0], dy = x.y + dr[i][1];\n\t\t\tif (dx <= 0 || dy <= 0 || dx > N || dy > M || Vis[dx][dy] || A[dx][dy] == '#') continue;\n\t\t\tQ.push(mp(dx, dy));\n\t\t\tVis[dx][dy] = 1;\n\t\t\tvec.pb(mp(dx, dy));\n\t\t}\n\t\tif (A[x.x][x.y] == '?')\n\t\t{\n\t\t\tfor (int i = 0; i < gate.size(); ++i)\n\t\t\t{\n\t\t\t\tint dx = gate[i].x, dy = gate[i].y;\n\t\t\t\tif (Vis[dx][dy]) continue;\n\t\t\t\tQ.push(mp(dx, dy));\n\t\t\t\tVis[dx][dy] = 1;\n\t\t\t\tvec.pb(mp(dx, dy));\n\t\t\t}\n\t\t}\n\t}\n//\tfor (int i = 0; i < vec.size(); ++i) cout<<vec[i].x<<\" \"<<vec[i].y<<endl;\n\twhile (1)\n\t{\n\t\tint fl = 0;\n\t\tfor (int i = 0; i < vec.size(); ++i)\n\t\t{\n\t\t\tpii now = vec[i];\n\t\t\tdouble ans = 1e5, sum, stay;\n\t\t\tfor (int j = 0; j < 4; ++j)\n\t\t\t{\n\t\t\t\tsum = stay = 0;\n\t\t\t\tfor (int k = 0; k < 4; ++k)\n\t\t\t\t{\n\t\t\t\t\tint dx = now.x + dr[k][0], dy = now.y + dr[k][1];\n\t\t\t\t\tif (j == k)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (A[dx][dy] == '#') stay += P;\n\t\t\t\t\t\telse sum += Dis[dx][dy] * P;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n/**/\t\t\t\t\tdouble pp = (1.0 - P) / 3.0;\n\t\t\t\t\t\tif (A[dx][dy] == '#') stay += pp;\n\t\t\t\t\t\telse sum += Dis[dx][dy] * pp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsum += 1;\n\t\t\t\tif (stay < 1.0 - eps) sum /= (1.0 - stay);\n\t\t\t\telse sum = 1e5;\n\t\t\t\tif (sum < ans - eps) ans = sum;\n\t\t\t}\n\t\t\tif (A[now.x][now.y] == '?')\n\t\t\t{\n\t\t\t\tsum = 0;\n\t\t\t\tfor (int j = 0; j < gate.size(); ++j)\n\t\t\t\t{\n\t\t\t\t\tpii tmp = gate[j];\n\t\t\t\t\tif (tmp.x == now.x && tmp.y == now.y) continue;\n\t\t\t\t\tsum += Dis[tmp.x][tmp.y];\n\t\t\t\t}\n\t\t\t\tsum /= (1.0 * gate.size() - 1);\n\t\t\t\tsum += 1;\n\t\t\t\tif (sum < ans - eps) ans = sum;\n\t\t\t}\n\t\t\tif (ans < Dis[now.x][now.y] - eps) Dis[now.x][now.y] = ans, fl = 1;\n\t\t}\n\t\tif (!fl) break;\n\t}\n\tprintf(\"%.2lf\\n\", Dis[sx][sy]);\n\treturn 0;\n}\n```\n\n","categories":["Problem"],"tags":["概率和期望"]},{"title":"「CF1009F」Dominant Indices - map + 启发式合并","url":"/2018/07/23/Educational-Codeforces-Round-47-F-Dominant-Indices-map-%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/","content":"\n\n\n题目链接：[传送门](http://codeforces.com/contest/1009/problem/F)\n\n### Description\n\n给定一棵$n$个点的树，对于每一个点求出子树内所在深度节点个数最多的相对深度（即深度减去当前点的深度）\n\n\n\n### Constraints\n\n$n \\leq 10^6$\n\n<!--more-->\n\n### Solution\n\n用map记录子树信息，直接树上启发式合并即可\n\n\n\n### Debug\n\n53L: 不能直接swap(ans[x], ans[y])，否则会改变ans[y]的值\n\n58L:  不能用迭代器，要用键值，并且迭代器只能++或--，而不能+1, -1\n\n\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define x1 X1 \n#define x2 X2\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) {return a < b ? a = b, 1 : 0;}\ntemplate <typename T> inline int Chkmin (T &a, T b) {return a > b ? a = b, 1 : 0;}\ninline int read ()\n{\n\tint sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = sum * 10 + ch - '0';\n\treturn sum * fl;\n}\n\nconst int Maxn = 1e6 + 100;\n\nint N, dep[Maxn];\nint e, Begin[Maxn], To[Maxn << 1], Next[Maxn << 1];\nmap <int, int> sum[Maxn];\npii ans[Maxn];\n\ninline void add_edge (int x, int y)\n{\n\tTo[++e] = y;\n\tNext[e] = Begin[x];\n\tBegin[x] = e;\n}\n\ninline void dfs (int x, int fa)\n{\n\tsum[x][dep[x]] = 1;\n\tans[x] = mp(1, -dep[x]);\n\tfor (int i = Begin[x]; i; i = Next[i])\n\t{\n\t\tint y = To[i];\n\t\tif (y == fa) continue;\n\t\tdep[y] = dep[x] + 1; dfs(y, x);\n\t\tif (sum[x].size() < sum[y].size())\n\t\t{\n\t\t\tsum[x].swap(sum[y]);\n/**/\t\tans[x] = ans[y];\n\t\t}\n\t\tmap <int, int> :: iterator it;\n\t\tfor (it = sum[y].begin(); it != sum[y].end(); ++it)\n\t\t{\n/**/\t\tpii now = *it;\n\t\t\tsum[x][now.x] += now.y;\n\t\t\tans[x] = max(ans[x], mp(sum[x][now.x], -now.x));\n\t\t}\n\t}\n}\n\nint main()\n{\n#ifdef hk_cnyali\n\tfreopen(\"F.in\", \"r\", stdin);\n\tfreopen(\"F.out\", \"w\", stdout);\n#endif\n\tN = read();\n\tfor (int i = 1; i < N; ++i)\n\t{\n\t\tint x = read(), y = read();\n\t\tadd_edge (x, y);\n\t\tadd_edge (y, x);\n\t}\n\tdfs(1, 0);\n\tfor (int i = 1; i <= N; ++i)\n\t\tprintf(\"%d\\n\", -ans[i].y - dep[i]);\n\treturn 0;\n}\n```\n\n","categories":["Problem"],"tags":["Codeforces","数据结构","启发式合并"]},{"title":"7-23模拟赛 Summary","url":"/2018/07/23/7-23%E6%A8%A1%E6%8B%9F%E8%B5%9B-Summary/","content":"","categories":["Summary"],"tags":["Summary"]},{"title":"7-22模拟赛 Summary","url":"/2018/07/22/7-22%E6%A8%A1%E6%8B%9F%E8%B5%9B-Summary/","content":"","categories":["Summary"],"tags":["容斥","Summary","线段树","数据结构","树状数组"]},{"title":"「NOI2018」屠龙勇士 - Ex_gcd","url":"/2018/07/21/Luogu-P4774-NOI2018-%E5%B1%A0%E9%BE%99%E5%8B%87%E5%A3%AB-Exgcd/","content":"\n### Description\n\n小 D 最近在网上发现了一款小游戏。游戏的规则如下：\n\n- 游戏的目标是按照编号 $1~n$ 顺序杀掉 $n$ 条巨龙，每条巨龙拥有一个初始的生命值 $a_i$ 。同时每条巨龙拥有恢复能力，当其使用恢复能力时，它的生命值就会每次增加 $p_i$，直至生命值非负。只有在**攻击结束后**且当生命值**恰好**为 $0$ 时它才会死去。\n\n- 游戏开始时玩家拥有 $m$ 把攻击力已知的剑，每次面对巨龙时，玩家只能选择一把剑，当杀死巨龙后这把剑就会消失，但作为奖励，玩家会获得全新的一把剑。\n\n  <!--more-->\n\n小 D 觉得这款游戏十分无聊，但最快通关的玩家可以获得 ION2018 的参赛资格， 于是小 D 决定写一个笨笨的机器人帮她通关这款游戏，她写的机器人遵循以下规则：\n\n- 每次面对巨龙时，机器人会选择当前拥有的，攻击力不高于巨龙初始生命值中**攻击力最大**的一把剑作为武器。如果没有这样的剑，则选择**攻击力最低**的一把剑作为武器。\n- 机器人面对每条巨龙，它都会使用上一步中选择的剑攻击巨龙**固定的** $x$ 次，使巨龙的生命值减少 $x \\times ATK$\n- 之后，巨龙会不断使用恢复能力，每次恢复 $p_i$ 生命值。若在使用恢复能力前或某一次恢复后其生命值为 $0$，则巨龙死亡，玩家通过本关。\n\n那么显然机器人的**攻击次数**是决定能否最快通关这款游戏的关键。小 D 现在得知了每条巨龙的所有属性，她想考考你，你知道应该将机器人的攻击次数 $x$ 设置为多少，才能用最少的攻击次数通关游戏吗？\n\n当然如果无论设置成多少都无法通关游戏，输出 $-1$ 即可。\n\n\n\n### Constraints\n\n$30pts: n,m\\leq10^5 ,p_i=1$\n\n另外$70pts: n,m\\leq10^5, a_i\\leq p_i, LCM(p_i)\\leq10^{12}$\n\n\n\n### Solution\n\n考场上一开始还看错了题，以为一次打不死还可以换一把剑继续打。。。\n\n首先，我们显然可以用multiset预处理出面对每条龙时用到的剑的攻击力(记为$k_i$)\n\n**注意：**\n\n**用set lower_bound时，必须用S.lower_bound(x)，而不能用lower_bound(S.begin(), S.end(), x)，否则会超时**\n\n**并且multiset的删除必须要传迭代器，如果直接删除值的话会删除里面所有的这个数**\n\n题意可转化为求满足以下式子的$x$的最小正整数解:\n\n$ \\left\\{ \\begin{aligned} k_1x & \\equiv  a_1  (mod\\ p_1) \\ (a_1-xk_1\\leq0) \\\\ k_2x & \\equiv  a_2  (mod\\ p_2) \\ (a_2-xk_2\\leq0)\\\\ &...\\\\ k_nx & \\equiv  a_n (mod\\ p_n) \\ (a_n-xk_n\\leq0) \\end{aligned} \\right. $\n\n* 若$p_i=1$\n\n  此时无论如何都能杀死所有龙，$x$只需要满足$a_i-xk_i\\leq0$那么答案即为$\\max\\{\\lceil \\frac{k_i}{a_i}\\rceil \\}$\n\n* 若$a_i\\leq p_i$\n\n  此时$x$只需要满足$x\\equiv a_i * k_i^{-1} (mod\\ p_i)$\n\n  我们用Ex_gcd不断合并方程组求解即可（具体见[大佬的Blog](https://www.cnblogs.com/zjp-shadow/p/9267675.html)）\n\n  > 19.3.6 UPD\n  > 不用看大佬博客了，自己写了：[求解模线性方程组 - ex_gcd](https://hk-cnyali.com/2018/11/06/%E6%B1%82%E8%A7%A3%E6%A8%A1%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84-ex-gcd/)\n\n  **几个需要注意的地方:**\n\n  **1. 逆元有可能不存在，但是方程却有解。对于这种情况我们将方程全部同除$$gcd(a_i, k_i, p_i)$$即可**\n\n  **2. 中间可能会爆long long，那么需要使用快速乘，快速乘中间一定要先对a和b取模，并且变成非负，再进行运算**\n\n\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define int long long\n#define x first\n#define y second\n#define x1 X1 \n#define x2 X2\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) {return a < b ? a = b, 1 : 0;}\ntemplate <typename T> inline int Chkmin (T &a, T b) {return a > b ? a = b, 1 : 0;}\ninline int read ()\n{\n\tint sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = sum * 10 + ch - '0';\n\treturn sum * fl;\n}\n\nconst int maxn = 1e5 + 100;\n\nint N, M;\nint A[maxn], P[maxn], ATK[maxn], mod[maxn], rest[maxn]; \n\ninline int Plus (int &a, int b, int p) { a %= p; b %= p; (a += b) %= p; }\n\ninline int Mult (int a, int b, int p)\n{\n\tint ans = 0;\n\ta = (a % p + p) % p;\n\tb = (b % p + p) % p;\n\twhile (b)\n\t{\n\t\tif (b & 1) Plus (ans, a, p);\n\t\tPlus (a, a, p);\n\t\tb >>= 1;\n\t}\n\treturn ans;\n}\n\ninline void Exgcd (int a, int b, int &d, int &x, int &y)\n{\n\tif (!b) d = a, x = 1, y = 0;\n\telse { Exgcd(b, a % b, d, y, x); y -= x * (a / b); }\n}\ninline int Inv (int a,int n)\n{\n\tint d, x, y;\n    Exgcd (a, n, d, x, y);\n    return d == 1 ? (x + n) % n : -1;\n}\n\ninline int Solve()\n{\n\tfor (int i = 1; i < N; ++i)\n\t{\n        int a = mod[i], b = mod[i + 1], c = rest[i + 1] - rest[i], gcd = __gcd(a, b), k1, k2, g;\n        if (c % gcd) return -1;\n        a /= gcd; b /= gcd; c /= gcd;\n        Exgcd(a, b, g, k1, k2);\n        k1 = (Mult(k1, c, b) + b) % b;\n        mod[i + 1] = mod[i] / __gcd(mod[i], mod[i + 1]) * mod[i + 1] ;\n        rest[i + 1] = (Mult(mod[i], k1, mod[i + 1]) + rest[i]) % mod[i + 1];\n\t}\n    return rest[N];\n}\n\nmultiset <int> S;\n\nmain()\n{\n\tfreopen(\"dragon.in\", \"r\", stdin);\n\tfreopen(\"dragon.out\", \"w\", stdout);\n\tint T = read();\n\twhile (T--)\n\t{\n\t\tS.clear();\n\t\tN = read(), M = read();\n\t\tfor (int i = 1; i <= N; ++i) A[i] = read();\n\t\tint fl = 0;\n\t\tfor (int i = 1; i <= N; ++i)\n\t\t{\n\t\t\tP[i] = read();\n\t\t\tif (P[i] != 1) fl = 1;\n\t\t}\n\t\tfor (int i = 1; i <= N; ++i) ATK[i] = read();\n\t\tint ans = -1;\n\t\tfor (int i = 1; i <= M; ++i) S.insert(read());\n\t\tfor (int i = 1; i <= N; ++i)\n\t\t{\n\t\t\tmultiset <int> :: iterator it = S.upper_bound(A[i]);\n\t\t\tif (it != S.begin())\n\t\t\t\tit--;\n\t\t\trest[i] = *it;\n\t\t\tChkmax(ans, (int)ceil((double)(1.0 * A[i] / rest[i])));\n\t\t\tS.erase(it);\n\t\t\tS.insert(ATK[i]);\n\t\t}\n\t\tif (!fl) cout<<ans<<endl;\n\t\telse\n\t\t{\n\t\t\tint flag = 0;\n\t\t\tfor (int i = 1; i <= N; ++i)\n\t\t\t{\n\t\t\t\tmod[i] = P[i];\n\t\t\t\tint x = Inv(rest[i], mod[i]);\n\t\t\t\tif (x == -1) \n\t\t\t\t{ \n\t\t\t\t\tint g = __gcd(rest[i], mod[i]);\n\t\t\t\t\tint gg = __gcd(g, A[i]);\n\t\t\t\t\tif (gg != g)\n\t\t\t\t\t{\n\t\t\t\t\t\tflag = 1; break; \n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\trest[i] /= g, mod[i] /= g, A[i] /= g;\n\t\t\t\t\t\tx = Inv(rest[i], mod[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trest[i] = Mult(A[i], x, mod[i]);\n\t\t\t}\n\t\t\tif (flag) cout<<-1<<endl;\n\t\t\telse cout<<Solve()<<endl;\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\n","categories":["Problem"],"tags":["数学","数论","ex_gcd"]},{"title":"「NOI2018」归程 - 可持久化并查集","url":"/2018/07/18/Luogu-P4768-NOI2018-%E5%BD%92%E7%A8%8B-%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E5%B9%B6%E6%9F%A5%E9%9B%86/","content":"\n### Description\n\n给出一个$n$个点$m$条边的无向连通图，每条边有长度和海拔。$q$次询问，每次给出一个水位线$p$ ，和一个节点$v$，询问从$v$节点开始，经过一段连续的海拔大于$p$的边后，到1号节点的最短路（前缀海拔大于$p$的边不算贡献）\n\n\n\n### Constraints\n\n$n \\leq 200000 $\n\n$m, q \\leq 400000$\n\n强制在线\n\n<!--more-->\n\n### Solution\n\n~~考场上调了一个上午，最后居然还因为数组开小RE两个点，我还是太弱了~~\n\n显然对于一个点，答案就是它所在的海拔大于$p$的联通块中$dis_i$(表示从1号点的最短路)最小的一个\n\n如果不强制在线的话，我们只需要先跑一遍最短路，然后将询问按$p$排序，用并查集维护联通块和答案即可\n\n如果强制在线，则需要使用可持久化并查集\n\n可持久化并查集实际上就是用主席树来维护可持久化数组（$fa[]$和$ans[]$）\n\n然后就能通过此题了\n\n\n\n### Code(5KB)\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define x1 X1 \n#define x2 X2\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) {return a < b ? a = b, 1 : 0;}\ntemplate <typename T> inline int Chkmin (T &a, T b) {return a > b ? a = b, 1 : 0;}\n\ninline int read ()\n{\n\tint sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + (ch ^ 48);\n\treturn sum * fl;\n}\n\nconst int Maxn = 300000 + 100, Maxm = 900000 + 100;\n\nint N, M, QQ, K, S, e, Begin[Maxn], To[Maxm], Next[Maxm], W[Maxm], H[Maxm];\n\ninline void Init()\n{\n\te = 0;\n\tmemset(Begin, 0, sizeof Begin);\n}\n\ninline void add_edge (int x, int y, int l, int a)\n{\n\tTo[++e] = y;\n\tNext[e] = Begin[x];\n\tBegin[x] = e;\n\tW[e] = l;\n\tH[e] = a;\n}\n\nint Vis[Maxn], Dis[Maxn];\n\nstruct node\n{\n\tint a, b;\n\tbool operator < (const node &x) const { return x.b < b; }\n};\n\ninline void Dijkstra()\n{\n\tstatic priority_queue <node> Q;\n\tfor (int i = 0; i <= N; ++i) Dis[i] = -1, Vis[i] = 0;\n\tDis[1] = 0;\n\tQ.push((node){1, 0});\n\twhile (!Q.empty())\n\t{\n\t\tnode tmp = Q.top(); Q.pop();\n\t\tint x = tmp.a;\n\t\tif (Vis[x]) continue;\n\t\tVis[x] = 1;\n\t\tfor (int i = Begin[x]; i; i = Next[i])\n\t\t{\n\t\t\tint y = To[i];\n\t\t\tif (Dis[y] > Dis[x] + W[i] || Dis[y] == -1)\n\t\t\t{\n\t\t\t\tDis[y] = Dis[x] + W[i];\n\t\t\t\tQ.push((node){y, Dis[y]});\n\t\t\t}\n\t\t}\n\t}\n}\n\nint HH[Maxm];\nstruct edge\n{\n\tint x, y, z, h;\n}A[Maxm];\n\ninline int cmp1 (int a, int b)\n{\n\treturn a > b;\n}\ninline int cmp2 (edge a, edge b)\n{\n\treturn a.h > b.h;\n}\n\nint Root[Maxm][2], fa[Maxn], Cnt;\n\nnamespace SEG\n{\n\tstruct tree\n\t{\n\t\tint lson[2], rson[2], val, fa;\n\t}Tree[Maxn * 30];\n\n\tinline void build (int &root, int l, int r, int op)\n\t{\n\t\troot = ++ Cnt;\n\t\tif (l == r)\n\t\t{\n\t\t\tif (!op) Tree[root].fa = l;\n\t\t\telse Tree[root].val = Dis[l];\n\t\t\treturn ;\n\t\t}\n\t\tint mid = (l + r) >> 1;\n\t\tbuild (Tree[root].lson[op], l, mid, op);\n\t\tbuild (Tree[root].rson[op], mid + 1, r, op);\n\t}\n\n\tinline void insert (int pre, int &now, int l, int r, int x, int d, int op)\n\t{\n\t\t//if (!now)\n\t\t{\n\t\t\tnow = ++ Cnt;\n\t\t\tTree[now].lson[op] = Tree[pre].lson[op];\n\t\t\tTree[now].rson[op] = Tree[pre].rson[op];\n\t\t}\n\t\tif (l == r)\n\t\t{\n\t\t\tif (!op) Tree[now].fa = d;\n\t\t\telse Tree[now].val = d;\n\t\t\treturn ;\n\t\t}\n\t\tint mid = (l + r) >> 1;\n\t\tif (x <= mid) insert (Tree[pre].lson[op], Tree[now].lson[op], l, mid, x, d, op);\n\t\telse insert (Tree[pre].rson[op], Tree[now].rson[op], mid + 1, r, x, d, op);\n\t}\n\n\tinline int query (int root, int l, int r, int x, int op)\n\t{\n\t\tif (l == r)\n\t\t{\n\t\t\tif (!op) return Tree[root].fa;\n\t\t\treturn Tree[root].val;\n\t\t}\n\t\tint mid = (l + r) >> 1;\n\t\tif (x <= mid) return query (Tree[root].lson[op], l, mid, x, op);\n\t\telse return query (Tree[root].rson[op], mid + 1, r, x, op);\n\t}\n\n\tinline int find (int root, int x)\n\t{\n\t\tint f = query (root, 1, N, x, 0);\n\t\treturn f == x ? x : find(root, f);\n\t}\n}\n\nint size[Maxn];\n\ninline int find (int x)\n{\n\treturn fa[x] == x ? x : find(fa[x]);\n}\n\ninline void Link (int x, int y, int id)\n{\n\tint fx = find(x), fy = find(y);\n\tif (fx == fy)\n\t\treturn ;\n\t//\tcout<<x<<\" \"<<y<<\"| \"<<fx<<\" \"<<fy<<\" | \"<<id<<endl;\n\tif (size[fx] < size[fy]) swap(fx, fy);\n\tsize[fx] += size[fy];\n\tfa[fy] = fx;\n\tSEG :: insert (Root[id - 1][0], Root[id][0], 1, N, fy, fx, 0);\n\tif (Dis[fy] < Dis[fx])\n\t{\n\t\tDis[fx] = Dis[fy];\n\t\tSEG :: insert (Root[id - 1][1], Root[id][1], 1, N, fx, Dis[fy], 1);\n\t}\n}\n\nint Pos[Maxm];\n\nmain()\n{\n\tfreopen(\"return.in\", \"r\", stdin);\n\tfreopen(\"return.out\", \"w\", stdout);\n\tint T = read();\n\twhile (T--)\n\t{\n\t\tInit();\n\t\tmemset(SEG :: Tree, 0, sizeof SEG :: Tree);\n\t\tmemset(Root, 0, sizeof Root);\n\t\tCnt = 0;\n\t\tN = read(), M = read();\n\t\tfor (int i = 1; i <= M; ++i)\n\t\t{\n\t\t\tint x = read(), y = read(), l = read(), a = read();\n\t\t\tA[i] = ((edge){x, y, l, a});\n\t\t\tHH[i] = a;\n\t\t\tadd_edge (x, y, l, a);\n\t\t\tadd_edge (y, x, l, a);\n\t\t}\n\t\tDijkstra();\n\t\tsort(HH + 1, HH + M + 1, cmp1); sort(A + 1, A + M + 1, cmp2);\n\t\tint tot = unique(HH + 1, HH + M + 1) - HH - 1;\n\t\tint MIN = HH[tot];\n\t\tHH[++tot] = -0x3f3f3f3f;\n\t\tfor (int i = 1; i <= N; ++i) fa[i] = i, size[i] = 1;\n\t\tSEG :: build (Root[0][0], 1, N, 0);\n\t\tSEG :: build (Root[0][1], 1, N, 1);\n\t\tint j = 1;\n\t\tPos[1] = 0;\n\t\tfor (int i = 1; i <= M; ++i)\n\t\t{\n\t\t\tRoot[i][0] = Root[i - 1][0];\n\t\t\tRoot[i][1] = Root[i - 1][1];\n\t\t\tLink(A[i].x, A[i].y, i);\n\t\t\tif (HH[j] != A[i].h) ++j;\n\t\t\tPos[j + 1] = i;\n\t\t}\n\t\tfor (int i = 1; i <= tot; ++i) HH[i] = -HH[i];\n\t\tQQ = read(), K = read(), S = read();\n\t\tint ans = 0;\n\t\twhile (QQ--)\n\t\t{\n\t\t\tint v = read(), p = read();\n\t\t\tv = (v + K * ans - 1) % N + 1;\n\t\t\tp = (p + K * ans) % (S + 1);\n\t\t\tif (p < MIN)\n\t\t\t\tans = 0;\n\t\t\telse\n\t\t\t{\n\t\t\t\tp = -p;\n\t\t\t\tint pos = lower_bound(HH + 1, HH + tot + 1, p) - HH;\n\t\t\t\tpos = Pos[pos];\n\t\t\t\tans = SEG :: query (Root[pos][1], 1, N, SEG :: find (Root[pos][0], v), 1);\n\t\t\t}\n\t\t\tprintf(\"%d\\n\", ans);\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\n","categories":["Problem"],"tags":["最短路","数据结构","并查集","可持久化"]},{"title":"7-15模拟赛Summary","url":"/2018/07/17/7-15%E6%A8%A1%E6%8B%9F%E8%B5%9BSummary/","content":"","categories":["Summary"],"tags":["Summary","tarjan","缩点","差分","边双"]},{"title":"7-14模拟赛Summary","url":"/2018/07/14/7-14%E6%A8%A1%E6%8B%9F%E8%B5%9BSummary/","content":"","categories":["Summary"],"tags":["Summary","线段树","数据结构","概率和期望"]},{"title":"「CF990F」Flow Control - 构造","url":"/2018/07/09/Educational-Codeforces-Round-45-F-Flow-Control-%E6%9E%84%E9%80%A0/","content":"\n### Description\n\n给出一个$n$个点$m$条边的图，对于每个点有一个流量$s_i$表示它需要恰好流进或流出（正/负）多少流量\n\n问是否存在一种流量方案使得每个点都满足流进或流出$s_i$的流量\n\n如果存在则输出方案\n\n\n\n### Constraints\n\n$n,m \\leq 2 * 10^5 $\n\n<!--more-->\n\n### Solution\n\n考虑贪心，从这个图中提取出一棵树出来，在树上考虑流量问题\n\n那么从下至上依次贪心满足流量，最后判断1号节点流量是否平衡即可\n\n\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define x1 X1 \n#define x2 X2\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) {return a < b ? a = b, 1 : 0;}\ntemplate <typename T> inline int Chkmin (T &a, T b) {return a > b ? a = b, 1 : 0;}\ntemplate <typename T> T read()\n{\n\tT fl = 1, sum = 0; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = sum * 10 + ch - '0';\n\treturn sum * fl;\n}\n\nconst int Maxn = 2 * 1e5 + 100;\n\nint N, M, e, Begin[Maxn], To[Maxn << 1], Next[Maxn << 1], W[Maxn << 1];\nint A[Maxn], Vis[Maxn], Ans[Maxn];\n\ninline void add_edge (int x, int y)\n{\n\tTo[++e] = y;\n\tNext[e] = Begin[x];\n\tBegin[x] = e;\n}\n\ninline void dfs (int x)\n{\n\tVis[x] = 1;\n\tfor (int i = Begin[x]; i; i = Next[i])\n\t{\n\t\tint y = To[i];\n\t\tif (Vis[y]) continue;\n\t\tdfs(y);\n\t\tAns[(i + 1) / 2] = A[y] * ((i % 2) ? 1 : -1);\n\t\tA[x] += A[y];\n\t}\n}\n\nint main()\n{\n#ifdef hk_cnyali\n\tfreopen(\"F.in\", \"r\", stdin);\n\tfreopen(\"F.out\", \"w\", stdout);\n#endif\n\tN = read<int>();\n\tfor (int i = 1; i <= N; ++i) A[i] = read<int>();\n\tM = read<int>();\n\tfor (int i = 1; i <= M; ++i)\n\t{\n\t\tint x = read<int>(), y = read<int>();\n\t\tadd_edge (x, y);\n\t\tadd_edge (y, x);\n\t}\n\tdfs(1);\n\tif (A[1]) \n\t{\n\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\tputs(\"Possible\");\n\tfor (int i = 1; i <= M; ++i) cout<<Ans[i]<<endl;\n\treturn 0;\n}\n```\n\n","categories":["Problem"],"tags":["Codeforces","构造"]},{"title":"「BZOJ3653」谈笑风生 - 二维数点","url":"/2018/07/08/Luogu-P3899-BZOJ3653-%E8%B0%88%E7%AC%91%E9%A3%8E%E7%94%9F-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%82%B9/","content":"\n题目连接：[传送门](https://www.luogu.org/problemnew/show/P3899)\n\n### Description\n\n给一棵$n$颗节点的树，$m$次询问，每次询问给定$a$,$k$，求三元组$(a,b,c)$的数量满足：\n\n1. $a$和$b$都是$c$的祖先\n2. $a$和$b$在树上距离不超过$k$\n3. $a,b,c$互不相同\n\n\n\n### Constraints\n\n$n,m \\leq 3 * 10^5$\n\n<!--more-->\n\n\n\n### Solution\n\n显然$a,b,c$在同一条链上，考虑两种情况:\n\n* $dep_a > dep_b$\n\n  此时答案显然为$\\min\\{(dep_a - 1), k)\\} * (size_a - 1)$\n\n* $dep_a < dep_b$\n\n  此时即要求$\\sum_{x} size_x - 1$ ($x$满足$dep_x \\leq dep_a + k$且$x$在$a$的子树内)\n\n  那么我们只需要在$dfs$序上二维数点($x$轴表示$dfs$序，$y$轴表示$dep$,平面内点权为$size_x - 1$)即可\n\n**debug：89行$dep[a] + k$需要与$Maxdep$取min**\n\n\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define int long long\n#define x first\n#define y second\n#define x1 X1 \n#define x2 X2\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> T read()\n{\n\tT fl = 1, sum = 0; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = sum * 10 + ch - '0';\n\treturn sum * fl;\n}\n\nconst int Maxn = 300000 + 100;\n\nint N, M;\nint e, Begin[Maxn], To[Maxn << 1], Next[Maxn << 1];\nint dfn[Maxn], Index, size[Maxn], dep[Maxn], Ans[Maxn], idfn[Maxn], Maxdep;\n\nstruct node\n{\n\tint x, y, num, op;\n};\nvector <node> vec[Maxn];\n\ninline void add_edge (int x, int y)\n{\n\tTo[++e] = y;\n\tNext[e] = Begin[x];\n\tBegin[x] = e;\n}\n\ninline void dfs (int x, int fa)\n{\n\tdfn[x] = ++Index;\n\tidfn[Index] = x;\n\tsize[x] = 1;\n\tfor (int i = Begin[x]; i; i = Next[i])\n\t{\n\t\tint y = To[i];\n\t\tif (y == fa) continue;\n\t\tdep[y] = dep[x] + 1;\n\t\tChkmax(Maxdep, dep[y]);\n\t\tdfs(y, x);\n\t\tsize[x] += size[y];\n\t}\n}\n\nnamespace BIT\n{\n#define lowbit(x) (x & (-x))\n\tint sum[Maxn];\n\tinline void add (int x, int v) { while (x <= N) sum[x] += v, x += lowbit(x); }\n\tinline int query (int x) { int ans = 0; while (x) ans += sum[x], x -= lowbit(x); return ans; }\n}\n\nmain()\n{\n#ifdef hk_cnyali\n\tfreopen(\"A.in\", \"r\", stdin);\n\tfreopen(\"A.out\", \"w\", stdout);\n#endif\n\tN = read<int>(), M = read<int>();\n\tfor (int i = 1; i < N; ++i)\n\t{\n\t\tint x = read<int>(), y = read<int>();\n\t\tadd_edge (x, y); add_edge (y, x);\n\t}\n\tdep[1] = 1;\n\tdfs(1, 0);\n\tfor (int i = 1; i <= M; ++i)\n\t{\n\t\tint a = read<int>(), k = read<int>();\n\t\tAns[i] += min((dep[a] - 1), k) * (size[a] - 1);\n\t\tvec[dfn[a] - 1].pb((node){dep[a], min(Maxdep, dep[a] + k), i, -1});\n\t\tvec[dfn[a] + size[a] - 1].pb((node){dep[a], min(Maxdep, dep[a] + k), i, 1});\n\t}\n\tfor (int i = 1; i <= N; ++i)\n\t{\n\t\tBIT :: add (dep[idfn[i]], size[idfn[i]] - 1);\n\t\tfor (int j = 0; j < vec[i].size(); ++j)\n\t\t{\n\t\t\tnode x = vec[i][j];\n\t\t\tAns[x.num] += x.op * (BIT :: query (x.y) - BIT :: query (x.x));\n\t\t}\n\t}\n\tfor (int i = 1; i <= M; ++i)\n\t\tprintf(\"%lld\\n\", Ans[i]);\n\treturn 0;\n}\n```\n\n","categories":["Problem"],"tags":["线段树","数据结构"]},{"title":"「NOIp模拟赛7.1」tree - 状压dp","url":"/2018/07/06/7-1-tree-%E7%8A%B6%E5%8E%8Bdp/","content":"\n### Description\n\n求一颗$n$个节点树的期望深度（$i$号节点的父亲在$[1,i)$中均匀随机）\n\n第一问不取模，四舍五入到整数\n\n第二问对质数$p$取模\n\n### Constraints\n\n$n \\leq 24, p \\leq 10^9 + 7 $且$p$为质数\n\n<!--more-->\n\n### Solution\n\n第一问直接打表\n\n第二问由于每一种情况的概率相同，便能将期望问题转化为计数问题，考虑Dp\n\n暴力记录每个点的深度状态显然不行，考虑到树上节点深度都是连续的，那么排序，差分过后一定是一个$0/1$序列\n\n那么就可以记录这个$0/1$序列，进行状压Dp了\n\n~~我的做法好像和std有一点不一样，常数大一些，需要加一些优化才能过~~\n\n设$dp[state]$表示$0/1$序列为$state$的树有多少种\n\n那么新增一个节点，枚举它的深度$i$，设$sum$ 为在$state$中深度-1的节点个数\n\n那么$dp[state'] = dp[state'] + dp[state] * sum$\n\n直接暴力转移即可\n\n优化：加法取模函数，快速乘~~瞬间从6s变成1.6s~~\n\n\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define double long double\n#define x first\n#define y second\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) {return a < b ? a = b, 1 : 0;}\ntemplate <typename T> inline int Chkmin (T &a, T b) {return a > b ? a = b, 1 : 0;}\ntemplate <typename T> T read()\n{\n\tint fl = 1, sum = 0; char ch = getchar();\n\twhile (ch < '0' || ch > '9') {if (ch == '-') fl = -1; ch = getchar();}\n\twhile (ch >= '0' && ch <= '9') sum = sum * 10 + ch - '0', ch = getchar();\n\treturn sum * fl;\n}\n#include <bits/stdc++.h>\n\n#define double long double\n#define x first\n#define y second\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) {return a < b ? a = b, 1 : 0;}\ntemplate <typename T> inline int Chkmin (T &a, T b) {return a > b ? a = b, 1 : 0;}\ntemplate <typename T> T read()\n{\n\tint fl = 1, sum = 0; char ch = getchar();\n\twhile (ch < '0' || ch > '9') {if (ch == '-') fl = -1; ch = getchar();}\n\twhile (ch >= '0' && ch <= '9') sum = sum * 10 + ch - '0', ch = getchar();\n\treturn sum * fl;\n}\n\nconst int Maxn = 30;\n\nint N, Mod, Dp[(1 << 25) + 100];\nbool Vis[(1 << 25) + 100];\n\ninline void Add (int &x, int y)\n{\n\tx += y;\n\tif (x >= Mod) x -= Mod;\n}\n\ninline int Mult (int a, int b)\n{\n\tint ans = 0;\n\twhile (b)\n\t{\n\t\tif (b & 1) Add (ans, a);\n\t\tAdd (a, a);\n\t\tb >>= 1;\n\t}\n\treturn ans;\n}\n\ninline int Pow (int a, int b)\n{\n\tint ans = 1;\n\twhile (b)\n\t{\n\t\tif (b & 1) ans = Mult (ans, a);\n\t\ta = Mult (a, a);\n\t\tb >>= 1;\n\t}\n\treturn ans;\n}\n\nint Ans[30] = {0, 1, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6};\nint Pow2[30];\nstruct node\n{\n\tint cnt, pos;\n}A[30];\n\nmain()\n{\n\tfreopen(\"tree.in\", \"r\", stdin);\n\tfreopen(\"tree.out\", \"w\", stdout);\n\tN = read<int>(), Mod = read<int>();\n\tprintf(\"%d\\n\", Ans[N]);\n\tfor (int i = 0; i < 30; ++i) Pow2[i] = (1ll << i);\n\tint POS = 0;\n\tDp[1] = 1;\n\tVis[1] = 1;\n\tfor (int state = 1; state < Pow2[N]; ++state)\n\t{\n\t\tif (state >= Pow2[POS]) ++POS;\n\t\tif (!Vis[state]) continue;\n\t\tint sum = 0, fl = 0, cnt = 0;\n\t\tfor (int i = 0; i < POS; ++i)\n\t\t{\n\t\t\t++cnt;\n\t\t\tif (state & (Pow2[i]))\n\t\t\t\tA[++sum].cnt = cnt, A[sum + 1].pos = i + 1, cnt = 0;\n\t\t}\n\t\tAdd (Dp[state << 1 | 1], Mult (Dp[state], A[1].cnt)); \n\t\tVis[state << 1 | 1] = 1;\n\t\tfor (int i = 1; i < sum; ++i)\n\t\t{\n\t\t\tint now = state & (Pow2[A[i].pos] - 1);\n\t\t\tAdd (Dp[(state ^ now) << 1 | now], Mult (Dp[state], A[i + 1].cnt));\n\t\t\tVis[(state ^ now) << 1 | now] = 1;\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int state = Pow2[N - 1]; state < Pow2[N]; ++state) \n\t{\n\t\tif (!Vis[state]) continue;\n\t\tint cnt = __builtin_popcount(state);\n\t\t//\t\tcout<<state<<\" \"<<Dp[state]<<\" \"<<cnt<<endl;\n\t\tAdd (ans, Mult (Dp[state], cnt));\n\t}\n\t//\tcout<<\"*\"<<ans<<endl;\n\n\tint sum = 1;\n\tfor (int i = 1; i < N; ++i) sum = Mult (sum, i);\n\tcout<<Mult (ans, Pow(sum, Mod - 2))<<endl;\n\treturn 0;\n}\nconst int Maxn = 30;\n\nint N, Mod, Dp[(1 << 25) + 100];\nbool Vis[(1 << 25) + 100];\n\ninline void Add (int &x, int y)\n{\n\tx += y;\n\tif (x >= Mod) x -= Mod;\n}\n\ninline int Mult (int a, int b)\n{\n\tint ans = 0;\n\twhile (b)\n\t{\n\t\tif (b & 1) Add (ans, a);\n\t\tAdd (a, a);\n\t\tb >>= 1;\n\t}\n\treturn ans;\n}\n\ninline int Pow (int a, int b)\n{\n\tint ans = 1;\n\twhile (b)\n\t{\n\t\tif (b & 1) ans = Mult (ans, a);\n\t\ta = Mult (a, a);\n\t\tb >>= 1;\n\t}\n\treturn ans;\n}\n\nint Ans[30] = {0, 1, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6};\nint Pow2[30];\nstruct node\n{\n\tint cnt, pos;\n}A[30];\n\nmain()\n{\n\tfreopen(\"tree.in\", \"r\", stdin);\n\tfreopen(\"tree.out\", \"w\", stdout);\n\tN = read<int>(), Mod = read<int>();\n\tprintf(\"%d\\n\", Ans[N]);\n\tfor (int i = 0; i < 30; ++i) Pow2[i] = (1ll << i);\n\tint POS = 0;\n\tDp[1] = 1;\n\tVis[1] = 1;\n\tfor (int state = 1; state < Pow2[N]; ++state)\n\t{\n\t\tif (state >= Pow2[POS]) ++POS;\n\t\tif (!Vis[state]) continue;\n\t\tint sum = 0, fl = 0, cnt = 0;\n\t\tfor (int i = 0; i < POS; ++i)\n\t\t{\n\t\t\t++cnt;\n\t\t\tif (state & (Pow2[i]))\n\t\t\t\tA[++sum].cnt = cnt, A[sum + 1].pos = i + 1, cnt = 0;\n\t\t}\n\t\tAdd (Dp[state << 1 | 1], Mult (Dp[state], A[1].cnt)); \n\t\tVis[state << 1 | 1] = 1;\n\t\tfor (int i = 1; i < sum; ++i)\n\t\t{\n\t\t\tint now = state & (Pow2[A[i].pos] - 1);\n\t\t\tAdd (Dp[(state ^ now) << 1 | now], Mult (Dp[state], A[i + 1].cnt));\n\t\t\tVis[(state ^ now) << 1 | now] = 1;\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int state = Pow2[N - 1]; state < Pow2[N]; ++state) \n\t{\n\t\tif (!Vis[state]) continue;\n\t\tint cnt = __builtin_popcount(state);\n\t\t//\t\tcout<<state<<\" \"<<Dp[state]<<\" \"<<cnt<<endl;\n\t\tAdd (ans, Mult (Dp[state], cnt));\n\t}\n\t//\tcout<<\"*\"<<ans<<endl;\n\n\tint sum = 1;\n\tfor (int i = 1; i < N; ++i) sum = Mult (sum, i);\n\tcout<<Mult (ans, Pow(sum, Mod - 2))<<endl;\n\treturn 0;\n}\n```\n\n","categories":["Problem"],"tags":["动态规划","状态压缩"]},{"title":"「NOIp模拟赛7.4」divide - Dp","url":"/2018/07/05/7-4-divide-dp/","content":"\n### Description\n\n有$n$艘飞船，每艘飞船有一个武力值$w_i$。你需要把它们分成两队，每队飞船数目任意。\n\n如果两艘飞船$i$和$j$ 的武力值相加不小于$m$且不在同一队，那么这两艘飞船就能配合默契\n\n问最多能有多少飞船配合默契（不一定是一一配对，可以多对多），同时还需算出有多少种分队方案可以达到此效果\n\n第二问对$10^9+7$取模\n\n\n\n### Hint\n\n$n\\leq 2000, m\\leq 2 * 10^6, w_i \\leq 10^6$\n\n\n\n<!--more-->\n\n\n\n### Solution\n\n将$w$排序后，考虑在$[l,t]$这段区间中\n\n若 $w_1+w_n < m$，那么$w_1$与区间中所有飞船配合都不默契，递归处理$[l+1,r]$\n\n若 $w_1+w_n >= m$，那么$w_n$与区间中所有飞船配合都默契，递归处理$[l,r-1]$\n\n将这些数字依次取出，就能得到一个新的顺序\n\n在这个新的顺序中，我们不关心每一个具体的$w$的值，只关心它是否能与其他飞船配合默契\n\n设$op[i]$表示第$i$艘飞船是否能与其后面的所有飞船配合默契（要么全部都能，要么全部都不能）\n\n再把数组翻转一下便于dp处理（翻转之后$op[i]$表示第$i$艘飞船是否能与其前面的所有飞船配合默契）\n\n设$f[i][j]$表示，考虑完了前$i$艘飞船，其中有$j$艘属于第一队的最多默契数\n\n$f[i][j]=max(f[i-1][j-1]+op[i] * (i-j), f[i-1][j]+op[i] * j)$\n\n（max前半部分表示选进第一队，后半部分表示选进第二队）\n\n方案数类似转移，直接累加即可\n\n\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define x1 X1 \n#define x2 X2\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) {return a < b ? a = b, 1 : 0;}\ntemplate <typename T> inline int Chkmin (T &a, T b) {return a > b ? a = b, 1 : 0;}\ntemplate <typename T> T read()\n{\n\tT fl = 1, sum = 0; char ch = getchar();\n\twhile (ch < '0' || ch > '9') {if (ch == '-') fl = -1; ch = getchar();}\n\twhile (ch >= '0' && ch <= '9') sum = sum * 10 + ch - '0', ch = getchar();\n\treturn sum * fl;\n}\n\nconst int Maxn = 2000 + 10, Mod = 1e9 + 7;\n\nint N, M, A[Maxn], op[Maxn], f[Maxn][Maxn], g[Maxn][Maxn], ans1, ans2, cnt;\n\ninline void Solve (int l, int r)\n{\n\tif (cnt == N) return ;\n\tif (A[l] + A[r] < M) { op[++cnt] = 0; Solve(l + 1, r); }\n\telse { op[++cnt] = 1; Solve(l, r - 1); }\n}\n\nint main()\n{\n\tfreopen(\"divide.in\", \"r\", stdin);\n\tfreopen(\"divide.out\", \"w\", stdout);\n\tN = read<int>(), M = read<int>();\n\tfor (int i = 1; i <= N; ++i) A[i] = read<int>();\n\tsort(A + 1, A + N + 1);\n\tSolve(1, N);\n\treverse(op + 1, op + N + 1);\n//\tfor (int i = 1; i <= N; ++i) cout<<op[i]<<\" \";\n//\tputs(\"\");\n\tmemset(f, -0x3f3f3f3f, sizeof f);\n\tf[0][0] = 0;\n\tg[0][0] = 1;\n\tfor (int i = 1; i <= N; ++i)\n\t{\n\t\tfor (int j = 0; j <= i; ++j)\n\t\t{\n\t\t\tif (!j)\n\t\t\t{\n\t\t\t\tf[i][j] = f[i - 1][j] + op[i] * j;\n\t\t\t\tg[i][j] = g[i - 1][j];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint tmp1 = f[i - 1][j - 1] + op[i] * (i - j), tmp2 = f[i - 1][j] + op[i] * j;\n\t\t\tif (tmp1 == tmp2) f[i][j] = tmp1, g[i][j] = (g[i - 1][j - 1] + g[i - 1][j]) % Mod;\n\t\t\telse if (tmp1 < tmp2) f[i][j] = tmp2, g[i][j] = g[i - 1][j];\n\t\t\telse f[i][j] = tmp1, g[i][j] = g[i - 1][j - 1];\n\t\t}\n\t}\n\tfor (int i = 0; i <= N; ++i)\n\t{\n//\t\tcout<<f[N][i]<<\" \";\n\t\tif (f[N][i] > ans1 && g[N][i]) ans1 = f[N][i], ans2 = g[N][i];\n\t\telse if (f[N][i] == ans1) (ans2 += g[N][i]) %= Mod;\n\t}\n//\tputs(\"\");\n\tcout<<ans1<<\" \"<<ans2<<endl;\n\treturn 0;\n}\n```\n\n","categories":["Problem"],"tags":["动态规划"]},{"title":"「CF983E」 NN country - 倍增 + 二维数点","url":"/2018/07/04/Codeforces-Round-483-Div-1-E-NN-country-%E5%80%8D%E5%A2%9E-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%82%B9/","content":"\n题目链接：[传送门](http://codeforces.com/contest/983/problem/E)\n\n### Description\n\n给一棵$n$个节点的树，有$m$条路径。给出$q$组询问，每组询问$(x, y)$求出$x$到$y$的路径至少需要多少条给出的路径覆盖,可能无解\n\n\n\n### Hint\n\n$n, m, q \\leq 2 * 10^5$\n\n<!--more-->\n\n\n\n### Solution\n\n首先对于一条询问的路径$(x, y)$，我们可以拆成$(x,lca)$和$(y, lca)$这两条路径\n\n那么我们只需要考虑从一个点$x$到它的祖先$lca$至少需要多少条路径覆盖\n\n显然这个我们可以通过倍增来实现\n\n设$top[x][i]$表示节点$x$被$2^i$条路径覆盖，能到达的深度最浅的点，直接倍增即可\n\n假设$x$已经倍增到了$u$节点，且$dep_{top[u][0]} \\leq dep_{lca}$，感性理解就是在$lca$下面一点点的那个点，$y$已经倍增到了$v$,且总共倍增了$sum$次\n\n那么有可能存在一条链能直接覆盖$(u, v)$ ，那么答案就是$sum+1$\n\n如果不存在那么答案就是$sum+2$\n\n要判断是否存在一条能覆盖$(u,v)$的链，实际上就是要求是否存在一条链，使得它的两个端点分别在$u$和$v$的子树中\n\n那么这一部分的求解就转化成了在$dfs$序上的二维数点问题\n\n扫描线 + 树状数组即可\n\n$P.S.$代码居然写了4.2K。。。\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define x1 X1 \n#define x2 X2\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) {return a < b ? a = b, 1 : 0;}\ntemplate <typename T> inline int Chkmin (T &a, T b) {return a > b ? a = b, 1 : 0;}\ntemplate <typename T> T read()\n{\n\tT fl = 1, sum = 0; char ch = getchar();\n\twhile (ch < '0' || ch > '9') {if (ch == '-') fl = -1; ch = getchar();}\n\twhile (ch >= '0' && ch <= '9') sum = sum * 10 + ch - '0', ch = getchar();\n\treturn sum * fl;\n}\n\nconst int Maxn = 2 * 1e5 + 100;\n\nint N, M, Q;\nint e, Begin[Maxn], To[Maxn << 1], Next[Maxn << 1];\nint anc[Maxn][22], top[Maxn][22], dep[Maxn], dfn[Maxn], Index, size[Maxn];\nint Ans[Maxn];\n\ninline void add_edge (int x, int y)\n{\n\tTo[++e] = y;\n\tNext[e] = Begin[x];\n\tBegin[x] = e;\n}\n\ninline void pre_dfs (int x)\n{\n\tfor (int i = 1; i <= 20; ++i) anc[x][i] = anc[anc[x][i - 1]][i - 1];\n\tdfn[x] = ++Index;\n\tsize[x] = 1;\n\tfor (int i = Begin[x]; i; i = Next[i])\n\t{\n\t\tint y = To[i];\n\t\tif (y == anc[x][0]) continue;\n\t\tanc[y][0] = x;\n\t\tdep[y] = dep[x] + 1;\n\t\tpre_dfs(y);\n\t\tsize[x] += size[y];\n\t}\n}\n\ninline void dfs (int x)\n{\n\tfor (int i = Begin[x]; i; i = Next[i])\n\t{\n\t\tint y = To[i];\n\t\tif (y == anc[x][0]) continue;\n\t\tdfs(y);\n\t\tif (dep[top[y][0]] < dep[top[x][0]]) top[x][0] = top[y][0];\n\t}\n}\n\ninline int Lca (int x, int y)\n{\n\tif (dep[x] < dep[y]) swap(x, y);\n\tfor (int i = 20; i >= 0; --i)\n\t\tif (dep[anc[x][i]] >= dep[y]) x = anc[x][i];\n\tif (x == y) return x;\n\tfor (int i = 20; i >= 0; --i)\n\t\tif (anc[x][i] != anc[y][i])\n\t\t\tx = anc[x][i], y = anc[y][i];\n\treturn anc[x][0];\n}\n\nstruct query\n{\n\tint x, y, num, type; \n};\n\nvector <query> vec[Maxn];\nvector <int> vec1[Maxn];\nint FLAG[Maxn];\n\ninline void calc (int x, int y, int nowww)\n{\n\tint LCA = Lca(x, y), now = x, sum = 0, u, v;\n\tfor (int i = 20; i >= 0; --i)\n\t\tif (dep[top[now][i]] > dep[LCA]) now = top[now][i], sum |= (1 << i);\n\tu = now;\n\tif (dep[top[u][0]] > dep[LCA]) { FLAG[nowww] = 1; Ans[nowww] = -1; return ; }\n\tnow = y;\n\tfor (int i = 20; i >= 0; --i)\n\t\tif (dep[top[now][i]] > dep[LCA]) now = top[now][i], sum += (1 << i);\n\tv = now;\n\tif (dep[top[v][0]] > dep[LCA]) { FLAG[nowww] = 1; Ans[nowww] = -1; return ; }\n\tif (LCA == x || LCA == y) { FLAG[nowww] = 1; Ans[nowww] = sum + 1; return ; }\n\tint x1 = dfn[u], x2 = dfn[u] + size[u] - 1, y1 = dfn[v], y2 = dfn[v] + size[v] - 1;\n//\tcout<<x1<<\" \"<<x2<<\" \"<<y1<<\" \"<<y2<<endl;\n\tvec[x1 - 1].pb((query){y1 - 1, y2, nowww, -1}); vec[x2].pb((query){y1 - 1, y2, nowww, 1});\n\tAns[nowww] = sum;\n}\n\nnamespace BIT\n{\n\tint Sum[Maxn << 1];\n#define lowbit(x) (x & (-x))\n\tinline void add (int x, int v) { while (x <= N) Sum[x] += v, x += lowbit(x); }\n\tinline int query (int x) { int ans = 0; while (x) ans += Sum[x], x -= lowbit(x); return ans; }\n}\n\nint Sum[Maxn];\n\nint main()\n{\n#ifdef hk_cnyali\n\tfreopen(\"E.in\", \"r\", stdin);\n\tfreopen(\"E.out\", \"w\", stdout);\n#endif\n\tN = read<int>();\n\tfor (int i = 2; i <= N; ++i)\n\t{\n\t\tint x = read<int>();\n\t\tadd_edge (x, i); add_edge (i, x);\n\t}\n\tfor (int i = 1; i <= N; ++i) top[i][0] = i;\n\tM = read<int>();\n\tdep[1] = 1; pre_dfs(1);\n\twhile (M--)\n\t{\n\t\tint x = read<int>(), y = read<int>();\n\t\tint u = Lca(x, y);\n//\t\tcout<<x<<\" \"<<y<<\" \"<<u<<endl;\n\t\tvec1[dfn[x]].pb(dfn[y]);\n\t\tvec1[dfn[y]].pb(dfn[x]);\n\t\tif (dep[u] < dep[top[x][0]]) top[x][0] = u; //, cout<<\"fuck\";\n\t\tif (dep[u] < dep[top[y][0]]) top[y][0] = u; //, cout<<\"fuck\";\n//\t\tputs(\"\");\n\t}\n\tdfs(1);\n\n\tfor (int j = 1; j <= 20; ++j)\n\t\tfor (int i = 1; i <= N; ++i)\n\t\t\ttop[i][j] = top[top[i][j - 1]][j - 1];\n\n\tQ = read<int>();\n\tfor (int i = 1; i <= Q; ++i)\n\t{\n\t\tint x = read<int>(), y = read<int>();\n\t\tcalc(x, y, i);\n\t}\n\n\tfor (int i = 1; i <= N; ++i)\n\t{\n\t\tfor (int j = 0; j < vec1[i].size(); ++j)\n\t\t{\n\t\t\tint x = vec1[i][j];\n\t\t\tBIT :: add(x, 1);\n\t\t}\n\t\tfor (int j = 0; j < vec[i].size(); ++j)\n\t\t{\n\t\t\tquery x = vec[i][j];\n\t\t\tint sum = BIT :: query(x.y) - BIT :: query(x.x);\n\t\t\tSum[x.num] += sum * x.type;\n\t\t}\n\t}\n\t\n\tfor (int i = 1; i <= Q; ++i)\n\t{\n\t\tif (FLAG[i]);\n\t\telse if (Sum[i] > 0) Ans[i] ++;\n\t\telse Ans[i] += 2;\n\t\tprintf(\"%d\\n\", Ans[i]);\n\t}\n\n\treturn 0;\n}\n\n/*\n注意dfn[x]和x不要搞混了。。。\n*/\n```\n\n","categories":["Problem"],"tags":["Codeforces","数据结构","倍增"]},{"title":"「CF992E」 Nastya and King-Shamans - 线段树","url":"/2018/07/01/Codeforces-Round-489-E-Nastya-and-King-Shamans-%E7%BA%BF%E6%AE%B5%E6%A0%91/","content":"\n题目链接：[传送门](http://codeforces.com/contest/992/problem/E)\n\n### Description\n\n给你一个长度为$n$的序列$a_i$，有$q$次操作，每次操作$(x, y)$将第$x$个数改为$y$，求在每次操作后是否存在$i$，使得$a_i=sum_{i-1}$  若存在则输出任意一个即可，否则输出-1\n\n\n\n### Hint\n\n$n,q \\leq 10^5$\n\n$a_i \\leq 10^9$\n\n<!--more-->\n\n### Solution\n\n从i$=1$开始，首先求出$sum_{i}$，然后在$[i+1, n]$中找到第一个$a_j\\ge sum_i $\n\n如果$a_j==sum_{j-1}$结束搜索，否则令$i=j$，循环过程\n\n因为每次做完一次之后sum会至少增大一倍，所以每次查询的复杂度为$O(log_2(max(a_i)))$\n\n然后用线段树维护区间和以及区间最大值（用来二分查找$a_j\\ge sum_i$）\n\n总时间复杂度为$O(n\\cdot log_2n\\cdot log_2(max(a_i))$\n\n\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define int long long\n#define x first\n#define y second\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) {return a < b ? a = b, 1 : 0;}\ntemplate <typename T> inline int Chkmin (T &a, T b) {return a > b ? a = b, 1 : 0;}\ntemplate <typename T> T read()\n{\n\tT fl = 1, sum = 0; char ch = getchar();\n\twhile (ch < '0' || ch > '9') {if (ch == '-') fl = -1; ch = getchar();}\n\twhile (ch >= '0' && ch <= '9') sum = sum * 10 + ch - '0', ch = getchar();\n\treturn sum * fl;\n}\n\nconst int Maxn = 2e5 + 100;\n\nint N, M, A[Maxn];\n\nstruct tree\n{\n\tint Max, sum, val;\n}Tree[Maxn << 2];\n\nnamespace SEG\n{\n#define lson root << 1, l, mid\n#define rson root << 1 | 1, mid + 1, r\n\tinline void push_up (int root)\n\t{\n\t\tTree[root].Max = max(Tree[root << 1 | 1].Max, Tree[root << 1].Max);\n\t\tTree[root].sum = Tree[root << 1 | 1].sum + Tree[root << 1].sum;\n\t}\n\n\tinline void build (int root, int l, int r)\n\t{\n\t\tif (l == r)\n\t\t{\n\t\t\tTree[root].Max = Tree[root].sum = Tree[root].val = A[l];\n\t\t\treturn ;\n\t\t}\n\t\tint mid = (l + r) >> 1;\n\t\tbuild (lson), build (rson);\n\t\tpush_up (root);\n\t}\n\n\tinline int query_sum (int root, int l, int r, int x, int y)\n\t{\n\t\tif (x <= l && r <= y) return Tree[root].sum;\n\t\tint mid = (l + r) >> 1, ans = 0;\n\t\tif (x <= mid) ans += query_sum (lson, x, y);\n\t\tif (y > mid) ans += query_sum (rson, x, y);\n\t\treturn ans;\n\t}\n\n\tinline int query_max (int root, int l, int r, int x, int y)\n\t{\n\t\tif (x <= l && r <= y) return Tree[root].sum;\n\t\tint mid = (l + r) >> 1, ans = 0;\n\t\tif (x <= mid) Chkmax(ans, query_sum (lson, x, y));\n\t\tif (y > mid) Chkmax(ans, query_sum (rson, x, y));\n\t\treturn ans;\n\t}\n\n\tinline void update (int root, int l, int r, int x, int v)\n\t{\n\t\tif (l == r)\n\t\t{\n\t\t\tTree[root].sum = Tree[root].val = Tree[root].Max = v;\n\t\t\treturn ;\n\t\t}\n\t\tint mid = (l + r) >> 1;\n\t\tif (x <= mid) update (lson, x, v);\n\t\telse update (rson, x, v);\n\t\tpush_up (root);\n\t}\n\n\tint ANS;\n\n\tinline void find (int root, int l, int r, int x, int y, int val)\n\t{\n\t\tif (ANS != -1) return ;\n\t\tif (l == r) { ANS = l; return ; }\n\t\tint mid = (l + r) >> 1;\n\t\tif (Tree[root << 1].Max >= val && x <= mid) find (lson, x, y, val);\n\t\tif (Tree[root << 1 | 1].Max >= val && y > mid) find (rson, x, y, val);\n\t}\n\n}\n\nmain()\n{\n#ifdef hk_cnyali\n\tfreopen(\"E.in\", \"r\", stdin);\n\tfreopen(\"E.out\", \"w\", stdout);\n#endif\n\tN = read<int>(), M = read<int>();\n\tfor (int i = 1; i <= N; ++i) A[i] = read<int>();\n\tSEG :: build (1, 1, N);\n\twhile (M--)\n\t{\n\t\tint x = read<int>(), y = read<int>();\n\t\tSEG :: update (1, 1, N, x, y);\n\t\tA[x] = y;\n\t\tif (A[1] == 0) { puts(\"1\"); continue; }\n\t\tint i = 1, j, fl = 0;\n\t\twhile (1)\n\t\t{\n\t\t\tif (i == N) break;\n\t\t\tint sum = SEG :: query_sum (1, 1, N, 1, i);\n\t\t\tint MAX = SEG :: query_max (1, 1, N, i + 1, N);\n//\t\t\tcout<<i<<\" \"<<sum<<\" \"<<MAX<<endl;\n\t\t\tif (MAX < sum) break;\n\t\t\tSEG :: ANS = -1;\n\t\t\tSEG :: find (1, 1, N, i + 1, N, sum);\n\t\t\tj = SEG :: ANS;\n\t\t\tif (j == -1) break;\n\t\t\tif (A[j] == SEG :: query_sum (1, 1, N, 1, j - 1)) { fl = 1; break; }\n\t\t\ti = j;\n\t\t}\n\t\tif (!fl) puts(\"-1\");\n\t\telse printf(\"%lld\\n\", j);\n\t}\n\treturn 0;\n}\n```\n","categories":["Problem"],"tags":["Codeforces","线段树","数据结构"]},{"title":"「CF1000F」One Occurrence - 线段树 + 扫描线","url":"/2018/06/28/Educational-Codeforces-Round-46-F-One-Occurrence-(%E7%BA%BF%E6%AE%B5%E6%A0%91+%E6%89%AB%E6%8F%8F%E7%BA%BF)/","content":"\n### Description\n\n给定一个长度为n的数组a，有m次询问，每次询问区间$[l, r]$内是否存在只出现过一次的数字，如果有则任意输出一个即可\n\n\n\n### Hint\n\n$n, m, a_i\\leq 5 * 10^5$\n\n\n\n<!--more-->\n\n\n\n### Solution\n\n我们考虑将询问离线，用扫描线和贪心的思想\n\n设$Pre[i]$表示$a[i]$这个数上一次出现的位置，那么对于一个区间$[l, r]$，我们只需要看其中最小的$Pre[i]$是否比l小（线段树维护），即可判断是否存在，如果有则输出这个最小的$Pre[i]$\n\n但是如果直接这么做的话，对于$l\\leq i<j \\leq r$ 且$a[i] = a[j], Pre[i]<l$的情况，我们会将$a[i]$统计进答案，而事实上这种情况是不符合题意的\n\n对于这种情况，我们只需要在离线扫描线处理到$i$时，将线段树中$Pre[i]$的值设为$inf$\n\n那么直接在线段树上查询最小值即可\n\n\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n#define x first\n#define y second\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\ntemplate <typename T> inline int Chkmax (T &a, T b) {return a < b ? a = b, 1 : 0;}\ntemplate <typename T> inline int Chkmin (T &a, T b) {return a > b ? a = b, 1 : 0;}\ntemplate <typename T> T read()\n{\n\tint fl = 1, sum = 0; char ch = getchar();\n\twhile (ch < '0' || ch > '9') {if (ch == '-') fl = -1; ch = getchar();}\n\twhile (ch >= '0' && ch <= '9') sum = sum * 10 + ch - '0', ch = getchar();\n\treturn sum * fl;\n}\n\nconst int Maxn = 5e5 + 100, inf = 0x3f3f3f3f;\n\nint N, M, A[Maxn];\nvector <pii> Q[Maxn];\n\nnamespace SEG\n{\n\tpii Tree[Maxn << 2];\n\n\tinline void push_up (int root) { Tree[root] = min(Tree[root << 1], Tree[root << 1 | 1]); }\n\n\tinline void update (int root, int l, int r, int x, pii v)\n\t{\n\t\tif (l == r) { Tree[root] = v; return ; }\n\t\tint mid = (l + r) >> 1;\n\t\tif (x <= mid) update (root << 1, l, mid, x, v);\n\t\telse update (root << 1 | 1, mid + 1, r, x, v);\n\t\tpush_up(root);\n\t}\n\n\tinline pii query (int root, int l, int r, int x, int y)\n\t{\n\t\tif (l > y || r < x) return {inf, inf};\n\t\tif (x <= l && r <= y) return Tree[root];\n\t\tint mid = (l + r) >> 1;\n\t\tpii ans = {inf, inf};\n\t\tif (x <= mid) ans = min(ans, query (root << 1, l, mid, x, y));\n\t\tif (y > mid) ans = min(ans, query (root << 1 | 1, mid + 1, r, x, y));\n\t\treturn ans;\n\t}\n}\n\ninline void Input()\n{\n\tN = read<int>();\n\tfor (int i = 1; i <= N; ++i) A[i] = read<int>();\n\tM = read<int>();\n\tfor (int i = 1; i <= M; ++i)\n\t{\n\t\tint x = read<int>(), y = read<int>();\n\t\tQ[y].pb({x, i});\n\t}\n}\n\npii Pre[Maxn];\nint id[Maxn], Ans[Maxn];\n\nint main()\n{\n#ifdef hk_cnyali\n\tfreopen(\"F.in\", \"r\", stdin);\n\tfreopen(\"F.out\", \"w\", stdout);\n#endif\n\tInput();\n\n\tfor (int i = 1; i <= N; ++i)\n\t{\n\t\tPre[i] = {id[A[i]], A[i]};\n\t\tid[A[i]] = i;\n\t}\n\tfor (int i = 1; i <= N; ++i)\n\t{\n\t\tif (Pre[i].x) SEG :: update(1, 1, N, Pre[i].x, {inf, inf});\n\t\tSEG :: update(1, 1, N, i, Pre[i]);\n\t\tfor (int j = 0; j < Q[i].size(); ++j)\n\t\t{\n\t\t\tpii x = Q[i][j], ans = SEG :: query(1, 1, N, x.x, i);\n\t\t\tif (ans.x < x.x) Ans[x.y] = ans.y;\n\t\t}\n\t}\n\tfor (int i = 1; i <= M; ++i) printf(\"%d\\n\", Ans[i]);\n\treturn 0;\n}\n```\n\n","categories":["Problem"],"tags":["Codeforces","线段树","数据结构","扫描线"]},{"title":"「CQOI2011」动态逆序对 - CDQ分治","url":"/2018/06/21/Luogu-P1357-CQOI2011-%E5%8A%A8%E6%80%81%E9%80%86%E5%BA%8F%E5%AF%B9-CDQ%E5%88%86%E6%B2%BB/","content":"\n题目链接：[传送门](https://www.luogu.org/problemnew/show/3157 \"传送门\")\n\n### Description\n\n对于序列A，它的逆序对数定义为满足i < j，且Ai > Aj的数对(i,j)的个数。给1到n的一个排列，按照某种顺序依次删除m个元素，你的任务是在每次删除一个元素之前统计整个序列的逆序对数。\n\n<!--more-->\n\n### Input\n\n输入第一行包含两个整数n和m，即初始元素的个数和删除的元素个数。以下n行每行包含一个1到n之间的正整数，即初始排列。以下m行每行一个正整数，依次为每次删除的元素。\n\n### Output\n\n输出包含m行，依次为删除每个元素之前，逆序对的个数。\n\n### Sample Input\n\n> 5 4 1 5 3 4 2 5 1 4 2\n\n### Sample Output\n\n> 5 2 2 1\n\n\n\n### Solution\n\n[这道题的树套树做法](http://hk-cnyali.com/2018/01/07/Luogu-P3157-CQOI2011-%E5%8A%A8%E6%80%81%E9%80%86%E5%BA%8F%E5%AF%B9/)\n\n\nCDQ分治做法：\n\n我们将询问离线，将删除看成倒过来加入。设每个元素位置，值，被删除时间分别为$p_i, v_i, t_i$\n\n那么第$i$个元素被加入时，所有满足以下条件的$j$都能产生贡献：\n\n$t_i < t_j\\ p_i<p_j\\ v_i>v_j $或$t_i < t_j\\ p_i>p_j\\ v_i<v_j $\n\n那么我们只需要先以$t$为关键字排序，然后cdq去掉$p$这一维，用树状数组维护$v$的信息即可\n\n\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n#define int long long\n\nusing namespace std;\n\nconst int Maxn = 100000 + 100, Maxm = 50000 + 100;\n\nint N, M;\n\nstruct node\n{\n\tint t, p, v, ans;\n}A[Maxn];\n\ninline int read ()\n{\n\tchar ch = getchar(); int sum, fl = 1;\n\twhile (ch < '0' || ch > '9') {if (ch == '-') fl = -1; ch = getchar();}\n\tsum = ch - '0';\n\tch = getchar();\n\twhile (ch >= '0' && ch <= '9') sum = sum * 10 + ch - '0', ch = getchar();\n\treturn sum * fl;\n}\n\ninline int cmp1 (node a, node b) { return a.t < b.t; }\ninline int cmp2 (node a, node b) { return a.p < b.p; }\ninline int cmp3 (node a, node b) { return a.v < b.v; }\n\nnamespace BIT\n{\n#define lowbit(x) (x & (-x))\n\tint Sum[Maxn << 1];\n\tinline void add (int x, int v) { while (x <= N) { Sum[x] += v; x += lowbit(x); } }\n\tinline int query (int x) { int ans = 0; while (x) { ans += Sum[x]; x -= lowbit(x); } return ans;}\n}\n\ninline void Solve (int l, int r)\n{\n\tif (l == r)\n\t\treturn ;\n\tint mid = (l + r) >> 1;\n\tSolve (l, mid), Solve (mid + 1, r);\n\n\tint pos = r;\n\tfor (int i = mid; i >= l; --i)\n\t{\n\t\twhile (pos > mid && A[pos].p > A[i].p)\n\t\t\tBIT :: add(A[pos].v, 1), --pos;\n\t\tA[i].ans += BIT :: query(A[i].v - 1);\n\t}\n\tfor (int i = r; i > pos; --i) BIT :: add(A[i].v, -1);\n\n\tpos = mid + 1;\n\tfor (int i = l; i <= mid; ++i)\n\t{\n\t\twhile (pos <= r && A[i].p > A[pos].p)\n\t\t\tBIT :: add(A[pos].v, 1), ++pos;\n\t\tA[i].ans += BIT :: query(N) - BIT :: query(A[i].v);\n\t}\n\tfor (int i = mid + 1; i < pos; ++i) BIT :: add(A[i].v, -1);\n\tsort(A + l, A + r + 1, cmp2);\n}\n\nint Ans[Maxn];\n\nmain()\n{\n#ifdef hk_cnyali\n\tfreopen(\"A.in\", \"r\", stdin);\n\tfreopen(\"A.out\", \"w\", stdout);\n#endif\n\tscanf(\"%lld%lld\", &N, &M);\n\tfor (int i = 1; i <= N; ++i) A[i].v = read(), A[i].p = i;\n\tsort(A + 1, A + N + 1, cmp3);\n\tfor (int i = 1; i <= M; ++i)\n\t{\n\t\tint x = read();\n\t\tA[x].t = i;\n\t}\n\tfor (int i = 1; i <= N; ++i)\n\t\tif (!A[i].t) A[i].t = M + 1;\n\tsort(A + 1, A + N + 1, cmp1);\n\tSolve (1, N);\n\tsort(A + 1, A + N + 1, cmp1);\n\tint ans = 0;\n\tfor (int i = N; i >= 1; --i)\n\t{\n\t\tans += A[i].ans;\n\t\tAns[A[i].t] = ans;\n\t}\n\tfor (int i = 1; i <= M; ++i) printf(\"%lld\\n\", Ans[i]);\n\treturn 0;\n}\n```\n\n","categories":["Problem"],"tags":["树状数组","CDQ分治","省选"]},{"title":"博客由WordPress迁移至Hexo","url":"/2018/06/14/%E5%8D%9A%E5%AE%A2%E7%94%B1WordPress%E8%BF%81%E7%A7%BB%E8%87%B3Hexo/","content":"\n\n\n\n\n由于WordPress实在是太慢，今天正式把博客转到Hexo+github上了\n\n<!--more-->\n\nHexo明显比WordPress快多了，~~逼格也高多了，还省了100块钱的虚拟主机费~~\n\n主要原因还是Hexo比WordPress方便很多，本地用Typora写了md之后可以直接hexo server在本地看效果，不像WordPress那么麻烦，能节省很多时间\n\n另外，域名到期不打算续费之后博客还是能在本地运行，以后还是能翻看之前的东西，如果在WordPress上写的话就什么都没了，这一点也很重要\n\n还是希望这个博客能继续坚持写下去\n\n继续努力奋斗吧\n","tags":["OI历程"]},{"title":"「NOIp模拟赛6.13」walk - 枚举因子 + 最长链","url":"/2018/06/13/6-13-walk-%E6%9E%9A%E4%B8%BE%E5%9B%A0%E5%AD%90-%E6%9C%80%E9%95%BF%E9%93%BE/","content":"\n### Description\n\n给定一棵 n 个节点的树,每条边的长度为 1,同时有一个权值w。定义一条路径的权值为路径上所有边的权值的最大公约数。现在对于任意 i∈ \\[1,n\\] ,求树上所有长度为 i 的简单路径中权值最大的是多少。如果不存在长度为 i 的路径,则第 i 行输出 0。\n\n<!--more-->\n\n### Hint\n\n对于 30%的数据,$n\\leq 1000$ \n\n对于额外 30%的数据,$w\\leq100$ \n\n对于 100%的数据,$n\\leq 4 * 10^5,1\\leq u,v\\leq n,w\\leq 10^6$\n\n### Solution\n\n首先考虑w比较小的做法，我们可以枚举公因数，然后每次$O(n)$去加边并dfs一遍求出最长链 \n\n这样的复杂度是$O(w * n)$的 \n\n而实际上我们并不需要在枚举公因数时，每一个点和每一条边都判断一下。\n\n考虑用空间换时间，把每条边拆成它因数个数条边，然后每次枚举了公因数后直接便利那些边和点即可。\n\n 那么这样的复杂度是所有数的质因子个数，最多不会超过$O(n^{1.5})$ \n\n要注意数组不能memset，要手动清空\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n#define pb(x) push_back(x)\n\nusing namespace std;\n\nconst int Maxn = 4 * 1e5 + 100;\n\nint e, Begin[Maxn], To[Maxn << 1], Next[Maxn << 1], W[Maxn << 1];\n\nint Stack[Maxn << 2], top;\n\nint N;\n\ninline void add_edge (int x, int y, int z)\n{\n    To[++e] = y;\n    Next[e] = Begin[x];\n    Begin[x] = e;\n    W[e] = z;\n    Stack[++top] = x;\n    Stack[++top] = y;\n}\n\nint Ans[Maxn];\n\nstruct node\n{\n    int x, y, z;\n}E[Maxn << 1];\n\nvector <int> vec[1000010];\n\nint now[Maxn], maxdep[Maxn], Vis[Maxn], ma[Maxn];\nint Vis1[Maxn];\nint cnt;\n\ninline void dfs (int s, int x, int fa, int dep)\n{\n    Vis[x] = cnt;\n    if (dep >= maxdep[s]) maxdep[s] = dep, now[s] = x;\n    for (int i = Begin[x]; i; i = Next[i])\n    {\n        int y = To[i];\n        if (y == fa) continue;\n        dfs(s, y, x, dep + 1);\n    }\n}\n\nint Maxdep;\n\ninline void dfs1 (int x, int fa, int dep)\n{\n    Vis1[x] = 1;\n    if (dep >= Maxdep) Maxdep = dep;\n    for (int i = Begin[x]; i; i = Next[i])\n    {\n        int y = To[i];\n        if (y == fa) continue;\n        dfs1(y, x, dep + 1);\n    }\n}\n\nint main()\n{\n    freopen(\"walk.in\", \"r\", stdin);\n    freopen(\"walk.out\", \"w\", stdout);\n    scanf(\"%d\", &N);\n    for (int i = 1; i < N; ++i)\n    {\n        int x, y, z;\n        scanf(\"%d%d%d\", &x, &y, &z);\n        E[i] = (node){x, y, z};\n        for (int j = 1; j * j <= z; ++j)\n        {\n            if (!(z % j))\n            {\n                vec[j].pb(i);\n                if (j * j != z)\n                    vec[z / j].pb(i);\n            }\n        }\n    }\n    for (int i = 1; i <= 1000000; ++i)\n    {\n        e = cnt = 0;\n        for (int j = 0; j < vec[i].size(); ++j)\n        {\n            add_edge (E[vec[i][j]].x, E[vec[i][j]].y, E[vec[i][j]].z),add_edge (E[vec[i][j]].y, E[vec[i][j]].x, E[vec[i][j]].z);\n        }\n        for (int j = 1; j <= top; ++j)\n            if (!Vis[Stack[j]])\n            {\n                ++cnt;\n                dfs(Stack[j], Stack[j], 0, 0);\n                ma[cnt] = now[Stack[j]];\n            }\n        Maxdep = 0;\n        for (int j = 1; j <= top; ++j)\n            if (!Vis1[ma[Vis[Stack[j]]]])\n                dfs1(ma[Vis[Stack[j]]], 0, 0);\n        while (top) Begin[Stack[top]] = Vis[Stack[top]] = Vis1[Stack[top]] = maxdep[Stack[top]] = now[Stack[top]] = 0, top--;\n        Ans[Maxdep] = i;\n    }\n    for (int i = N; i >= 1; --i) Ans[i] = max(Ans[i], Ans[i + 1]);\n    for (int i = 1; i <= N; ++i) printf(\"%d\\n\", Ans[i]);\n    return 0;\n}\n```\n","categories":["Problem"]},{"title":"「NOIp模拟赛6.11」最近公共祖先 - dfs序 + 线段树","url":"/2018/06/12/6-11-%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88-dfs%E5%BA%8F-%E7%BA%BF%E6%AE%B5%E6%A0%91/","content":"\n### Description\n\n给定一颗n个节点的有根树，每个节点有一个固定的权值和一种颜色(黑/白)，初始时都为白色，需实现以下操作： 1. Modify v：将v的颜色改为黑色 2. Query v： 找到一个黑色节点u，使得u和v的最近公共祖先z对应的权值尽可能大，输出z的权值，若不存在输出-1\n<!--more-->\n\n### Solution\n\n考试的时候差一点想到正解 \n考虑统计贡献。对于每一个节点，显然它只会对它子树中的节点产生贡献。 \n我们考虑将节点x染黑时，我们先用W\\[x\\]更新x的子树中的所有节点，\n然后对于x的每一个祖先f，设x在f的子节点g所对应的子树中，那么在f的子树中除掉g的子树的部分就是需要用W\\[f\\]更新的部分。 \n接下来有个非常重要的优化：如果对于一个节点x，如果它在此次修改操作前子树中已经存在黑色节点，那么显然在用W\\[x\\]更新完答案后就不需要更新x的祖先了。\n因为x的祖先肯定已经通过同样的方式更新过一次了。 \n加上这个优化后，更新的总次数最多为$n+m$次 \n那么我们直接在dfs序上用线段树维护子树信息即可 \n总复杂度$O(m \\\\log n + n\\\\log n)$\n\n### Code\n```cpp\n    #include <bits/stdc++.h>\n    \n    using namespace std;\n    \n    const int Maxn = 100000 + 100, Maxm = 2 * 100000 + 100;\n    \n    int N, M;\n    \n    int e, Begin[Maxn], To[Maxm], Next[Maxm];\n    int W[Maxn], fa[Maxn], dfn[Maxn], Index, size[Maxn];\n    int Vis[Maxn];\n    \n    namespace DS\n    {\n        int Tree[Maxn << 2], tag[Maxn << 2];\n    \n        inline void init ()\n        {\n            memset(Tree, -1, sizeof Tree);\n            memset(tag, -1, sizeof tag);\n        }\n    \n        inline void push_up (int x)\n        {\n            Tree[x] = max(Tree[x << 1], Tree[x << 1 | 1]);\n        }\n    \n        inline void push_down (int x)\n        {\n            if (tag[x] == -1) return ;\n            Tree[x << 1] = max(tag[x], Tree[x << 1]);\n            Tree[x << 1 | 1] = max(tag[x], Tree[x << 1 | 1]);\n            tag[x << 1] = max(tag[x], tag[x << 1]);\n            tag[x << 1 | 1] = max(tag[x], tag[x << 1 | 1]);\n            tag[x] = -1;\n        }\n    \n        inline void update (int root, int l, int r, int x, int y, int v)\n        {\n            if (x > r || y < l) return ;\n            if (x <= l && r <= y)\n            {\n                Tree[root] = max(Tree[root], v);\n                tag[root] = max(tag[root], v);\n                return ;\n            }\n            int mid = (l + r) >> 1;\n            push_down (root);\n            if (x <= mid) update (root << 1, l, mid, x, y, v);\n            if (y > mid) update (root << 1 | 1, mid + 1, r, x, y, v);\n            push_up (root);\n        }\n    \n        inline int query (int root, int l, int r, int x)\n        {\n            if (l == r) return Tree[root];\n            int mid = (l + r) >> 1;\n            push_down(root);\n            if (x <= mid) return query (root << 1, l, mid, x);\n            else return query (root << 1 | 1, mid + 1, r, x);\n        }\n    }\n    \n    inline void add_edge (int x, int y)\n    {\n        To[++e] = y;\n        Next[e] = Begin[x];\n        Begin[x] = e;\n    }\n    \n    inline void dfs (int x)\n    {\n        dfn[x] = ++Index;\n        size[x] = 1;\n        for (int i = Begin[x]; i; i = Next[i])\n        {\n            int y = To[i];\n            if (fa[x] == y) continue;\n            fa[y] = x;\n            dfs(y);\n            size[x] += size[y];\n        }\n    }\n    \n    inline void update (int x)\n    {\n        DS :: update(1, 1, N, dfn[x], dfn[x] + size[x] - 1, W[x]);\n        if (Vis[x]) return ;\n        Vis[x] = 1;\n        int last = x;\n        x = fa[x];\n        while (x)\n        {\n            DS :: update (1, 1, N, dfn[x], dfn[last] - 1, W[x]);\n            DS :: update (1, 1, N, dfn[last] + size[last], dfn[x] + size[x] - 1, W[x]);\n            if (Vis[x]) return ;\n            Vis[x] = 1;\n            last = x;\n            x = fa[x];\n        }\n    }\n    \n    int main()\n    {\n        freopen(\"lca.in\", \"r\", stdin);\n        freopen(\"lca.out\", \"w\", stdout);\n        scanf(\"%d%d\", &N, &M);\n    \n        for (int i = 1; i <= N; ++i) scanf(\"%d\", &W[i]);\n        for (int i = 1; i < N; ++i)\n        {\n            int x, y;\n            scanf(\"%d%d\", &x, &y);\n            add_edge (x, y);\n            add_edge (y, x);\n        }\n    \n        dfs(1);\n    \n        DS :: init();\n        char S[10];\n        while (M--)\n        {\n            int x;\n            scanf(\"%s%d\", S, &x);\n            if (S[0] == 'M') update (x);\n            else\n                printf(\"%d\\n\", DS :: query (1, 1, N, dfn[x]));\n        }\n        return 0;\n    }\n```\n","categories":["Problem"],"tags":["线段树"]},{"title":"「CF987F」 AND Graph - 建图","url":"/2018/06/04/Codeforces-Round-485-Div-2-F-AND-Graph-%E5%BB%BA%E5%9B%BE/","content":"\n题目链接：[传送门](http://codeforces.com/contest/987/problem/F)\n\n### Description\n\n给定$m$个均小于$2^n$的数，其中若满足$x \\& y = 0$则x和y之间有一条边。问连完所有边后连通块个数\n<!--more-->\n\n### Hint\n\n$0 \\leq n \\leq 22, 1\\leq m \\leq 2^n$\n\n### Solution\n\n套路建图题。 之前cxr大佬讲过一个类似的题目，思路差不多 \n总共建$m+2^n$个点，m个给出的点记为$(x,1)$，另外建$2^n$个点，记为$(x,2)$ 考虑这样连边：\n\n##### 对于所给的m个点从$(x,1)$ 连向 $(x,2)$\n\n##### 对于所有的x从$(x,2)$连向$(x|(1 << k),2)$，其中k满足x的第k位为0\n\n##### 对于所给的m个点从$(\\sim x,2)$连向$(x,1)$ ~x为x在$2^n$意义下取反\n\n证明比较显然，就不赘述了 不用真正把边都连出来，直接dfs即可\n\n### Code\n```cpp\n    #include <bits/stdc++.h>\n    \n    using namespace std;\n    \n    const int Maxn = (1 << 22) + 1000;\n    \n    int A[Maxn], P[Maxn], N, M, PP[Maxn];\n    \n    inline void dfs (int x)\n    {\n        int REV = ((1 << N) - 1) ^ x;\n        if (P[REV]) return ;\n        P[REV] = 1;\n        if (PP[REV]) dfs(REV);\n        for (int i = 0; i < N; ++i)\n        {\n            if (!(x & (1 << i)))\n            {\n                dfs(x | (1 << i));\n            }\n        }\n    }\n    \n    int main()\n    {\n    #ifdef hk_cnyali\n        freopen(\"F.in\", \"r\", stdin);\n        freopen(\"F.out\", \"w\", stdout);\n    #endif\n        scanf(\"%d%d\", &N, &M);\n        for (int i = 1; i <= M; ++i){ scanf(\"%d\", &A[i]); PP[A[i]] = 1;}\n        int cnt = 0;\n        for (int i = 1; i <= M; ++i)\n        {\n            if (!P[A[i]])\n            {\n                ++cnt;\n                dfs(A[i]);\n            }\n        }\n        cout<<cnt<<endl;\n        return 0;\n    }\n```\n","categories":["Problem"],"tags":["Codeforces"]},{"title":"「AH2017/HNOI2017」礼物 - FFT","url":"/2018/05/17/HNOI2017-%E7%A4%BC%E7%89%A9-FFT/","content":"\n题目链接：[传送门](https://www.luogu.org/problemnew/show/P3723)\n\n### Description\n\n有两个长度为$n$的序列，序列元素为$[1,m]$ ，定义两个序列的差异值为$n_i=\\sum(x_i-y_i)^2$ \n\n可以给第一个序列加上一个长度c，第二个序列可以任意旋转，问最小差异值。\n\n<!--more-->\n\n### Constraints\n\n$n\\le50000,m\\le100$\n\n### Solution\n\n假设差异值最小的序列为A和B，则其差异值为 \n\n$\\sum (a_i-b_i+c)$ $=\\sum (a_i^2 + b_i^2) + nc^2 + 2c\\sum(a_i-b_i)^2-2\\sum a_i b_i$\n\n第一项已知，二三项可以通过枚举c求出最小值，因此我们只需要$\\sum a_i b_i$最大 \n\n将A翻转之后原式变为$\\sum a_{n-i+1} b_i$ 显然它是一个卷积的形式。\n\n我们将翻转后的A序列倍长，卷上B，用FFT即可（答案即为卷积后n+1项至2n项中间的最大值,这个自己推一推就能发现） \n\nPS： FFT注意最后要**四舍五入**。。。\n\n### Code\n```cpp\n#include <bits/stdc++.h>\n#define int long long\n\nusing namespace std;\n\nconst int Maxn = 1000000 + 100;\nconst double PI = acos(-1.0);\n\nstruct Complex \n{\n\tdouble x, y;\n\tComplex() {x = 0, y = 0;}\n\tfriend Complex operator + (const Complex &a, const Complex &b)\n\t{\n\t\tComplex c;\n\t\tc.x = a.x + b.x, c.y = a.y + b.y;\n\t\treturn c;\n\t}\n\tfriend Complex operator - (const Complex &a, const Complex &b)\n\t{\n\t\tComplex c;\n\t\tc.x = a.x - b.x, c.y = a.y - b.y;\n\t\treturn c;\n\t}\n\tfriend Complex operator * (const Complex &a, const Complex &b)\n\t{\n\t\tComplex c;\n\t\tc.x = a.x * b.x - a.y * b.y;\n\t\tc.y = a.x * b.y + a.y * b.x;\n\t\treturn c;\n\t}\n};\n\nComplex F1[Maxn], F2[Maxn];\n\nint A[Maxn], B[Maxn];\nint N, M, limit, NN;\nint rev[Maxn];\n\ninline void FFT_init()\n{\n\tfor (int i = 1; i <= N * 2; ++i) F1[i].x = (double)A[i], F2[i].x = (double)B[i];\n\tM = N * 3;\n\tfor (NN = 1; NN <= M; NN <<= 1) limit ++;\n\tfor (int i = 0; i < NN; ++i) rev[i] = (rev[i >> 1] >> 1) | ((i & 1) * (1 << (limit - 1)));\n}\n\ninline void FFT (Complex *A, int type)\n{\n\tfor (int i = 0; i <= NN; ++i) if (i < rev[i]) swap(A[i], A[rev[i]]);\n\tfor (int mid = 1; mid < NN; (mid <<= 1))\n\t{\n\t\tComplex Wn;\n\t\tWn.x = cos(PI / mid), Wn.y = type * sin(PI / mid);\n\t\tfor (int I = (mid << 1), i = 0; i < NN; i += I)\n\t\t{\n\t\t\tComplex W;\n\t\t\tW.x = 1;\n\t\t\tfor (int j = 1; j <= mid; ++j, W = W * Wn)\n\t\t\t{\n\t\t\t\tComplex x = A[i + j - 1], y = W * A[i + j + mid - 1];\n\t\t\t\tA[i + j - 1] = x + y, A[i + j + mid - 1] = x - y;\n\t\t\t}\n\t\t}\n\t}\n\tif (type == -1) for (int i = 0; i <= NN; ++i) A[i].x /= NN;\n}\n\nmain()\n{\n#ifdef hk_cnyali\n\tfreopen(\"gift.in\", \"r\", stdin);\n\tfreopen(\"gift.out\", \"w\", stdout);\n#endif\n\tscanf(\"%lld%lld\", &N, &M);\n\tint sum1 = 0, sum2 = 0, ans = 0;\n\tfor (int i = 1; i <= N; ++i) scanf(\"%lld\", &A[i]), sum1 += A[i] * A[i], sum2 += A[i];\n\tfor (int i = 1; i <= N; ++i) scanf(\"%lld\", &B[i]), sum1 += B[i] * B[i], sum2 -= B[i];\n\n\tans = LLONG_MAX;\n\tfor (int c = M - 100; c <= M + 100; ++c)\n\t\tans = min(ans, N * c * c + 2 * c * sum2);\n\tans += sum1;\n\treverse(A + 1, A + N + 1);\n\tfor (int i = 1; i <= N; ++i) A[i + N] = A[i];\n\n\tFFT_init();\n\tFFT(F1, 1), FFT(F2, 1);\n\tfor (int i = 0; i <= NN; ++i) F1[i] = F1[i] * F2[i];\n\tFFT(F1, -1);\n\n\tsum1 = 0ll;\n\tfor (int i = N + 1; i <= 2 * N; ++i) sum1 = max(sum1, (int)(F1[i].x + 0.5));\n\n\tprintf(\"%lld\\n\", ans - 2ll * sum1);\n\treturn 0;\n}\n```\n","categories":["Problem"],"tags":["FFT"]},{"title":"「CF967E」Big Secret - 贪心","url":"/2018/05/01/Codeforces-Round-477-Div-2-E-Big-Secret-%E8%B4%AA%E5%BF%83/","content":"\n题目连接：[传送门](http://codeforces.com/contest/967/problem/E)\n\n### Description\n\n给你一个数列$A$，求是否存在它的一个排列使得前缀异或和单调递增。如果存在，则输出一种方案\n<!--more-->\n\n### Hint\n\n$N \\leq 10^5, A_i\\leq 2^{60}$\n\n### Sample Input\n\n> 6 4 7 7 12 31 61\n\n### Sample Output\n\n> Yes 4 12 7 31 7 61\n\n### Solution\n\n我们倒着按位考虑。 \n先将所有数全都异或起来，那么我们需要依次选择这些数，使得异或出来的结果递减。 \n于是直接对当前已经异或出来的结果$state$从低位到高位贪心。\n假设当前考虑到第i位，那么我们只需看是否存在一个最高位为i的数还未被选。\n这样就能保证$state$递减，并且是最优的情况。\n如果在某一时刻不存在这样的i，那么无解 \n最后将记下来的数列翻转一下即为答案，时间复杂度$O(N log \\ max\\{A_i\\} )$\n\n### Code\n```cpp\n    #include <bits/stdc++.h>\n    #define int long long\n    \n    using namespace std;\n    \n    const int Maxn = 100000 + 100;\n    \n    int N;\n    \n    struct node\n    {\n        int val, h;\n    }A[Maxn];\n    \n    inline int cmp (node a, node b) {return a.val < b.val;}\n    \n    stack <int> S[70];\n    int Ans[Maxn];\n    \n    main()\n    {\n    #ifdef hk_cnyali\n        freopen(\"E.in\", \"r\", stdin);\n        freopen(\"E.out\", \"w\", stdout);\n    #endif\n        scanf(\"%lld\", &N);\n        int sum = 0;\n        for (int i = 1; i <= N; ++i) scanf(\"%lld\", &A[i].val), sum ^= A[i].val;\n    \n        for (int i = 1; i <= N; ++i)\n        {\n            int x = A[i].val;\n            while (x)\n                x >>= 1, A[i].h ++;\n            S[A[i].h].push(i);\n        }\n    \n    \n        for (int i = 1; i <= N; ++i)\n        {\n            int a = sum, len = 1, pos = 0;\n            while (a)\n            {\n                if ((a & 1) && !S[len].empty())\n                {\n                    pos = S[len].top(); S[len].pop();\n                    break;\n                }\n                ++len;\n                a >>= 1;\n            }\n            if (!pos)\n            {\n                cout<<\"No\"<<endl;\n                return 0;\n            }\n            sum ^= A[pos].val;\n            Ans[++Ans[0]] = A[pos].val;\n        }\n        reverse(Ans + 1, Ans + N + 1);\n    \n        cout<<\"Yes\"<<endl;\n        for (int i = 1; i <= N; ++i) printf(\"%lld \", Ans[i]);\n        puts(\"\");\n        return 0;\n    }\n```\n","categories":["Problem"],"tags":["Codeforces","贪心"]},{"title":"「NOIp模拟赛5.1」B - 线段树","url":"/2018/05/01/5-1-B/","content":"\n### Description\n\n有一个 N 块石头组成的蓄水池,第 i 块石头高度为 ai。你需要进行两种操作: 1.询问蓄水池的容量(蓄水池最多能储存多少水)。 2.将第 x 块石头的高度增加 v。 \n\n<!--more-->\n\n### Hint\n\n$1 \\leq N,Q \\leq 10^5$ $1 \\leq a_i \\leq 10^4, 1\\leq x\\leq N, 1 \\leq v \\leq 10^4$\n\n### Solution\n\n我的做法好像和别人的做法都不太一样。。。 考虑类似于分治的做法，每次求出区间的最大值和最大值所在的位置。然后看这个最大值是否比区间的左右端点高，如果高的话就分开递归求解；否则答案直接加上左右端点较短的那条边所对应的整个矩形大小减去被填上的大小。 然后维护最大值和最大值的位置用一个线段树维护下（单点修改，区间查询），区间被填上的大小（即A\\[i\\]的和）再用一个线段树维护下（也是单点修改，区间查询）。算上之前的分治，总复杂度为$O(Nlog^2N)$ 自认为这个做法还是比较好想的\n\n### Code\n\n```cpp\n    #include <bits/stdc++.h>\n    #define LL long long\n    \n    using namespace std;\n    \n    const int Maxn = 100000 + 100, inf = 0x3f3f3f3f;\n    \n    int N, M;\n    int A[Maxn], Sum[Maxn];\n    \n    namespace SEG1\n    {\n        struct tree\n        {\n            int Max, sum, pos;\n        }Tree[Maxn * 4];\n    \n        inline void push_up(int root)\n        {\n            if (Tree[root << 1].Max >= Tree[root].Max)\n                Tree[root].Max = Tree[root << 1].Max, Tree[root].pos = Tree[root << 1].pos;\n            if (Tree[root << 1 | 1].Max >= Tree[root].Max)\n                Tree[root].Max = Tree[root << 1 | 1].Max, Tree[root].pos = Tree[root << 1 | 1].pos;\n        }\n    \n        inline void create(int root, int l, int r)\n        {\n            if (l == r) { Tree[root].sum = Tree[root].Max = A[l]; Tree[root].pos = l; return ; }\n            int mid = (l + r) >> 1;\n            create(root << 1, l, mid);\n            create(root << 1 | 1, mid + 1, r);\n            push_up(root);\n        }\n    \n        inline void update (int root, int l, int r, int x, int y)\n        {\n            if (l == r)\n            {\n                Tree[root].sum += y;\n                Tree[root].Max = max(Tree[root].Max, Tree[root].sum);\n                return ;\n            }\n            int mid = (l + r) >> 1;\n            if (x <= mid) update (root << 1, l, mid, x, y);\n            else update (root << 1 | 1, mid + 1, r, x, y);\n            push_up(root);\n        }\n    \n        int MAX, POS;\n        inline void query (int root, int l, int r, int x, int y)\n        {\n            if (x > r || y < l) return ;\n            if (x <= l && r <= y)\n            {\n                if (Tree[root].Max >= MAX) MAX = Tree[root].Max, POS = Tree[root].pos;\n                return ;\n            }\n            int mid = (l + r) >> 1;\n            if (x <= mid) query (root << 1, l, mid, x, y);\n            if (y > mid) query (root << 1 | 1, mid + 1, r, x, y);\n        }\n    }\n    \n    namespace SEG2\n    {\n        struct node\n        {\n            int Sum;\n        }Tree[Maxn * 4];\n        inline void push_up(int root)\n        {\n            Tree[root].Sum = (Tree[root << 1].Sum + Tree[root << 1 | 1].Sum);\n        }\n        inline void create(int root, int l, int r)\n        {\n            if (l == r) { Tree[root].Sum = A[l]; return ; }\n            int mid = (l + r) >> 1;\n            create(root << 1, l, mid);\n            create(root << 1 | 1, mid + 1, r);\n            push_up(root);\n        }\n        inline void update(int root, int l, int r, int x, LL y)\n        {\n            if (l == r)\n            {\n                Tree[root].Sum += (y * (r - l + 1));\n                return ;\n            }\n            int mid = (l + r) >> 1;\n            if (x <= mid) update (root << 1, l, mid, x, y);\n            else update (root << 1 | 1, mid + 1, r, x, y);\n            push_up(root);\n        }\n    \n        inline int query (int root, int l, int r, int x, int y)\n        {\n            if (x > r || y < l) return 0;\n            if (x <= l && r <= y) return Tree[root].Sum;\n            int mid = (l + r) >> 1, Ans = 0;\n            if (x <= mid) Ans += query(root << 1, l, mid, x, y);\n            if (y > mid) Ans += query(root << 1 | 1, mid + 1, r, x, y);\n            push_up(root);\n            return Ans;\n        }\n    }\n    \n    inline LL Solve (int l, int r)\n    {\n        if (l >= r - 1) return 0;\n        SEG1 :: MAX = 0;\n        SEG1 :: POS = 0;\n        SEG1 :: query (1, 1, N, l + 1, r - 1);\n        int pos = SEG1 :: POS;\n        if (A[pos] <= A[l] && A[pos] <= A[r])\n            return (LL)min(A[l], A[r]) * (r - l - 1) - SEG2 :: query(1, 1, N, l + 1, r - 1);\n        return Solve(l, pos) + Solve(pos, r);\n    }\n    \n    int main()\n    {\n        freopen(\"B.in\", \"r\", stdin);\n        freopen(\"B.out\", \"w\", stdout);\n        scanf(\"%d%d\", &N, &M);\n        for (int i = 1; i <= N; ++i) scanf(\"%d\", &A[i]);\n        SEG1 :: create(1, 1, N);\n        SEG2 :: create(1, 1, N);\n        while (M--)\n        {\n            char S[5];\n            scanf(\"%s\", S);\n            if (S[0] == 'P')\n                printf(\"%lld\\n\", Solve(1, N));\n            else \n            {\n                int x, y;\n                scanf(\"%d%d\", &x, &y);\n                A[x] += y;\n                SEG1 :: update(1, 1, N, x, y);\n                SEG2 :: update(1, 1, N, x, y);\n            }\n        }\n        return 0;\n    }\n```\n","categories":["Problem"],"tags":["线段树","分治"]},{"title":"「NOIp模拟赛5.1」A - 前缀和","url":"/2018/05/01/5-1-A/","content":"\n### Description\n\n给定长度为 n 的 01 串 S,定义 F(x, y) (x <= y)为 S 串第 x 位到第 y 位中 ‘1’ 的个数。 求有多少个三元组 (i, j, k) 满足 i < j < k, Sj = 1 且 F(i, j) = F(j, k)\n\n\n<!--more-->\n\n### Hint\n\n$3 \\leq n \\leq 2 * 10^5$\n\n### Solution\n\n考试的时候一直是往先确定j，然后再去计算i和k的取值的方面想的，然后不知道怎么优化到$O(N)$。。。 可以发现，当确定了i和k时，j就能被确定。并且只有当F(i,k)为奇数且除了i和k之外至少要有一个1时才存在j。然后我们用前缀和搞一下就可以了\n\n### Code\n\n```cpp\n    #include <bits/stdc++.h>\n    #define int long long\n    \n    using namespace std;\n    \n    const int Maxn = 2 * 1e5 + 100;\n    \n    int A[Maxn], N;\n    int Sum[Maxn], SUM[Maxn][2], Next[Maxn], Pre[Maxn];\n    \n    inline int safe_getchar ()\n    {\n        char ch = getchar();\n        while (ch != '0' && ch != '1') ch = getchar();\n        return ch - '0';\n    }\n    \n    main()\n    {\n        freopen(\"A.in\", \"r\", stdin);\n        freopen(\"A.out\", \"w\", stdout);\n        scanf(\"%lld\", &N);\n        for (int i = 1; i <= N; ++i)\n            A[i] = safe_getchar(), Sum[i] = Sum[i - 1] + A[i];\n        int cnt1 = 0, cnt2 = 0, Ans = 0, pos = 0;\n        SUM[0][0] = 1;\n        for (int i = 1; i <= N; ++i)\n        {\n            if (Sum[i] & 1)\n                SUM[i][1] = SUM[i - 1][1] + 1, SUM[i][0] = SUM[i - 1][0];\n            else \n                SUM[i][0] = SUM[i - 1][0] + 1, SUM[i][1] = SUM[i - 1][1];\n            Pre[i] = pos;\n            if (A[i])\n                pos = i;\n        }\n        for (int i = 2; i <= N; ++i)\n        {\n            Ans += SUM[Pre[i] - 2][((Sum[i] % 2) ^ 1)];\n    //      cout<<i<<\" \"<<Ans<<endl;\n        }\n        cout<<Ans<<endl;\n        return 0;\n    }\n```\n","categories":["Problem"],"tags":["前缀和"]},{"title":"「NOIp模拟赛4.30」排列 - 网络流","url":"/2018/04/30/4-30-%E6%8E%92%E5%88%97-permutation/","content":"\n### Description\n\n有 n 个数 x 1 ~x n 。你需要找出它们的一个排列,满足 m 个条件,每个条件形 如 x a 必须在 x b 之前。在此基础上,你要最大化这个排列的最大子段和\n<!--more-->\n\n### Hint\n\n$n\\\\leq500,m\\\\leq1000,|x_i|\\\\leq1000$,保证存在至少一种排列\n\n### Solution\n\n考虑最小割，把问题转化成删掉一些点 \n首先，对于最后的的答案,一定形如“不选->选->不选”这样的三段。 \n那么，将每个点拆成 S->i1->i2->T,割不同的三条边分别表示在不同的三段中。\n 对于每个点，如果它的值大于0，那么从S向i1，i2向T分别连容量为权值的边；\n否则从i1向i2连容量为权值的相反数的边 \n每个限制(a,b)，我们如果将(a1,b1), (a2,b2)连上容量为正无穷的边，就能保证a和b一定在相同的割集中，也就满足了这个限制。 \n答案就是正的权值和-最小割\n\n### Code\n\n```cpp\n    #include <bits/stdc++.h>\n    \n    using namespace std;\n    \n    const int Maxn = 2000 + 10, Maxm = 8000 + 10, S = 2002, T = 2003, inf = 0x3f3f3f3f;\n    \n    int N, M;\n    int e, Begin[Maxn], To[Maxm], Next[Maxm], W[Maxm];\n    \n    inline void add_edge (int x, int y, int z)\n    {\n        To[e] = y;\n        Next[e] = Begin[x];\n        Begin[x] = e;\n        W[e++] = z;\n    }\n    \n    inline void Link (int x, int y, int z)\n    {\n        add_edge (x, y, z);\n        add_edge (y, x, 0);\n    }\n    \n    namespace Flow\n    {\n        int Dis[Maxn];\n    \n        inline int bfs ()\n        {\n            queue <int> Q;\n            Q.push(S);\n            memset(Dis, -1, sizeof Dis);\n            Dis[S] = 0;\n            while (!Q.empty())\n            {\n                int x = Q.front(); Q.pop();\n                for (int i = Begin[x]; ~i; i = Next[i])\n                {\n                    int y = To[i];\n                    if (W[i] <= 0 || Dis[y] != -1) continue;\n                    Dis[y] = Dis[x] + 1;\n                    Q.push(y);\n                }\n            }\n            return Dis[T] != -1;\n        }\n    \n        inline int find (int x, int now)\n        {\n            if (x == T) return now;\n            for (int i = Begin[x]; ~i; i = Next[i])\n            {\n                int y = To[i], sum;\n                if (W[i] > 0 && Dis[y] == Dis[x] + 1 && (sum = find(y, min(now, W[i]))))\n                {\n                    W[i] -= sum;\n                    W[i ^ 1] += sum;\n                    return sum;\n                }\n            }\n            return 0;\n        }\n    \n        inline int work ()\n        {\n            int ans = 0;\n            while (bfs())\n            {\n                int sum = 0;\n                while (sum = find(S, inf)) ans += sum;\n            }\n            return ans;\n        }\n    }\n    \n    int main()\n    {\n        freopen(\"permutation.in\", \"r\", stdin);\n        freopen(\"permutation.out\", \"w\", stdout);\n        memset(Begin, -1, sizeof Begin);\n        scanf(\"%d%d\", &N, &M);\n        int sum = 0;\n        for (int i = 1; i <= N; ++i)\n        {\n            int x;\n            scanf(\"%d\", &x);\n            if (x > 0)\n            {\n                sum += x;\n                Link(S, i, x);\n                Link(i + N, T, x);\n            }\n            else \n            {\n                Link(i, i + N, -x);\n            }\n        }\n        for (int i = 1; i <= M; ++i)\n        {\n            int x, y;\n            scanf(\"%d%d\", &x, &y);\n            Link(x, y, inf);\n            Link(x + N, y + N, inf);\n        }\n        printf(\"%d\\n\", sum - Flow :: work());\n        return 0;\n    }\n```\n","categories":["Problem"],"tags":["网络流","最大流","最小割"]},{"title":"「NOIp模拟赛4.30」数列 - 贪心","url":"/2018/04/30/4-30-%E6%95%B0%E5%88%97-sequence/","content":"\n### Description\n\n给定一个整数数列 a,定义$f(a) = max_{1\\\\leq i < j \\\\leq n} \\\\{ a_j-a_i \\\\}$,保证 $f(a) > 0$ 你需要求出至少需要修改 a 的多少个位置才能使$ f(a)$变小。注意,你修改之后的数也必须是整数。\n\n<!--more-->\n\n### Hint\n\n$2 \\\\leq n \\\\leq 10^6 , |a_i| \\\\leq 10^9$\n\n### Solution\n\n这道题刚看起来没有一点思路，感觉完全不知道怎么做。仔细分析之后就可以发现实际上就是一个简单的贪心。我们先将最大的符合条件的差值Max求出，然后再扫一遍，将所有满足差值为Max的这样的组合找出，把数量直接加起来即可\n\n### Code\n\n```cpp\n    #include <bits/stdc++.h>\n    \n    using namespace std;\n    \n    const int Maxn = 2 * 1e6 + 100;\n    \n    int N, A[Maxn], P[Maxn];\n    \n    int maxx = -0x3f3f3f3f, ans = 0x3f3f3f3f;\n    \n    inline void Check (int sum)\n    {\n        int Min = 0x3f3f3f3f, Max = 0;\n        for (int i = 1; i <= N; ++i)\n        {\n            if (!P[i])\n            {\n                Min = min(Min, A[i]);\n                Max = max(Max, A[i] - Min);\n            }\n        }\n        if (Max < maxx)\n        {\n            ans = min(ans, sum);\n        }\n    }\n    \n    inline void dfs (int x, int sum)\n    {\n        if (x == N)\n        {\n            Check(sum);\n            return ;\n        }\n        P[x + 1] = 1;\n        dfs(x + 1, sum + 1);\n        P[x + 1] = 0;\n        dfs(x + 1, sum);\n    }\n    \n    map <int, int> Map;\n    int main()\n    {\n        freopen(\"sequence.in\", \"r\", stdin);\n        freopen(\"sequence.out\", \"w\", stdout);\n        scanf(\"%d\", &N);\n    \n        int Max = -0x3f3f3f3f, Min = INT_MAX, top = 0;\n        for (int i = 1; i <= N; ++i)\n        {\n            scanf(\"%d\", &A[i]);\n            Min = min(Min, A[i]);\n            Max = max(Max, A[i] - Min);\n        }\n        if (N <= 20)\n        {\n            maxx = Max;\n            dfs(0, 0);\n            cout<<ans<<endl;\n            return 0;\n        }\n    \n        int Ans = 0;\n        for (int i = 1; i <= N; ++i)\n        {\n            if (Map[A[i] - Max])\n            {\n                Map[A[i] - Max] --;\n                ++Ans;\n            }\n            Map[A[i]]++;\n        }\n        cout<<Ans<<endl;\n        return 0;\n    }\n```\n","categories":["Problem"],"tags":["贪心"]},{"title":"「AGC001E」BBQ Hard - 组合数学","url":"/2018/03/29/agc001-E-BBQ-Hard-%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/","content":"\n题目链接：[传送门](https://beta.atcoder.jp/contests/agc001/tasks/agc001_e)\n\n### Description\n\n求$\\sum_{i=1}^{n}\\sum_{j=1}^{i-1}\\binom{A_i+B_i+A_j+B_j}{A_i+A_j}$\n\n<!--more-->\n\n### Solution\n\n我们通过观察式子可以发现题目就是要求所有$(-A_i,-B_i)$到$(A_j,B_j)$的方案数（只能向上走或者向右走），于是我们可以用Dp来解决，初始化时在每个$Dp[-A[i]] [-B[i]]$处++，然后直接用$Dp[i][j]+=Dp[i-1][j]+Dp[i][j-1]$统计答案即可 然后因为我们求的j是< i的，所以需要减去一个$(-A[i],-B[i])$到自己的方案，并且最后的ans要除以2\n\n### Code\n\n```cpp\n    #include <bits/stdc++.h>\n    \n    using namespace std;\n    \n    typedef long long LL;\n    \n    const int Maxn = 200000, Maxm = 4000, Mod = (int)(1e9 + 7);\n    \n    int A[Maxn + 10], B[Maxn + 10], Dp[Maxm * 2 + 10][Maxm * 2 + 10], fac[Maxn + 10], inv[Maxn + 10];\n    int N;\n    \n    inline int Pow (LL a, int b)\n    {\n        LL ans = 1;\n        while (b)\n        {\n            if (b & 1) (ans *= a) %= Mod;\n            (a *= a) %= Mod;\n            b >>= 1;\n        }\n        return ans;\n    }\n    \n    inline int C (int n, int m)\n    {\n        return ((LL)fac[n] * inv[m] % Mod * inv[n - m] % Mod);\n    }\n    \n    main()\n    {\n    #ifdef hk_cnyali\n        freopen(\"A.in\", \"r\", stdin);\n        freopen(\"A.out\", \"w\", stdout);\n    #endif\n        scanf(\"%d\", &N);\n        fac[0] = 1;\n        inv[0] = 1;\n        for (int i = 1; i <= Maxn + 1; ++i) fac[i] = ((LL)fac[i - 1] * i) % Mod, inv[i] = Pow(fac[i], Mod - 2);\n        for (int i = 1; i <= N; ++i)\n        {\n            scanf(\"%d%d\", &A[i], &B[i]);\n            Dp[2001 - A[i]][2001 - B[i]] ++;\n            //cout<<Maxm + 1 - A[i]<<\" \"<<Maxm + 1 - B[i]<<endl;\n        }\n        for (int i = 1; i <= Maxm + 2; ++i)\n            for (int j = 1; j <= Maxm + 2; ++j)\n                (Dp[i][j] += Dp[i][j - 1] + Dp[i - 1][j]) %= Mod;\n        LL ans = 0;\n        for (int i = 1; i <= N; ++i)\n        {\n            ans += Dp[A[i] + 2001][B[i] + 2001];\n            ans = ((ans - C(A[i] + A[i] + B[i] + B[i], A[i] + A[i])) % Mod + Mod) % Mod;\n        }\n        printf(\"%d\\n\", ans * inv[2] % Mod);\n        return 0;\n    }\n```\n","categories":["Problem"],"tags":["数学","组合数学","agc","Atcoder"]},{"title":"3-26模拟赛 Summary","url":"/2018/03/26/3-26%E6%A8%A1%E6%8B%9F%E8%B5%9B-Summary/","content":"","categories":["Summary"]},{"title":"3-25模拟赛 Summary","url":"/2018/03/26/3-25%E6%A8%A1%E6%8B%9F%E8%B5%9B-Summary/","content":"","categories":["Summary"]},{"title":"Educational Codeforces Round 40 Summary","url":"/2018/03/26/Educational-Codeforces-Round-40-Summary/","content":"\n比赛链接：[传送门](http://codeforces.com/contest/954)\n\nProcess\n-------\n\n这场打得还可以，简单题做得比较快，但是后面两个小时连一道题都没做出来，有点可惜\n<!--more-->\n\nProblems\n--------\n\n### C Matrix Walk\n\n我们发现向左或向右走只会加减1，向上或向下只会加减m 于是第一遍for求出m，第二遍for判断是否出左右界，n直接输出10^9即可\n\n#### Code\n```cpp\n    #include <bits/stdc++.h>\n    \n    using namespace std;\n    \n    int N;\n    int A[200000 + 100];\n    \n    int main()\n    {\n    #ifdef hk_cnyali\n        freopen(\"C.in\", \"r\", stdin);\n        freopen(\"C.out\", \"w\", stdout);\n    #endif\n        scanf(\"%d\", &N);\n        int sum = 0;\n        for (int i = 1; i <= N; ++i)\n        {\n            scanf(\"%d\", &A[i]);\n            if (i == 1) continue;\n            if (abs(A[i] - A[i - 1]) == 1) continue;\n            if (A[i] == A[i - 1])\n            {\n                cout<<\"NO\"<<endl;\n                return 0;\n            }\n            if (sum && abs(A[i] - A[i - 1]) != sum) \n            {\n                cout<<\"NO\"<<endl;\n                return 0;\n            }\n            sum = abs(A[i] - A[i - 1]);\n        }\n        for (int i = 2; i <= N; ++i)\n        {\n            if (A[i] == A[i - 1] + 1 && sum && !(A[i - 1] % sum))\n            {\n                cout<<\"NO\"<<endl;\n                return 0;\n            }\n            if (A[i - 1] == A[i] + 1 && sum && !(A[i] % sum))\n            {\n                cout<<\"NO\"<<endl;\n                return 0;\n            }\n        }\n        if (!sum) sum = 1;\n        cout<<\"YES\"<<endl;\n        cout<<1000000000<<\" \"<<sum<<endl;\n        return 0;\n    }\n``` \n\n### D Fight Against Traffic\n\n分别以s和t为起点各跑一遍最短路，然后n^2枚举任意两个城市计算答案即可\n\n#### Code\n``cpp\n    #include <bits/stdc++.h>\n    \n    using namespace std;\n    \n    const int Maxn = 10000 + 10, Maxm = 20000 + 10, inf = 0x3f3f3f3f;\n    \n    int N, M, S, T;\n    int A[1010][1010];\n    \n    int e, Begin[Maxn], To[Maxm], Next[Maxm], W[Maxm];\n    int Vis[Maxn];\n    inline void add_edge(int x, int y)\n    {\n        To[++e] = y;\n        Next[e] = Begin[x];\n        Begin[x] = e;\n        W[e] = 1;\n    }\n    struct node\n    {\n        int a, b;\n        bool operator < (const node &x) const\n        {\n            return x.b < b;\n        }\n    };\n    priority_queue <node> Q;\n    inline void Dijkstra(int *Dis)\n    {\n        for (int i = 1; i <= N; ++i) Dis[i] = inf, Vis[i] = 0;\n        Dis[S] = 0;\n        while (!Q.empty()) Q.pop();\n        Q.push((node){S, 0});\n        while (!Q.empty())\n        {\n            node tmp = Q.top(); Q.pop();\n            int x = tmp.a;\n            if (Vis[x]) continue;\n            Vis[x] = 1;\n            for (int i = Begin[x]; i; i = Next[i])\n            {\n                int y = To[i];\n                if (Dis[y] > Dis[x] + W[i])\n                {\n                    Dis[y] = Dis[x] + W[i];\n                    Q.push((node){y, Dis[y]});\n                }\n            }\n        }\n    }\n    int Dis1[Maxn], Dis2[Maxn];\n    \n    int main()\n    {\n    #ifdef hk_cnyali\n        freopen(\"D.in\", \"r\", stdin);\n        freopen(\"D.out\", \"w\", stdout);\n    #endif\n        scanf(\"%d%d%d%d\", &N, &M, &S, &T);\n        for (int i = 1; i <= M; ++i)\n        {\n            int x, y;\n            scanf(\"%d%d\", &x, &y);\n            A[x][y] = 1;\n            A[y][x] = 1;\n            add_edge (x, y);\n            add_edge (y, x);\n        }\n        Dijkstra(Dis1);\n        swap(S, T);\n        Dijkstra(Dis2);\n        swap(S, T);\n        int sum = Dis1[T], ans = 0;\n        for (int i = 1; i <= N; ++i)\n        {\n            for (int j = i + 1; j <= N; ++j)\n            {\n                if (A[i][j]) continue;\n                //cout<<i<<\" \"<<j<<\" \"<<Dis1[i] + Dis2[j]<<\" \"<<sum<<endl;\n                if (Dis1[i] + Dis2[j] + 1 >= sum && Dis1[j] + Dis2[i] + 1 >= sum)\n                    ++ans;\n            }\n        }\n        //cout<<Dis1[2] + Dis2[5] <<endl;\n        cout<<ans<<endl;\n        return 0;\n    }\n```\n","categories":["Summary"],"tags":["Codeforces","最短路"]},{"title":"「BZOJ1101」ZAP-Queries - 莫比乌斯反演 + 整除分块入门","url":"/2018/03/24/Luogu-P3455-BZOJ1101-ZAP-Queries-%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94-%E6%95%B4%E9%99%A4%E5%88%86%E5%9D%97%E5%85%A5%E9%97%A8/","content":"\n题目链接：[传送门](https://www.luogu.org/problemnew/show/P3455)\n\n### Description\n\n对于给定的整数a,b和d，有多少正整数对x,y，满足x<=a，y<=b，并且gcd(x,y)=d。 数据组数<=50000, a, b <= 50000\n<!--more-->\n\n### Sample Input\n\n> 2 4 5 2 6 4 3\n\n### Sample Output\n\n> 3 2\n\n### Solution\n\n第一道这种数论题 \n\n我们假设n<=m，则有 \n\n$\\sum_{i=1}^n \\sum_{j=1}^m [gcd(i, j) == d]$ \n$=\\sum_{i=1}^{\\lfloor \\frac{n}{d} \\rfloor} \\sum_{j=1}^{\\lfloor \\frac{m}{d} \\rfloor } [gcd(i, j) == 1]$\n\n$=\\sum_{i=1}^{\\lfloor \\frac{n}{d} \\rfloor} \\sum_{j=1}^{\\lfloor \\frac{m}{d} \\rfloor}\\sum_{g|i, j}^n \\mu(g)$ \n\n$=\\sum_{g=1}^n \\mu(g) \\lfloor \\frac{n}{dg} \\rfloor \\lfloor \\frac{m}{dg} \\rfloor$ \n然后就能将μ求个前缀和，然后用整除分块来做了 \n\n整除分块就是我们可以发现像$\\lfloor \\frac{n}{i}\\rfloor$这样的式子的取值只有$\\sqrt N$种，而某一段连续的i的区间对应的是同一个值。 \n\n我们考虑，如果某一段区间的左端点为d的话，那么所对应的值x就等于$\\lfloor \\frac{n}{d}\\rfloor$。\n\n而区间的右端点的位置显然为$\\lfloor \\frac{n}{x}\\rfloor$，\n\n代入得到此时$d = \\lfloor \\frac{n}{\\lfloor \\frac{n}{d}\\rfloor}\\rfloor$\n\n于是就这样处理即可，复杂度为$O(\\sqrt N)$\n\n### Code\n```cpp\n    #include <bits/stdc++.h>\n    #define LL long long\n    \n    using namespace std;\n    \n    const int Maxn = 100000;\n    \n    int N, M, D;\n    int Not_Prime[Maxn + 100], Prime[Maxn + 100], Mu[Maxn + 100], cnt;\n    \n    inline void Init()\n    {\n        Not_Prime[0] = Not_Prime[1] = 1;\n        Mu[1] = 1;\n        for (int i = 2; i <= Maxn; ++i)\n        {\n            if (!Not_Prime[i])\n            {\n                Prime[++cnt] = i;\n                Mu[i] = -1;\n            }\n            for (int j = 1; j <= cnt && i  * Prime[j] <= Maxn; ++j)\n            {\n                Not_Prime[i * Prime[j]] = 1;\n                if (!(i % Prime[j])) break;\n                Mu[i * Prime[j]] = -Mu[i];\n            }\n        }\n        for (int i = 2; i < Maxn; ++i)\n            Mu[i] += Mu[i - 1];\n    }\n    \n    inline LL Solve ()\n    {\n        N /= D;\n        M /= D;\n        int last;\n        if (N > M) swap(N, M);\n        LL Ans = 0ll;\n        for (int i = 1; i <= N; i = last + 1)\n        {\n            last = min(N / (N / i), M / (M / i));\n            Ans += 1LL * (Mu[last] - Mu[i - 1]) * (N / i) * (M / i);\n        }\n        return Ans;\n    }\n    \n    int main()\n    {\n    #ifdef hk_cnyali\n        freopen(\"A.in\", \"r\", stdin);\n        freopen(\"A.out\", \"w\", stdout);\n    #endif\n        int T;\n        scanf(\"%d\", &T);\n        Init();\n        while (T--)\n        {\n            scanf(\"%d%d%d\", &N, &M, &D);\n            printf(\"%lld\\n\", Solve());\n        }\n        return 0;\n    }\n```\n","categories":["Problem"],"tags":["数论","线性筛","莫比乌斯反演"]},{"title":"最小生成树【最小瓶颈路、斯坦纳树、最小树形图、最小乘积生成树】Summary","url":"/2018/03/17/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E3%80%90%E6%9C%80%E5%B0%8F%E7%93%B6%E9%A2%88%E8%B7%AF%E3%80%81%E6%96%AF%E5%9D%A6%E7%BA%B3%E6%A0%91%E3%80%81%E6%9C%80%E5%B0%8F%E6%A0%91%E5%BD%A2%E5%9B%BE%E3%80%81%E6%9C%80%E5%B0%8F%E4%B9%98%E7%A7%AF%E7%94%9F%E6%88%90%E6%A0%91%E3%80%91Summary/","content":"\n知识点总结\n-----\n\n### 最小瓶颈路\n\n在最小生成树的基础上倍增处理下边权最大值就行\n\n### 斯坦纳树\n\n就是一个状压dp: $dp[i][state]$表示以i为根，指定集合中的点的连通状态为state的生成树的最小总权值 \n转移方程有两种： \n1、枚举子集： \n$dp[i][state] = min(dp[i][state], dp[i][sub] + dp[i][state - sub])$\n枚举子集的方法：\n\n```cpp\n    for(sub=(state-1)&state;sub;sub=(sub-1)&state) \n```\n\n2、松弛操作（i到j有边相连） \n$dp[i][state]=min(dp[i][state], dp[j][state]+W[i][j])$\n\n### [最小树形图](https://www.cnblogs.com/xzxl/p/7243466.html)\n\n### [最小乘积生成树](https://www.cnblogs.com/autsky-jadek/p/3959446.html)(这篇有图，比较清晰)\n\n<!--more-->\nProblems\n--------\n\n### Codeforces 733F Drivers Dissatisfaction(最小生成树+LCA)\n\n_[Codeforces 733F Drivers Dissatisfaction(最小生成树+LCA)](http://hk-cnyali.com/2018/03/16/codeforces-733f-drivers-dissatisfaction%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91lca/)_\n\n### BZOJ3732 Network(最小瓶颈路)\n\n最小瓶颈路模板\n```cpp\n    #include <bits/stdc++.h>\n    \n    using namespace std;\n    \n    const int Maxn = 150000 + 10, Maxm = 600000 + 100;\n    \n    struct node\n    {\n        int x, y, z;\n    }A[Maxn];\n    \n    inline int cmp (node a, node b)\n    {\n        return a.z < b.z;\n    }\n    \n    int N, M;\n    int e, Begin[Maxn], To[Maxm], Next[Maxm], W[Maxm];\n    int anc[Maxn][21], Max[Maxn][21];\n    int fa[Maxn], deep[Maxn];\n    \n    inline void add_edge (int x, int y, int z)\n    {\n        To[++e] = y;\n        Next[e] = Begin[x];\n        Begin[x] = e;\n        W[e] = z;\n    }\n    \n    inline int find (int x)\n    {\n        return fa[x] == x ? x : fa[x] = find(fa[x]);\n    }\n    \n    inline void dfs (int x)\n    {\n        for (int i = 1; i <= 20; ++i) anc[x][i] = anc[anc[x][i - 1]][i - 1], Max[x][i] = max(Max[x][i - 1], Max[anc[x][i - 1]][i - 1]);\n        for (int i = Begin[x]; i; i = Next[i])\n        {\n            int y = To[i];\n            if (y == anc[x][0]) continue;\n            anc[y][0] = x;\n            Max[y][0] = W[i];\n            deep[y] = deep[x] + 1;\n            dfs(y);\n        }\n    }\n    \n    inline int Lca (int x, int y)\n    {\n        int Ans = 0;\n        if (deep[x] < deep[y]) swap(x, y);\n        for (int i = 20; i >= 0; --i)\n            if (deep[anc[x][i]] >= deep[y])\n                Ans = max(Ans, Max[x][i]), x = anc[x][i];\n        if (x == y) return Ans;\n    \n        for (int i = 20; i >= 0; --i)\n            if (anc[x][i] != anc[y][i])\n                Ans = max(Ans, max(Max[x][i], Max[y][i])), x = anc[x][i], y = anc[y][i];\n    \n        Ans = max(Ans, max(Max[x][0], Max[y][0]));\n        return Ans;\n    }\n    \n    int main()\n    {\n    #ifdef hk_cnyali\n        freopen(\"A.in\", \"r\", stdin);\n        freopen(\"A.out\", \"w\", stdout);\n    #endif\n        int K;\n        scanf(\"%d%d%d\", &N, &M, &K);\n        for (int i = 1; i <= N; ++i) fa[i] = i;\n        for (int i = 1; i <= M; ++i)\n            scanf(\"%d%d%d\", &A[i].x, &A[i].y, &A[i].z);\n        sort(A + 1, A + M + 1, cmp);\n    \n        int cnt = 0;\n        for (int i = 1; i <= M; ++i)\n        {\n            int fx = find(A[i].x), fy = find(A[i].y);\n            if (fx == fy) continue;\n            add_edge (A[i].x, A[i].y, A[i].z);\n            add_edge (A[i].y, A[i].x, A[i].z);\n        //  add_edge (fx, fy, A[i].z);\n        //  add_edge (fy, fx, A[i].z);\n            fa[fy] = fx;\n            ++cnt;\n            if (cnt == N - 1) break;\n        }\n    \n        dfs(1);\n    \n        while (K--)\n        {\n            int x, y;\n            scanf(\"%d%d\", &x, &y);\n            printf(\"%d\\n\", Lca(x, y));\n        }\n        return 0;\n    }\n```\n\n\n### Hdu3311 Dig the Wells（斯坦纳树+状压dp+SPFA）\n\n_[Hdu3311 Dig the Wells（斯坦纳树+状压dp+SPFA）](http://hk-cnyali.com/2018/03/16/hdu3311-dig-the-wells%EF%BC%88%E6%96%AF%E5%9D%A6%E7%BA%B3%E6%A0%91%E7%8A%B6%E5%8E%8Bdpspfa%EF%BC%89/)_\n\n### Hdu4085 Peach Blossom Spring(斯坦纳树)\n\n_[Hdu4085 Peach Blossom Spring(斯坦纳树)](http://hk-cnyali.com/2018/03/17/hdu4085-peach-blossom-spring%E6%96%AF%E5%9D%A6%E7%BA%B3%E6%A0%91/)_\n\n### Hdu4966 GGS-DDU (最小树形图/朱刘算法)\n\n_[Hdu4966 GGS-DDU (最小树形图/朱刘算法)](http://hk-cnyali.com/2018/03/17/hdu4966-ggs-ddu-%E6%9C%80%E5%B0%8F%E6%A0%91%E5%BD%A2%E5%9B%BE-%E6%9C%B1%E5%88%98%E7%AE%97%E6%B3%95/)_\n\n### BZOJ2395 Timeismoney（最小乘积生成树）\n\n_[BZOJ2395 Timeismoney（最小乘积生成树）](http://hk-cnyali.com/2018/03/17/bzoj2395-timeismoney%EF%BC%88%E6%9C%80%E5%B0%8F%E4%B9%98%E7%A7%AF%E7%94%9F%E6%88%90%E6%A0%91%EF%BC%89/)_\n\n### Hdu5697 刷题计划（最小乘积生成树）\n\n_[Hdu5697 刷题计划（最小乘积生成树）](http://hk-cnyali.com/2018/03/17/hdu5697-%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92%EF%BC%88%E6%9C%80%E5%B0%8F%E4%B9%98%E7%A7%AF%E7%94%9F%E6%88%90%E6%A0%91%EF%BC%89/)_\n","categories":["Summary"],"tags":["Summary","最小生成树","LCA","最小乘积生成树","最小瓶颈路","斯坦纳树","最小树形图"]},{"title":"「Hdu5697」刷题计划 - 最小乘积生成树","url":"/2018/03/17/Hdu5697-%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92%EF%BC%88%E6%9C%80%E5%B0%8F%E4%B9%98%E7%A7%AF%E7%94%9F%E6%88%90%E6%A0%91%EF%BC%89/","content":"\n题目链接：[传送门](http://acm.hdu.edu.cn/showproblem.php?pid=5697)\n\n### Description\n\n大赛将至，摆在你面前的是n道题目，第 i(1≤i≤n) 道题目能提升 ai 点智力值，代码量为 bi KB，无聊值为 ci ，求至少提升m点智力值的情况下，所做题目代码量之和 ∗ 无聊值之和最小为多少\n\n<!--more-->\n### Solution\n\n这道题用到了求最小乘积生成树的思想 只是把求最小乘积生成树时的Kruskal换成Dp即可 Dp方程：$Dp\\[j\\] = min(Dp\\[j\\], Dp\\[j-v\\[i\\]\\]+value\\[i\\])$\n\n### Code\n```cpp\n    #include <bits/stdc++.h>\n    #define int long long\n    \n    using namespace std;\n    \n    const int Maxn = 1000 + 10;\n    \n    struct edge\n    {\n        int a, b, c, v;\n    }A[Maxn];\n    \n    struct point\n    {\n        int x, y;\n        bool operator < (const point &a) const\n        {\n            unsigned int p = x; p *= y;\n            unsigned int q = a.x; q *= a.y;\n            return q == p ? x < a.x : p < q;\n        }\n    };\n    \n    point Ans;\n    \n    int N, M, MAX;\n    int Dp[1000 + 10];\n    \n    point save[1000 + 10];\n    \n    inline point DP ()\n    {\n        point now;\n        now.x = now.y = 1e9;\n        //  cout<<now.x<<\" \"<<now.y<<endl;\n        for (int i = 1; i <= MAX; ++i) Dp[i] = 0x3f3f3f3f3f3f3f3f;\n        Dp[0] = 0;\n        for (int i = 1; i <= N; ++i)\n        {\n            for (int j = MAX; j >= A[i].v; --j)\n            {\n                if (Dp[j] > Dp[j - A[i].v] + A[i].c)\n                {\n                    Dp[j] = Dp[j - A[i].v] + A[i].c;\n                    save[j].x = save[j - A[i].v].x + A[i].a;\n                    save[j].y = save[j - A[i].v].y + A[i].b;\n                }\n            }\n        }\n        int k = M;\n        for (int i = M; i <= MAX; ++i) if (Dp[k] > Dp[i]) k = i;\n        now = save[k];\n        if (now < Ans) Ans = now;\n        return now;\n    }\n    \n    inline int mul (point a, point b, point c)\n    {\n        return (c.y - a.y) * (b.x - a.x) - (c.x - a.x) * (b.y - a.y);\n    }\n    \n    inline void Solve (point a, point b)\n    {\n        for (int i = 1; i <= M; ++i)\n            A[i].c = A[i].b * (a.x - b.x) + A[i].a * (b.y - a.y);\n        point c = DP();\n        if (mul(a, b, c) <= 0) return ;\n        Solve (a, c);\n        Solve (c, b);\n    }\n    \n    inline void Init ()\n    {\n        Ans.x = Ans.y = 1e9;\n        MAX = 0;\n        memset(save, 0, sizeof save);\n    }\n    \n    main()\n    {\n    #ifdef hk_cnyali\n        freopen(\"A.in\", \"r\", stdin);\n        freopen(\"A.out\", \"w\", stdout);\n    #endif\n        while (~scanf(\"%lld%lld\", &N, &M))\n        {\n            Init();\n            for (int i = 1; i <= N; ++i)\n                scanf(\"%lld%lld%lld\", &A[i].v, &A[i].a, &A[i].b), MAX += A[i].v;\n            for (int i = 1; i <= N; ++i) A[i].c = A[i].a;\n            point a = DP();\n            for (int i = 1; i <= N; ++i) A[i].c = A[i].b;\n            point b = DP();\n            Solve (b, a);\n            printf(\"%lld\\n\", Ans.x * Ans.y);\n        }\n        return 0;\n    }\n```\n","categories":["Problem"],"tags":["动态规划","最小生成树","最小乘积生成树"]},{"title":"「BZOJ2395」 Timeismoney - 最小乘积生成树","url":"/2018/03/17/BZOJ2395-Timeismoney%EF%BC%88%E6%9C%80%E5%B0%8F%E4%B9%98%E7%A7%AF%E7%94%9F%E6%88%90%E6%A0%91%EF%BC%89/","content":"\n题目链接：[BZOJ(权限题)](http://www.lydsy.com/JudgeOnline/problem.php?id=2395) 、[YALIOJ](http://218.77.114.12:1980/v3/contest_show.php?cid=313#problem/G)\n\n### Description\n\n有n个城市(编号从0..n-1)，m条公路(双向的)，从中选择n-1条边，使得任意的两个城市能够连通，一条边需要的c的费用和t的时间，定义一个方案的权值v=n-1条边的费用和 * n-1条边的时间和，你的任务是求一个方案使得v最小\n<!--more-->\n\n### Solution\n\n学习了一发最小乘积生成树，感觉好像特别巧妙 这题就是模板题\n\n### Code\n```cpp\n    #include <bits/stdc++.h>\n    \n    using namespace std;\n    \n    const int Maxn = 200 + 10, Maxm = 20000 + 10;\n    \n    struct edge\n    {\n        int x, y;\n        int a, b, c;\n    }A[Maxm];\n    \n    inline int cmp1 (edge u, edge v) {return u.a < v.a;}\n    inline int cmp2 (edge u, edge v) {return u.b < v.b;}\n    inline int cmp3 (edge u, edge v) {return u.c < v.c;}\n    \n    struct point\n    {\n        int x, y;\n        bool operator < (const point &a) const\n        {\n            unsigned int p = x; p *= y;\n            unsigned int q = a.x; q *= a.y;\n            return q == p ? x < a.x : p < q;\n        }\n    };\n    \n    point Ans;\n    \n    int N, M, fa[Maxn];\n    \n    inline int find (int x)\n    {\n        return fa[x] == x ? x : fa[x] = find(fa[x]);\n    }\n    \n    inline point MST ()\n    {\n        for (int i = 1; i <= N; ++i) fa[i] = i;\n        point now;\n        now.x = now.y = 0;\n        for (int i = 1; i <= M; ++i)\n        {\n            int fx = find(A[i].x), fy = find(A[i].y);\n            if (fx != fy)\n            {\n                fa[fx] = fy;\n                now.x += A[i].a;\n                now.y += A[i].b;\n            }\n        }\n    //  cout<<now.x<<\" \"<<now.y<<endl;\n        if (now < Ans) Ans = now;\n        return now;\n    }\n    \n    inline int mul (point a, point b, point c)\n    {\n        return (c.y - a.y) * (b.x - a.x) - (c.x - a.x) * (b.y - a.y);\n    }\n    \n    inline void Solve (point a, point b)\n    {\n        for (int i = 1; i <= M; ++i)\n            A[i].c = A[i].b * (a.x - b.x) + A[i].a * (b.y - a.y);\n        sort(A + 1, A + M + 1, cmp3);\n        point c = MST();\n        if (mul(a, b, c) <= 0) return ;\n        Solve (a, c);\n        Solve (c, b);\n    }\n    \n    int main()\n    {\n    #ifdef hk_cnyali\n        freopen(\"A.in\", \"r\", stdin);\n        freopen(\"A.out\", \"w\", stdout);\n    #endif\n        Ans.x = Ans.y = 1e9;\n        scanf(\"%d%d\", &N, &M);\n        for (int i = 1; i <= M; ++i)\n            scanf(\"%d%d%d%d\", &A[i].x, &A[i].y, &A[i].a, &A[i].b), A[i].x ++, A[i].y ++;\n        sort(A + 1, A + M + 1, cmp1);\n        point a = MST();\n        sort(A + 1, A + M + 1, cmp2);\n        point b = MST();\n        Solve (b, a);\n        printf(\"%d %d\\n\", Ans.x, Ans.y);\n        return 0;\n    }\n```\n","categories":["Problem"],"tags":["最小生成树","计算几何","最小乘积生成树"]},{"title":"「Hdu4966」 GGS-DDU - 最小树形图/朱刘算法","url":"/2018/03/17/Hdu4966-GGS-DDU-%E6%9C%80%E5%B0%8F%E6%A0%91%E5%BD%A2%E5%9B%BE-%E6%9C%B1%E5%88%98%E7%AE%97%E6%B3%95/","content":"\n题目链接：[传送门](http://acm.hdu.edu.cn/showproblem.php?pid=4966)\n\n### Description\n\n有一个人，想学习N个科目，每个科目都有相应的层次 有M个课程，M个课程的要求是，你的第c个科目的层次要达到l1，才可以参加，参加完这个课程后，你需要缴费money，但你的第d个科目的层次会达到l2 问如何花最少的钱，使得每个科目的层次都达到最高\n\n<!--more-->\n\n### Solution\n\n每个科目的每个层次都看成一个点，每个科目的层次0和一个根连边，费用为0；每个科目的高层次向下一个低层次连边，费用为0(因为你高层次的会了就表示低层次的也会了) 然后用朱刘算法跑一遍最小树形图即可\n\n### Code\n```cpp\n    #include <bits/stdc++.h>\n    \n    using namespace std;\n    \n    const int Maxn = 500 + 10, Maxm = 2500 + 10, inf = INT_MAX;\n    \n    struct node\n    {\n        int x, y, w;\n    }edge[Maxm];\n    \n    int N, M, cnt, Ans, Index;\n    int Map[55][500 + 10];\n    \n    inline void Init()\n    {\n        cnt = Ans = Index = 0;\n    }\n    \n    inline void add_edge (int x, int y, int z)\n    {\n        edge[++cnt].x = x;\n        edge[cnt].y = y;\n        edge[cnt].w = z;\n    }\n    \n    int In[Maxn], Pre[Maxn];\n    int id[Maxn], Vis[Maxn];\n    \n    inline int Solve (int root)\n    {\n        while (1)\n        {\n            for (int i = 1; i <= N; ++i) In[i] = inf;\n            for (int i = 1; i <= cnt; ++i)\n            {\n                int x = edge[i].x, y = edge[i].y;\n                if (x != y && edge[i].w < In[y])\n                {\n                    Pre[y] = x;\n                    In[y] = edge[i].w;\n                }\n            }\n            for (int i = 1; i <= N; ++i)\n                if (i != root && In[i] == inf) return -1;\n    \n            int sum = 0;\n            memset(id, -1, sizeof id);\n            memset(Vis, -1, sizeof Vis);\n            In[root] = 0;\n            for (int i = 1; i <= N; ++i)\n            {\n                Ans += In[i];\n                int now = i;\n                while (Vis[now] != i && now != root && id[now] == -1)\n                {\n                    Vis[now] = i;\n                    now = Pre[now];\n                }\n    \n                if (now != root && id[now] == -1)\n                {\n                    int tmp = Pre[now];\n                    ++sum;\n                    while (tmp != now)\n                    {\n                        id[tmp] = sum;\n                        tmp = Pre[tmp];\n                    }\n                    id[now] = sum;\n                }\n            }\n            if (!sum) return Ans;\n    \n            for (int i = 1; i <= N; ++i)\n                if (id[i] == -1) id[i] = ++sum;\n            for (int i = 1; i <= cnt; ++i)\n            {\n                int x = edge[i].x, y = edge[i].y;\n                edge[i].x = id[x]; edge[i].y = id[y];\n                if (id[x] != id[y])\n                    edge[i].w -= In[y];\n            }\n            N = sum;\n            root = id[root];\n        }\n    }\n    \n    int main()\n    {\n    #ifdef hk_cnyali\n        freopen(\"A.in\", \"r\", stdin);\n        freopen(\"A.out\", \"w\", stdout);\n    #endif\n        while (1)\n        {\n            scanf(\"%d%d\", &N, &M);\n            if (N == M && !N) break;\n            Init();\n            for (int i = 1; i <= N; ++i)\n            {\n                int x;\n                scanf(\"%d\", &x);\n                for (int j = 0; j <= x; ++j)\n                    Map[i][j] = ++Index;\n                Map[i][501] = x;\n            }\n            while (M--)\n            {\n                int a, b, c, d, e;\n                scanf(\"%d%d%d%d%d\", &a, &b, &c, &d, &e);\n                add_edge(Map[a][b], Map[c][d], e);\n            }\n    \n            for (int i = 1; i <= N; ++i)\n                for (int j = 1; j <= Map[i][501]; ++j)\n                {\n                    add_edge(Map[i][j], Map[i][j - 1], 0);\n                }\n    \n            for (int i = 1; i <= N; ++i)\n                add_edge(0, Map[i][0], 0);\n    \n            N = Index;\n    \n            printf(\"%d\\n\", Solve(0));\n        }\n        return 0;\n    }\n```\n","categories":["Problem"],"tags":["最小生成树","最小树形图","朱刘算法"]},{"title":"「Hdu4085」 Peach Blossom Spring - 斯坦纳树","url":"/2018/03/17/Hdu4085-Peach-Blossom-Spring-%E6%96%AF%E5%9D%A6%E7%BA%B3%E6%A0%91/","content":"\n题目链接：[传送门](http://acm.hdu.edu.cn/showproblem.php?pid=4085)\n\n### Description\n\n给你n,m,k ，分别表示有n个点，m条边，每条边有一个权值，表示修复这条边需要的代价，从前k个点中任取一个使其和后k个点中的某一个点，通过边连接，并且必须是一一对应，问最小的代价是多少\n<!--more-->\n\n### Solution\n\n又是一道斯坦纳树的题。还是一样的套路，只是最后在计算答案时要判断一下状态是否是前k个和后k个一一对应，跑个Dp即可\n\n### Code\n```cpp\n    #include <bits/stdc++.h>\n    \n    using namespace std;\n    \n    const int Maxn = 50 + 5, Maxm = 6000 + 10, inf = 100000000;\n    \n    int N, M, K;\n    int e, Begin[Maxm], To[Maxm * 2], Next[Maxm * 2], W[Maxm * 2];\n    int Dis[Maxn][(1 << 11)], Vis[Maxm], Dp[(1 << 11)];\n    \n    inline void Init ()\n    {\n        e = 0;\n        memset(Begin, 0, sizeof Begin);\n        memset(Vis, 0, sizeof Vis);\n    }\n    \n    inline void add_edge (int x, int y, int z)\n    {\n        To[++e] = y;\n        Next[e] = Begin[x];\n        Begin[x] = e;\n        W[e] = z;\n    }\n    \n    queue <int> Q;\n    inline void SPFA (int state)\n    {\n        while (!Q.empty())\n        {\n            int x = Q.front(); Q.pop();\n            Vis[x] = 0;\n            for (int i = Begin[x]; i; i = Next[i])\n            {\n                int y = To[i];\n                if (Dis[y][state] > Dis[x][state] + W[i])\n                {\n                    Dis[y][state] = Dis[x][state] + W[i];\n                    if (!Vis[y])\n                    {\n                        Vis[y] = 1;\n                        Q.push(y);\n                    }\n                }\n            }\n        }\n    }\n    \n    inline int Check (int state)\n    {\n        int now = 0;\n        for (int i = 0; i < K; ++i)\n        {\n            if (state & (1 << i)) ++now;\n            if (state & (1 << (i + K))) --now;\n        }\n        return !now;\n    }\n    \n    int main()\n    {\n    #ifdef hk_cnyali\n        freopen(\"A.in\", \"r\", stdin);\n        freopen(\"A.out\", \"w\", stdout);\n    #endif\n        int T;\n        scanf(\"%d\", &T);\n        while (T--)\n        {\n            scanf(\"%d%d%d\", &N, &M, &K);\n            Init();\n            while (M--)\n            {\n                int x, y, z;\n                scanf(\"%d%d%d\", &x, &y, &z);\n                add_edge(x, y, z);\n                add_edge(y, x, z);\n            }\n    \n            for (int i = 1; i <= N; ++i)\n                for (int j = 0; j < (1 << 10); ++j)\n                    Dis[i][j] = inf;\n            for (int i = 1; i <= K; ++i)\n                Dis[i][1 << (i - 1)] = 0;\n            int tmp = K;\n            for (int i = N - K + 1; i <= N; ++i)\n                Dis[i][1 << tmp] = 0, ++tmp;\n    \n            for (int state = 1; state < (1 << tmp); ++state)\n            {\n                for (int i = 1; i <= N; ++i)\n                {\n                    for (int s1 = state & (state - 1); s1; s1 = state & (s1 - 1))\n                        Dis[i][state] = min(Dis[i][state], Dis[i][state - s1] + Dis[i][s1]);\n                    if (Dis[i][state] != inf) Q.push(i), Vis[i] = 1;\n                }\n                SPFA(state);\n            }\n    \n            for (int state = 1; state < (1 << tmp); ++state)\n            {\n                Dp[state] = inf;\n                for (int i = 1; i <= N; ++i)\n                    Dp[state] = min(Dp[state], Dis[i][state]);\n            }\n    \n            for (int state = 1; state < (1 << tmp); ++state)\n            {\n                if (!Check(state)) continue;\n                for (int s1 = state & (state - 1); s1; s1 = state & (s1 - 1))\n                {\n                    if (!Check(s1)) continue;\n                    Dp[state] = min(Dp[state], Dp[s1] + Dp[state - s1]);\n                }\n            }\n            if (Dp[(1 << tmp) - 1] == inf) cout<<\"No solution\"<<endl;\n            else cout<<Dp[(1 << tmp) - 1]<<endl;\n        }\n        return 0;\n    }\n```\t\n","categories":["Problem"],"tags":["动态规划","最短路","状态压缩","斯坦纳树"]},{"title":"「Hdu3311」 Dig the Wells - 斯坦纳树 + 状压DP + SPFA","url":"/2018/03/16/Hdu3311-Dig-the-Wells%EF%BC%88%E6%96%AF%E5%9D%A6%E7%BA%B3%E6%A0%91-%E7%8A%B6%E5%8E%8BDP-SPFA%EF%BC%89/","content":"\n题目链接：[传送门](http://acm.hdu.edu.cn/showproblem.php?pid=3311)\n\n### Description\n\nn个和尚住的地方，m个其他地方。每个地方挖一口井需要花费q\\[i\\]的钱，两个地方连通需要花费对应的边权值。求所有人都能喝到水的最小花费。\n<!--more-->\n\n### Solution\n\n新建一个节点，连接所有点，边权为挖井的花费，然后直接上斯坦纳树即可\n\n### Code\n```cpp\n    #include <bits/stdc++.h>\n    \n    using namespace std;\n    \n    const int Maxn = 1000 + 10, Maxm = 10000 + 10, inf = 100000000;\n    \n    int N, M, K;\n    int e, Begin[Maxm], To[Maxm * 2], Next[Maxm * 2], W[Maxm * 2];\n    int Dis[Maxn][(1 << 11)], Vis[Maxm], Dp[(1 << 11)];\n    \n    inline void Init ()\n    {\n        e = 0;\n        memset(Begin, 0, sizeof Begin);\n        memset(Vis, 0, sizeof Vis);\n        for (int i = 1; i <= N + M; ++i)\n            for (int j = 0; j < (1 << 10); ++j)\n                Dis[i][j] = inf;\n    }\n    \n    inline void add_edge (int x, int y, int z)\n    {\n        To[++e] = y;\n        Next[e] = Begin[x];\n        Begin[x] = e;\n        W[e] = z;\n    }\n    \n    queue <int> Q;\n    inline void SPFA (int state)\n    {\n        while (!Q.empty())\n        {\n            int x = Q.front(); Q.pop();\n            Vis[x] = 0;\n            for (int i = Begin[x]; i; i = Next[i])\n            {\n                int y = To[i];\n                if (Dis[y][state] > Dis[x][state] + W[i])\n                {\n                    Dis[y][state] = Dis[x][state] + W[i];\n                    if (!Vis[y])\n                    {\n                        Vis[y] = 1;\n                        Q.push(y);\n                    }\n                }\n            }\n        }\n    }\n    \n    int main()\n    {\n    #ifdef hk_cnyali\n        freopen(\"A.in\", \"r\", stdin);\n        freopen(\"A.out\", \"w\", stdout);\n    #endif\n        while (~scanf(\"%d%d%d\", &N, &M, &K))\n        {\n            Init();\n            for (int i = 1; i <= N + M; ++i)\n            {\n                int x;\n                scanf(\"%d\", &x);\n                if (i <= N)\n                {\n                    Dis[i][(1 << (i - 1))] = 0;\n                    Dis[i][(1 << (i - 1)) | (1 << N)] = x;\n                }\n                else Dis[i][1 << N] = x;\n            }\n            while (K--)\n            {\n                int x, y, z;\n                scanf(\"%d%d%d\", &x, &y, &z);\n                add_edge(x, y, z);\n                add_edge(y, x, z);\n            }\n    \n    \n            int tmp = N + 1;\n            for (int state = 1; state < (1 << tmp); ++state)\n            {\n                for (int i = 1; i <= N + M; ++i)\n                {\n                    for (int s1 = state & (state - 1); s1; s1 = state & (s1 - 1))\n                        Dis[i][state] = min(Dis[i][state], Dis[i][(state - s1)] + Dis[i][s1]);\n                    if (Dis[i][state] != inf) Q.push(i), Vis[i] = 1;\n                }\n                SPFA(state);\n            }\n    \n            for (int state = 1; state < (1 << tmp); ++state)\n            {\n                Dp[state] = inf;\n                for (int i = 1; i <= N + M; ++i)\n                    Dp[state] = min(Dp[state], Dis[i][state]);//cout<<Dis[i][state]<<\" \";\n    //          cout<<endl;\n            }\n    \n            for (int state = 1; state < (1 << tmp); ++state)\n            {\n                if (!(state & (1 << N))) continue;\n                for (int s1 = state & (state - 1); s1; s1 = state & (s1 - 1))\n                {\n                    if (!(s1 & (1 << N))) continue;\n                    Dp[state] = min(Dp[state], Dp[s1] + Dp[(state - s1) | (1 << N)]);\n                }\n            }\n            cout<<Dp[(1 << tmp) - 1]<<endl;\n        }\n        return 0;\n    }\n```\n","categories":["Problem"],"tags":["动态规划","最短路","状态压缩","斯坦纳树"]},{"title":"「CF733F」 Drivers Dissatisfaction - 最小生成树 + LCA","url":"/2018/03/16/Codeforces-733F-Drivers-Dissatisfaction-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91-LCA/","content":"\n题目链接：[传送门](http://codeforces.com/contest/733/problem/F)\n\n### Description\n\n给一张n个点m条边的连通图，每条边(ai,bi)有一个权值wi和费用ci，表示这条边每降低1的权值需要ci的花费。现在一共有S费用可以用来降低某些边的权值（可以降到负数），求图中的一棵权值和最小的生成树并输出方案。\n<!--more-->\n\n### Solution\n\n显然S都要用到一条边上。\n那么我们先跑一次最小生成树，顺便用倍增更新一遍最大值。\n然后枚举每一条边，如果这条边在最小生成树里的话就直接更新答案，\n否则求一遍这条边的两个顶点在树中所经过边的最大值，替换后更新答案即可\n\n### Code\n```cpp\n    #include <bits/stdc++.h>\n    \n    using namespace std;\n    \n    const int Maxn = 200000 + 10, Maxm = 400000 + 100, inf = 0x3f3f3f3f;\n    \n    int Vis[Maxm];\n    \n    struct MAX\n    {\n        int x, y;\n    }Max[Maxn][21];\n    \n    struct node\n    {\n        int x, y, w, id, c;\n    }A[Maxn];\n    \n    inline int cmp (node a, node b)\n    {\n        return a.w < b.w;\n    }\n    \n    int N, M, C[Maxn];\n    int e, Begin[Maxn], To[Maxm], Next[Maxm], W[Maxm], ID[Maxm];\n    int anc[Maxn][21];\n    int fa[Maxn], deep[Maxn];\n    \n    inline void add_edge (int x, int y, int z, int k)\n    {\n        To[++e] = y;\n        Next[e] = Begin[x];\n        Begin[x] = e;\n        W[e] = z;\n        ID[e] = k;\n    }\n    \n    inline int find (int x)\n    {\n        return fa[x] == x ? x : fa[x] = find(fa[x]);\n    }\n    \n    inline MAX max (MAX a, MAX b)\n    {\n        if (a.x > b.x) return a;\n        return b;\n    }\n    \n    inline void dfs (int x)\n    {\n        for (int i = 1; i <= 20; ++i) anc[x][i] = anc[anc[x][i - 1]][i - 1], Max[x][i] = max(Max[x][i - 1], Max[anc[x][i - 1]][i - 1]);\n        for (int i = Begin[x]; i; i = Next[i])\n        {\n            int y = To[i];\n            if (y == anc[x][0]) continue;\n            anc[y][0] = x;\n            Max[y][0].x = W[i];\n            Max[y][0].y = ID[i];\n            deep[y] = deep[x] + 1;\n            dfs(y);\n        }\n    }\n    \n    inline MAX Lca (int x, int y)\n    {\n        MAX Ans = (MAX){0, 0};\n        if (deep[x] < deep[y]) swap(x, y);\n        for (int i = 20; i >= 0; --i)\n            if (deep[anc[x][i]] >= deep[y])\n                Ans = max(Ans, Max[x][i]), x = anc[x][i];\n        if (x == y) return Ans;\n    \n        for (int i = 20; i >= 0; --i)\n            if (anc[x][i] != anc[y][i])\n                Ans = max(Ans, max(Max[x][i], Max[y][i])), x = anc[x][i], y = anc[y][i];\n    \n        Ans = max(Ans, max(Max[x][0], Max[y][0]));\n        return Ans;\n    }\n    \n    int main()\n    {\n    #ifdef hk_cnyali\n        freopen(\"A.in\", \"r\", stdin);\n        freopen(\"A.out\", \"w\", stdout);\n    #endif\n        int K;\n        scanf(\"%d%d\", &N, &M);\n        for (int i = 1; i <= M; ++i) scanf(\"%d\", &A[i].w);\n        for (int i = 1; i <= M; ++i) scanf(\"%d\", &A[i].c);\n        for (int i = 1; i <= N; ++i) fa[i] = i;\n        for (int i = 1; i <= M; ++i)\n            scanf(\"%d%d\", &A[i].x, &A[i].y), A[i].id = i;\n        sort(A + 1, A + M + 1, cmp);\n    \n        int cnt = 0;\n        int Sum = 0;\n        for (int i = 1; i <= M; ++i)\n        {\n            int fx = find(A[i].x), fy = find(A[i].y);\n            if (fx == fy) continue;\n            Vis[i] = 1;\n            add_edge (A[i].x, A[i].y, A[i].w, i);\n            add_edge (A[i].y, A[i].x, A[i].w, i);\n            Sum += A[i].w;\n        //  add_edge (fx, fy, A[i].z);\n        //  add_edge (fy, fx, A[i].z);\n            fa[fy] = fx;\n            ++cnt;\n            if (cnt == N - 1) break;\n        }\n    \n        dfs(1);\n    \n        scanf(\"%d\", &K);\n        int Ans = inf;\n    \n        int type = 0, id1 = 0, id2 = 0;\n        for (int i = 1; i <= M; ++i)\n        {\n            if (Vis[i])\n            {\n                //cout<<i<<\" *\"<< Sum - K / A[i].c<<endl;\n                if ((Sum - K / A[i].c) < Ans)\n                {\n                    Ans = Sum - K / A[i].c;\n                    type = 0, id1 = i;\n                }\n            }\n            else\n            {\n                MAX tmp = Lca(A[i].x, A[i].y);\n                //cout<<A[i].x<<\" \"<<A[i].y<<\" | \"<<tmp.x<<\" \"<<tmp.y<<endl;\n                //cout<<i<<\" *\"<< Sum - tmp.x + A[i].w - K / A[i].c<<endl;\n                if ((Sum - tmp.x + A[i].w - K / A[i].c) < Ans)\n                {\n                    Ans = Sum - tmp.x + A[i].w - K / A[i].c;\n                    type = 1, id1 = i, id2 = tmp.y; \n                }\n            }\n        }\n        //cout<<type<<\" \"<<id1<<\" \"<<id2<<endl;\n    \n        if (!type) A[id1].w -= K / A[id1].c;\n        else Vis[id1] = 1, A[id1].w -= K / A[id1].c, Vis[id2] = 0;\n    \n        cout<<Ans<<endl;\n        for (int i = 1; i <= M; ++i)\n            if (Vis[i])\n                printf(\"%d %d\\n\", A[i].id, A[i].w);\n        return 0;\n    }\n```\n","categories":["Problem"],"tags":["倍增","最小生成树","LCA","最小瓶颈路"]},{"title":"回文串【manacher算法和回文自动机、回文树】 Summary","url":"/2018/03/15/%E5%9B%9E%E6%96%87%E4%B8%B2%E3%80%90manacher%E7%AE%97%E6%B3%95%E5%92%8C%E5%9B%9E%E6%96%87%E8%87%AA%E5%8A%A8%E6%9C%BA%E3%80%81%E5%9B%9E%E6%96%87%E6%A0%91%E3%80%91-Summary/","content":"\n知识点总结\n-----\n\n[Manacher1](https://segmentfault.com/a/1190000008484167) [Manacher2](https://segmentfault.com/a/1190000003914228) [回文自动机/回文树](http://blog.csdn.net/lwfcgz/article/details/48739051)\n\n<!--more-->\nProblems\n--------\n\n### Hdu5785 Interesting(Manacher)\n\n[Hdu5785 Interesting(Manacher)](http://hk-cnyali.com/2018/03/15/hdu5785-interestingmanacher/)\n\n### Hdu5157 Harry and magic string(回文自动机)\n\n[Hdu5157 Harry and magic string(回文自动机)](http://hk-cnyali.com/2018/03/15/hdu5157-harry-and-magic-string%E5%9B%9E%E6%96%87%E8%87%AA%E5%8A%A8%E6%9C%BA/)\n\n### Hdu5421 Victor and String（回文自动机）\n\n[Hdu5421 Victor and String（回文自动机）](http://hk-cnyali.com/2018/03/15/hdu5421-victor-and-string%EF%BC%88%E5%9B%9E%E6%96%87%E8%87%AA%E5%8A%A8%E6%9C%BA%EF%BC%89/)\n\n### Hdu3068 最长回文\n\nManacher模板题\n\n### Code\n```cpp\n    #include <bits/stdc++.h>\n    \n    using namespace std;\n    \n    const int Maxn = 2 * 11000000 + 100;\n    \n    char S[Maxn];\n    char A[Maxn];\n    int P[Maxn];\n    \n    int N;\n    \n    inline void Input ()\n    {\n        N = strlen(S + 1);\n        for (int i = 1; i <= N; ++i)\n            A[i * 2] = S[i], A[i * 2 - 1] = '#';\n        A[0] = '!', A[2 * N + 1] = '#';\n        A[2 * N + 2] = '*';\n        N = 2 * N + 1;\n    }\n    \n    inline void Solve ()\n    {\n        int id = 0, Max = 0;\n        int Ans = 0;\n        for (int i = 0; i <= N; ++i) P[i] = 0;\n        for (int i = 1; i <= N; ++i)\n        {\n            if (i < Max)\n                P[i] = min(Max - i, P[2 * id - i]);\n            else P[i] = 1;\n            while (A[i + P[i]] == A[i - P[i]]) P[i] ++;\n            //cout<<P[i]<<endl;\n            if (Max < i + P[i] - 1)\n            {\n                Max = i + P[i] - 1;\n                id = i;\n            }\n            Ans = max(Ans, P[i] - 1);\n        }\n        cout<<Ans<<endl;\n    }\n    \n    int main()\n    {\n    #ifdef hk_cnyali\n        freopen(\"A.in\", \"r\", stdin);\n        freopen(\"A.out\", \"w\", stdout);\n    #endif\n        while (~scanf(\"%s\", S + 1))\n        {\n            Input();\n            Solve();\n        }\n        return 0;\n    }\n```\n\n### \\[Apio2014\\]回文串\n\n回文自动机模板题\n```\n    #include <bits/stdc++.h>\n    #define LL long long\n    \n    using namespace std;\n    \n    const int Maxn = 300000 + 100;\n    \n    char S[Maxn];\n    int N, cnt;\n    \n    struct tree\n    {\n        int cnt, ch[30], len, fail;\n    };\n    \n    namespace PAM\n    {\n        tree Tree[Maxn];\n        int root0, root1, now;\n    \n        inline void init ()\n        {\n            cnt = -1;\n            root0 = ++cnt, root1 = ++cnt;\n            Tree[root0].fail = root1;\n            Tree[root0].len = 0;\n            Tree[root1].len = -1;\n        }\n    \n        inline int get_fail (int now, int i)\n        {\n            while (S[i - Tree[now].len - 1] != S[i]) now = Tree[now].fail;\n            return now;\n        }\n    \n        inline void add (int c, int i)\n        {\n            now = get_fail(now, i);\n            if (!Tree[now].ch[c])\n            {\n                int x = ++cnt;\n                Tree[x].len = Tree[now].len + 2;\n                Tree[x].fail = Tree[get_fail(Tree[now].fail, i)].ch[c];\n                Tree[now].ch[c] = x;\n            }\n            now = Tree[now].ch[c];\n            Tree[now].cnt ++;\n        }\n    }\n    \n    int main()\n    {\n    #ifdef hk_cnyali\n        freopen(\"A.in\", \"r\", stdin);\n        freopen(\"A.out\", \"w\", stdout);\n    #endif\n    \n        scanf(\"%s\", S);\n        PAM :: init();\n        int N = strlen(S);\n        for (int i = 0; i < N; ++i)\n            PAM :: add(S[i] - 'a', i);\n    \n        LL Ans = 0;\n        for (int i = cnt; i > 1; --i)\n        {\n            PAM :: Tree[PAM :: Tree[i].fail].cnt += PAM :: Tree[i].cnt;\n            Ans = max(Ans, (LL)((LL)PAM :: Tree[i].cnt * PAM :: Tree[i].len));\n        }\n        cout<<Ans<<endl;\n        return 0;\n    }\n```\n\n### BZOJ2565 最长双回文串（Manacher）\n\n[BZOJ2565 最长双回文串（Manacher）](http://hk-cnyali.com/2018/03/15/bzoj2565-%E6%9C%80%E9%95%BF%E5%8F%8C%E5%9B%9E%E6%96%87%E4%B8%B2%EF%BC%88manacher%EF%BC%89/)\n","categories":["Summary"],"tags":["Summary","字符串","Manacher","回文自动机"]},{"title":"「BZOJ2565」 最长双回文串 - Manacher","url":"/2018/03/15/BZOJ2565-%E6%9C%80%E9%95%BF%E5%8F%8C%E5%9B%9E%E6%96%87%E4%B8%B2%EF%BC%88Manacher%EF%BC%89/","content":"\n题目链接：[传送门](http://www.lydsy.com/JudgeOnline/problem.php?id=2565)\n\n### Description\n\n顺序和逆序读起来完全一样的串叫做回文串。比如acbca是回文串，而abc不是（abc的顺序为“abc”，逆序为“cba”，不相同）。 输入长度为n的串S，求S的最长双回文子串T,即可将T分为两部分X，Y，（|X|,|Y|≥1）且X和Y都是回文串。\n<!--more-->\n\n### Solution\n\n设l\\[i\\]表示以i开始的最长回文串，r\\[i\\]表示以i结尾的最长回文串。在求Manacher的过程中就可以更新这两个数组。但是这样求出来的不一定是最优的，最后还需要再扫一遍通过l\\[i - 2\\]-2来更新l\\[i\\],r\\[i\\]同理\n\n### Code\n```cpp\n    #include <bits/stdc++.h>\n    \n    using namespace std;\n    \n    const int Maxn = 2 * 11000000 + 100;\n    \n    char S[Maxn];\n    char A[Maxn];\n    int P[Maxn];\n    int r[Maxn], l[Maxn];\n    \n    int N;\n    \n    inline void Input ()\n    {\n        scanf(\"%s\", S + 1);\n        N = strlen(S + 1);\n        for (int i = 1; i <= N; ++i)\n            A[i * 2] = S[i], A[i * 2 - 1] = '#';\n        A[0] = '!', A[2 * N + 1] = '#';\n        A[2 * N + 2] = '*';\n        N = 2 * N + 1;\n    }\n    \n    inline void Solve ()\n    {\n        int id = 0, Max = 0;\n        for (int i = 1; i <= N; ++i)\n        {\n            if (i < Max)\n                P[i] = min(Max - i, P[2 * id - i]);\n            else P[i] = 1;\n            while (A[i + P[i]] == A[i - P[i]]) P[i] ++;\n            if (Max < i + P[i] - 1)\n            {\n                Max = i + P[i] - 1;\n                id = i;\n            }\n            l[i - P[i] + 1] = max(l[i - P[i] + 1], P[i] - 1);\n            r[i + P[i] - 1] = max(r[i + P[i] - 1], P[i] - 1);\n        }\n    \n        for (int i = 1; i <= N; i += 2) l[i] = max(l[i], l[i - 2] - 2);\n        for (int i = N; i >= 1; i -= 2) r[i] = max(r[i], r[i + 2] - 2);\n        int Ans = 0;\n        for (int i = 1; i <= N; i += 2) if (l[i] && r[i]) Ans = max(Ans, l[i] + r[i]);\n        cout<<Ans<<endl;\n    }\n    \n    int main()\n    {\n    #ifdef hk_cnyali\n        freopen(\"A.in\", \"r\", stdin);\n        freopen(\"A.out\", \"w\", stdout);\n    #endif\n        Input();\n        Solve();\n        return 0;\n    }\n```\n","categories":["Problem"],"tags":["字符串","Manacher"]},{"title":"「Hdu5421」Victor and String - 回文自动机","url":"/2018/03/15/Hdu5421-Victor-and-String%EF%BC%88%E5%9B%9E%E6%96%87%E8%87%AA%E5%8A%A8%E6%9C%BA%EF%BC%89/","content":"\n题目链接：[传送门](http://acm.hdu.edu.cn/showproblem.php?pid=5421)\n\n### Description\n\n有n种操作，开始给你一个空串，给你4中操作 1 c 在字符串的首部添加字符c 2 c 在字符串的尾部添加字符c 3 询问字符中的本质不同的回文串的个数 4 询问字符串中回文串的个数\n<!--more-->\n\n### Solution\n\n回文自动机的last(或now)搞两个记录即可，其他都是常规操作 只是有些细节要注意一下\n\n### Code\n```cpp\n    #include <bits/stdc++.h>\n    #define LL long long\n    \n    using namespace std;\n    \n    const int Maxn = 300000 + 100;\n    \n    int S[Maxn];\n    int N, cnt;\n    LL sum;\n    \n    struct tree\n    {\n        int cnt, ch[30], len, fail;\n    };\n    \n    namespace PAM\n    {\n        tree Tree[Maxn];\n        int root0, root1;\n        int last[2];\n        int l, r;\n    \n        inline void init ()\n        {\n            memset(Tree, 0, sizeof Tree);\n            memset(S, -1, sizeof S);\n            cnt = -1;\n            sum = 0;\n            last[0] = last[1] = 1;\n            l = Maxn / 2;\n            r = l - 1;\n            root0 = ++cnt, root1 = ++cnt;\n            Tree[root0].fail = root1; Tree[root1].fail = root1;\n            Tree[root0].len = 0; Tree[root1].len = -1;\n        }\n    \n        inline int get_fail (int now, int type)\n        {\n            if (type) while (S[r - Tree[now].len - 1] != S[r]) now = Tree[now].fail;\n            else while (S[l + Tree[now].len + 1] != S[l]) now = Tree[now].fail;\n            return now;\n        }\n    \n        inline void add (int c, int type)\n        {\n            if (type) S[++r] = c;\n            else S[--l] = c;\n            int now = get_fail(last[type], type);\n            if (!Tree[now].ch[c])\n            {\n                int x = ++cnt;\n                Tree[x].len = Tree[now].len + 2;\n                Tree[x].fail = Tree[get_fail(Tree[now].fail, type)].ch[c];\n                Tree[x].cnt = Tree[Tree[x].fail].cnt + 1;\n                Tree[now].ch[c] = x;\n            }\n            now = Tree[now].ch[c];\n            sum += (LL)Tree[now].cnt;\n            last[type] = now;\n            if (Tree[now].len == r - l + 1)\n                last[type ^ 1] = now;\n        }\n    }\n    \n    inline char safe_getchar()\n    {\n        char ch = getchar();\n        while (ch < 'a' || ch > 'z') ch = getchar();\n        return ch;\n    }\n    \n    int main()\n    {\n    #ifdef hk_cnyali\n        freopen(\"A.in\", \"r\", stdin);\n        freopen(\"A.out\", \"w\", stdout);\n    #endif\n    \n        while (~scanf(\"%d\", &N))\n        {\n            PAM :: init();\n            while (N--)\n            {\n                int type;\n                char c;\n                scanf(\"%d\", &type);\n                if (type <= 2)\n                {\n                    c = safe_getchar();\n                    PAM :: add(c - 'a' + 1, type - 1);\n                }\n                else if (type == 3)\n                    printf(\"%d\\n\", cnt - 1);\n                else printf(\"%lld\\n\", sum);\n            }\n        }\n        return 0;\n    }\n```\n","categories":["Problem"],"tags":["字符串","回文自动机"]},{"title":"「Hdu5157」 Harry and magic string - 回文自动机","url":"/2018/03/15/Hdu5157-Harry-and-magic-string-%E5%9B%9E%E6%96%87%E8%87%AA%E5%8A%A8%E6%9C%BA/","content":"\n题目链接：[传送门](http://acm.hdu.edu.cn/showproblem.php?pid=5157)\n\n### Description\n\n求一个字符串中所有不相交的回文串对\n\n### Solution\n\n回文自动机裸题，正着加一遍反着加一遍即可 当然也可以用Manacher A掉\n\n### Code\n```cpp\n    #include <bits/stdc++.h>\n    #define LL long long\n    \n    using namespace std;\n    \n    const int Maxn = 100000 + 100;\n    \n    int S[Maxn];\n    char S1[Maxn];\n    LL Sum[Maxn];\n    int cnt;\n    \n    struct tree\n    {\n        int cnt, ch[30], len, fail;\n    };\n    \n    namespace PAM\n    {\n        tree Tree[Maxn];\n        int root0, root1, now, n;\n    \n        inline void init ()\n        {\n            memset(Tree, 0, sizeof Tree);\n            memset(S, -1, sizeof S);\n            n = 0;\n            cnt = -1;\n            now = 0;\n            root0 = ++cnt, root1 = ++cnt;\n            S[0] = -1;\n            Tree[root0].fail = root1;\n            Tree[root0].len = 0;\n            Tree[root1].len = -1;\n        }\n    \n        inline int get_fail (int now)\n        {\n            while (S[n - Tree[now].len - 1] != S[n]) now = Tree[now].fail;\n            return now;\n        }\n    \n        inline int add (int c)\n        {\n            S[++n] = c;\n            now = get_fail(now);\n            if (!Tree[now].ch[c])\n            {\n                int x = ++cnt;\n                Tree[x].len = Tree[now].len + 2;\n                Tree[x].fail = Tree[get_fail(Tree[now].fail)].ch[c];\n                Tree[x].cnt = Tree[Tree[x].fail].cnt + 1;\n                Tree[now].ch[c] = x;\n            }\n            now = Tree[now].ch[c];\n            return Tree[now].cnt;\n        }\n    }\n    \n    int main()\n    {\n    #ifdef hk_cnyali\n        freopen(\"A.in\", \"r\", stdin);\n        freopen(\"A.out\", \"w\", stdout);\n    #endif\n    \n        while (~scanf(\"%s\", S1))\n        {\n            PAM :: init();\n            int N = strlen(S1);\n            Sum[N] = 0;\n            for (int i = N - 1; i >= 0; --i)\n                Sum[i] = Sum[i + 1] + (LL)PAM :: add(S1[i] - 'a' + 1);\n            PAM :: init();\n            LL Ans = 0;\n            for (int i = 0; i < N; ++i)\n                Ans += (LL)((LL)PAM :: add(S1[i] - 'a' + 1) * Sum[i + 1]);\n            cout<<Ans<<endl;\n        }\n        return 0;\n    }\n    \n\n3.16 Upd\n--------\n\n今天无聊把A题manacher魔改一番A掉了这道题 原来用manacher做这道题更简单\n\n    #include <bits/stdc++.h>\n    #define int long long\n    \n    using namespace std;\n    \n    const int Maxn = 2e5 + 10 ;\n    \n    char S[Maxn], A[Maxn];\n    int P[Maxn];\n    int Sum1[Maxn], Sum2[Maxn];\n    int L[Maxn], R[Maxn];\n    \n    int N;\n    \n    inline void Init ()\n    {\n        memset(P, 0, sizeof P);\n        memset(A, 0, sizeof A);\n        memset(L, 0, sizeof L);\n        memset(R, 0, sizeof R);\n        memset(Sum1, 0, sizeof Sum1);\n        memset(Sum2, 0, sizeof Sum2);\n    }\n    \n    inline void Manacher ()\n    {\n        N = strlen(S + 1);\n        for (int i = 1; i <= N; ++i)\n            A[i * 2] = S[i], A[i * 2 - 1] = '#';\n        A[0] = '%', A[N * 2 + 1] = '#';\n        N = N * 2 + 1;\n        for (int i = 0; i <= N; ++i) S[i] = A[i];\n    \n        int id = 0, Max = 0;\n        for (int i = 1; i <= N; ++i)\n        {\n            if (i < Max)\n                P[i] = min(P[2 * id - i], Max - i);\n            else P[i] = 1;\n            while (S[i + P[i]] == S[i - P[i]]) P[i] ++;\n            if (Max < i + P[i] - 1)\n            {\n                Max = i + P[i] - 1;\n                id = i;\n            }\n        }\n    }\n    \n    inline void Solve ()\n    {\n        Manacher();\n        for (int i = 1; i <= N; ++i)\n            Sum1[i - P[i] + 1] += 1, Sum1[i + 1] -= 1;\n        for (int i = 1; i <= N; ++i)\n        {\n            Sum1[i] += Sum1[i - 1];\n            if (!(i % 2)) L[i / 2] = Sum1[i];\n        }\n    \n        memset(Sum1, 0, sizeof Sum1);\n    \n        for (int i = 1; i <= N; ++i)\n            Sum1[i] += 1, Sum1[i + P[i]] -= 1;\n        for (int i = 1; i <= N; ++i)\n        {\n            Sum1[i] += Sum1[i - 1];\n            if (!(i % 2)) R[i / 2] = Sum1[i];\n        }\n    \n        memset(Sum2, 0, sizeof Sum2);\n    \n        N /= 2;\n        for (int i = N; i >= 1; --i)\n            Sum2[i] = Sum2[i + 1] + L[i];\n        int Ans = 0ll;\n        for (int i = 1; i < N; ++i)\n            (Ans += Sum2[i + 1] * R[i]);\n        cout<<Ans<<endl;\n    \n    }\n    \n    main()\n    {\n    #ifdef hk_cnyali\n        freopen(\"A.in\", \"r\", stdin);\n        freopen(\"A.out\", \"w\", stdout);\n    #endif\n        while (~scanf(\"%s\", S + 1))\n        {\n            Init();\n            Solve();\n            memset(S, 0, sizeof S);\n        }\n        return 0;\n    }\n```\n","categories":["Problem"],"tags":["字符串","Manacher","回文自动机"]},{"title":"「Hdu5785」Interesting - Manacher","url":"/2018/03/15/Hdu5785-Interesting-Manacher/","content":"\n题目链接：[传送门](http://acm.hdu.edu.cn/showproblem.php?pid=5785)\n\n### Description\n\n给你一个串,定义了一个权值和,每个权值是两个回文串拼起来的左右坐标乘积\n<!--more-->\n\n### Solution\n\n设R\\[i\\]为所有以 i 为右端点的回文字串的左端点之和，同理，L\\[i\\]表示所有以 i 为左端点的回文子串的右端点之和。显然，答案为$\\\\sum (L\\[i+1\\]\\*R\\[i\\])$ 对于L和R，我们可以考虑对每个以i为中心的回文串算贡献，用类似差分+前缀和的思想可以O(1)修改，最后O(N)遍历一遍即能求出\n\n### Code\n```cpp\n    #include <bits/stdc++.h>\n    #define int long long\n    \n    using namespace std;\n    \n    const int Maxn = 2e6 + 10, Mod = 1000000007;\n    \n    char S[Maxn], A[Maxn];\n    int P[Maxn];\n    int Sum1[Maxn], Sum2[Maxn];\n    int L[Maxn], R[Maxn];\n    \n    int N;\n    \n    inline void Init ()\n    {\n        memset(P, 0, sizeof P);\n        memset(A, 0, sizeof A);\n        memset(L, 0, sizeof L);\n        memset(R, 0, sizeof R);\n        memset(Sum1, 0, sizeof Sum1);\n        memset(Sum2, 0, sizeof Sum2);\n    }\n    \n    inline void Manacher ()\n    {\n        N = strlen(S + 1);\n        for (int i = 1; i <= N; ++i)\n            A[i * 2] = S[i], A[i * 2 - 1] = '#';\n        A[0] = '%', A[N * 2 + 1] = '#';\n        N = N * 2 + 1;\n        for (int i = 0; i <= N; ++i) S[i] = A[i];\n    \n        int id = 0, Max = 0;\n        for (int i = 1; i <= N; ++i)\n        {\n            if (i < Max)\n                P[i] = min(P[2 * id - i], Max - i);\n            else P[i] = 1;\n            while (S[i + P[i]] == S[i - P[i]]) P[i] ++;\n            if (Max < i + P[i] - 1)\n            {\n                Max = i + P[i] - 1;\n                id = i;\n            }\n        }\n    }\n    \n    inline void Solve ()\n    {\n        Manacher();\n        for (int i = 1; i <= N; ++i)\n        {\n            Sum1[i - P[i] + 1] += i, Sum1[i + 1] -= i;\n            Sum2[i - P[i] + 1] ++, Sum2[i + 1] --;\n        }\n        for (int i = 1; i <= N; ++i)\n        {\n            Sum1[i] += Sum1[i - 1], Sum2[i] += Sum2[i - 1];\n            if (!(i % 2)) L[i / 2] = (Sum1[i] - i / 2 * Sum2[i]) % Mod;\n        }\n    \n        memset(Sum1, 0, sizeof Sum1);\n        memset(Sum2, 0, sizeof Sum2);\n    \n        for (int i = 1; i <= N; ++i)\n        {\n            Sum1[i] += i, Sum1[i + P[i]] -= i;\n            Sum2[i] ++, Sum2[i + P[i]] --;\n        }\n        for (int i = 1; i <= N; ++i)\n        {\n            Sum1[i] += Sum1[i - 1], Sum2[i] += Sum2[i - 1];\n            if (!(i % 2)) R[i / 2] = (Sum1[i] - i / 2 * Sum2[i]) % Mod;\n        }\n    \n        int Ans = 0ll;\n        N /= 2;\n        for (int i = 1; i < N; ++i)\n            (Ans += L[i + 1] * R[i] % Mod) %= Mod;\n        cout<<Ans<<endl;\n    \n    }\n    \n    main()\n    {\n    #ifdef hk_cnyali\n        freopen(\"A.in\", \"r\", stdin);\n        freopen(\"A.out\", \"w\", stdout);\n    #endif\n        while (~scanf(\"%s\", S + 1))\n        {\n            Init();\n            Solve();\n            memset(S, 0, sizeof S);\n        }\n        return 0;\n    }\n```\n","categories":["Problem"],"tags":["差分","前缀和","字符串","Manacher"]},{"title":"高级数据结构【Splay相关，可持久化数据结构、重量平衡树、仙人掌系列、支配树、划分树】 Summary","url":"/2018/03/14/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%90Splay%E7%9B%B8%E5%85%B3%EF%BC%8C%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E9%87%8D%E9%87%8F%E5%B9%B3%E8%A1%A1%E6%A0%91%E3%80%81%E4%BB%99%E4%BA%BA%E6%8E%8C%E7%B3%BB%E5%88%97%E3%80%81%E6%94%AF%E9%85%8D%E6%A0%91%E3%80%81%E5%88%92%E5%88%86%E6%A0%91%E3%80%91-Summary/","content":"\n知识点总结\n-----\n\n这个专题好像没什么新算法，标题里的重量平衡树、仙人掌、划分树好像都没用到。。。 都是一些可持久化数据结构和Splay的题目 最多多了一个支配树，在专门那篇Blog里也有学习资料\n<!--more-->\nProblems\n--------\n\n### Hdu2475 Box(Splay)\n\n_[Hdu2475 Box(Splay)](http://hk-cnyali.com/2018/03/13/hdu2475-boxsplay/)_\n\n### Hdu5923 Prediction(并查集)\n\n_[Hdu5923 Prediction(并查集)](http://hk-cnyali.com/2018/03/13/hdu5923-prediction%E5%B9%B6%E6%9F%A5%E9%9B%86/)_\n\n### Hdu2665 Kth number（主席树）\n\n主席树模板，只是想吐槽一下题目里说好的求第k大，结果写成第k小才A\n```cpp\n    #include <bits/stdc++.h>\n    \n    using namespace std;\n    \n    const int Maxn = 100000 + 100;\n    \n    struct node\n    {\n        int id, val;\n    }A[Maxn];\n    \n    inline int cmp (node a, node b)\n    {\n        return a.val < b.val;\n    }\n    \n    int N, M;\n    int Cnt;\n    \n    struct Tree\n    {\n        int lson, rson, val;\n    }Tree[Maxn * 20];\n    \n    int Root[Maxn], Rank[Maxn];\n    \n    inline void build (int &root, int l, int r)\n    {\n        root = ++ Cnt;\n        Tree[root].val = 0;\n        if (l == r) return ;\n        int mid = (l + r) >> 1;\n        build(Tree[root].lson, l, mid);\n        build(Tree[root].rson, mid + 1, r);\n    }\n    \n    inline void Insert (int pre, int &now, int l, int r, int x)\n    {\n        now = ++ Cnt;\n        Tree[now].lson = Tree[pre].lson;\n        Tree[now].rson = Tree[pre].rson;\n        Tree[now].val = Tree[pre].val + 1;\n        if (l == r) return ;\n        int mid = (l + r) >> 1;\n        if (x <= mid) Insert(Tree[pre].lson, Tree[now].lson, l, mid, x);\n        else Insert(Tree[pre].rson, Tree[now].rson, mid + 1, r, x);\n    }\n    \n    inline int Query (int pre, int now, int l, int r, int x)\n    {\n        if (l == r)\n            return l;\n        int mid = (l + r) >> 1;\n        int left = Tree[Tree[now].lson].val - Tree[Tree[pre].lson].val;\n        if (left >= x)\n            return Query(Tree[pre].lson, Tree[now].lson, l, mid, x);\n        else return Query(Tree[pre].rson, Tree[now].rson, mid + 1, r, x - left);\n    }\n    \n    int main()\n    {\n    #ifdef hk_cnyali\n        freopen(\"A.in\", \"r\", stdin);\n        freopen(\"A.out\", \"w\", stdout);\n    #endif\n        int t;\n        scanf(\"%d\", &t);\n        while (t--)\n        {\n            Cnt = 0;\n            memset(A, 0, sizeof A);\n            memset(Root, 0, sizeof Root);\n            memset(Tree, 0, sizeof Tree);\n            memset(Rank, 0, sizeof Rank);\n            scanf(\"%d%d\", &N, &M);\n            for (int i = 1; i <= N; ++i)\n                scanf(\"%d\", &A[i].val), A[i].id = i;\n            sort(A + 1, A + N + 1, cmp);\n            for (int i = 1; i <= N; ++i) Rank[A[i].id] = i;\n            build(Root[0], 1, N);\n            for (int i = 1; i <= N; ++i)\n                Insert(Root[i - 1], Root[i], 1, N, Rank[i]);\n            for (int i = 1; i <= M; ++i)\n            {\n                int x, y, k;\n                scanf(\"%d%d%d\", &x, &y, &k);\n                printf(\"%d\\n\", A[Query(Root[x - 1], Root[y], 1, N, k)].val);\n            }\n        }\n        return 0;\n    }\n```\n\n### Hdu4757 Tree(可持久化01Trie)\n\n_[Hdu4757 Tree(可持久化01Trie)](http://hk-cnyali.com/2018/03/13/hdu4757-tree%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%9601trie/)_\n\n### Hdu5324 Boring Class(树套树)\n\n_[Hdu5324 Boring Class(树套树)](http://hk-cnyali.com/2018/03/14/hdu5324-boring-class%E6%A0%91%E5%A5%97%E6%A0%91/)_\n\n### POJ3580 SuperMemo(Splay)\n\n_[POJ3580 SuperMemo(Splay)](http://hk-cnyali.com/2018/03/14/poj3580-supermemosplay/)_\n\n### Hdu6041 I Curse Myself(tarjan)\n\n_[Hdu6041 I Curse Myself(tarjan)](http://hk-cnyali.com/2018/03/13/hdu6041-i-curse-myselftarjan/)_\n\n### Hdu4694 Important Sisters(支配树)\n\n_[Hdu4694 Important Sisters(支配树)](http://hk-cnyali.com/2018/03/13/hdu4694-important-sisters%E6%94%AF%E9%85%8D%E6%A0%91/)_\n\n### Hdu4417 Super Mario(主席树)\n```cpp\n    #include <bits/stdc++.h>\n    #define lowbit(x) x & (-x)\n    \n    using namespace std;\n    \n    const int Maxn = 1e5 + 10;\n    \n    int N, M;\n    int A[Maxn], B[Maxn];\n    int Root[Maxn];\n    \n    struct tree\n    {\n        int lson, rson, val;\n    };\n    \n    namespace DS\n    {\n        tree Tree[Maxn * 20];\n        int cnt = 0;\n    \n        inline void insert (int &now, int pre, int l, int r, int z)\n        {\n            now = ++cnt;\n            Tree[now].lson = Tree[pre].lson;\n            Tree[now].rson = Tree[pre].rson;\n            Tree[now].val = Tree[pre].val + 1;\n            if (l == r)\n                return ;\n            int mid = (l + r) >> 1;\n            if (z <= mid)\n                insert (Tree[now].lson, Tree[pre].lson, l, mid, z);\n            else insert (Tree[now].rson, Tree[pre].rson, mid + 1, r, z);\n        }\n    \n        inline int query (int now, int pre, int l, int r, int x, int y)\n        {\n            if (x > r || y < l) return 0;\n            if (x <= l && r <= y) return Tree[now].val - Tree[pre].val;\n            int mid = (l + r) >> 1;\n            int ans = 0;\n            if (x <= mid) ans += query (Tree[now].lson, Tree[pre].lson, l, mid, x, y);\n            if (y > mid) ans += query (Tree[now].rson, Tree[pre].rson, mid + 1, r, x, y);\n            return ans;\n        }\n    }\n    \n    inline void Init()\n    {\n        DS :: cnt = 0;\n    }\n    \n    inline void Solve()\n    {\n        scanf(\"%d%d\", &N, &M);\n        for (int i = 1; i <= N; ++i) scanf(\"%d\", &B[i]), A[i] = B[i];\n        sort(B + 1, B + N + 1);\n        int len = unique(B + 1, B + N + 1) - B - 1;\n        for (int i = 1; i <= N; ++i)\n            A[i] = lower_bound(B + 1, B + len + 1, A[i]) - B;\n        for (int i = 1; i <= N; ++i)\n            DS :: insert(Root[i], Root[i - 1], 1, N, A[i]);\n    \n        while (M--)\n        {\n            int x, y, z;\n            scanf(\"%d%d%d\", &x, &y, &z);\n            x++, y++;\n            z = upper_bound(B + 1, B + len + 1, z) - B - 1;\n            printf(\"%d\\n\", DS :: query (Root[y], Root[x - 1], 1, N, 1, z));\n        }\n    }\n    \n    int main()\n    {\n    #ifdef hk_cnyali\n        freopen(\"A.in\", \"r\", stdin);\n        freopen(\"A.out\", \"w\", stdout);\n    #endif\n        int T;\n        scanf(\"%d\", &T);\n        for (int xz = 1; xz <= T; ++xz)\n        {\n            printf(\"Case %d:\\n\", xz);\n            Init();\n            Solve();\n        }\n        return 0;\n    }\n```\n","categories":["Summary"],"tags":["数据结构","并查集","平衡树","Splay","01Trie","Trie","支配树","可持久化"]},{"title":"「POJ3580」 SuperMemo - Splay","url":"/2018/03/14/POJ3580-SuperMemo-Splay/","content":"\n题目链接：[传送门](http://poj.org/problem?id=3580)\n\n### Description\n\n给你一个序列，支持一下操作： \n1. add(x, y, D): 区间\\[x, y\\] + D \n2. reverse(x, y): 区间\\[x,y\\]翻转 \n3. revolve(x, y, T): 将区间\\[x,y\\]的最右一个数提到最左，进行T次\n4. insert(x, P): 在序列第x个数后添加P这个数\n5. delete(x): 删除第x个数\n6. min(x, y): 查询区间\\[x, y\\]最小值\n<!--more-->\n\n### Solution\n\nSplay裸题 \n12456都是常规操作， 第3个操作相当于在T %= (y-x+1)后将区间\\[y-z+1, y\\]剪切到区间\\[x, y-z\\]的前面，也是一个比较容易的操作 \n不过这道题又调了我一个下午，最后发现是insert中在while找x的后继时忘记push_down了\n\n### Code\n```cpp\n    #include <iostream>\n    #include <cstdio>\n    #include <cstring>\n    #include <cmath>\n    #include <algorithm>\n    #include <limits.h>\n    \n    using namespace std;\n    \n    const int Maxn = 1e6 + 10;\n    \n    int N, M, A[Maxn];\n    int root;\n    \n    struct tree\n    {\n        int val, minn, rev, add, size, ch[2], fa;\n    };\n    \n    namespace Splay\n    {\n        tree Tree[Maxn];\n        int cnt = 0;\n    #define lson Tree[x].ch[0]\n    #define rson Tree[x].ch[1]\n    \n        inline void print (int x)\n        {\n            if (lson) print(lson);\n            cout<<Tree[x].val<<\" \";\n            if (rson) print(rson);\n        }\n    \n        inline void newnode (int &x, int val, int fa)\n        {\n            x = ++cnt;\n            Tree[x].minn = Tree[x].val = val;\n            Tree[x].fa = fa;\n            Tree[x].size = 1;\n            Tree[x].rev = Tree[x].add = Tree[x].ch[0] = Tree[x].ch[1] = 0;\n        }\n    \n        inline void delnode (int x)\n        {\n            Tree[x].val = Tree[x].minn = Tree[x].rev = Tree[x].add = Tree[x].size = 0;\n            Tree[x].ch[0] = Tree[x].ch[1] = Tree[x].fa = 0;\n        }\n    \n        inline void push_up (int x)\n        {\n            Tree[x].minn = Tree[x].val;\n            Tree[x].size = 1;\n            if (lson) Tree[x].minn = min (Tree[x].minn, Tree[lson].minn), Tree[x].size += Tree[lson].size;\n            if (rson) Tree[x].minn = min (Tree[x].minn, Tree[rson].minn), Tree[x].size += Tree[rson].size;\n        }\n    \n        inline void push_down (int x)\n        {\n            if (Tree[x].add)\n            {\n                Tree[lson].val += Tree[x].add; Tree[rson].val += Tree[x].add;\n                Tree[lson].add += Tree[x].add; Tree[rson].add += Tree[x].add;\n                Tree[lson].minn += Tree[x].add; Tree[rson].minn += Tree[x].add;\n                Tree[x].add = 0;\n            }\n            if (Tree[x].rev)\n            {\n                //swap (lson, rson);\n                if (lson) swap (Tree[lson].ch[0], Tree[lson].ch[1]), Tree[lson].rev ^= 1;\n                if (rson) swap (Tree[rson].ch[0], Tree[rson].ch[1]), Tree[rson].rev ^= 1;\n            //  Tree[Tree[lson].ch[0]].rev ^= 1; Tree[Tree[lson].ch[1]].rev ^= 1;\n            //  Tree[Tree[rson].ch[0]].rev ^= 1; Tree[Tree[rson].ch[1]].rev ^= 1;\n                Tree[x].rev = 0;\n            }\n        }\n    \n        inline int judge_dir (int x)\n        {\n            return Tree[Tree[x].fa].ch[1] == x;\n        }\n    \n        inline void connect (int x, int fa, int dir)\n        {\n            Tree[x].fa = fa;\n            Tree[fa].ch[dir] = x;\n        }\n    \n        inline void rotate (int x)\n        {\n            int f = Tree[x].fa;\n            int dirx = judge_dir(x);\n            int anc = Tree[f].fa;\n            int dirf = judge_dir(f);\n            push_down(f), push_down(x);\n            connect (Tree[x].ch[dirx ^ 1], f, dirx);\n            connect (f, x, (dirx ^ 1));\n            connect (x, anc, dirf);\n            push_up(f), push_up(x);\n        }\n    \n        inline void splay (int x, int y)\n        {\n            while (Tree[x].fa != y)\n            {\n                int f = Tree[x].fa;\n                int dirx = judge_dir(x), dirf = judge_dir(f);\n                if (Tree[f].fa == y) rotate(x);\n                else if (dirx == dirf) rotate(f), rotate(x);\n                else rotate(x), rotate(x);\n            }\n            if (!y) root = x;\n        }\n    \n        inline void build (int &x, int l, int r, int fa)\n        {\n            if (l > r) return ;\n            int mid = (l + r) >> 1;\n            newnode (x, A[mid], fa);\n            build (lson, l, mid - 1, x);\n            build (rson, mid + 1, r, x);\n            push_up(x);\n        }\n    \n        inline int kth (int k)\n        {\n            int x = root;\n            while (1)\n            {\n                push_down (x);\n                if (k == Tree[lson].size + 1) return x;\n                if (k <= Tree[lson].size) x = lson;\n                else k -= (Tree[lson].size + 1), x = rson;\n            }\n        }\n    \n        inline void add (int x, int y, int z)\n        {\n            x = kth(x - 1), y = kth(y + 1);\n            splay (x, 0); splay (y, x);\n            x = Tree[y].ch[0];\n            Tree[x].val += z; Tree[x].minn += z; Tree[x].add += z;\n            splay (x, 0);\n        }\n    \n        inline void reverse (int x, int y)\n        {\n            x = kth(x - 1), y = kth(y + 1);\n            splay (x, 0); splay (y, x);\n            x = Tree[y].ch[0];\n    //      cout<<x<<endl;\n    //      cout<<lson<<\" \"<<rson<<endl;\n            swap(lson, rson);\n            Tree[x].rev ^= 1;\n            splay (x, 0);\n            //Tree[lson].rev ^= 1;\n            //Tree[rson].rev ^= 1;\n        }\n    \n        inline void revolve (int l1, int r1, int l2, int r2)\n        {\n            int x = kth(l2 - 1), y = kth(r2 + 1);\n            splay (x, 0), splay (y, x);\n            int a = Tree[y].ch[0];\n            Tree[y].ch[0] = 0;\n            x = kth(l1 - 1), y = kth(l1);\n            splay (x, 0), splay (y, x);\n            connect(a, y, 0);\n        }\n    \n        inline void insert (int x, int val)\n        {\n            int tmp = x;\n            x = kth(x);\n            splay (x, 0);\n            int now = rson;\n            while (Tree[now].ch[0]) push_down (now),/*attention!*/ now = Tree[now].ch[0];\n            push_down(now);//attention!\n            //the above 3 lines you can also write :  int now = kth(tmp + 1);\n            newnode (x, val, now);\n            connect (x, now, 0);\n            splay (x, 0);\n        }\n    \n        inline void del (int x)\n        {\n            splay (kth(x - 1), 0);\n            splay (kth(x + 1), root);\n            x = root;\n            delnode (Tree[rson].ch[0]);\n            Tree[rson].ch[0] = 0;\n            push_up (rson);\n            push_up (x);\n        }\n    \n        inline int query (int x, int y)\n        {\n            x = kth(x - 1), y = kth(y + 1);\n            splay (x, 0), splay (y, x);\n            //print(root);\n            //cout<<endl;\n            return Tree[Tree[y].ch[0]].minn; \n        }\n    }\n    \n    int main()\n    {\n    #ifdef hk_cnyali\n        freopen(\"A.in\", \"r\", stdin);\n        freopen(\"A.out\", \"w\", stdout);\n    #endif\n        scanf(\"%d\", &N);\n        A[1] = A[N + 2] = INT_MAX;\n        for (int i = 2; i <= N + 1; ++i) scanf(\"%d\", &A[i]);\n        Splay :: build (root, 1, N + 2, 0);\n        scanf(\"%d\", &M);\n        while (M --)\n        {\n            char s[10];\n            scanf(\"%s\", s);\n            int x, y, z;\n            if (s[0] == 'A')\n            {\n                scanf(\"%d%d%d\", &x, &y, &z);\n                x++ , y++;\n                Splay :: add (x, y, z);\n            }\n            else if (s[0] == 'R' && s[3] == 'E')\n            {\n                scanf(\"%d%d\", &x, &y);\n                x++, y++;\n                Splay :: reverse (x, y);\n            }\n            else if (s[0] == 'R' && s[3] == 'O')\n            {\n                scanf(\"%d%d%d\", &x, &y, &z);\n                x++, y++;\n                z %= (y - x + 1);\n                Splay :: revolve (x, y - z, y - z + 1, y);\n            }\n            else if (s[0] == 'I')\n            {\n                scanf(\"%d%d\", &x, &y);\n                x++;\n                Splay :: insert (x, y);\n            }\n            else if (s[0] == 'D')\n            {\n                scanf(\"%d\", &x);\n                x++;\n                Splay :: del (x);\n            }\n            else \n            {\n                scanf(\"%d%d\", &x, &y);\n                x++, y++;\n                printf(\"%d\\n\", Splay :: query (x, y));\n            }\n        }\n        return 0;\n    }\n```\n","categories":["Problem"],"tags":["数据结构","平衡树","Splay","树"]},{"title":"「Hdu5324」Boring Class - 树套树","url":"/2018/03/14/Hdu5324-Boring-Class-%E6%A0%91%E5%A5%97%E6%A0%91/","content":"\n题目链接：[传送门](acm.hdu.edu.cn/showproblem.php?pid=5324)\n\n### Description\n\n给出两个长度为n的数组A,B。求一个子序列，使得子序列中A数组单调不降，B数组单调不升\n\n<!--more-->\n\n### Solution\n\n本质就是个三维偏序 可以用CDQ分治+树状数组过掉，\n但是由于我对Splay情有独钟想练一下Splay，就写的树状数组套Splay \n开始写完之后调好久以为是处理权值相同的情况的时候有问题，于是一顿魔改（即读入数据之后的那十几行代码），\n把原数组乱搞成了一个元素互不相同的数组，\n后来发现是Splay里面 写错了，\n稍微改了下A了之后就懒得把魔改部分改回去了\n\n### Code\n```cpp\n    #include <bits/stdc++.h>\n    #define lowbit(x) x & (-x)\n    \n    using namespace std;\n    \n    const int Maxn = 5e4 + 10;\n    \n    int N;\n    int A[Maxn], B[Maxn], len1, len2;\n    int Next[Maxn];\n    int Dp[Maxn], Root[Maxn];\n    \n    struct node\n    {\n        int val, id;\n    }X[Maxn], Y[Maxn];\n    int tmp1[Maxn], tmp2[Maxn];\n    \n    inline int cmp1 (node a, node b)\n    {\n        if (a.val == b.val) return a.id > b.id;\n        return a.val < b.val;\n    }\n    \n    inline int cmp2 (node a, node b)\n    {\n        return a.id < b.id;\n    }\n    \n    inline int cmp3 (node a, node b)\n    {\n        if (a.val == b.val) return a.id < b.id;\n        return a.val < b.val;\n    }\n    \n    \n    struct tree\n    {\n        int maxv, maxid, id, val, ch[2], dp, fa;\n    };\n    \n    namespace Splay\n    {\n        tree Tree[Maxn * 16];\n        int cnt;\n    \n        inline int judge_dir (int x)\n        {\n            return Tree[Tree[x].fa].ch[1] == x;\n        }\n    \n        inline void chkmax (tree &x, int DP, int ID)\n        {\n            if (DP > x.maxv) x.maxv = DP, x.maxid = ID;\n            else if (DP == x.maxv && ID < x.maxid) x.maxid = ID;\n        }\n    \n        inline void update (int x)\n        {\n            Tree[x].maxv = Tree[x].dp;\n            Tree[x].maxid = Tree[x].id;\n            if (Tree[x].ch[0]) chkmax (Tree[x], Tree[Tree[x].ch[0]].maxv, Tree[Tree[x].ch[0]].maxid);\n            if (Tree[x].ch[1]) chkmax (Tree[x], Tree[Tree[x].ch[1]].maxv, Tree[Tree[x].ch[1]].maxid);\n        }\n    \n        inline void connect (int x, int f, int dir)\n        {\n            Tree[x].fa = f;\n            Tree[f].ch[dir] = x;\n        }\n    \n        inline void rotate (int x)\n        {\n            int f = Tree[x].fa; \n            int dirx = judge_dir(x);\n            int anc = Tree[f].fa;\n            int dirf = judge_dir(f);\n            connect(Tree[x].ch[dirx ^ 1], f, dirx);\n            connect(f, x, (dirx ^ 1));\n            connect(x, anc, dirf);\n            update(f), update(x);\n        }\n    \n        inline void splay (int x, int y, int &root)\n        {\n            while (Tree[x].fa != y)\n            {\n                int f = Tree[x].fa;\n                int dirx = judge_dir(x), dirf = judge_dir(f);\n                if (Tree[f].fa == y) rotate(x);\n                else if (dirx == dirf) rotate(f), rotate(x);\n                else rotate(x), rotate(x);\n            }\n            if (!y) root = x;\n        }\n    \n        inline void Newnode (int val, int DP, int ID, int f)\n        {\n            Tree[++cnt].val = val;\n            Tree[cnt].maxv = Tree[cnt].dp = DP;\n            Tree[cnt].maxid = Tree[cnt].id = ID;\n            Tree[cnt].fa = f;\n        }\n    \n        inline void insert (int &root, int val, int DP, int ID)\n        {\n            if (!root)\n            {\n                Newnode(val, DP, ID, 0);\n                splay (cnt, 0, root);\n                return ;\n            }\n            int now = root;\n            while (1)\n            {\n                if (Tree[now].val == val)\n                {\n                    /*\n                    tree tmp;\n                    tmp.maxv = Tree[now].dp;\n                    tmp.maxid = Tree[now].id;\n                    chkmax (tmp, DP, ID);\n                    Tree[now].dp = tmp.maxv;\n                    Tree[now].id = tmp.maxid;\n                    splay (now, 0, root);\n                    */\n                    /*\n                    int tmp = Tree[now].ch[1];\n                    while (Tree[tmp].ch[0]) tmp = Tree[tmp].ch[0];\n                    Newnode(val, DP, ID, tmp);\n                    Tree[tmp].ch[0] = cnt;\n                    splay (cnt, 0, root);\n                    */\n                    return ;\n                }\n                int dir = (val > Tree[now].val);\n                if (!Tree[now].ch[dir])\n                {\n                    Newnode(val, DP, ID, now);\n                    Tree[now].ch[dir] = cnt;\n                    splay (cnt, 0, root);\n                    return ;\n                }\n                now = Tree[now].ch[dir];\n            }\n        }\n    \n        inline void query (int root, int val, tree &save)\n        {\n            int now = root;\n            while (1)\n            {\n                //cout<<root<<\" \"<<val<<\" \"<<now<<\" \"<<Tree[now].val<<endl;\n                if (!now) return ;\n                if (Tree[now].val < val)\n                {\n                    now = Tree[now].ch[1];\n                    continue;\n                }\n                chkmax (save, Tree[now].dp, Tree[now].id);\n                if (Tree[now].ch[1]) chkmax (save, Tree[Tree[now].ch[1]].maxv, Tree[Tree[now].ch[1]].maxid);\n                now = Tree[now].ch[0];\n            }\n        }\n    \n    }\n    \n    namespace BIT\n    {\n        inline void add (int x, int y, int DP, int ID)\n        {\n            while (x <= N)\n            {\n                Splay :: insert (Root[x], y, DP, ID);\n                x += lowbit(x);\n            }\n        }\n    \n        inline void query (int x, int y, int &DP, int &ID)\n        {\n            tree newnode;\n            newnode.maxv = DP;\n            newnode.maxid = ID;\n            while (x)\n            {\n                Splay :: query (Root[x], y, newnode);\n                x -= lowbit(x);\n            }\n            DP = newnode.maxv;\n            ID = newnode.maxid;\n        }\n    }\n    \n    inline void Init ()\n    {\n        memset(Dp, 0, sizeof Dp);\n        memset(Root, 0, sizeof Root);\n        memset(Splay :: Tree, 0, sizeof Splay :: Tree);\n        Splay :: cnt = 0;\n    }\n    \n    int main()\n    {\n    #ifdef hk_cnyali\n        freopen(\"A.in\", \"r\", stdin);\n        freopen(\"A.out\", \"w\", stdout);\n    #endif\n        while (~scanf(\"%d\", &N))\n        {\n            Init();\n            for (int i = 1; i <= N; ++i) scanf(\"%d\", &A[i]), X[i].val = A[i], X[i].id = i;\n            for (int i = 1; i <= N; ++i) scanf(\"%d\", &B[i]), Y[i].val = B[i], Y[i].id = i;\n            sort(X + 1, X + N + 1, cmp1);\n            sort(Y + 1, Y + N + 1, cmp3);\n            for (int i = 2; i <= N; ++i)\n                if (X[i].val <= X[i - 1].val)\n                    X[i].val = X[i - 1].val + 1;\n            for (int i = 2; i <= N; ++i)\n                if (Y[i].val <= Y[i - 1].val)\n                    Y[i].val = Y[i - 1].val + 1;\n            sort(X + 1, X + N + 1, cmp2);\n            sort(Y + 1, Y + N + 1, cmp2);\n            for (int i = 1; i <= N; ++i) A[i] = X[i].val;\n            for (int i = 1; i <= N; ++i) B[i] = Y[i].val;\n            sort(X + 1, X + N + 1, cmp1);\n            sort(Y + 1, Y + N + 1, cmp3);\n            for (int i = 1; i <= N; ++i) tmp1[i] = X[i].val;\n            for (int i = 1; i <= N; ++i) tmp2[i] = Y[i].val;\n            for (int i = 1; i <= N; ++i) A[i] = lower_bound(tmp1 + 1, tmp1 + N + 1, A[i]) - tmp1;\n            for (int i = 1; i <= N; ++i) B[i] = lower_bound(tmp2 + 1, tmp2 + N + 1, B[i]) - tmp2;\n            //for (int i = 1; i <= N; ++i) cout<<A[i]<<\" \";\n            //cout<<endl;\n            //for (int i = 1; i <= N; ++i) cout<<B[i]<<\" \";\n            //cout<<endl;\n            int Ans = 0, now = INT_MAX;\n            for (int i = N; i >= 1; --i)\n            {\n                int ID = INT_MAX, DP = 0;\n                BIT :: query (A[i], B[i], DP, ID);\n                //cout<<A[i]<<\" \"<<B[i]<<endl;\n                //cout<<DP<<\" \"<<ID<<endl;\n                Dp[i] = DP + 1;\n                Next[i] = ID;\n                BIT :: add (A[i], B[i], Dp[i], i);\n                if (Dp[i] >= Ans)\n                {\n                    now = i;\n                    Ans = Dp[i];\n                }\n            }\n            //for (int i = 1; i <= N; ++i) cout<<Dp[i]<<\" \";cout<<endl;\n            //for (int i = 1; i <= N; ++i) cout<<Next[i]<<\" \";cout<<endl;\n            cout<<Ans<<endl;\n            while (now != INT_MAX)\n            {\n                cout<<now;\n                now = Next[now];\n                if (now != INT_MAX) cout<<\" \";\n            }\n            cout<<endl;\n        }\n        return 0;\n    }\n```\n","categories":["Problem"],"tags":["数据结构","树状数组","平衡树","Splay","树套树"]},{"title":"「Hdu4694」 Important Sisters - 支配树","url":"/2018/03/13/Hdu4694-Important-Sisters-%E6%94%AF%E9%85%8D%E6%A0%91/","content":"\n题目链接：[传送门](http://acm.hdu.edu.cn/showproblem.php?pid=4694)\n\n### Description\n\n支配树模板 [学习资料](https://wenku.baidu.com/view/b06471d019e8b8f67d1cb91b.html)\n<!--more-->\n\n### Code\n```cpp\n    #include <bits/stdc++.h>\n    #define int long long\n    \n    using namespace std;\n    \n    const int Maxn = 50000 + 10, Maxm = 100000 + 10;\n    \n    int N, M;\n    int e, Begin[Maxn], To[Maxm * 2], Next[Maxm * 2];\n    int Index, dfn[Maxn], id[Maxn], fa[Maxn], f[Maxn], val[Maxn], idom[Maxn], semi[Maxn];\n    int Ans[Maxn];\n    vector <int> dom[Maxn], vec[Maxn];\n    \n    inline void Init()\n    {\n        e = Index = 0;\n        for (int i = 1; i <= N; ++i) vec[i].clear(), dom[i].clear(), Begin[i] = dfn[i] = idom[i] = Ans[i] = 0, f[i] = val[i] = semi[i] = i;\n    }\n    \n    inline void add_edge (int x, int y)\n    {\n        To[++e] = y;\n        Next[e] = Begin[x];\n        Begin[x] = e;\n    }\n    \n    inline void dfs (int x)\n    {\n        dfn[x] = ++Index;\n        id[Index] = x;\n        for (int i = Begin[x]; i; i = Next[i])\n        {\n            int y = To[i];\n            vec[y].push_back(x);\n            if (dfn[y]) continue;\n            fa[y] = x;\n            dfs(y);\n        }\n    }\n    \n    inline int find (int x)\n    {\n        if (f[x] == x) return x;\n        int y = find(f[x]);\n        if (dfn[semi[val[f[x]]]] < dfn[semi[val[x]]]) val[x] = val[f[x]];\n        return f[x] = y;\n    }\n    \n    inline void Calc ()\n    {\n        for (int i = 1; i <= Index; ++i)\n        {\n            int x = id[i];\n            Ans[x] += x;\n            if (idom[x]) Ans[x] += Ans[idom[x]];\n        }\n    }\n    \n    inline int mmin (int x, int y)\n    {\n        return dfn[x] < dfn[y] ? x : y;\n    }\n    \n    main()\n    {\n    #ifdef hk_cnyali\n        freopen(\"A.in\", \"r\", stdin);\n        freopen(\"A.out\", \"w\", stdout);\n    #endif\n        while (~scanf(\"%lld%lld\", &N, &M))\n        {\n            Init();\n            for (int i = 1; i <= M; ++i)\n            {\n                int x, y;\n                scanf(\"%lld%lld\", &x, &y);\n                add_edge (x, y);\n            }\n    \n            dfs(N);\n    \n            for (int i = Index; i > 1; --i)\n            {\n                int x = id[i];\n                for (int j = 0; j < vec[x].size(); ++j)\n                {\n                    int now = vec[x][j];\n                    if (dfn[now] < dfn[x]) semi[x] = mmin(semi[x], now);\n                    else\n                    {\n                        find(now);\n                        semi[x] = mmin(semi[x], semi[val[now]]);\n                    }\n                }\n    \n                f[x] = fa[x], dom[semi[x]].push_back(x);\n                for (int j = 0; j < dom[fa[x]].size(); ++j)\n                {\n                    int now = dom[fa[x]][j]; find(now);\n                    idom[now] = (dfn[semi[val[now]]] < dfn[semi[now]]) ? val[now] : fa[x];\n                }\n            }\n    \n            for (int i = 2; i <= Index; ++i)\n            {\n                int x = id[i];\n                if (idom[x] != semi[x]) idom[x] = idom[idom[x]];\n            }\n    \n            Calc();\n    \n            cout<<Ans[1];\n            for (int i = 2; i <= N; ++i)\n                cout<<\" \"<<Ans[i];\n            cout<<endl;\n        }\n        return 0;\n    }\n```\n","categories":["Problem"],"tags":["tarjan","数据结构","支配树"]},{"title":"「Hdu6041」I Curse Myself - tarjan","url":"/2018/03/13/Hdu6041-I-Curse-Myself-tarjan/","content":"\n题目链接:[传送门](http://acm.hdu.edu.cn/showproblem.php?pid=6041)\n\n### Description\n\n给你一棵无向带边权的仙人掌（节点数<=1e3），求前k(1<=k<=1e5)小生成树的权值 * k之和。\n<!--more-->\n\n### Solution\n\n一开始看到这道题差点被仙人掌吓到了。。。 \n实际上由于这个图是仙人掌，那么它的生成树就一定是每个环去掉一条边所构成的，\n我们可以通过存边的tarjan算法找到仙人掌上的所有环，\n题目要求k小生成树，我们只要找到去掉的边的k大的组合即可。 \n那么就可把问题简化为：有一些集合，在每个集合中选一个数，求前k大的组合。 \n然后这就是一个很经典的问题了，直接用堆维护即可(证明见[此](http://blog.csdn.net/v5zsq/article/details/76768985))（一开始用的priority_queu发现被卡常，换成make_heap才卡进4000ms）\n\n### Code\n```cpp\n    #include <bits/stdc++.h>\n    \n    using namespace std;\n    \n    const int Maxn = 1000 + 10, Maxm = 2000 + 10, Maxk = 1e5 + 10;\n    \n    int N, M, K;\n    int e, Begin[Maxn], Next[Maxm * 2], To[Maxm * 2], W[Maxm * 2];\n    int Ans[Maxk], dfn[Maxn], low[Maxn], Index;\n    int tmp[Maxk], Sum;\n    stack <int> S;\n    struct node\n    {\n        int val, pos1, pos2;\n        bool operator < (const node &x) const\n        {\n            return x.val > val;\n        }\n    }A[Maxk];\n    \n    struct heap {\n        int point;\n        node data[Maxk];\n        heap (){};\n        inline int empty()\n        {\n            return !point;\n        }\n        inline void clear()\n        {\n            point = 0;\n        }\n        inline void push(node a) {\n            data[++point] = a;\n            push_heap(data + 1, data + point + 1);\n        }\n        inline node pop() {\n            node res = data[1];\n            pop_heap(data + 1, data + point + 1);\n            --point;\n            return res;\n        }\n        inline node top() {\n            return data[1];\n        }\n    }Q;\n    \n    inline int read(){\n        int x=0,w=1;\n        char ch=0;\n        while (ch<'0' || ch>'9'){\n              if (ch=='-') w=-1;\n              ch=getchar();\n        }\n        while (ch<='9' && ch>='0'){\n              x=(x<<1)+(x<<3)+ch-'0';\n              ch=getchar();\n        }\n        return x*w;\n    }\n    \n    inline void Init ()\n    {\n        e = Index = Sum = 0;\n        for (int i = 1; i <= N; ++i) Begin[i] = dfn[i] = 0;\n        Ans[0] = 0;\n    }\n    \n    inline void add_edge (int x, int y, int z)\n    {\n        To[++e] = y;\n        Next[e] = Begin[x];\n        Begin[x] = e;\n        W[e] = z;\n    }\n    \n    inline void Input ()\n    {\n        while (M--)\n        {\n            int x, y, z;\n            x = read(); y = read(); z = read();\n            Sum += z;\n            add_edge (x, y, z);\n            add_edge (y, x, z);\n        }\n        K = read();\n    }\n    \n    int save[Maxk];\n    \n    inline void Calc ()\n    {\n    //  priority_queue <node> Q;\n        Q.clear();\n        for (int i = 1; i <= tmp[0]; ++i)\n            Q.push((node){Ans[1] + tmp[i], 1, i});\n        save[0] = 0;\n        while (save[0] < K && !Q.empty())\n        {\n            node x = Q.top(); Q.pop();\n            save[++save[0]] = x.val;\n            if (x.pos1 + 1 <= Ans[0])\n                Q.push((node){Ans[x.pos1 + 1] + tmp[x.pos2], x.pos1 + 1, x.pos2});\n        }\n        for (int i = 0; i <= save[0]; ++i)\n            Ans[i] = save[i];\n    }\n    \n    inline void tarjan (int x, int fa)\n    {\n        dfn[x] = low[x] = ++Index;\n        for (int i = Begin[x]; i; i = Next[i])\n        {\n            int y = To[i];\n            if (y == fa) continue;\n            if (!dfn[y])\n            {\n                S.push(i);\n                tarjan(y, x);\n                low[x] = min(low[x], low[y]);\n                if (low[y] >= dfn[x])\n                {\n                    tmp[0] = 0;\n                    while (1)\n                    {\n                        int a = S.top(); S.pop();\n                        tmp[++tmp[0]] = W[a];\n                        if (a == i) break;\n                    }\n                    if (tmp[0] > 1) Calc();\n                }\n            }\n            else if (dfn[y] < dfn[x])\n                S.push(i), low[x] = min(low[x], dfn[y]);\n        }\n    }\n    \n    int tot;\n    inline void Solve ()\n    {\n        Ans[++Ans[0]] = 0;\n        tarjan(1, -1);\n        unsigned ans = 0;\n        for (int i = 1; i <= Ans[0]; ++i)\n            ans += i * (Sum - Ans[i]);\n        printf(\"Case #%d: %u\\n\", ++tot, ans);\n    }\n    \n    int main()\n    {\n    #ifdef hk_cnyali\n        freopen(\"A.in\", \"r\", stdin);\n        freopen(\"A.out\", \"w\", stdout);\n    #endif\n        while (~scanf(\"%d%d\", &N, &M))\n        {\n            Init();\n            Input();\n            Solve();\n        }\n        return 0;\n    }\n```\n","categories":["Problem"],"tags":["tarjan","数据结构","堆"]},{"title":"「Hdu4757」 Tree - 可持久化01Trie","url":"/2018/03/13/Hdu4757-Tree-%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%9601Trie/","content":"\n题目链接：[传送门](http://acm.hdu.edu.cn/showproblem.php?pid=4757)\n\n### Description\n\n给定一棵树，每个节点有权值，每次查询节点 (u,v) 以及 x ，问 u 到 v 路径上的某个节点与 x 异或最大的值是多少。\n<!--more-->\n\n### Solution\n\n首先可以将树上问题转化到序列上做。如果不是查询区间的话，我们可以直接使用01Trie来做，如果需要查询区间的话，自然就想到将它可持久化。我们在从根开始dfs时，建出可持久化01Trie，对于一个询问（u,v），我们只要求出(u, Lca)和(v, Lca)的答案再取max即可\n\n### Code\n```cpp\n    #include <bits/stdc++.h>\n    \n    using namespace std;\n    \n    const int Maxn = 1e5 + 10, Maxm = 20;\n    \n    int N, M;\n    int e, Begin[Maxn], To[Maxn * 2], Next[Maxn * 2];\n    int Root[Maxn], Deep[Maxn];\n    int A[Maxn], anc[Maxn][21];\n    \n    namespace DS\n    {\n        int Son[Maxn * 20][2], Sum[Maxn * 20];\n        int cnt;\n    \n        inline void insert (int &now, int pre, int w)\n        {\n            now = ++cnt;\n            int now1 = now, now2 = pre;\n            for (int i = 17; i >= 0; --i)\n            {\n                int x = w >> i & 1;\n                Son[now1][x] = ++cnt;\n                Son[now1][x ^ 1] = Son[now2][x ^ 1];\n                if (!Son[now2][x])\n                    Sum[Son[now1][x]] = 1;\n                else \n                    Sum[Son[now1][x]] = Sum[Son[now2][x]] + 1;\n                now1 = Son[now1][x], now2 = Son[now2][x];\n            }\n        }\n    \n        inline int query (int now, int pre, int w)\n        {\n            int now1 = now, now2 = pre;\n            int ans = 0;\n            for (int i = 17; i >= 0; --i)\n            {\n                int x = w >> i & 1;\n                //cout<<x<<endl;\n                //cout<<now1<<\" \"<<now2<<\" \"<<Son[now1][x ^ 1]<<\" \"<<Son[now1][x]<<\" \"<<Sum[Son[now1][x ^ 1]]<<\" \"<<Sum[Son[now1][x]]<<endl;\n                if ((Sum[Son[now1][x ^ 1]] - Sum[Son[now2][x ^ 1]]) > 0)\n                {\n                    ans += (1 << i);\n                    now1 = Son[now1][x ^ 1];\n                    now2 = Son[now2][x ^ 1];\n                }\n                else \n                {\n                    now1 = Son[now1][x];\n                    now2 = Son[now2][x];\n                }\n            }\n            return ans;\n        }\n    }\n    \n    inline void Init ()\n    {\n        e = 0;\n        memset(Begin, 0, sizeof Begin);\n        memset(DS :: Sum, 0, sizeof DS :: Sum);\n        memset(DS :: Son, 0, sizeof DS :: Son);\n        DS :: cnt = 0;\n    }\n    \n    inline void add_edge (int x, int y)\n    {\n        To[++e] = y;\n        Next[e] = Begin[x];\n        Begin[x] = e;\n    }\n    \n    inline void dfs (int x, int fa)\n    {\n        DS :: insert(Root[x], Root[fa], A[x]);\n        anc[x][0] = fa;\n        Deep[x] = Deep[fa] + 1;\n        for (int i = 1; i <= 20; ++i) anc[x][i] = anc[anc[x][i - 1]][i - 1];\n        for (int i = Begin[x]; i; i = Next[i])\n        {\n            int y = To[i];\n            if (y == fa) continue;\n            dfs(y, x);\n        }\n    }\n    \n    inline int Lca (int x, int y)\n    {\n        if (Deep[x] < Deep[y]) swap(x, y);\n        for (int i = 20; i >= 0; --i)\n            if (Deep[anc[x][i]] >= Deep[y])\n                x = anc[x][i];\n        if (x == y) return x;\n        for (int i = 20; i >= 0; --i)\n            if (anc[x][i] != anc[y][i])\n                x = anc[x][i], y = anc[y][i];\n        return anc[x][0];\n    }\n    \n    inline int Query (int x, int y, int z)\n    {\n        int LCA = Lca(x, y);\n        return max(DS :: query (Root[x], Root[anc[LCA][0]], z), DS :: query (Root[y], Root[anc[LCA][0]], z));\n    }\n    \n    int main()\n    {\n    #ifdef hk_cnyali\n        freopen(\"A.in\", \"r\", stdin);\n        freopen(\"A.out\", \"w\", stdout);\n    #endif\n        while (~scanf(\"%d%d\", &N, &M))\n        {\n            Init();\n            for (int i = 1; i <= N; ++i)\n                scanf(\"%d\", &A[i]);\n            for (int i = 1; i < N; ++i)\n            {\n                int x, y;\n                scanf(\"%d%d\", &x, &y);\n                add_edge (x, y);\n                add_edge (y, x);\n            }\n            //Root[0] = ++DS :: cnt;\n            //DS :: init(Root[0], 0);\n            dfs(1, 0);\n            while (M--)\n            {\n                int x, y, z;\n                scanf(\"%d%d%d\", &x, &y, &z);\n                printf(\"%d\\n\", Query (x, y, z));\n            }\n        }\n        return 0;\n    }\n```\n","categories":["Problem"],"tags":["数据结构","01Trie","Trie","LCA","可持久化"]},{"title":"「Hdu5923」Prediction - 并查集","url":"/2018/03/13/Hdu5923-Prediction-%E5%B9%B6%E6%9F%A5%E9%9B%86/","content":"\n题目链接:[传送门](http://acm.hdu.edu.cn/showproblem.php?pid=5923)\n\n### Description\n\n分别给你一个有根树还有一个图，有根树得每个节点代表图的一条边。每次询问给你一个集合，把集合里所有的点以及所有点的祖先节点代表得边连起来。问连接后的图中连通块的个数\n<!--more-->\n\n### Solution\n\n我们考虑每个点建一个并查集，在从根dfs时维护从它到根所有点都选中时原图的状况，查询时暴力合并这些并查集即可。\n\n### Code\n```cpp\n    #include <bits/stdc++.h>\n    \n    using namespace std;\n    \n    const int Maxn = 500 + 10, Maxm = 10000 + 10;\n    \n    int fa[Maxm][Maxn];\n    int e, Begin[Maxm], Next[Maxm * 2], To[Maxm * 2];\n    int N, M, Q;\n    \n    struct node\n    {\n        int x, y;\n    }A[Maxm];\n    \n    inline void Init ()\n    {\n        e = 0;\n        memset(Begin, 0, sizeof Begin);\n        memset(fa, 0, sizeof fa);\n    }\n    \n    inline void add_edge (int x, int y)\n    {\n        To[++e] = y;\n        Next[e] = Begin[x];\n        Begin[x] = e;\n    }\n    \n    inline int find (int *f, int x)\n    {\n        return x == f[x] ? x : f[x] = find(f, f[x]);\n    }\n    \n    inline void Link (int *f, int x, int y)\n    {\n        int fx = find(f, x);\n        int fy = find(f, y);\n        if (fx == fy) return ;\n        f[fy] = fx;\n    }\n    \n    inline void dfs (int x, int f)\n    {\n        for (int i = 1; i <= N; ++i) fa[x][i] = fa[f][i];\n        Link (fa[x], A[x].x, A[x].y);\n        for (int i = Begin[x]; i; i = Next[i])\n        {\n            int y = To[i];\n            if (y == f) continue;\n            dfs(y, x);\n        }\n    }\n    \n    int Vis[Maxm];\n    int tot;\n    \n    inline void Solve()\n    {\n        scanf(\"%d%d\", &N, &M);\n        for (int i = 2; i <= M; ++i)\n        {\n            int x;\n            scanf(\"%d\", &x);\n            add_edge (x, i);\n            add_edge (i, x);\n        }\n        for (int i = 1; i <= M; ++i)\n            scanf(\"%d%d\", &A[i].x, &A[i].y);\n        for (int i = 1 ; i <= N; ++i) fa[0][i] = i;\n        dfs(1, 0);\n        scanf(\"%d\", &Q);\n        printf(\"Case #%d:\\n\", ++tot);\n        while (Q--)\n        {\n            int x;\n            scanf(\"%d\", &x);\n            for (int i = 1; i <= N; ++i) Vis[i] = i;\n            while (x--)\n            {\n                int k;\n                scanf(\"%d\", &k);\n                for (int i = 1; i <= N; ++i)\n                    Link(Vis, i, find(fa[k], i));\n            }\n            int Ans = 0;\n            for (int i = 1; i <= N; ++i) if (Vis[i] == i) ++Ans;\n            cout<<Ans<<endl;\n        }\n    }\n    \n    int main()\n    {\n    #ifdef hk_cnyali\n        freopen(\"A.in\", \"r\", stdin);\n        freopen(\"A.out\", \"w\", stdout);\n    #endif\n        int T;\n        scanf(\"%d\", &T);\n        while (T--)\n        {\n            Init();\n            Solve();\n        }\n        return 0;\n    }\n```\n","categories":["Problem"],"tags":["数据结构","并查集"]},{"title":"「Hdu2475」Box - Splay","url":"/2018/03/13/Hdu2475-Box-Splay/","content":"\n题目链接：[传送门](http://acm.hdu.edu.cn/showproblem.php?pid=2475)\n\n### Description\n\n有一些盒子，盒子里可以放盒子，给出最初的盒子的状态，有两种操作，第一种是将某一个盒子移动到另一个盒子（如果操作不合法就直接忽略），第二种是查询某个盒子最外边的盒子的编号。\n<!--more-->\n\n### Solution\n\n考虑先dfs一遍,第一次访问时在dfs序中新加一个x，子树访问完后再加一个x + N。\n那么$\\[x, x + N\\]$即为盒内的状况。\n我们考虑用Splay维护它，如果需要移动的话，直接将这个区间移动到目标位置后面即可，查询就直接查询最左端的点即可\n\n### Code\n```cpp\n    #include <bits/stdc++.h>\n    \n    using namespace std;\n    \n    const int Maxn = 5e5 + 10;\n    \n    int N, M;\n    int e, Begin[Maxn], To[Maxn * 2], Next[Maxn * 2];\n    int Index, dfn[Maxn];\n    int f[Maxn], cnt, root;\n    \n    struct tree\n    {\n        int ch[2], fa;\n    };\n    \n    namespace Splay\n    {\n        tree Tree[Maxn];\n    \n        inline int judge_dir (int x)\n        {\n            return Tree[Tree[x].fa].ch[1] == x;\n        }\n    \n        inline void Connect (int x, int f, int dir)\n        {\n            Tree[x].fa = f;\n            Tree[f].ch[dir] = x;\n        }\n    \n        inline void Rotate (int x)\n        {\n            int f = Tree[x].fa; \n            int dirx = judge_dir(x);\n            int anc = Tree[f].fa;\n            int dirf = judge_dir(f);\n            Connect(Tree[x].ch[dirx ^ 1], f, dirx);\n            Connect(f, x, (dirx ^ 1));\n            Connect(x, anc, dirf);\n        }\n    \n        inline void splay (int x, int y)\n        {\n            while (Tree[x].fa != y)\n            {\n                int f = Tree[x].fa;\n                int dirx = judge_dir(x), dirf = judge_dir(f);\n                if (Tree[f].fa == y) Rotate(x);\n                else if (dirx == dirf) Rotate(f), Rotate(x);\n                else Rotate(x), Rotate(x);\n            }\n        }\n    \n        inline void build (int &x, int l, int r, int fa)\n        {\n            if (l > r) return ;\n            int mid = (l + r) >> 1;\n            x = dfn[mid];\n            Tree[x].ch[0] = Tree[x].ch[1] = 0;\n            Tree[x].fa = fa;\n            build (Tree[x].ch[0], l, mid - 1, x);\n            build (Tree[x].ch[1], mid + 1, r, x);\n        }\n    \n        inline int query (int x)\n        {\n            splay(x, 0);\n            while (Tree[x].ch[0]) x = Tree[x].ch[0];\n            return x;\n        }\n    \n        inline void move (int x, int y)\n        {\n            if (x == y) return ;\n            splay (x, 0), splay (x + N, x);\n            int tmp = y;\n            while (tmp)\n            {\n                if (Tree[x + N].ch[0] == tmp) return ;\n                tmp = Tree[tmp].fa;\n            }\n    \n            int a = Tree[x].ch[0], b = Tree[x + N].ch[1];\n            Tree[x].ch[0] = Tree[x + N].ch[1] = Tree[a].fa = Tree[b].fa = 0;\n            if (a && b)\n            {\n                while (Tree[b].ch[0]) b = Tree[b].ch[0];\n                Tree[b].ch[0] = a;\n                Tree[a].fa = b;\n            }\n            if (!y) return ;\n            splay (y, 0);\n            int now = Tree[y].ch[1];\n            while (Tree[now].ch[0]) now = Tree[now].ch[0];\n            splay (now, y);\n            Tree[now].ch[0] = x;\n            Tree[x].fa = now;\n        }\n    }\n    \n    inline void Init ()\n    {\n        e = Index = root = 0;\n        memset(Begin, 0, sizeof Begin);\n        memset(f, 0, sizeof f);\n        memset(Splay :: Tree, 0, sizeof Splay :: Tree);\n    }\n    \n    inline void add_edge (int x, int y)\n    {\n        To[++e] = y;\n        Next[e] = Begin[x];\n        Begin[x] = e;\n    }\n    \n    inline void dfs (int x)\n    {\n        dfn[++cnt] = x;\n        for (int i = Begin[x]; i; i = Next[i])\n            dfs(To[i]);\n        dfn[++cnt] = x + N;\n    }\n    \n    int main()\n    {\n    #ifdef hk_cnyali\n        freopen(\"A.in\", \"r\", stdin);\n        freopen(\"A.out\", \"w\", stdout);\n    #endif\n        int fl = 0;\n        while (~scanf(\"%d\", &N))\n        {\n            if (fl) cout<<endl;\n            else fl = 1;\n            Init();\n            for (int i = 1; i <= N; ++i)\n            {\n                int x;\n                scanf(\"%d\", &x);\n                if (x)\n                    add_edge(x, i);\n                else f[i] = 1;\n            }\n            for (int i = 1; i <= N; ++i)\n            {\n                if (!f[i]) continue;\n                cnt = 0;\n                dfs(i);\n                Splay :: build (root, 1, cnt, 0);\n            }\n            scanf(\"%d\", &M);\n    \n            while (M--)\n            {\n                int x, y;\n                char s[10];\n                scanf(\"%s\", s);\n                if (s[0] == 'M')\n                {\n                    scanf(\"%d%d\", &x, &y);\n                    Splay :: move (x, y);\n                }\n                else \n                {\n                    scanf(\"%d\", &x);\n                    printf(\"%d\\n\", Splay :: query (x)), fflush(stdout);\n                }\n            }\n        }\n        return 0;\n    }\n```\n","categories":["Problem"],"tags":["数据结构","平衡树","Splay"]},{"title":"Codeforces Round #470 (Div. 2) Summary","url":"/2018/03/12/Codeforces-Round-470-Div-2-Summary/","content":"\n比赛链接：[传送门](http://codeforces.com/contest/948)\n\nSummary\n-------\n\n终于又上蓝了，这一场的题目都比较简单，最后两题还是有可能A掉的，不过比赛的时候基本没看最后两题。感觉第三题比第二题简单一点点。。。\n<!--more-->\n\nProblems\n--------\n\n### B Primal Sport\n\n先$\\sqrt N$去枚举可能的范围，再求个最小值即可 其实就是直接暴力搞\n\n#### Code\n```cpp\n    #include <bits/stdc++.h>\n    \n    using namespace std;\n    \n    const int Maxn = 1e6 + 10;\n    \n    int A[Maxn], Max[Maxn];\n    int N, Prime[Maxn], Vis[Maxn];\n    \n    int main()\n    {\n    #ifdef hk_cnyali\n        freopen(\"B.in\", \"r\", stdin);\n        freopen(\"B.out\", \"w\", stdout);\n    #endif\n        scanf(\"%d\", &N);\n        int Cnt = 0;\n        Vis[1] = 1;\n        for (int i = 2; i <= N; ++i)\n        {\n            if (!Vis[i]) Prime[++Cnt] = i;\n            for (int j = 1; j <= Cnt && i * Prime[j] <= N; ++j)\n            {\n                Vis[i * Prime[j]] = 1;\n                if (!(i % Prime[j])) break;\n            }\n        }\n    \n        int tot = 0;\n        for (int i = 1; i <= Cnt; ++i)\n            if (!(N % Prime[i])) A[++tot] = Prime[i];\n        for (int i = 1; i <= Cnt; ++i)\n            for (int j = 1; j * Prime[i] <= N; ++j)\n                Max[j * Prime[i]] = Prime[i];\n        int Ans = N;\n    \n        for (int i = 1; i <= tot; ++i)\n        {\n            int now = N - A[i] + 1;\n            if (now < 3) continue;\n            if (Vis[now]) Ans = min(Ans, now);\n            for (int j = max(now, A[i] + 1); j <= N; ++j)\n            {\n                int x = j - Max[j] + 1;\n                if (x <= Max[j]) x = Max[j] + 1;\n                if (x <= j && x >= 3)\n                    Ans = min(Ans, x);\n            }\n        }\n        cout<<Ans<<endl;\n        return 0;\n    }\n```\n\n### C Producing Snow\n\n用优先队列优化一下暴力就可以了\n\n#### Code\n```cpp\n    #include <bits/stdc++.h>\n    #define int long long\n    \n    using namespace std;\n    \n    const int Maxn = 1e5 + 10;\n    \n    int N, M;\n    \n    int A[Maxn], B[Maxn];\n    \n    priority_queue <int, vector <int>, greater<int> > Q;\n    //priority_queue <int> Q;\n    \n    main()\n    {\n    #ifdef hk_cnyali\n        freopen(\"C.in\", \"r\", stdin);\n        freopen(\"C.out\", \"w\", stdout);\n    #endif\n        scanf(\"%lld\", &N);\n        int sum = 0;\n        for (int i = 1; i <= N; ++i) scanf(\"%lld\", &A[i]);\n        for (int i = 1; i <= N; ++i) scanf(\"%lld\", &B[i]);\n        for (int i = 1; i <= N; ++i)\n        {\n            int Ans = 0;\n            Q.push(A[i] + sum);\n            sum += B[i];\n            while (!Q.empty())\n            {\n                int x = Q.top();\n                //cout<<x<<endl;\n                if (x >= sum)\n                    break;\n                Ans += (x - sum + B[i]);\n                Q.pop();\n            }\n            Ans += Q.size() * B[i];\n            cout<<Ans<<\" \";\n        }\n        return 0;\n    }\n```\n\n\n### D Perfect Security\n\n考虑贪心，建一棵01Trie，存在和当前位相同的就往下走，否则走另一边，更新答案\n\n#### Code\n```cpp\n    #include <bits/stdc++.h>\n    \n    using namespace std;\n    \n    const int Maxn = 3e5 + 10;\n    \n    int N;\n    int A[Maxn];\n    \n    namespace Trie\n    {\n        int son[Maxn * 30][2], Cnt[Maxn * 30];\n        int root = 1, cnt = 1;\n    \n        inline void insert (int x)\n        {\n            int now = root;\n            Cnt[root] ++;\n            for (int i = 29; i >= 0; --i)\n            {\n                int p = (x >> i) & 1;\n                if (!son[now][p]) son[now][p] = ++cnt;\n                now = son[now][p];\n                Cnt[now]++;\n            }\n        }\n    \n        inline int query (int x)\n        {\n            int now = root;\n            int ans = 0;\n            for (int i = 29; i >= 0; --i)\n            {\n                int p = (x >> i) & 1;\n                if (!son[now][p] || !Cnt[son[now][p]]) ans += (1 << i), now = son[now][p ^ 1];\n                else now = son[now][p], Cnt[now]--;\n            }\n            return ans;\n        }\n    }\n    \n    int main()\n    {\n    #ifdef hk_cnyali\n        freopen(\"D.in\", \"r\", stdin);\n        freopen(\"D.out\", \"w\", stdout);\n    #endif\n        scanf(\"%d\", &N);\n        for (int i = 1; i <= N; ++i) scanf(\"%d\", &A[i]);\n        for (int i = 1; i <= N; ++i)\n        {\n            int x;\n            scanf(\"%d\", &x);\n            Trie :: insert(x);\n        }\n        for (int i = 1; i <= N; ++i)\n            printf(\"%d \", Trie :: query (A[i]));\n        return 0;\n    }\n```\n","categories":["Summary"],"tags":["Codeforces","贪心","暴力","01Trie","Trie","优先队列"]},{"title":"分治【序列分治、树分治、整体二分、CDQ分治，莫队，树上莫队】 Summary","url":"/2018/03/12/%E5%88%86%E6%B2%BB%E3%80%90%E5%BA%8F%E5%88%97%E5%88%86%E6%B2%BB%E3%80%81%E6%A0%91%E5%88%86%E6%B2%BB%E3%80%81%E6%95%B4%E4%BD%93%E4%BA%8C%E5%88%86%E3%80%81CDQ%E5%88%86%E6%B2%BB%EF%BC%8C%E8%8E%AB%E9%98%9F%EF%BC%8C%E6%A0%91%E4%B8%8A%E8%8E%AB%E9%98%9F%E3%80%91-Summary/","content":"\n知识点总结\n-----\n\n[点分治1](https://www.cnblogs.com/Sakits/p/8328707.html) [点分治2](https://www.cnblogs.com/zhoushuyu/p/8137645.html) [整体二分](http://blog.csdn.net/ab_ever/article/details/77019020) [CDQ分治](https://www.cnblogs.com/muzu/p/7899098.html)\n\n<!--more-->\nProblems\n--------\n\n### Hdu5696 区间的价值\n\n_[Hdu5696 区间的价值(序列分治)](http://hk-cnyali.com/2018/03/07/hdu5696-%E5%8C%BA%E9%97%B4%E7%9A%84%E4%BB%B7%E5%80%BC%E5%BA%8F%E5%88%97%E5%88%86%E6%B2%BB/)_\n\n### Hdu5977 Garden of Eden\n\n_[Hdu 5977 Garden of Eden（点分治）](http://hk-cnyali.com/2018/03/07/hdu5977-garden-of-eden%EF%BC%88%E7%82%B9%E5%88%86%E6%B2%BB%EF%BC%89/)_\n\n### Hdu5016 Mark Master II\n\n_[Hdu5016 Mart Master II(点分治)](http://hk-cnyali.com/2018/03/09/hdu5016-mart-master-ii%E7%82%B9%E5%88%86%E6%B2%BB/)_\n\n### Hdu5412 CRB and Queries\n\n_[Hdu5412 CRB and Queries（整体二分）](http://hk-cnyali.com/2018/03/09/hdu5412-crb-and-queries%EF%BC%88%E6%95%B4%E4%BD%93%E4%BA%8C%E5%88%86%EF%BC%89/)_\n\n### Hdu6135 Casual Podracing\n\n_[Hdu6135 Casual Podracing（CDQ分治）](http://hk-cnyali.com/2018/03/12/hdu6135-casual-podracing%EF%BC%88cdq%E5%88%86%E6%B2%BB%EF%BC%89/)_\n\n### Hdu5213 Lucky\n\n_[Hdu5213 Lucky（莫队+容斥）](http://hk-cnyali.com/2018/03/09/hdu5213-lucky%EF%BC%88%E8%8E%AB%E9%98%9F%E5%AE%B9%E6%96%A5%EF%BC%89/)_\n\n### Hdu5799 This World need more Zhu\n\n_TODO_\n","categories":["Summary"],"tags":["Summary","莫队","分治","CDQ分治","点分治","整体二分"]},{"title":"「Hdu6135」Casual Podracing - CDQ分治","url":"/2018/03/12/Hdu6135-Casual-Podracing%EF%BC%88CDQ%E5%88%86%E6%B2%BB%EF%BC%89/","content":"\n题目链接：[传送门](http://acm.hdu.edu.cn/showproblem.php?pid=6135)\n\n### Description\n\n一个长度为L的圈，有n个人在上面跑，每个人的起始位置为di，速度为vi，且起始位置和速度均不相同，每个人有力量值wi，如果一个人遇到力量值比自己大的，则这个人会被标记，直到不会有人再被标记时将会停止，问这个过程总共花费多少时间\n<!--more-->\n\n### Solution\n\nCDQ分治 设2个人的起始位置为d1和d2，d1 < d2，设时间为t，如果这2个人相遇，则一定会有$d1 + t \\* v1 \\\\geq t2 + t \\* v2$或$d1 + t \\* v1 \\\\leq t2 + t \\* v2 - L$ 因此可以二分时间，记录时间t下每个人跑的距离dis\\[i\\]，按照起始位置从小到大排序，分治时按照力量值w从大到小排序，归并时记录左右两边$d + t \\* v$的最小值L1,L2和最大值R1,R2。对于左分治区间\\[l,m\\]的每个人，如果$dis\\[i\\] \\\\geq L2$或$dis\\[i\\] \\\\leq R2 - L$则将它标记；对于右分治区间$\\[m+1, r\\]$的每个人，如果$dis\\[j\\] \\\\geq L1 + L$或$dis\\[j\\] \\\\leq R1$则将它标记；如果存在人的力量值不是最大的且这个人没有被标记，则返回false，并记录他为最后一个要被标记的人last\n\n### Code\n```cpp\n    #include <bits/stdc++.h>\n    #define LL long long\n    \n    using namespace std;\n    \n    const int Maxn = 1e6 + 10;\n    const double inf = DBL_MAX, eps = 1e-14;\n    \n    int N, L;\n    struct node\n    {\n        int d, v, w, id;\n        double dis;\n    }A[Maxn], p[Maxn], tmp[Maxn];\n    \n    inline int cmp (node a, node b)\n    {\n        return a.d < b.d;\n    }\n    \n    int Max, last, Vis[Maxn];\n    \n    inline void Solve (int l, int r)\n    {\n        if (l >= r) return ;\n        int mid = (l + r) >> 1;\n        Solve (l, mid);\n        Solve (mid + 1, r);\n        int p1 = l, p2 = mid + 1, p3 = l;\n        double L1 = inf, L2 = inf, R1 = -inf, R2 = -inf;\n        double TL1 = inf, TL2 = inf, TR1 = -inf, TR2 = -inf;\n        while (p1 <= mid || p2 <= r)\n        {\n            if (p2 > r || (p1 <= mid && p[p1].w > p[p2].w))\n            {\n                if (p3 > l && tmp[p3 - 1].w > p[p1].w)\n                    L1 = TL1, R1 = TR1, L2 = TL2, R2 = TR2;\n                if (L2 <= p[p1].dis || R2 - L >= p[p1].dis)\n                    Vis[p[p1].id] = 1;\n                TL1 = min(TL1, p[p1].dis);\n                TR1 = max(TR1, p[p1].dis);\n                tmp[p3++] = p[p1++];\n            }\n            else \n            {\n                if (p3 > l && tmp[p3 - 1].w > p[p2].w)\n                    L1 = TL1, R1 = TR1, L2 = TL2, R2 = TR2;\n                if (L1 + L <= p[p2].dis || R1 >= p[p2].dis)\n                    Vis[p[p2].id] = 1;  \n                TL2 = min(TL2, p[p2].dis);\n                TR2 = max(TR2, p[p2].dis);\n                tmp[p3++] = p[p2++];\n            }\n        }\n        for (int i = l; i <= r; ++i)\n            p[i] = tmp[i];\n    }\n    \n    inline int Check (double x)\n    {\n        for (int i = 1; i <= N; ++i)\n        {\n            p[i] = A[i], Vis[i] = 0;\n            p[i].dis = p[i].d + x * p[i].v;\n        }\n        Solve (1, N);\n        for (int i = 1; i <= N; ++i)\n            if (!Vis[i] && A[i].w != Max)\n            {\n                last = i;\n                return 0;\n            }\n        return 1;\n    }\n    \n    inline void update (node a, node b, int &ans1, int &ans2)\n    {\n        if (a.v < b.v) swap(a, b);\n        LL x = a.v - b.v, y;\n        if (a.d < b.d) y = b.d - a.d;\n        else y = L - a.d + b.d;\n        if (y * ans1 <= x * ans2) ans1 = x, ans2 = y;\n    }\n    \n    int main()\n    {\n    #ifdef hk_cnyali\n        freopen(\"A.in\", \"r\", stdin);\n        freopen(\"A.out\", \"w\", stdout);\n    #endif\n        int T;\n        scanf(\"%d\", &T);\n    \n        while (T--)\n        {\n            scanf(\"%d%d\", &N, &L);\n            for (int i = 1; i <= N; ++i) scanf(\"%d\", &A[i].d);\n            for (int i = 1; i <= N; ++i) scanf(\"%d\", &A[i].v);\n            for (int i = 1; i <= N; ++i) scanf(\"%d\", &A[i].w);\n            sort(A + 1, A + N + 1, cmp);\n            for (int i = 1; i <= N; ++i) A[i].id = i;\n    \n            Max = 0;\n            for (int i = 1; i<= N; ++i)\n                Max = max(Max, A[i].w);\n    \n            double l = 0, r = L;\n            last = 0;\n    \n            while (l + eps < r)\n            {\n                double mid = (l + r) / 2;\n                if (Check (mid)) r = mid;\n                else l = mid;\n            }\n            if (!last)\n            {\n                cout<<0<<endl;\n                return 0;\n            }\n            int ans1 = 0, ans2 = 0;\n            for (int i = 1; i <= N; ++i)\n                if (A[i].w > A[last].w)\n                    update(A[i], A[last], ans1, ans2);\n            cout<<ans2 / __gcd(ans1, ans2)<<\"/\"<<ans1 / __gcd(ans1, ans2)<<endl;\n        }\n        return 0;\n    }\n```\n","categories":["Problem"],"tags":["二分","CDQ分治"]},{"title":"Codeforces Round #469 (Div. 2) Summary","url":"/2018/03/10/Codeforces-Round-469-Div-2-Summary/","content":"\n比赛链接：[传送门](http://codeforces.com/contest/950)\n\nSummary\n-------\n\n懒得吐槽学而思和CF的网络问题了，除了D题差一点点调出来之外，没有FST也没有掉分还是感到非常庆幸的 反正这场比赛是各种不顺，希望下一场能打的好一点\n<!--more-->\n\nProblems\n--------\n\n### C. Zebras\n\n#### Description\n\n定义一个01串为斑马：以0开头，01交替出现并以0结尾 问能否将给定的01串分成若干个斑马，并输出方案\n\n#### Solution\n\n考虑贪心，开两个栈（或者队列也行），分别储存0和1。\n如果当前元素为0，且1的栈不为空，则取出1栈栈顶元素；\n如果当前元素为1，且0的栈不为空，则取出0栈的栈顶元素，如果0的栈为空，则无解。\n最后再判一下1栈是否是空的即可\n\n#### Code\n```cpp\n    #include <bits/stdc++.h>\n    \n    using namespace std;\n    \n    const int Maxn = 200000 + 10;\n    \n    char S[Maxn];\n    \n    int Next[Maxn];\n    int N;\n    \n    struct node\n    {\n        int x, y;\n    };\n    \n    stack <node> S1, S2;\n    int Vis[Maxn];\n    \n    int main()\n    {\n    #ifdef hk_cnyali\n        freopen(\"C.in\", \"r\", stdin);\n        freopen(\"C.out\", \"w\", stdout);\n    #endif\n    \n        scanf(\"%s\", S + 1);\n        N = strlen(S + 1);\n        for (int i = 1; i <= N; ++i)\n        {\n            int x = S[i] - '0';\n            if (!x)\n            {\n                S1.push((node){x, i});\n                if (S2.empty()) continue;\n                int tmp = S2.top().y;\n                S2.pop();\n                Next[tmp] = i;\n            }\n            else \n            {\n                if (S1.empty())\n                {\n                    cout<<-1<<endl;\n                    return 0;\n                }\n                S2.push((node){x, i});\n                int tmp = S1.top().y;\n                S1.pop();\n                Next[tmp] = i;\n            }\n        }\n    \n        if (!S2.empty())\n        {\n            cout<<-1<<endl;\n            return 0;\n        }\n    \n        int Ans = 0;\n        for (int i = 1; i <= N; ++i)\n        {\n            if (Vis[i]) continue;\n            ++Ans;\n            int cnt = 0, tmp = i;\n            while (tmp)\n            {\n                Vis[tmp] = 1;\n                tmp = Next[tmp];\n            }\n        }\n        cout<<Ans<<endl;\n    \n        memset (Vis, 0, sizeof (Vis));\n        for (int i = 1; i <= N; ++i)\n        {\n            if (Vis[i]) continue;\n            int cnt = 0, tmp = i;\n            while (tmp)\n                cnt ++, tmp = Next[tmp];\n            cout<<cnt<<\" \";\n            tmp = i;\n            while (tmp)\n            {\n                cout<<tmp<<\" \";\n                Vis[tmp] = 1;\n                tmp = Next[tmp];\n            }\n            cout<<endl;\n        }\n        return 0;\n    }\n```\n\n### D. A Leapfrog in the Array\n\n#### Description\n\n懒得说了\n\n#### Solution\n\n通过模拟打表找规律我们可以发现奇数位上的数都不会动，\n偶数位上的数如果往前还原一步的话就能发现它们是连续的，并且依旧是保持着奇数为不动，偶数位继续向前还原的规律 \n然后就能通过不断递归求出答案\n\n#### Code\n```cpp\n    #include <bits/stdc++.h>\n    #define int long long\n    \n    using namespace std;\n    \n    int N, M;\n    \n    inline int Solve (int len, int x, int pos)\n    {\n        if ((len + pos) == 2 * (N - 1)) return 2 * N - 1;\n        if ((len + pos) & 1) return len + pos;\n        //if (!(len & 1)) return Solve (len + x, x / 2, pos / 2);\n        //return Solve (len + x, x / 2, pos / 2 + 1);\n        if (!(len & 1))\n            return Solve (len + x, x / 2, pos / 2);\n        else \n        {\n            if (!(x & 1))\n                return Solve (len + x, x / 2, pos / 2 + 1);\n            else return Solve (len + x, x / 2 + 1, pos / 2 + 1);\n        }\n    }\n    \n    main()\n    {\n    #ifdef hk_cnyali\n        freopen(\"D.in\", \"r\", stdin);\n        freopen(\"D.out\", \"w\", stdout);\n    #endif\n        scanf(\"%lld%lld\", &N, &M);\n        for (int i = 1; i <= M; ++i)\n        {\n            int x;\n            scanf(\"%lld\", &x);\n            printf(\"%lld\\n\", (Solve(0, N, x) + 1) / 2);\n        }\n        return 0;\n    }\n```\n","categories":["Summary"],"tags":["Codeforces","Summary","贪心"]},{"title":"「Hdu5213」Lucky - 莫队 + 容斥","url":"/2018/03/09/Hdu5213-Lucky%EF%BC%88%E8%8E%AB%E9%98%9F-%E5%AE%B9%E6%96%A5%EF%BC%89/","content":"\n题目链接：[传送门](http://acm.hdu.edu.cn/showproblem.php?pid=5213)\n\n### Description\n\n给一个序列a，以及K，有Q个询问，每个询问四个数，L,R,U,V, 求L<=i<=R,U<=j<=V，a\\[i\\]+a\\[j\\]=K的(i, j)对数（题目保证了L <= R < U <= V）\n\n### Solution\n\n因为要求的答案满足区间的可加性，我们令f(l,r)表示 l到r这个区间满足条件的ans,\n令F(l1,r1,l2,r2)为在这两个区间内选取的数满足条件的ans，\n则根据容斥定理，F(l1,r1,l2,r2)=f(l1,r2)-f(r1+1,r2)-f(l1,l2-1)+f(r1+1,l2-1)。\n然后就是莫队的操作了。\n\n### Code\n```cpp\n    #include <bits/stdc++.h>\n    \n    using namespace std;\n    \n    const int Maxn = 300000 + 10;\n    \n    int N, M, K;\n    int S;\n    int A[Maxn];\n    \n    struct node\n    {\n        int l, r, fl, id;\n    }Q[Maxn << 2];\n    \n    inline int cmp (node x, node y)\n    {\n        if((x.l / S) == (y.l / S)) return x.r < y.r;\n        return x.l < y.l;\n    }\n    \n    int Sum, Cnt[Maxn], Ans[Maxn];\n    \n    inline void update (int x, int y)\n    {\n        if (K > A[x] && K - A[x] <= N)\n            Sum += Cnt[K - A[x]] * y;\n    }\n    \n    int main()\n    {\n    #ifdef hk_cnyali\n        freopen(\"A.in\", \"r\", stdin);\n        freopen(\"A.out\", \"w\", stdout);\n    #endif\n        while (scanf(\"%d%d\", &N, &K) != EOF)\n        {\n            S = sqrt(N);\n            memset(Cnt, 0, sizeof (Cnt));\n            memset(Ans, 0, sizeof (Ans));\n            for (int i = 1; i <= N; ++i)\n                scanf(\"%d\", &A[i]);\n            scanf(\"%d\", &M);\n            int cnt = 0;\n            for (int i = 1; i <= M; ++i)\n            {\n                int l1, l2, r1, r2;\n                scanf(\"%d%d%d%d\", &l1, &r1, &l2, &r2);\n                Q[++cnt].l = l1, Q[cnt].r = r2, Q[cnt].fl = 1, Q[cnt].id = i;\n                Q[++cnt].l = l1, Q[cnt].r = l2 - 1, Q[cnt].fl = -1, Q[cnt].id = i;\n                Q[++cnt].l = r1 + 1, Q[cnt].r = r2, Q[cnt].fl = -1, Q[cnt].id = i;\n                Q[++cnt].l = r1 + 1, Q[cnt].r = l2 - 1, Q[cnt].fl = 1, Q[cnt].id = i;\n            }\n    \n            sort(Q + 1, Q + cnt + 1, cmp);\n            int l = 1, r = 0;\n            Sum = 0;\n            for (int i = 1; i <= cnt; ++i)\n            {\n                while (r < Q[i].r)\n                    update(++r, 1), Cnt[A[r]] ++;\n                while (r > Q[i].r)\n                    Cnt[A[r]] --, update(r--, -1);\n                while (l < Q[i].l)\n                    Cnt[A[l]] --, update(l++, -1);\n                while (l > Q[i].l)\n                    update(--l, 1), Cnt[A[l]] ++;\n                Ans[Q[i].id] += Sum * Q[i].fl;\n            }\n    \n            for (int i = 1; i <= M; ++i)\n                printf(\"%d\\n\", Ans[i]);\n        }\n        return 0;\n    }\n```\n","categories":["Problem"],"tags":["容斥","莫队"]},{"title":"「Hdu5412」CRB and Queries - 整体二分","url":"/2018/03/09/Hdu5412-CRB-and-Queries%EF%BC%88%E6%95%B4%E4%BD%93%E4%BA%8C%E5%88%86%EF%BC%89/","content":"\n题目链接：[传送门](http://acm.hdu.edu.cn/showproblem.php?pid=5412)\n\n### Descrption\n\n动态区间第K大\n\n### Solution\n\n本来想写树状数组套主席树的，太难打就学了一发整体二分\n<!--more-->\n\n### Code\n```cpp\n    #include <bits/stdc++.h>\n    #define int long long\n    \n    using namespace std;\n    \n    const int Maxn = 1e5 + 100;\n    \n    int N, M, Q;\n    \n    int A[Maxn];\n    \n    struct node\n    {\n        int x, y, k, t, ans;\n    }opt[Maxn << 2];\n    \n    namespace BIT\n    {\n        int Sum[Maxn << 2];\n    \n        inline int lowbit (int x)\n        {\n            return x & (-x);\n        }\n    \n        inline void add (int x, int d)\n        {\n            while (x <= N)\n            {\n                Sum[x] += d;\n                x += lowbit(x);\n            }\n        }\n    \n        inline int query (int x)\n        {\n            int ans = 0;\n            while (x)\n            {\n                ans += Sum[x];\n                x -= lowbit(x);\n            }\n            return ans;\n        }\n    \n    }\n    \n    inline void Init()\n    {\n        memset(BIT :: Sum, 0, sizeof BIT :: Sum);\n        M = 0;\n    }\n    \n    int q[Maxn << 2], Left[Maxn << 2];\n    int q1[Maxn << 2], q2[Maxn << 2];\n    \n    inline void Solve (int l, int r, int head, int tail)\n    {\n        //cout<<l<<\" \"<<r<<\" \"<<head<<\" \"<<tail<<endl;\n        if (head > tail) return ;\n        if (l == r)\n        {\n            for (int i = head; i <= tail; ++i)\n            {\n                int x = q[i];\n                if (opt[x].t)\n                    opt[x].ans = l;\n            }\n            return ;\n        }\n    \n        int mid = (l + r) >> 1;\n        for (int i = head; i <= tail; ++i)\n        {\n            int x = q[i];\n            if (!opt[x].t && opt[x].y <= mid)\n            {\n                BIT :: add(opt[x].x, opt[x].k);\n                Left[i] = 1;\n            }\n            else if (opt[x].t)\n            {\n                int sum = BIT :: query(opt[x].y) - BIT :: query(opt[x].x - 1);\n                if (opt[x].k <= sum)\n                    Left[i] = 1;\n                else opt[x].k -= sum;\n            }\n        }\n    \n        for (int i = head; i <= tail; ++i)\n        {\n            int x = q[i];\n            if (!opt[x].t && Left[i])\n                BIT :: add(opt[x].x, -opt[x].k);\n        }\n    \n        int cnt1, cnt2;\n        cnt1 = cnt2 = 0;\n        for (int i = head; i <= tail; ++i)\n        {\n            if (Left[i]) q1[++cnt1] = q[i];\n            else q2[++cnt2] = q[i];\n            Left[i] = 0;\n        }\n        //cout<<head<<\" \"<<tail<<\" \"<<cnt1<<\" \"<<cnt2<<endl;\n        for (int i = head; i <= cnt1 + head - 1; ++i)\n            q[i] = q1[i - head + 1];\n        for (int i = cnt1 + head; i <= tail; ++i)\n            q[i] = q2[i - cnt1 - head + 1];\n    \n    //  cout<<l<<\" \"<<mid<<\" * \"<<head<<\" \"<<head + cnt1 - 1<<endl;\n    //  cout<<mid + 1<<\" \"<<r<<\" * \"<<head + cnt1<<\" \"<<tail<<endl;\n        Solve(l, mid, head, head + cnt1 - 1);\n        Solve(mid + 1, r, head + cnt1, tail);\n    }\n    \n    main()\n    {\n    #ifdef hk_cnyali\n        freopen(\"A.in\", \"r\", stdin);\n        freopen(\"A.out\", \"w\", stdout);\n    #endif\n        while (~scanf(\"%lld\", &N))\n        {\n            Init();\n            for (int i = 1; i <= N; ++i)\n            {\n                scanf(\"%lld\", &A[i]);\n                opt[++M] = {i, A[i], 1, 0, 0};\n            }\n            scanf(\"%lld\", &Q);\n            while (Q--)\n            {\n                int type, x, y, k;\n                scanf(\"%lld\", &type);\n                if (type == 1)\n                {\n                    scanf(\"%lld%lld\", &x, &y);\n                    opt[++M] = {x, A[x], -1, 0, 0};\n                    A[x] = y;\n                    opt[++M] = {x, A[x], 1, 0, 0};\n                }\n                else \n                {\n                    scanf(\"%lld%lld%lld\", &x, &y, &k);\n                    opt[++M] = {x, y, k, 1, 0};\n                }\n            }\n            for (int i = 1; i <= M; ++i) q[i] = i;\n            Solve(1, 1e9 + 1, 1, M);\n        //  cout<<\"fuck\"<<endl;\n            for (int i = 1; i <= M; ++i)\n                if (opt[i].t)\n                    printf(\"%lld\\n\", opt[i].ans);\n        }\n        return 0;\n    }\n    \n    // 注意： q[i]和i不要搞错\n```\n","categories":["Problem"],"tags":["二分","分治","整体二分"]},{"title":"「Hdu5016」 Mart Master II - 点分治","url":"/2018/03/09/Hdu5016-Mart-Master-II-%E7%82%B9%E5%88%86%E6%B2%BB/","content":"\n题目链接：[传送门](http://acm.hdu.edu.cn/showproblem.php?pid=5016 \"传送门\")\n\n### Description\n\n有n个城市，有些城市被设定成集市 ，每个城市只能到离他最近的并且编号最小的集市，现在如果再建一个集市，那么最多有多少个城市可以到这个集市\n<!--more-->\n\n### Solution\n\n先跑一遍SPFA最短路，求出每个城市到最近的集市的距离和编号，然后点分治。对于树上的节点u，v，如果 dis\\[u\\] + dis\\[v\\] < near\\[v\\]（dis表示节点到根的距离，near表示接地离最近集市的距离），那么如果在节点u建立集市，那么节点v肯定会到u，把式子变形，得到dis\\[u\\] < near\\[v\\] - dis\\[v\\];那么只需要二分就可以求出有多少个节点到达u\n\n### Code\n```cpp\n    #include <bits/stdc++.h>\n    \n    using namespace std;\n    \n    const int Maxn = 1e5 + 100, inf = INT_MAX;\n    \n    int N, M, K;\n    int Begin[Maxn], To[Maxn * 2], Next[Maxn * 2], W[Maxn * 2], e;\n    int Ans[Maxn], Vis[Maxn];\n    int type[Maxn];\n    \n    struct node\n    {\n        int x, y;\n        bool operator < (const node &a) const\n        {\n            if (x == a.x) return y < a.y;\n            return x < a.x;\n        }\n    }near[Maxn], q[Maxn];\n    \n    inline void Init()\n    {\n        e = 0;\n        memset(Begin, 0, sizeof Begin);\n        memset(Ans, 0, sizeof Ans);\n        memset(Vis, 0, sizeof Vis);\n    }\n    \n    inline void add_edge (int x, int y, int z)\n    {\n        To[++e] = y;\n        Next[e] = Begin[x];\n        Begin[x] = e;\n        W[e] = z;\n    }\n    \n    inline void SPFA ()\n    {\n        queue <int> Q;\n        memset(Vis, 0, sizeof Vis);\n        for (int i = 1; i <= N; ++i)\n            if (type[i])\n                Q.push(i), Vis[i] = 1, near[i] = {0, i};\n            else near[i] = {inf, 0};\n        while (!Q.empty())\n        {\n            int x = Q.front();\n            //cout<<x<<endl;\n            Q.pop();\n            Vis[x] = 0;\n            for (int i = Begin[x]; i; i = Next[i])\n            {\n                int y = To[i];\n                //cout<<y<<\" \";\n                if (near[y].x > near[x].x + W[i])\n                {\n                    near[y].x = near[x].x + W[i];\n                    near[y].y = near[x].y;\n                    if (!Vis[y])\n                    {\n                        Vis[y] = 1;\n                        Q.push(y);\n                    }\n                }\n            }\n            //cout<<endl;\n        }\n    }\n    \n    int pos, Min;\n    int size[Maxn];\n    \n    inline void dfs1 (int x, int fa)\n    {\n        size[x] = 1;\n        for (int i = Begin[x]; i; i = Next[i])\n        {\n            int y = To[i];\n            if (Vis[y] || y == fa) continue;\n            dfs1 (y, x);\n            size[x] += size[y];\n        }\n    }\n    \n    inline void dfs2 (int x, int fa, int Size)\n    {\n        int tmp = Size - size[x];\n        for (int i = Begin[x]; i; i = Next[i])\n        {\n            int y = To[i];\n            if (y == fa || Vis[y]) continue;\n            dfs2 (y, x, Size);\n            tmp = max(tmp, size[y]);\n        }\n        if (tmp < Min)\n        {\n            Min = tmp;\n            pos = x;\n        }\n    }\n    \n    int cnt;\n    int rec[Maxn], Dis[Maxn];\n    \n    inline void dfs (int x, int fa, int dis)\n    {\n        Dis[x] = dis;\n        rec[++cnt] = x;\n        for (int i = Begin[x]; i; i = Next[i])\n        {\n            int y = To[i];\n            if (y == fa || Vis[y]) continue;\n            dfs (y, x, dis + W[i]);\n        }\n    }\n    \n    inline void Calc (int x, int d, int f)\n    {\n        //cout<<x<<\" \"<<d<<endl;\n        cnt = 0;\n        dfs(x, 0, d);\n    \n        for (int i = 1; i <= cnt; ++i)\n            q[i].x = near[rec[i]].x - Dis[rec[i]], q[i].y = near[rec[i]].y;\n    \n        sort(q + 1, q + cnt + 1);\n    //  for (int i = 1; i <= cnt; ++i)\n    //      cout<<q[i].x<<\" \"<<q[i].y<<endl;\n    //  cout<<endl;\n    \n        for (int i = 1; i <= cnt; ++i)\n        {\n            int x = rec[i];\n            if (!type[x])\n            {\n                node tmp = {Dis[x], x};\n                int p = lower_bound(q + 1, q + cnt + 1, tmp) - q;\n        //      cout<<\"*\"<<p<<endl;\n                Ans[x] += f * (cnt - p + 1);\n            }\n        }\n    }\n    \n    inline void Devide (int x)\n    {\n        Min = inf;\n        dfs1(x, 0);\n        dfs2(x, 0, size[x]);\n    \n        x = pos;\n        Calc(x, 0, 1);\n        Vis[x] = 1;\n    \n        for (int i = Begin[x]; i; i = Next[i])\n        {\n            int y = To[i];\n            if (Vis[y]) continue;\n            Calc(y, W[i], -1);\n            Devide(y);\n        }\n    }\n    \n    int main()\n    {\n    #ifdef hk_cnyali\n        freopen(\"A.in\", \"r\", stdin);\n        freopen(\"A.out\", \"w\", stdout);\n    #endif\n        while (~scanf(\"%d\", &N))\n        {\n            Init();\n            for (int i = 1; i < N; ++i)\n            {\n                int x, y, z ;\n                scanf(\"%d%d%d\", &x, &y, &z);\n                add_edge(x, y, z);\n                add_edge(y, x, z);\n            }\n            for (int i = 1; i <= N; ++i) scanf(\"%d\", &type[i]);\n    \n            SPFA();\n            //for (int i = 1; i <= N; ++i)\n            //  printf(\"%d %d\\n\", near[i].x, near[i].y), fflush(stdout);\n            Devide(1);\n    \n            int ans = 0;\n            for (int i = 1; i <= N; ++i) ans = max(ans, Ans[i]);\n            cout<<ans<<endl;\n        }\n        return 0;\n    }\n    //注意i和rec[i]不要搞混\n```\n","categories":["Problem"],"tags":["最短路","二分","分治","点分治"]},{"title":"「Hdu5977」Garden of Eden - 点分治","url":"/2018/03/07/Hdu5977-Garden-of-Eden%EF%BC%88%E7%82%B9%E5%88%86%E6%B2%BB%EF%BC%89/","content":"\n题目链接：[传送门](http://acm.hdu.edu.cn/showproblem.php?pid=5977 \"传送门\")\n\n### Description\n\n给一棵节点数为n，节点种类为k的无根树，问其中有多少种不同的简单路径，可以满足路径上经过所有k种类型的点？（a->b与b->a算作两条路径，起点与终点也可以相同）\n<!--more-->\n\n### Solution\n\n点分治裸题 \n又是一个以前一直听起来很高大上实际上比较简单的方法 \n这道题可以状压，然后就把问题转化成了路径状态的或运算 \n剩下的就是点分治模板的事情了 \n大概就是找重心，计算过此根的答案，然后分治求解\n\n### Code\n```cpp\n    #include <bits/stdc++.h>\n    #define int long long\n    \n    using namespace std;\n    \n    const int Maxn = 2e5 + 100, Maxm = 2048 + 10;\n    \n    int N, M, K;\n    int e, Begin[Maxn], To[Maxn * 2], Next[Maxn * 2];\n    int size[Maxn];\n    int A[Maxn], Ans, Cnt[Maxm], Vis[Maxn];\n    int root, Max;\n    \n    inline void Init()\n    {\n        e = 0;\n        Ans = 0;\n        memset(size, 0, sizeof size);\n        memset(Vis, 0, sizeof Vis);\n        memset(Begin, 0, sizeof Begin);\n    }\n    \n    inline void add_edge (int x, int y)\n    {\n        To[++e] = y;\n        Next[e] = Begin[x];\n        Begin[x] = e;\n    }\n    \n    inline void dfs (int x, int fa)\n    {\n        size[x] = 1;\n        for (int i = Begin[x]; i; i = Next[i])\n        {\n            int y = To[i];\n            if (y == fa || Vis[y]) continue;\n            dfs(y, x);\n            size[x] += size[y];\n        }\n    }\n    \n    inline void dfs1 (int x, int fa, int Size)\n    {\n        int tmp = 0;\n        for (int i = Begin[x]; i; i = Next[i])\n        {\n            int y = To[i];\n            if (y == fa || Vis[y]) continue;\n            dfs1(y, x, Size);\n            tmp = max(tmp, size[y]);\n        }\n        tmp = max(tmp, Size - size[x]);\n        if (tmp < Max)\n        {\n            Max = tmp;\n            root = x;\n        }\n    }\n    \n    int sum, rec[Maxn];\n    \n    inline void dfs (int x, int fa, int state)\n    {\n        Ans += Cnt[(~state) & ((1 << K) - 1)];\n        rec[++sum] = state;\n        for (int i = Begin[x]; i; i = Next[i])\n        {\n            int y = To[i];\n            if (Vis[y] || y == fa) continue;\n            dfs(y, x, state | (1 << A[y]));\n        }\n    }\n    \n    inline void Calc (int x)\n    {\n        memset(Cnt, 0, sizeof Cnt);\n        Cnt[0] = 1;\n        for (int i = Begin[x]; i; i = Next[i])\n        {\n            int y = To[i];\n            if (Vis[y]) continue;\n            sum = 0;\n            dfs(y, 0, (1 << A[x]) | (1 << A[y]));\n            for (int j = 1; j <= sum; ++j)\n                for (int k = 0; k < (1 << K); ++k)\n                {\n                    if ((rec[j] | k) == rec[j])\n                        Cnt[k] ++;\n                }\n        }\n    }\n    \n    inline void Divide (int x)\n    {\n        Max = INT_MAX;\n        dfs(x, 0);\n        dfs1(x, 0, size[x]);\n        Vis[root] = 1;\n        x = root;\n        Calc(x);\n        for (int i = Begin[x]; i; i = Next[i])\n        {\n            int y = To[i];\n            if (Vis[y]) continue;\n            Divide(y);\n        }\n    }\n    \n    main()\n    {\n    #ifdef hk_cnyali\n        freopen(\"A.in\", \"r\", stdin);\n        freopen(\"A.out\", \"w\", stdout);\n    #endif\n        while (scanf(\"%lld%lld\", &N, &K) != EOF)\n        {\n            Init();\n    \n            for (int i = 1; i <= N; ++i)\n                scanf(\"%lld\", &A[i]), A[i]--;\n    \n            for (int i =  1; i < N; ++i)\n            {\n                int x, y;\n                scanf(\"%lld%lld\", &x, &y);\n                add_edge (x, y);\n                add_edge (y, x);\n            }\n    \n            Divide(1);\n            Ans *= 2;\n            if (K == 1) Ans += N;\n            printf(\"%lld\\n\", Ans);\n        }\n        return 0;\n    }\n```\n","categories":["Problem"],"tags":["状态压缩","树","分治","点分治"]},{"title":"「Hdu5696」区间的价值 - 序列分治","url":"/2018/03/07/Hdu5696-%E5%8C%BA%E9%97%B4%E7%9A%84%E4%BB%B7%E5%80%BC-%E5%BA%8F%E5%88%97%E5%88%86%E6%B2%BB/","content":"\n题目链接：[传送门](http://acm.hdu.edu.cn/showproblem.php?pid=5696 \"传送门\")\n\n### Description\n\n给你一个序列，定义一个区间的价值是，这个区间里的最大值乘以最小值。求出所有区间长度对应的最大价值。**数据为全随机**\n<!--more-->\n\n### Solution\n\n由于数据是随机的，我们可以用分治法来解决这道题 我们用Solve(l, r)来求出区间\\[l,r\\]中各种区间长度的最大价值。然后，我们找出\\[l,r\\]中的最小值。固定了最小值以后，我们再去枚举最大值，算出各个价值。我们能发现，随着区间变长，如果最小值是固定的，那么最大值只有可能越来越大，价值也会越来越大。所以我们要把区间短的答案给区间长的更新。然后分治搞就行了\n\n### Code\n```cpp\n    #include <bits/stdc++.h>\n    #define int long long\n    \n    using namespace std;\n    \n    const int Maxn = 1e5 + 100;\n    \n    int A[Maxn], Ans[Maxn], N;\n    int tmp[Maxn];\n    \n    inline void Solve (int l, int r)\n    {\n        if (l > r) return ;\n        int pos = 0;\n        for (int i = l; i <= r; ++i)\n            if (!pos || A[i] < A[pos]) pos = i;\n        int len = r - l + 1;\n        for (int i = 1; i <= len; ++i) tmp[i] = 0;\n        for (int i = l; i <= pos; ++i)\n            tmp[pos - i + 1] = max(tmp[pos - i + 1], A[i] * A[pos]);\n        for (int i = pos; i <= r; ++i)\n            tmp[i - pos + 1] = max(tmp[i - pos + 1], A[i] * A[pos]);\n        int lastans = 0;\n        for (int i = 1; i <= len; ++i)\n        {\n            lastans = max(lastans, tmp[i]);\n            Ans[i] = max(Ans[i], lastans);\n        }\n        Solve(l, pos - 1);\n        Solve(pos + 1, r);\n    }\n    \n    main()\n    {\n    #ifdef hk_cnyali\n        freopen(\"A.in\", \"r\", stdin);\n        freopen(\"A.out\", \"w\", stdout);\n    #endif\n        while (scanf(\"%lld\", &N) != EOF)\n        {\n            memset(Ans, 0, sizeof (Ans));\n            for (int i = 1; i <= N; ++i)\n                scanf(\"%lld\", &A[i]);\n            Solve (1, N);\n            for (int i = 1; i <= N; ++i)\n                printf(\"%lld\\n\", Ans[i]);\n        }\n        return 0;\n    }\n```\n","categories":["Problem"],"tags":["暴力","分治","乱搞"]},{"title":"「CF427D」 Match & Catch - 字符串Dp","url":"/2018/03/07/Codeforces-Round-244-Div-2-D-Match-Catch-%E5%AD%97%E7%AC%A6%E4%B8%B2Dp/","content":"\n题目链接[传送门](http://codeforces.com/contest/427/problem/D \"传送门\")\n\n### Description\n\n给你两个字符串S1， S2， 求S1和S2的只出现过一次的最短公共子串\n\n### Solution\n\n字符串Dp 设$sa\\[i\\]$表示在S1中最短的以i结尾的只出现过一次的子串长度 $sb\\\\\\[i\\]$同理，设$Dp\\[i\\]\\[j\\]$表示S1中以i结尾，S2中以j结尾的最长公共子串的长度，然后转移还是比较好理解的，具体见代码\n\n### Code\n\n    #include <bits/stdc++.h>\n    \n    using namespace std;\n    \n    const int Maxn = 5000 + 10;\n    \n    int N, M;\n    char A[Maxn], B[Maxn];\n    int sa[Maxn], sb[Maxn], Dp[Maxn][Maxn];\n    \n    inline void DP (char a[], char b[], int n, int m)\n    {\n        memset(Dp, 0, sizeof Dp);\n        for (int i = 1; i <= n; ++i)\n            for (int j = 1; j <= m; ++j)\n                if (a[i] == b[j])\n                    Dp[i][j] = max(Dp[i][j], Dp[i - 1][j - 1] + 1);\n    }\n    \n    int main()\n    {\n    #ifdef hk_cnyali\n        freopen(\"C.in\", \"r\", stdin);\n        freopen(\"C.out\", \"w\", stdout);\n    #endif\n        scanf(\"%s%s\", A + 1, B + 1);\n        N = strlen(A + 1);\n        M = strlen(B + 1);\n        DP(A, A, N, N);\n        for (int i = 1; i <= N; ++i)\n            for (int j = 1; j <= N; ++j)\n                if (i != j)\n                    sa[i] = max(sa[i], Dp[i][j] + 1);\n    \n        DP(B, B, M, M);\n        for (int i = 1; i <= M; ++i)\n            for (int j = 1; j <= M; ++j)\n                if (i != j)\n                    sb[i] = max(sb[i], Dp[i][j] + 1);\n    \n        DP(A, B, N, M);\n        int Ans = -1;\n        for (int i = 1; i <= N; ++i)\n            for (int j = 1; j <= M; ++j)\n            {\n                //cout<<Dp[i][j]<<\" \"<<sa[i]<<\" \"<<sb[i]<<endl;\n                if (Dp[i][j] >= sa[i] && Dp[i][j] >= sb[j])\n                {\n                    if (Ans < 0 || Ans > max(sa[i], sb[j]))\n                        Ans = max(sa[i], sb[j]);\n                }\n            }\n        cout<<Ans<<endl;\n        return 0;\n    }\n","categories":["Problem"],"tags":["Codeforces","动态规划","字符串"]},{"title":"Educational Codeforces Round 39 Summary","url":"/2018/03/07/Educational-Codeforces-Round-39-Summary/","content":"\nSummary\n-------\n\n这场比赛本来是一次上分的好机会，一开始做出来了四道题，Rank排在前300，结果B因为看错题并且PP太水而惨遭叉掉，Rank直接掉到1600+，又要掉分了 以后打CF一定一定一定一定一定一定一定一定在做完会做的题之后要检查之前的每一道题，每一回打CF都是想当然觉得应该没问题就没管了，导致惨遭FST\n<!--more-->\n\nProblems\n--------\n\n### A\n\n绝对值相加即可\n\n### B\n\n按照题意模拟，把减法改成取模即可\n\n### C\n\n比较简单的模拟（贪心），对于每个字母它能变成排在它之后的所有字母，然后依次贪心即可\n```cpp\n    #include <bits/stdc++.h>\n    \n    using namespace std;\n    \n    const int Maxn = 1e5 + 10;\n    \n    char S[Maxn];\n    \n    int N, M;\n    int A[Maxn];\n    \n    int main()\n    {\n    #ifdef hk_cnyali\n        freopen(\"C.in\", \"r\", stdin);\n        freopen(\"C.out\", \"w\", stdout);\n    #endif\n        scanf(\"%s\", S + 1);\n        int N = strlen(S + 1);\n        if (N < 26)\n        {\n            cout<<-1<<endl;\n            return 0;\n        }\n        int pos = 1;\n        for (int i = 1; i <= N; ++i)\n        {\n            if (S[i] - 'a' + 1 <= pos && pos <= 26)\n            {\n                S[i] = 'a' + pos - 1;\n                ++pos;\n            }\n        }\n        if (pos <= 26) cout<<-1<<endl;\n        else puts(S + 1);\n        return 0;\n    }\n```\n\n### D\n\n设$W\\[i\\]\\[j\\]$表示第i天逃j次课最少需要花费的逃课次数，$Dp\\[i\\]\\[j\\]$表示到第i天总共逃了j次课最少需要花费的逃课次数。对于$W$数组可以通过前缀和N^3方计算出来，Dp数组也是一个比较水的Dp\n```cpp\n    #include <bits/stdc++.h>\n    \n    using namespace std;\n    \n    const int Maxn = 500 + 10, inf = INT_MAX;\n    \n    char S[Maxn];\n    \n    int N, M, K, A[Maxn][Maxn];\n    int w[Maxn][Maxn];\n    int Sum[Maxn][Maxn];\n    int Dp[Maxn][Maxn];\n    \n    int main()\n    {\n    #ifdef hk_cnyali\n        freopen(\"D.in\", \"r\", stdin);\n        freopen(\"D.out\", \"w\", stdout);\n    #endif\n        scanf(\"%d%d%d\", &N, &M, &K);\n        for (int i = 1; i <= N; ++i)\n        {\n            scanf(\"%s\", S);\n            for (int j = 1; j <= M; ++j)\n                A[i][j] = S[j - 1] - '0', Sum[i][j] = Sum[i][j - 1] + A[i][j];\n        }\n    \n        memset(w, 0x3f, sizeof (w));\n        memset(Dp, 0x3f, sizeof (Dp));\n        for (int i = 1; i <= N; ++i)\n        {\n            w[i][Sum[i][M]] = 0;\n            for (int x = 1; x <= M; ++x)\n                for (int y = x; y <= M; ++y)\n                {\n                    int sum = Sum[i][M] - Sum[i][y] + Sum[i][x - 1];\n                    w[i][sum] = min(w[i][sum], y - x + 1);\n                }\n        }\n    \n        Dp[0][0] = 0;\n        for (int i = 1; i <= N; ++i)\n        {\n            for (int j = 0; j <= K; ++j)\n                for (int k = 0; k <= j; ++k)\n                    Dp[i][j] = min(Dp[i][j], Dp[i - 1][j - k] + w[i][k]);\n        }\n        int ans = inf;\n        for (int i = 0; i <= K; ++i)\n            ans = min(ans, Dp[N][i]);\n        cout<<ans<<endl;\n        return 0;\n    }\n```\n","categories":["Summary"],"tags":["Codeforces","Summary","动态规划"]},{"title":"网络流【最大流、上下界可行流、最小割、最小割树、费用流】Summary","url":"/2018/03/01/%E7%BD%91%E7%BB%9C%E6%B5%81%E3%80%90%E6%9C%80%E5%A4%A7%E6%B5%81%E3%80%81%E4%B8%8A%E4%B8%8B%E7%95%8C%E5%8F%AF%E8%A1%8C%E6%B5%81%E3%80%81%E6%9C%80%E5%B0%8F%E5%89%B2%E3%80%81%E6%9C%80%E5%B0%8F%E5%89%B2%E6%A0%91%E3%80%81%E8%B4%B9%E7%94%A8%E6%B5%81%E3%80%91Summary/","content":"\n知识点总结\n-----\n\n[Dinic最大流](https://www.cnblogs.com/SYCstudio/p/7260613.html \"Dinic最大流\") [网络流](http://hk-cnyali.com/wp-admin/post.php?post=746&action=edit \"网络流\")\n\n### Attention\n\n要注意链式前向星的init()时$e = 1$因为取一条边的反向边的时候要^1\n<!--more-->\nProblems\n--------\n\n### hdu5988 Coding Contest\n\n#### Description\n\n给出n个点和m条边，每个点有si个人，bi份食物,每条边一开始可以通过一个人,后来的人每通过一个就有pi的概率使整个系统崩溃,问崩溃的最小的概率是多少\n\n#### Solution\n\n求最小崩溃的概率可以转化成求最大不崩溃的概率，然后跑最小费用最大流\n把每个点的人数看成需要流出的流量，食物看成需要流入的流量\n然后对概率取个log，把乘法变成加法，最后再乘回去即可。\n要注意SPFA中判断要加eps，否则精度会炸\n\n#### Code\n```cpp\n    #include <bits/stdc++.h>\n    \n    using namespace std;\n    \n    const int Maxn = 1000 + 10, Maxm = 200000 + 10, inf = INT_MAX;\n    const double eps = 1e-14;\n    \n    int N, M;\n    int e, Begin[Maxn], To[Maxm], Next[Maxm], W[Maxm];\n    int Cur[Maxm];\n    double Cost[Maxm];\n    int S, T;\n    \n    inline void Init()\n    {\n        e = 0;\n        memset(Begin, -1, sizeof(Begin));\n    }\n    \n    inline void add_edge (int x, int y, int z, double l)\n    {\n        To[e] = y;\n        Next[e] = Begin[x];\n        Begin[x] = e;\n        W[e] = z;\n        Cost[e++] = l;\n        swap(x, y);\n        To[e] = y;\n        Next[e] = Begin[x];\n        Begin[x] = e;\n        W[e] = 0;\n        Cost[e++] = -l;\n    }\n    \n    double Dis[Maxn];\n    int Vis[Maxn], level[Maxn];\n    \n    inline int SPFA()\n    {\n        for (int i = 0; i <= N + 1; ++i) Dis[i] = inf * 1.0, Vis[i] = 0;\n        queue <int> Q;\n        Q.push(S);\n        Dis[S] = 0.0;\n        Vis[S] = 1;\n        while (!Q.empty())\n        {\n            int x = Q.front(); Q.pop();\n            //cout<<\"*\"<<x<<endl;\n            Vis[x] = 0;\n            for (int i = Begin[x]; i + 1; i = Next[i])\n            {\n                int y = To[i];\n                //cout<<\"$\"<<y<<endl;\n                //cout<<W[i]<<\" \"<<Dis[y]<<\" \"<<Dis[x]<<\" \"<<Cost[i]<<endl;\n                if (W[i] > 0 && Dis[y] > Dis[x] + Cost[i] + eps)\n                {\n                    //cout<<\"$\"<<y<<endl;\n                //  cout<<Dis[y]<<\" \"<<Dis[x]<<\" \"<<Cost[i]<<endl;\n                    Dis[y] = Dis[x] + Cost[i];\n                //  cout<<Dis[y]<<endl;\n                    if (!Vis[y]) {Vis[y] = 1;Q.push(y);}\n                }\n            }\n        //  cout<<endl;\n        }\n        if (Dis[T] == inf) return 0;\n        return 1;\n    }\n    \n    inline int find (int x, int k)\n    {\n        Vis[x] = 1;\n        //cout<<x<<\" \"<<k<<endl;\n        if (x == T) return k;\n        for (int &i = Cur[x]; i + 1; i = Next[i])\n        {\n            int y = To[i], sum;\n    //      cout<<Dis[y]<<\" \"<<Dis[x] + Cost[i]<<endl;\n            if (!Vis[y] && W[i] > 0 && Dis[y] == Dis[x] + Cost[i] && (sum = find(y, min(k, W[i]))))\n            {\n                W[i] -= sum;\n                W[i ^ 1] += sum;\n                return sum;\n            }\n        }\n        return 0;\n    }\n    \n    int main()\n    {\n    #ifdef hk_cnyali\n        freopen(\"A.in\", \"r\", stdin);\n        freopen(\"A.out\", \"w\", stdout);\n    #endif\n        int t;\n        scanf(\"%d\", &t);\n    \n        while (t--)\n        {\n            scanf(\"%d%d\", &N, &M);\n            S = 0, T = N + 1;\n            Init();\n            for (int i = 1; i <= N; ++i)\n            {\n                int x, y;\n                scanf(\"%d%d\", &x, &y);\n                add_edge(S, i, x, 0.0);\n                add_edge(i, T, y, 0.0);\n                //cout<<S<<\" \"<<i<<\" \"<<T<<endl;\n            }\n    \n            for (int i = 1; i <= M; ++i)\n            {\n                int x, y, z;\n                double l;\n                scanf(\"%d%d%d%lf\", &x, &y, &z, &l);\n                l = -log(1 - l);\n                add_edge(x, y, z - 1, l);\n                add_edge(x, y, 1, 0.0);\n            }\n    \n            double Ans = 0;\n            while (SPFA())\n            {\n                //cout<<\"#\"<<Dis[T]<<endl;\n                //cout<<\"Begin\"<<endl;\n                for (int i = 0; i <= N + 1; ++i) Cur[i] = Begin[i];\n                memset(Vis, 0, sizeof(Vis));\n                Ans += find(S, inf) * Dis[T];\n                //cout<<\"End\"<<endl;\n            }\n            printf(\"%.2lf\\n\", 1 - exp(-Ans));\n        }\n        return 0;\n    }\n```\n\n### hdu3549 Flow Problem\n\n#### Description\n\n最大流模板\n\n#### Code\n```cpp\n    #include <bits/stdc++.h>\n    \n    using namespace std;\n    \n    const int Maxn = 20, Maxm = 1000 + 10, inf = INT_MAX;\n    \n    int N, M;\n    int e, Begin[Maxn], Next[Maxm * 2], To[Maxm * 2], W[Maxm * 2], Cur[Maxn];\n    int level[Maxn], Vis[Maxn];\n    \n    inline void Init()\n    {\n        e = 0;\n        memset(Begin, -1, sizeof (Begin));\n        memset(W, 0, sizeof (W));\n    }\n    \n    inline void add_edge (int x, int y, int z)\n    {\n        To[e] = y;\n        Next[e] = Begin[x];\n        Begin[x] = e;\n        W[e++] = z;\n    }\n    \n    queue <int> Q;\n    \n    inline int bfs ()\n    {\n        for (int i = 1; i <= N; ++i)\n            level[i] = -1, Vis[i] = 0;\n        level[1] = 0;\n        while (!Q.empty()) Q.pop();\n        Q.push(1);\n        while (!Q.empty())\n        {\n            int x = Q.front(); Q.pop();\n            if (Vis[x]) continue;\n            Vis[x] = 1;\n            for (int i = Begin[x]; i + 1; i = Next[i])\n            {\n                int y = To[i];\n                if (W[i] > 0 && level[y] < 0)\n                {\n                    level[y] = level[x] + 1;\n                    Q.push(y);\n                }\n            }\n        }\n        if (level[N] < 0) return 0;\n        return 1;\n    }\n    \n    inline int find (int x, int k)\n    {\n        if (x == N) return k;\n        for (int &i = Cur[x]; i + 1; i = Next[i])\n        {\n            int y = To[i], sum;\n            if (W[i] > 0 && level[y] == level[x] + 1 && (sum = find (y, min(k, W[i]))))\n            {\n                W[i] -= sum;\n                W[i ^ 1] += sum;\n                return sum;\n            }\n        }\n        return 0;\n    }\n    \n    int main()\n    {\n    #ifdef hk_cnyali\n        freopen(\"B.in\", \"r\", stdin);\n        freopen(\"B.out\", \"w\", stdout);\n    #endif\n        int T, Cnt = 0;\n        scanf(\"%d\", &T);\n    \n        while (T--)\n        {\n            scanf(\"%d%d\", &N, &M);\n            Init();\n            while (M--)\n            {\n                int x, y, z;\n                scanf(\"%d%d%d\", &x, &y, &z);\n                add_edge(x, y, z);\n                add_edge(y, x, 0);\n            }\n            for (int i = 1; i <= N; ++i) Cur[i] = Begin[i];\n    \n            int Ans = 0;\n            while (bfs())\n            {\n                int Sum = 0;\n                for (int i = 1; i <= N; ++i) Cur[i] = Begin[i];\n                while (Sum = (find(1, inf)))\n                    Ans += Sum;\n            }\n            printf(\"Case %d: %d\\n\", ++Cnt, Ans);\n        }\n        return 0;\n    }\n```\n\n### hdu3657 Game\n\n#### Description\n\n给你一个n×m的矩阵，矩阵的值表示选择这个格子所能获得的得分，如果相邻的格子被选择（四联通）的话，就要减掉一个2 * (两个格子值'与'的结果)。题目会钦定K个点必须选。求最大能获得的得分\n\n#### Solution\n\n这道题建图的方法比较巧妙。我们可以先假设全部的格子都选了，然后从中间去掉一些点使得去掉这些点的代价最小。于是就转化成了最小割问题。我们根据坐标奇偶性建图，跑一遍最小割即可。（具体建图方法见代码）\n\n#### Code\n```cpp\n    #include <bits/stdc++.h>\n    \n    using namespace std;\n    \n    const int Maxn = 3000, Maxm = 200000 + 10, inf = INT_MAX;\n    \n    int N, M, K;\n    int p[Maxn], A[Maxn];\n    int e, Begin[Maxn], To[Maxm], Next[Maxm], W[Maxm], Cur[Maxm];\n    int S, T;\n    \n    inline void Init()\n    {\n        S = 0, T = N * M + 1;\n        e = 0;\n        memset(Begin, -1, sizeof Begin);\n    }\n    \n    inline void add_edge (int x, int y, int z)\n    {\n        To[e] = y;\n        Next[e] = Begin[x];\n        Begin[x] = e;\n        W[e++] = z;\n        swap(x, y);\n        To[e] = y;\n        Next[e] = Begin[x];\n        Begin[x] = e;\n        W[e++] = 0;\n    }\n    \n    int dr[4][2] = { {0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n    int level[Maxn];\n    \n    inline int bfs ()\n    {\n        queue <int> Q;\n        for (int i = S; i <= T; ++i) level[i] = -1;\n        level[S] = 0;\n        Q.push(S);\n        while (!Q.empty())\n        {\n            int x = Q.front(); Q.pop();\n            for (int i = Begin[x]; i + 1; i = Next[i])\n            {\n                int y = To[i];\n                //cout << \"*\" << y << endl;\n                if (W[i] > 0 && level[y] < 0)\n                {\n                    level[y] = level[x] + 1;\n                    Q.push(y);\n                }\n            }\n        }\n    //  cout<<level[T]<<endl;\n        return level[T] != -1;\n    }\n    \n    inline int find (int x, int k)\n    {\n        if (x == T) return k;\n        for (int &i = Cur[x]; i + 1; i = Next[i])\n        {\n            int y = To[i], sum;\n            if (W[i] > 0 && level[y] == level[x] + 1 && (sum = find(y, min(k, W[i]))))\n            {\n                W[i] -= sum;\n                W[i ^ 1] += sum;\n                return sum;\n            }\n        }\n        return 0;\n    }\n    \n    int main()\n    {\n    #ifdef hk_cnyali\n        freopen(\"C.in\", \"r\", stdin);\n        freopen(\"C.out\", \"w\", stdout);\n    #endif\n        while (scanf(\"%d%d%d\", &N, &M, &K) != EOF)\n        {\n            Init();\n            int Sum = 0;\n            for (int i = 1; i <= N; ++i)\n                for (int j = 1; j <= M; ++j)\n                {\n                    int x;\n                    scanf(\"%d\", &x);\n                    Sum += x;\n                    p[M * (i - 1) + j] = x;\n                    A[M * (i - 1) + j] = x;\n                }\n    \n            while (K--)\n            {\n                int x, y;\n                scanf(\"%d%d\", &x, &y);\n                p[M * (x - 1) + y] = inf;\n            }\n    \n            for (int i = 1; i <= N; ++i)\n            {\n                for (int j = 1; j <= M; ++j)\n                {\n                    int id = M * (i - 1) + j;\n                    if (!((i + j) & 1))\n                    {\n                        add_edge (S, id, p[id]);\n                        for (int k = 0; k < 4; ++k)\n                        {\n                            int x = i + dr[k][1], y = j + dr[k][0];\n                            if (x < 1 || x > N || y < 1 || y > M) continue;\n                            int id2 = M * (x - 1) + y;\n                            add_edge (id, id2, 2 * (A[id] & A[id2]));\n                        }\n                    }\n                    else\n                        add_edge (id, T, p[id]);\n                }\n            }\n        //  cout<<e<<endl;\n    \n            while (bfs())\n            {\n        //      cout<<\"fuck\"<<endl;\n                for (int i = S; i <= T; ++i)\n                    Cur[i] = Begin[i];\n                int sum = 0;\n                while (sum = find(S, inf))\n                    Sum -= sum;\n            }\n    \n            cout<<Sum<<endl;\n        }\n        return 0;\n    }\n```\n\n### hdu3987 Harry Potter and the Forbidden Forest\n\n#### Description\n\n求最小割中边数最小的一组割\n\n#### Solution\n\n先跑一边最大流，然后把满流的边（即可能成为答案的边）设为1，其他的边设为inf，再跑一边最大流即为答案\n\n#### Code\n```cpp\n    #include <bits/stdc++.h>\n    \n    using namespace std;\n    \n    const int Maxn = 1000 + 10, Maxm = 200000 + 10, inf = INT_MAX;\n    \n    int N, M, e, Begin[Maxn], To[Maxm * 2], Next[Maxm * 2], W[Maxm * 2];\n    int X[Maxm * 2], Y[Maxm * 2], Z[Maxm * 2];\n    int Cur[Maxm * 2], level[Maxn];\n    \n    inline void Init()\n    {\n        e = 0;\n        memset(Begin, -1, sizeof(Begin));\n    }\n    \n    inline void add_edge (int x, int y, int z)\n    {\n        X[e] = x, Y[e] = y, Z[e] = z;\n        To[e] = y;\n        Next[e] = Begin[x];\n        Begin[x] = e;\n        W[e++] = z;\n    }\n    \n    queue <int> Q;\n    inline int bfs ()\n    {\n        while (!Q.empty()) Q.pop();\n        for (int i = 1; i <= N; ++i) level[i] = -1;\n        Q.push(1);\n        level[1] = 0;\n    \n        while (!Q.empty())\n        {\n            int x = Q.front(); Q.pop();\n            for (int i = Begin[x]; i + 1; i = Next[i])\n            {\n                int y = To[i];\n                if (W[i] > 0 && level[y] < 0)\n                {\n                    level[y] = level[x] + 1;\n                    Q.push(y);\n                }\n            }\n        }\n        if (level[N] < 0) return 0;\n        return 1;\n    }\n    \n    inline int find (int x, int k)\n    {\n        if (x == N) return k;\n        for (int &i = Cur[x]; i + 1; i = Next[i])\n        {\n            int y = To[i], sum;\n            if (W[i] > 0 && level[y] == level[x] + 1 && (sum = find(y, min(k, W[i]))))\n            {\n                //cout<<sum<<endl;\n                W[i] -= sum;\n                W[i ^ 1] += sum;\n                return sum;\n            }\n        }\n        return 0;\n    }\n    \n    int main()\n    {\n    #ifdef hk_cnyali\n        freopen(\"D.in\", \"r\", stdin);\n        freopen(\"D.out\", \"w\", stdout);\n    #endif\n    \n        int T;\n        scanf(\"%d\", &T);\n        int cntt = 0;\n        while (T--)\n        {\n            scanf(\"%d%d\", &N, &M);\n            Init();\n            for (int i = 1; i <= M; ++i)\n            {\n                int x, y, z, z1;\n                scanf(\"%d%d%d%d\", &x, &y, &z, &z1);\n                x++, y++;\n                add_edge(x, y, z);\n                add_edge(y, x, 0);\n                if (z1) add_edge(y, x, z), add_edge(x, y, 0);\n            }\n    \n            while (bfs())\n            {\n                for (int i = 1; i <= N; ++i) Cur[i] = Begin[i];\n    //          for  (int i = 0; i <= e; ++i) cout<<W[i]<<\" \";\n    //          cout<<endl;\n                while (find(1, inf));\n            }\n    \n            for (int i = 0; i < e; i += 2)\n            {\n                if (!W[i]) W[i] = 1, W[i ^ 1] = 0;\n                else W[i] = inf, W[i ^ 1] = 0;\n            }\n    \n            int Ans = 0, sum;\n            while (bfs())\n            {\n                for (int i = 1; i <= N; ++i) Cur[i] = Begin[i];\n                while (sum = find(1, inf))\n                    Ans += sum;\n            }\n    \n            printf(\"Case %d: %d\\n\", ++cntt, Ans);\n        }\n        return 0;\n    }\n```\n\n### hdu4940 Destroy Transportation system\n\n#### Description\n\n无源无汇上下界可行流模板\n\n#### Code\n```cpp\n    #include <bits/stdc++.h>\n    \n    using namespace std;\n    \n    const int Maxn = 200 + 10, Maxm = 10000 + 10, inf = INT_MAX;\n    \n    int e, Begin[Maxn], To[Maxm * 2], Next[Maxm * 2], W[Maxm * 2];\n    int Cur[Maxn];\n    int In[Maxn], S, T;\n    int upper[Maxm], lowwer[Maxm];\n    int level[Maxn];\n    \n    int N, M;\n    \n    inline void Init()\n    {\n        e = 0;\n        memset (Begin, -1, sizeof Begin);\n        memset (In, 0, sizeof In);\n        S = 0, T = N + 1;\n    }\n    \n    inline void add_edge (int x, int y, int z)\n    {\n        To[e] = y; Next[e] = Begin[x];\n        Begin[x] = e; W[e++] = z;\n        swap(x, y);\n        To[e] = y; Next[e] = Begin[x];\n        Begin[x] = e; W[e++] = 0;\n    }\n    \n    inline int bfs ()\n    {\n        queue <int> Q;\n        for (int i = S; i <= T; ++i) level[i] = -1;\n        level[S] = 0;\n        Q.push(S);\n        while (!Q.empty())\n        {\n            int x = Q.front(); Q.pop();\n            for (int i = Begin[x]; i + 1; i = Next[i])\n            {\n                int y = To[i];\n                if (W[i] > 0 && level[y] < 0)\n                {\n                    level[y] = level[x] + 1;\n                    Q.push(y);\n                }\n            }\n        }\n        return level[T] != -1;\n    }\n    \n    inline int find (int x, int k)\n    {\n        if (x == T) return k;\n        for (int &i = Cur[x]; i + 1; i = Next[i])\n        {\n            int y = To[i], sum;\n            if (W[i] > 0 && level[y] == level[x] + 1 && (sum = find(y, min(k, W[i]))))\n            {\n                W[i] -= sum;\n                W[i ^ 1] += sum;\n                return sum;\n            }\n        }\n        return 0;\n    }\n    \n    int main()\n    {\n    #ifdef hk_cnyali\n        freopen(\"E.in\", \"r\", stdin);\n        freopen(\"E.out\", \"w\", stdout);\n    #endif\n        int t;\n        scanf(\"%d\", &t);\n        for (int xz = 1; xz <= t; ++xz)\n        {\n            scanf(\"%d%d\", &N, &M);\n            Init();\n            for (int i = 1; i <= M; ++i)\n            {\n                int x, y, u, l;\n                scanf(\"%d%d%d%d\", &x, &y, &u, &l);\n                add_edge (x, y, l);\n        //      cout<<x<<\" \"<<y<<\" \"<<l<<endl;\n                In[y] += u;\n                In[x] -= u;\n            }\n    \n            int cnt = 0;\n            for (int i = 1; i <= N; ++i)\n            {\n            //  cout<<In[i]<<endl;\n                if (In[i] > 0) add_edge (S, i, In[i]), cnt += In[i];\n                else add_edge (i, T, -In[i]);\n            }\n    \n            int Ans = 0;\n            while (bfs())\n            {\n                for (int i = S; i <= T; ++i) Cur[i] = Begin[i];\n                int sum;\n                while (sum = find(S, inf))Ans += sum;\n            }\n    \n            printf(\"Case #%d: \", xz);\n            if (cnt == Ans)\n                cout<<\"happy\"<<endl;\n            else cout<<\"unhappy\"<<endl;\n        }\n        return 0;\n    }\n```\n\n### hdu4862 Jump\n\n#### Description\n\n给定一个n*m的矩形(n,m≤10),每个矩形中有一个0~9的数字。 　　一共可以进行k次游戏，每次游戏可以任意选取一个没有经过的格子为起点，并且跳任意多步，每步可以向右方和下方跳。每次跳需要消耗两点间的曼哈顿距离减一的能量，若每次跳的起点和终点的数字相同，可以获得该数字的能量。（能量可以为负） 　　询问k次或更少次游戏后是否可以经过所有的格子，若可以求出最大的剩余能量。\n\n#### Solution\n\n建图的时候把每个点拆成两部分，\n从S向左半部分连cap为1，cost为0的边，从右边部分向T连cap为1，cost为0的边\n然后向每个可以到达的点连一条cap为1，cost为题目中所说的值的边，不过要建负的，最后再取相反数（因为是要使能量最大）\n然后还要再新建一个点，由S向这个点连一条cap为K，cost为0的边，这样保证在K步之内有解\n然后跑一遍最大流，如果最大流==N×M，则输出最小费用。否则输出-1\n\n#### Code\n```cpp\n    #include <bits/stdc++.h>\n    \n    using namespace std;\n    \n    const int Maxn = 200 + 10, Maxm = 10000 + 10, inf = INT_MAX;\n    \n    int e, Begin[Maxn], To[Maxm * 2], Next[Maxm * 2], W[Maxm * 2];\n    int Cur[Maxn];\n    int In[Maxn], S, T;\n    int upper[Maxm], lowwer[Maxm];\n    int level[Maxn];\n    \n    int N, M;\n    \n    inline void Init()\n    {\n        e = 0;\n        memset (Begin, -1, sizeof Begin);\n        memset (In, 0, sizeof In);\n        S = 0, T = N + 1;\n    }\n    \n    inline void add_edge (int x, int y, int z)\n    {\n        To[e] = y; Next[e] = Begin[x];\n        Begin[x] = e; W[e++] = z;\n        swap(x, y);\n        To[e] = y; Next[e] = Begin[x];\n        Begin[x] = e; W[e++] = 0;\n    }\n    \n    inline int bfs ()\n    {\n        queue <int> Q;\n        for (int i = S; i <= T; ++i) level[i] = -1;\n        level[S] = 0;\n        Q.push(S);\n        while (!Q.empty())\n        {\n            int x = Q.front(); Q.pop();\n            for (int i = Begin[x]; i + 1; i = Next[i])\n            {\n                int y = To[i];\n                if (W[i] > 0 && level[y] < 0)\n                {\n                    level[y] = level[x] + 1;\n                    Q.push(y);\n                }\n            }\n        }\n        return level[T] != -1;\n    }\n    \n    inline int find (int x, int k)\n    {\n        if (x == T) return k;\n        for (int &i = Cur[x]; i + 1; i = Next[i])\n        {\n            int y = To[i], sum;\n            if (W[i] > 0 && level[y] == level[x] + 1 && (sum = find(y, min(k, W[i]))))\n            {\n                W[i] -= sum;\n                W[i ^ 1] += sum;\n                return sum;\n            }\n        }\n        return 0;\n    }\n    \n    int main()\n    {\n    #ifdef hk_cnyali\n        freopen(\"E.in\", \"r\", stdin);\n        freopen(\"E.out\", \"w\", stdout);\n    #endif\n        int t;\n        scanf(\"%d\", &t);\n        for (int xz = 1; xz <= t; ++xz)\n        {\n            scanf(\"%d%d\", &N, &M);\n            Init();\n            for (int i = 1; i <= M; ++i)\n            {\n                int x, y, u, l;\n                scanf(\"%d%d%d%d\", &x, &y, &u, &l);\n                add_edge (x, y, l);\n        //      cout<<x<<\" \"<<y<<\" \"<<l<<endl;\n                In[y] += u;\n                In[x] -= u;\n            }\n    \n            int cnt = 0;\n            for (int i = 1; i <= N; ++i)\n            {\n            //  cout<<In[i]<<endl;\n                if (In[i] > 0) add_edge (S, i, In[i]), cnt += In[i];\n                else add_edge (i, T, -In[i]);\n            }\n    \n            int Ans = 0;\n            while (bfs())\n            {\n                for (int i = S; i <= T; ++i) Cur[i] = Begin[i];\n                int sum;\n                while (sum = find(S, inf))Ans += sum;\n            }\n    \n            printf(\"Case #%d: \", xz);\n            if (cnt == Ans)\n                cout<<\"happy\"<<endl;\n            else cout<<\"unhappy\"<<endl;\n        }\n        return 0;\n    }\n```\n","categories":["Summary"],"tags":["网络流","最大流","费用流"]},{"title":"tarjan【桥、割点、点双、边双、支配树】 Summary","url":"/2018/02/27/tarjan%E3%80%90%E6%A1%A5%E3%80%81%E5%89%B2%E7%82%B9%E3%80%81%E7%82%B9%E5%8F%8C%E3%80%81%E8%BE%B9%E5%8F%8C%E3%80%81%E6%94%AF%E9%85%8D%E6%A0%91%E3%80%91-Summary/","content":"\n知识点总结\n-----\n\n### 定义\n\n1.  割点：若删掉某点后，原连通图分裂为多个子图，则称该点为割点。\n    \n2.  割点集合：在一个无向连通图中，如果有一个顶点集合，删除这个顶点集合，以及这个集合中所有顶点相关联的边以后，原图变成多个连通块，就称这个点集为割点集合。\n    \n3.  点连通度：最小割点集合中的顶点数。\n    \n<!--more-->\n\n1.  割边(桥)：删掉它之后，图必然会分裂为两个或两个以上的子图。\n    \n2.  割边集合：如果有一个边集合，删除这个边集合以后，原图变成多个连通块，就称这个点集为割边集合。\n    \n3.  边连通度：一个图的边连通度的定义为，最小割边集合中的边数。\n    \n4.  缩点：把没有割边的连通子图缩为一个点，此时满足任意两点之间都有两条路径可达。\n    \n5.  双连通分量：分为点双连通和边双连通。它的标准定义为：点连通度大于1的图称为点双连通图，边连通度大于1的图称为边双连通图。通俗地讲，满足任意两点之间，能通过两条或两条以上没有任何重复边的路到达的图称为双连通图。无向图G的极大双连通子图称为双连通分量。\n    \n\n### 求解方法\n\n1.求强连通分量、割点、桥、缩点： \n对于Tarjan算法中，我们得到了dfn和low两个数组， \nlow\\[u\\]=min(low\\[u\\],dfn\\[v\\])——(u,v)为后向边，v不是u的子树； \nlow\\[u\\]=min(low\\[u\\],low\\[v\\])——(u,v)为树枝边，v为u的子树； \n下边对其进行讨论： \n若low\\[v\\]>=dfn\\[u\\],则u为割点，u和它的子孙形成一个块。\n因为这说明u的子孙不能够通过其他边到达u的祖先，\n这样去掉u之后，图必然分裂为两个子图。 \n若low\\[v\\]\\>dfn\\[u\\],则(u,v)为割边。理由类似于上一种情况。 \n2.求双连通分量以及构造双连通分量： \n对于点双连通分量，实际上在求割点的过程中就能顺便把每个点双连通分量求出。\n建立一个栈，存储当前双连通分量，在搜索图时，每找到一条树枝边或后向边(非横叉边)，就把这条边加入栈中。\n如果遇到某时满足DFS(u)<=Low(v)，说明u是一个割点，同时把边从栈顶一个个取出，\n直到遇到了边(u,v)，取出的这些边与其关联的点，组成一个点双连通分量。\n割点可以属于多个点双连通分量，其余点和每条边只属于且属于一个点双连通分量。 \n对于边双连通分量，求法更为简单。只需在求出所有的桥以后，把桥边删除，原图变成了多个连通块，则每个连通块就是一个边双连通分量。\n桥不属于任何一个边双连通分量，其余的边和每个顶点都属于且只属于一个边双连通分量。\n\nProblem\n-------\n\n### hdu4378 Caocao's Bridges\n\n#### Description\n\n求权值最小的桥，特判如果最小桥值为0，则输出1\n\n#### Code\n```cpp\n    #include <bits/stdc++.h>\n    \n    using namespace std;\n    \n    const int Maxn = 1000000 + 10;\n    \n    int Ans;\n    int N, M;\n    int A[1010][1010];\n    int P[1010][1010];\n    int e, Begin[Maxn], To[Maxn * 2], Next[Maxn * 2];\n    int dfn[Maxn], low[Maxn], Index;\n    \n    inline void tarjan (int x, int fa)\n    {\n        dfn[x] = low[x] = ++Index;\n        for (int i = Begin[x]; i; i = Next[i])\n        {\n            int y = To[i];\n            if (y == fa) continue;\n            if (!dfn[y])\n            {\n                tarjan(y, x);\n                low[x] = min(low[x], low[y]);\n                if (dfn[x] < low[y] && !P[x][y])\n                    Ans = min(Ans, A[x][y]);\n            }\n            else\n                low[x] = min(low[x], dfn[y]);\n        }\n    }\n    \n    inline void add_edge (int x, int y)\n    {\n        To[++e] = y;\n        Next[e] = Begin[x];\n        Begin[x] = e;\n    }\n    \n    int main()\n    {\n    #ifdef hk_cnyali\n        freopen(\"A.in\", \"r\", stdin);\n        freopen(\"A.out\", \"w\", stdout);\n    #endif\n        while (scanf(\"%d%d\", &N, &M) != EOF)\n        {\n            if (!N && !M) break;\n            Index = 0;\n            for (int i = 1; i <= N; ++i)\n                for (int j = 1; j <= N; ++j)\n                    A[i][j] = INT_MAX;\n            memset(dfn, 0, sizeof(dfn));\n            memset(P, 0, sizeof(P));\n            memset(Begin, 0, sizeof(Begin));\n            Ans = INT_MAX;\n            for (int i = 1; i <= M; ++i)\n            {\n                int x, y, z;\n                scanf(\"%d%d%d\", &x, &y, &z);\n                add_edge (x, y);\n                add_edge (y, x);\n                if (A[x][y] != INT_MAX) P[x][y] = P[y][x] = 1;\n                A[x][y] = A[y][x] = min(A[x][y], z);\n            }\n    \n            int fl = 0;\n            for (int i = 1; i <= N; ++i)\n                if (!dfn[i])\n                {\n                    if (i != 1)\n                    {\n                        fl = 1;\n                        break;\n                    }\n                    tarjan(i, 0);\n                }\n    \n            if (fl) cout<<0<<endl;\n            else if (Ans == INT_MAX) cout<<-1<<endl;\n            else if (!Ans) cout<<1<<endl;\n            else cout<<Ans<<endl;\n        }\n        return 0;\n    }\n```\n\n### hdu3394 Railway\n\n#### Description\n\n求桥的数量以及点双中 边数比点数多的边数之和\n\n#### Code\n```cpp\n    #include <iostream>\n    #include <cstdio>\n    #include <cstring>\n    #include <cmath>\n    #include <stack>\n    \n    using namespace std;\n    \n    const int Maxn = 100000 + 100;\n    \n    int Ans1, Ans2;\n    int N, M;\n    int e, Begin[Maxn], To[Maxn * 2], Next[Maxn * 2];\n    int dfn[Maxn], low[Maxn], Index;\n    int Vis[Maxn];\n    int BCC[Maxn];\n    \n    stack <int> S;\n    \n    inline void Calc ()\n    {\n        memset(Vis, 0, sizeof(Vis));\n        for (int i = 1; i <= BCC[0]; ++i) Vis[BCC[i]] = 1;\n        int Cnt = 0;\n        for (int i = 1; i <= BCC[0]; ++i)\n        {\n            for (int j = Begin[BCC[i]]; j; j = Next[j])\n            {\n                if (Vis[To[j]])\n                    Cnt ++;\n            }\n        }\n        Cnt /= 2;\n        if (Cnt > BCC[0]) Ans2 += Cnt;\n    }\n    \n    inline void tarjan (int x, int fa)\n    {\n        dfn[x] = low[x] = ++Index;\n        S.push(x);\n        for (int i = Begin[x]; i; i = Next[i])\n        {\n            int y = To[i];\n            if (y == fa) continue;\n            if (!dfn[y])\n            {\n                tarjan(y, x);\n                low[x] = min(low[x], low[y]);\n                if (dfn[x] <= low[y])\n                {\n                    if (dfn[x] < low[y])\n                        ++Ans1;\n                    memset(BCC, 0, sizeof(BCC));\n                    while (1)\n                    {\n                        int a = S.top(); S.pop();\n                        BCC[++BCC[0]] = a;\n                        if (a == y) break;\n                    }\n                    BCC[++BCC[0]] = x;\n                    Calc();\n                }\n            }\n            else\n                low[x] = min(low[x], dfn[y]);\n        }\n    }\n    \n    inline void add_edge (int x, int y)\n    {\n        To[++e] = y;\n        Next[e] = Begin[x];\n        Begin[x] = e;\n    }\n    \n    int main()\n    {\n    #ifdef hk_cnyali\n        freopen(\"B.in\", \"r\", stdin);\n        freopen(\"B.out\", \"w\", stdout);\n    #endif\n        while (scanf(\"%d%d\", &N, &M) != EOF)\n        {\n            e = 0;\n            if (!N && !M) break;\n            Index = 0;\n            memset(dfn, 0, sizeof(dfn));\n            memset(Begin, 0, sizeof(Begin));\n            while (!S.empty()) S.pop();\n            Ans1 = Ans2 = 0;\n            for (int i = 1; i <= M; ++i)\n            {\n                int x, y;\n                scanf(\"%d%d\", &x, &y);\n                ++x, ++y;\n                add_edge (x, y);\n                add_edge (y, x);\n            }\n    \n            for (int i = 1; i <= N; ++i)\n                if (!dfn[i])\n                    tarjan(i, -1);\n    \n            cout<<Ans1<<\" \"<<Ans2<<endl;\n        }\n        return 0;\n    }\n```\n\n### hdu2460 Network\n\n#### Description\n\n给出一个无向图以及Q次询问，每次询问增加一条无向边，要求输出增加这条边后剩余的桥的数目\n\n#### Solution\n\n先求桥的数量，然后每次询问暴力跳LCA就能过\n\n#### Code\n```cpp\n    #include <bits/stdc++.h>\n    \n    using namespace std;\n    \n    const int Maxn = 400000 + 10;\n    \n    int N, M;\n    int Ans, Vis[Maxn];\n    int e, Begin[Maxn], To[Maxn], Next[Maxn], f[Maxn];\n    int fa[Maxn];\n    int dfn[Maxn], low[Maxn], Index;\n    \n    inline void add_edge (int x, int y)\n    {\n        To[e] = y;\n        Next[e] = Begin[x];\n        Begin[x] = e;\n        f[e ++ ] = 0;\n    }\n    \n    inline void tarjan (int x)\n    {\n        dfn[x] = low[x] = ++Index;\n        for (int i = Begin[x]; i + 1; i = Next[i])\n        {\n            int y = To[i];\n            if (f[i]) continue;\n            f[i] = f[i ^ 1] = 1;\n            if (!dfn[y])\n            {\n                fa[y] = x;\n                tarjan(y);\n                low[x] = min(low[x], low[y]);\n                if (low[y] > dfn[x])\n                    ++Ans, Vis[y] = 1;\n            }\n            else low[x] = min(low[x], dfn[y]);\n        }\n    }\n    \n    inline void LCA (int x, int y)\n    {\n        while (dfn[x] > dfn[y])\n        {\n            //cout<<x<<endl;\n            if (Vis[x]) --Ans, Vis[x] = 0;\n            x = fa[x];\n        }\n    \n        while (dfn[y] > dfn[x])\n        {\n            //cout<<y<<endl;\n            if (Vis[y]) --Ans, Vis[y] = 0;\n            y = fa[y];\n        }\n    \n        while (x != y)\n        {\n            if (Vis[x]) --Ans, Vis[x] = 0;\n            if (Vis[y]) --Ans, Vis[y] = 0;\n            x = fa[x], y = fa[y];\n        }\n    }\n    \n    int main()\n    {\n    #ifdef hk_cnyali\n        freopen(\"C.in\", \"r\", stdin);\n        freopen(\"C.out\", \"w\", stdout);\n    #endif\n        int cnt = 0;\n        while (1)\n        {\n            e = 0;\n            Index = 0;\n            Ans = 0;\n            memset(Begin, -1, sizeof(Begin));\n            memset(dfn, 0, sizeof(dfn));\n            memset(Vis, 0, sizeof(Vis));\n            scanf(\"%d%d\", &N, &M);\n            if (!N && !M) break;\n            for (int i = 1; i <= M; ++i)\n            {\n                int x, y;\n                scanf(\"%d%d\", &x, &y);\n                add_edge (x, y);\n                add_edge (y, x);\n            }\n    \n            tarjan(1);\n    \n            scanf(\"%d\", &M);\n            printf(\"Case %d:\\n\", ++cnt);\n            while (M--)\n            {\n                int x, y;\n                scanf(\"%d%d\", &x, &y);\n                LCA(x, y);\n                printf(\"%d\\n\", Ans);\n            }\n            cout<<endl;\n        }\n        return 0;\n    }\n```\n\n### hdu4587 TWO NODES\n\n#### Description\n\nn点的无向图，问删除两个点以后，该图最多被分成多少个联通快？\n\n#### Solution\n\n先枚举第一个点，然后跑一遍tarjan求出除去这个点之外的割点的数量，然后把去掉之后的联通块数量加那个值取max即可\n\n#### Code\n```cpp\n    #include <bits/stdc++.h>\n    \n    using namespace std;\n    \n    const int Maxn = 5000 + 10;\n    \n    int N, M;\n    int e, Begin[Maxn], To[Maxn * 2], Next[Maxn * 2], f[Maxn * 2];\n    int dfn[Maxn], low[Maxn], cut[Maxn], Index;\n    int root;\n    \n    inline void Init ()\n    {\n        e = 0;\n        memset(Begin, -1, sizeof(Begin));\n    }\n    \n    inline void init()\n    {\n        memset(cut, 0, sizeof(cut));\n        memset(dfn, 0, sizeof(dfn));\n        memset(f, 0, sizeof(f));\n        Index = 0;\n    }\n    \n    inline void add_edge (int x, int y)\n    {\n        To[e] = y;\n        Next[e] = Begin[x];\n        Begin[x] = e;\n        f[e++] = 0;\n    }\n    \n    inline void tarjan (int x, int no)\n    {\n        int son = 0;\n        dfn[x] = low[x] = ++Index;\n        for (int i = Begin[x]; i + 1; i = Next[i])\n        {\n            int y = To[i];\n            if (y == no || f[i]) continue;\n            f[i] = f[i ^ 1] = 1;\n            if (!dfn[y])\n            {\n                ++son;\n                tarjan(y, no);\n                low[x] = min(low[x], low[y]);\n                if (low[y] >= dfn[x])\n                    cut[x] ++;\n            }\n            else low[x] = min(low[x], dfn[y]);\n        }\n        if (x == root) cut[x] --;\n    }\n    \n    int main()\n    {\n    #ifdef hk_cnyali\n        freopen(\"D.in\", \"r\", stdin);\n        freopen(\"D.out\", \"w\", stdout);\n    #endif\n    \n        while (scanf(\"%d%d\", &N, &M) != EOF)\n        {\n            Init();\n            for (int i = 1; i <= M; ++i)\n            {\n                int x, y;\n                scanf(\"%d%d\", &x, &y);\n                ++x, ++y;\n                add_edge (x, y);\n                add_edge (y, x);\n            }\n    \n            int Ans = 0;\n            for (int i = 1; i <= N; ++i)\n            {\n                int Sum = 0;\n                init();\n                for (int j = 1; j <= N; ++j)\n                    if (i != j && !dfn[j])\n                    {\n                        ++ Sum;\n                        root = j;\n                        tarjan(j, i);\n                    }\n    //          cout<<Sum<<endl;\n                for (int j = 1; j <= N; ++j)\n                    if (i != j)\n                        Ans = max(Ans, Sum + cut[j]);\n            }\n            cout<<Ans<<endl;\n        }\n    \n        return 0;\n    }\n```\n\n### hdu4612 Warm up\n\n#### Description\n\n给一个图， 求增加一条边之后的桥的数量最少是多少。有重边\n\n#### Solution\n\n先求桥的数量然后减去缩点求直径的长度即可\n\n#### Code\n```cpp\n    //#pragma GCC optimize(2)\n    #include <bits/stdc++.h>\n    \n    using namespace std;\n    //__attribute__((optimize(\"-O2\")))\n    \n    const int Maxn = 200000 + 100, Maxm = 2000000 + 100;\n    \n    int N, M, Ans;\n    int e, Begin[Maxn], To[Maxm], Next[Maxm], f[Maxm];\n    int Q1[Maxm], Q2[Maxm];\n    int dfn[Maxn], low[Maxn], Index;\n    int vis[Maxn];\n    int belong[Maxn];\n    int c;\n    bitset <Maxn> Vis;\n    \n    stack <int> S;\n    \n    inline void Init()\n    {\n        Ans = 0;\n        c = 0;\n        Index = e = 0;\n        while (!S.empty()) S.pop();\n        for (int i = 1; i <= N; ++i) Begin[i] = -1, belong[i] = dfn[i] = Vis[i] = low[i] = vis[i] = 0;\n        memset(f, 0, sizeof(f));\n        //memset(Vis, 0, sizeof(Vis));\n        //Vis.clear();\n    }\n    \n    inline void add_edge (int x, int y)\n    {\n        To[e] = y;\n        Next[e] = Begin[x];\n        Begin[x] = e;\n        f[e ++] = 0;\n    }\n    \n    inline void tarjan (int x)\n    {\n        dfn[x] = low[x] = ++ Index;\n        S.push(x);\n        vis[x] = 1;\n        int a, i;\n        for (i = Begin[x]; i + 1; i = Next[i])\n        {\n            if (f[i]) continue;\n            f[i] = f[i ^ 1] = 1;\n            if (!dfn[To[i]])\n            {\n                tarjan(To[i]);\n                low[x] = min(low[x], low[To[i]]);\n                if (low[To[i]] > dfn[x])\n                    ++Ans;\n            }\n            else if (vis[To[i]]) low[x] = min(low[x], dfn[To[i]]);\n        }\n        if (low[x] == dfn[x])\n        {\n            ++c;\n            while (1)\n            {\n                a = S.top(); S.pop();\n                vis[a] = 0;\n                belong[a] = c;\n                if (a == x) break;\n            }\n        }\n    }\n    \n    int pos, sum;\n    \n    inline void dfs (int x, int dep)\n    {\n        Vis[x] = 1;\n        if (dep >= sum) pos = x, sum = dep;\n        int y;\n        for (int i = Begin[x]; i + 1; i = Next[i])\n        {\n            y = To[i];\n            if (Vis[y]) continue;\n            dfs (y, dep + 1);\n        }\n    }\n    \n    int main()\n    {\n    #ifdef hk_cnyali\n        freopen(\"E.in\", \"r\", stdin);\n        freopen(\"E.out\", \"w\", stdout);\n    #endif\n        int x, y, a;\n        int i, j;\n        while (1)\n        {\n            scanf(\"%d%d\", &N, &M);\n            if (!N && !M) break;\n            Init();\n            for (i = 1; i <= M; ++i)\n            {\n                scanf(\"%d%d\", &x, &y);\n                add_edge (x, y);\n                add_edge (y, x);\n            }\n    \n            for (i = 1; i <= N; ++i)\n                if (!dfn[i])\n                    tarjan(i);\n    //      cout<<Ans<<endl;\n    \n            e = 0;\n            for (i = 1; i <= N; ++i)\n            {\n                for (j = Begin[i]; j + 1; j = Next[j])\n                {\n                    //              cout<<belong[i]<<\" \"<<belong[To[j]]<<endl;\n                    //add_edge1(belong[i], belong[To[j]]), add_edge1(belong[To[j]], belong[i]);\n                    if (belong[i] == belong[To[j]]) continue;\n                    Q1[++e] = belong[i], Q2[e] = belong[To[j]];\n                }\n            }\n    \n            memset(Begin, -1, sizeof(Begin));\n            int cnt = e;\n            e = 0;\n            for (i = 1; i <= cnt; ++i)\n                add_edge(Q1[i], Q2[i]), add_edge(Q2[i], Q1[i]);\n    \n            pos = sum = 0;\n            dfs(1, 0);\n            //memset(Vis, 0, sizeof(Vis));\n            for (i = 1; i <= N; ++i) Vis[i] = 0;\n            int now = pos;\n            pos = sum = 0;\n            dfs(now, 0);\n            printf(\"%d\\n\", Ans - sum);\n        }\n        return 0;\n    }\n```\n\n### hdu4694 Important Sisters\n\n支配树模板\n\n#### Code\n```\n    #include <bits/stdc++.h>\n    #define int long long\n    \n    using namespace std;\n    \n    const int Maxn = 50000 + 10, Maxm = 100000 + 10;\n    \n    int N, M;\n    int e, Begin[Maxn], To[Maxm * 2], Next[Maxm * 2];\n    int Index, dfn[Maxn], id[Maxn], fa[Maxn], f[Maxn], val[Maxn], idom[Maxn], semi[Maxn];\n    int Ans[Maxn];\n    vector <int> dom[Maxn], vec[Maxn];\n    \n    inline void Init()\n    {\n        e = Index = 0;\n        for (int i = 1; i <= N; ++i) vec[i].clear(), dom[i].clear(), Begin[i] = dfn[i] = idom[i] = Ans[i] = 0, f[i] = val[i] = semi[i] = i;\n    }\n    \n    inline void add_edge (int x, int y)\n    {\n        To[++e] = y;\n        Next[e] = Begin[x];\n        Begin[x] = e;\n    }\n    \n    inline void dfs (int x)\n    {\n        dfn[x] = ++Index;\n        id[Index] = x;\n        for (int i = Begin[x]; i; i = Next[i])\n        {\n            int y = To[i];\n            vec[y].push_back(x);\n            if (dfn[y]) continue;\n            fa[y] = x;\n            dfs(y);\n        }\n    }\n    \n    inline int find (int x)\n    {\n        if (f[x] == x) return x;\n        int y = find(f[x]);\n        if (dfn[semi[val[f[x]]]] < dfn[semi[val[x]]]) val[x] = val[f[x]];\n        return f[x] = y;\n    }\n    \n    inline void Calc ()\n    {\n        for (int i = 1; i <= Index; ++i)\n        {\n            int x = id[i];\n            Ans[x] += x;\n            if (idom[x]) Ans[x] += Ans[idom[x]];\n        }\n    }\n    \n    inline int mmin (int x, int y)\n    {\n        return dfn[x] < dfn[y] ? x : y;\n    }\n    \n    main()\n    {\n    #ifdef hk_cnyali\n        freopen(\"A.in\", \"r\", stdin);\n        freopen(\"A.out\", \"w\", stdout);\n    #endif\n        while (~scanf(\"%lld%lld\", &N, &M))\n        {\n            Init();\n            for (int i = 1; i <= M; ++i)\n            {\n                int x, y;\n                scanf(\"%lld%lld\", &x, &y);\n                add_edge (x, y);\n            }\n    \n            dfs(N);\n    \n            for (int i = Index; i > 1; --i)\n            {\n                int x = id[i];\n                for (int j = 0; j < vec[x].size(); ++j)\n                {\n                    int now = vec[x][j];\n                    if (dfn[now] < dfn[x]) semi[x] = mmin(semi[x], now);\n                    else\n                    {\n                        find(now);\n                        semi[x] = mmin(semi[x], semi[val[now]]);\n                    }\n                }\n    \n                f[x] = fa[x], dom[semi[x]].push_back(x);\n                for (int j = 0; j < dom[fa[x]].size(); ++j)\n                {\n                    int now = dom[fa[x]][j]; find(now);\n                    idom[now] = (dfn[semi[val[now]]] < dfn[semi[now]]) ? val[now] : fa[x];\n                }\n            }\n    \n            for (int i = 2; i <= Index; ++i)\n            {\n                int x = id[i];\n                if (idom[x] != semi[x]) idom[x] = idom[idom[x]];\n            }\n    \n            Calc();\n    \n            cout<<Ans[1];\n            for (int i = 2; i <= N; ++i)\n                cout<<\" \"<<Ans[i];\n            cout<<endl;\n        }\n        return 0;\n    }\n```\n","categories":["Summary"],"tags":["Summary","tarjan","点双","边双","割点","桥"]},{"title":"「HNOI2012」永无乡 - 线段树合并","url":"/2018/02/19/Luogu-P3224-HNOI2012-%E6%B0%B8%E6%97%A0%E4%B9%A1-%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%90%88%E5%B9%B6/","content":"\n题目链接：[传送门](https://www.luogu.org/problemnew/show/P3224 \"传送门\")\n\n### Description\n\n永无乡包含 n 座岛，编号从 1 到 n，每座岛都有自己的独一无二的重要度，按照重要度可 以将这 n 座岛排名，名次用 1 到 n 来表示。某些岛之间由巨大的桥连接，通过桥可以从一个岛 到达另一个岛。如果从岛 a 出发经过若干座（含 0 座）桥可以到达岛 b，则称岛 a 和岛 b 是连 通的。 现在有两种操作： B x y 表示在岛 x 与岛 y 之间修建一座新桥。 Q x k 表示询问当前与岛 x连通的所有岛中第 k 重要的是哪座岛，即所有与岛 x 连通的岛中重要度排名第 k 小的岛是哪 座，请你输出那个岛的编号。\n<!--more-->\n\n### Hint\n\nn<=100000,m<=n\n\n### Sample Input\n\n> 5 1 4 3 2 5 1 1 2 7 Q 3 2 Q 2 1 B 2 3 B 1 5 Q 2 1 Q 2 4 Q 2 3\n\n### Sample Ouput\n\n> -1 2 5 1 2\n\n### Solution\n\n一道比较裸的线段树合并（也可以用平衡树合并），算是一道模板题 \n用并查集维护一下连通性，用权值线段树维护一下所在联通块的岛的信息，\n对于每个连边我们直接线段树合并信息即可 \n只是要注意要启发式合并，否则会T掉5个点\n\n### Summary\n\n以后写题还是要细心点，开始开个数组Tree\\[Maxn * 30\\]手一快写成了Tree\\[Maxn << 30\\]，然后各种奇奇怪怪的错误都出来了，调了半个小时才调出来。。。\n\n### Code\n```cpp\n    #include <bits/stdc++.h>\n    \n    using namespace std;\n    \n    \n    const int Maxn = 100000 + 100;\n    \n    int N, M;\n    int Root[Maxn];\n    \n    namespace DS\n    {\n        int Cnt = 0;\n        struct tree\n        {\n            int lson, rson, val;\n        }Tree[Maxn * 10];\n    \n        inline void build (int &now, int l, int r, int x)\n        {\n            now = ++ Cnt;\n            //cout<<now<<\" \"<<l<<\" \"<<r<<\" \"<<x<<\" \"<<Tree[now].val<<endl;\n            Tree[now].val = 1;\n            if (l == r)\n                return ;\n            int mid = (l + r) >> 1;\n            if (x <= mid) build (Tree[now].lson, l, mid, x);\n            else build (Tree[now].rson, mid + 1, r, x);\n        }\n    \n        inline void merge (int &now, int nxt, int l, int r)\n        {\n            if (!now) \n            {\n                now = nxt;\n                return ;\n            }\n            if (!nxt) return ;\n            Tree[now].val += Tree[nxt].val;\n            int mid = (l + r) >> 1;\n            merge (Tree[now].lson, Tree[nxt].lson, l, mid);\n            merge (Tree[now].rson, Tree[nxt].rson, mid + 1, r);\n        }\n    \n        inline int query (int root, int l, int r, int k)\n        {\n            //cout<<root<<\" \"<<l<<\" \"<<r<<\" \"<<k<<\" \"<<Tree[root].val<<endl;\n            if (l == r)\n                return l;\n            int mid = (l + r) >> 1;\n            if (k <= Tree[Tree[root].lson].val) return query (Tree[root].lson, l, mid, k);\n            else return query (Tree[root].rson, mid + 1, r, k - Tree[Tree[root].lson].val);\n        }\n    }\n    \n    using namespace DS;\n    \n    int fa[Maxn], Map[Maxn];\n    \n    inline int find (int x)\n    {\n        return fa[x] == x ? x : find(fa[x]);\n    }\n    \n    inline void Merge (int x, int y)\n    {\n        int fx = find(x), fy = find(y);\n        if (fx == fy) return ;\n        if (Tree[Root[fx]].val >= Tree[Root[fy]].val)\n        {\n            merge(Root[fx], Root[fy], 1, N);\n            fa[fy] = fx;\n        }\n        else \n        {\n            swap(fx, fy);\n            merge(Root[fx], Root[fy], 1, N);\n            fa[fy] = fx;\n        }\n    }\n    \n    inline int Query (int x, int k)\n    {\n        if (Tree[Root[find(x)]].val < k) return -1;\n        return Map[query (Root[find(x)], 1, N, k)];\n    }\n    \n    int main()\n    {\n    #ifdef hk_cnyali\n        freopen(\"A.in\", \"r\", stdin);\n        freopen(\"A.out\", \"w\", stdout);\n    #endif\n        scanf(\"%d%d\", &N, &M);\n    \n    \n        for (int i = 1; i <= N; ++i)\n        {\n            int x;\n            scanf(\"%d\", &x);\n            Map[x] = i;\n            build(Root[i], 1, N, x);\n        }\n    \n        for (int i = 1; i <= N; ++i) fa[i] = i;\n    \n        while (M --)\n        {\n            int x, y;\n            scanf(\"%d%d\", &x, &y);\n            Merge (x, y);\n        }\n    \n        scanf(\"%d\", &M);\n    \n        while (M --)\n        {\n            char S[20];\n            int x, y;\n            scanf(\"%s%d%d\", S, &x, &y);\n            if (S[0] == 'B')\n                Merge (x, y);\n            else\n                printf(\"%d\\n\", Query (x, y));\n        }\n    \n        return 0;\n    }\n```\n","categories":["Problem"],"tags":["线段树","数据结构","线段树合并","启发式合并","省选","权值线段树"]},{"title":"Codeforces Round #463 C Permutation Cycle","url":"/2018/02/16/Codeforces-Round-463-C-Permutation-Cycle/","content":"\n题目链接：[传送门](http://codeforces.com/contest/932/problem/C \"传送门\")\n\n<!--more-->\n### Solution\n\n实际上就是求Ax + By = N的非负整数解（x和y都要非负），我是写的扩欧求的，实际上只需要暴力一个一个试就可以了。\n然后写扩欧的话要注意在用特解求非负整数解的时候要注意A和B都要除一个gcd\n考试的时候没加，然后就愉快地FST，rating暴跌了\n\n### Code\n```cpp\n    #include <bits/stdc++.h>\n    #define int long long\n    \n    using namespace std;\n    \n    int N, A, B;\n    int Ans[1000000 + 100];\n    \n    inline int ex_gcd (int a, int b, int &x, int &y)\n    {\n        if (!b)\n        {\n            x = 1;\n            y = 0;\n            return a;\n        }\n        int gcd = ex_gcd (b, a % b, x, y);\n        int tmp = x;\n        x = y;\n        y = tmp - a / b * y;\n        return gcd;\n    }\n    \n    main()\n    {\n    #ifdef hk_cnyali\n        freopen(\"C.in\", \"r\", stdin);\n        freopen(\"C.out\", \"w\", stdout);\n    #endif\n        scanf(\"%lld%lld%lld\", &N, &A, &B);\n        int x, y;\n        int g = ex_gcd(A, B, x, y);\n        if (N % g)\n        {\n            cout<<-1<<endl;\n            return 0;\n        }\n        B /= g;\n        int t1 = ((N / g) * x % B + B) % B;\n        B *= g;\n        int p1 = (N - A * t1) / B;\n        A /= g;\n        int p2 = ((N / g) * y % A + A) % A;\n        A *= g;\n        int t2 = (N - B * p2) / A;\n        if ((p1 < 0) || (t2 < 0))\n        {\n            cout<<-1<<endl;\n            return 0;\n        }\n        if (p2 >= 0 && t2 >= 0) p1 = p2, t1 = t2;\n        swap(p1, t1);\n        for (int i = 0; i < p1; ++i)\n        {\n            Ans[i * A + 1] = i * A + A;\n            for (int j = 2; j <= A; ++j)\n                Ans[i * A + j] = i * A + j - 1;\n        }\n        for (int i = 0; i < t1; ++i)\n        {\n            Ans[A * p1 + i * B + 1] = A * p1 + i * B + B;\n            for (int j = 2; j <= B; ++j)\n                Ans[A * p1 + i * B + j] = A * p1 + i * B + j - 1;\n        }\n        for (int i = 1; i <= N; ++i) cout<<Ans[i]<<\" \";\n        cout<<endl;\n        return 0;\n    }\n```\n","categories":["Problem"],"tags":["数学","gcd","构造","ex_gcd"]},{"title":"Codeforces Round #462(Div 2) ABCD","url":"/2018/02/15/Codeforces-Round-462-Div-2-ABCD/","content":"\n这场CF打得辣鸡的死，rating直线下掉，唉。。。 比赛链接：[传送门](http://codeforces.com/contest/934 \"传送门\")\n<!--more-->\n\nA A Compatible Pair\n-------------------\n\n### Solution\n\nN^3暴力枚举所有情况即可\n\n### Code\n```cpp\n    #include <bits/stdc++.h>\n    #define LL long long\n    \n    using namespace std;\n    \n    int N, M;\n    int A[100], B[100];\n    \n    int main()\n    {\n    #ifdef hk_cnyali\n        freopen(\"A.in\", \"r\", stdin);\n        freopen(\"A.out\", \"w\", stdout);\n    #endif\n        scanf(\"%d%d\", &N, &M); \n        for (int i = 1; i <= N; ++i) scanf(\"%d\", &A[i]);\n        for (int i = 1; i <= M; ++i) scanf(\"%d\", &B[i]);\n        LL Ans = LLONG_MAX;\n        for (int i = 1; i <= N; ++i)\n        {\n            LL Sum = LLONG_MIN, Summ = 1;\n            for (int j = 1; j <= N; ++j)\n                for (int k = 1; k <= M; ++k)\n                {\n                    if (j != i)\n                        Sum = max(Sum, (LL)A[j] * B[k]);\n                }\n            Ans = min(Ans, Sum);\n        }\n        cout<<Ans<<endl;\n        return 0;\n    }\n   ```\n\n### Summary\n\n要注意Ans和Sum一定要开到最大/最小，考场上Sum赋的0x3f3f3f3f3f3f3f(少写了个3f)然后就悲催地FST了。。。 以后开inf都用INT_MAX和LLONG_MAX算了\n\nB A Prosperous Lot\n------------------\n\n### Solution\n\n>36则无解，否则用8凑2,0凑1即可\n\n### Code\n```cpp\n    #include <bits/stdc++.h>\n    \n    using namespace std;\n    \n    int N;\n    \n    int main()\n    {\n    #ifdef hk_cnyali\n        freopen(\"B.in\", \"r\", stdin);\n        freopen(\"B.out\", \"w\", stdout);\n    #endif\n        scanf(\"%d\", &N);\n        if (N == 1)\n        {\n            cout<<4<<endl;\n            return 0;\n        }\n        if (N > 18 * 2){cout<<-1<<endl; return 0;}\n        if (N & 1) \n        {\n            for (int i = 1; i <= N / 2; ++i) cout<<\"8\";\n            cout<<0<<endl;\n        }\n        else \n        {\n            for (int i = 1; i <= N / 2; ++i)\n                cout<<\"8\";\n            cout<<endl;\n        }\n        return 0;\n    }\n   ``` \n\n### Summary\n\n开始被hack了半天没找出错，后来才发现原来10^18是19位数，开始想成了不能超过17位数然后就gg了\n\nC A Twisty Movement\n-------------------\n\n### Solution\n\n设Dp\\[i\\]\\[j\\]表示区间i~j翻转的最大值，那么我们就可以用N^2的区间Dp把这个Dp数组处理出来（详见代码），然后在N^2枚举哪个区间翻转即可\n\n### Code\n```cpp\n    #include <bits/stdc++.h>\n    \n    using namespace std;\n    \n    const int Maxn = 2000 + 10;\n    \n    int N, A[Maxn];\n    int Dp[Maxn][Maxn];\n    int Sum1[Maxn], Sum2[Maxn];\n    \n    int main()\n    {\n    #ifdef hk_cnyali\n        freopen(\"C.in\", \"r\", stdin);\n        freopen(\"C.out\", \"w\", stdout);\n    #endif\n        scanf(\"%d\", &N);\n        for (int i = 1; i <= N; ++i)\n        {\n            scanf(\"%d\", &A[i]);\n            Sum1[i] = Sum1[i - 1];\n            Sum2[i] = Sum2[i - 1];\n            if (A[i] == 1) Sum1[i] = Sum1[i - 1] + 1;\n            else Sum2[i] = Sum2[i - 1] + 1;\n        }\n        for (int l = 1; l <= N; ++l)\n            for (int i = 1; i + l - 1 <= N; ++i)\n            {\n                int j = i + l - 1;\n                if (A[i] == 1)\n                    Dp[i][j] = max(Dp[i + 1][j], Sum1[j] - Sum1[i - 1]);\n                else Dp[i][j] = Dp[i + 1][j] + 1;\n            }\n        int Ans = 0;\n        for (int i = 1; i <= N; ++i)\n            for (int j = i; j <= N; ++j)\n                Ans = max(Ans, Sum1[i - 1] + Sum2[N] - Sum2[j] + Dp[i][j]);\n        cout<<Ans<<endl;\n        return 0;\n    }\n   ``` \n\n### Summary\n\n唉，Dp题还是做少了，这种简单的Dp考场上都没调出来，Dp方面还要加强\n\nD A Determined Cleanup\n----------------------\n\n### Solution\n\n自己找规律+看样例乱搞了一下搞出来了一种做法AC了，具体也不知道怎么证明之类的 \n大概就是观察了下$(x+m)(k_3x^3 + k_2x^2 + k_1x + k_0)+n$这个式子\n展开之后变成了$ax^4+(k_3m+k_2)x^3 + (k_2m+k_1)x^2 + (k_1m + k_0)x + dm + n$ \n然后就使得dm+n>=0且尽量小，cm+d>=0且尽量小。。。这样迭代地去算 \n知道找到了一个$k_i$使得$k_i >= 0$且$k_i < m$就跳出循环 \n大概就是这样 \n然后C++里的ceil不知道为什么数字一大就有问题，于是就手写了一个和ceil功能一样的东西。。。\n\n### Code\n```cpp\n    #include <bits/stdc++.h>\n    #define LL long long\n    \n    using namespace std;\n    \n    const int Maxn = 1000000 + 100;\n    \n    LL N, M;\n    LL A[Maxn];\n    \n    int main()\n    {\n    #ifdef hk_cnyali\n        freopen(\"D.in\", \"r\", stdin);\n        freopen(\"D.out\", \"w\", stdout);\n    #endif\n        scanf(\"%lld%lld\", &N, &M);\n    \n        int Cnt = 0;\n        while (1)\n        {\n            A[++Cnt] = (((LL)(ceil((long double)(-N) / M)) * M + N) % M + M) % M;\n            if (N >= 0 && N < M)\n                break;\n            //N = (LL)ceil(((long double)(-N) / M));\n            if (!(N % M))\n                N = (-N) / M;\n            else if (N > 0)\n                N = (-N) / M;\n            else N = (-N) / M + 1;\n            //cout<<N<<endl;\n        }\n        cout<<Cnt<<endl;\n        for (LL i = 1; i <= Cnt; ++i) cout<<A[i]<<\" \";\n        cout<<endl;\n        return 0;\n    }\n```\n","categories":["Problem"],"tags":["数学"]},{"title":"2.13 Luogu Test Summary","url":"/2018/02/13/2-13-Luogu-Test-Summary/","content":"\nProcess\n-------\n\n先开T1，看一眼感觉好像是求ax+by>=N的正整数解，然后想了半天不知道怎么搞，然后发现了一些奇奇怪怪的结论，过了样例（此时过去40min）。正准备开T2的时候感觉有点虚，然后还是写了个暴力，一拍发现错好多。。。然后就开始各种玄学改程序，最后居然拍上了，感觉特别稳就交了不管了（flag++）接着看T2，首先想到暴力N^5，然后花了2min发现N^4的做法，然后愉快地码码码，交，居然比赛的时候显示A掉了！！！特别开心地打了个暴力拍，又拍出问题。。。检查好久发现暴力写错了。。。最后只剩30min看T3，写了个30pts的大暴力，然后检查了下T1发现一个LL打成int，改了之后就没时间了 最后T1一个细节打错了爆掉了25分。。。无缘Rank1。。。\n\n<!--more-->\n\nScore\n-----\n\n75 + 100 + 30 = 205 Rank 4（好水啊。。。）\n\nProblems\n--------\n\n### A\n\n乱搞的。。。 赛后发现暴力也能A。。。 比赛的做法其实和正解差不了多少 直接上正解算了 ![](http://hk-cnyali.com/wp-content/uploads/2018/02/QQ%E5%9B%BE%E7%89%8720180213132812-300x102.png)\n\n### B\n\nN^2枚举把哪两个点连0边，N^2算答案 算答案的时候因为如果加了0边对最短路产生了影响的话那么一定是从某一点走最短路到连0边的一个端点，再由0边的另一个端点走到另外一个点 然后就能N^2算答案了\n\n### C\n\n只会暴力dfs，还不会正解\n\nLearn\n-----\n\n1.  以后还是要对自己有自信一点，像T1这种题一定要静下心来把每个细节都想清楚，即使wa了很多次也不能浮躁，要相信自己只要把细节都处理好，按照那个思路去做一定能A\n2.  时间分配可能还是有问题，T1花了将近2h才只有75pts，T2 min就想到做法了。\n3.  还是要继续刷题，不能看题解，事实证明这对思维还是有很大的提升的，否则T2我应该也不会那么快地想到做法\n","categories":["Summary"],"tags":["Summary"]},{"title":"「AH2017/HNOI2017」影魔 - 暴力 + 扫描线 + 线段树","url":"/2018/02/13/HNOI2017-%E5%BD%B1%E9%AD%94-%E6%9A%B4%E5%8A%9B-%E6%89%AB%E6%8F%8F%E7%BA%BF-%E7%BA%BF%E6%AE%B5%E6%A0%91/","content":"\n题目链接：[传送门](https://www.luogu.org/problemnew/show/P3722 \"传送门\")\n\n### Description\n\n给你一个$N$的排列，对于区间$[l,r]$，若$l$和$r$为区间最大值与次大值，则对区间有$p1$的贡献；\n\n若$l$和$r$中一个为最大值，一个不为次大值，则有$p2$的贡献。有$m$个查询$[l,r]$，查询区间$[l,r]$内的贡献\n\n<!--more-->\n\n### Constraints\n\n$1 \\le n,m \\le 200000,1 \\le p1,p2 \\le 1000$\n\n### Solution\n\n先把每个位置它左边比它第一个大和右边比它第一个大的位置（分别记为L\\[i\\], R\\[i\\]）找出来\n\n别人都是用的单调栈搞，但实际上直接暴力跳就可以了（见[AGC005B](http://hk-cnyali.com/2018/02/05/AGC005-B-Minimum-Sum/ \"AGC005B\")） \n\n复杂度能保证（证起来有点麻烦就不写了） \n\n然后那么对于区间L\\[i\\]到R\\[i\\]有p1的贡献. \n\n对于左端点在L\\[i\\]+1到i-1,右端点为R\\[i\\]的区间有p2的贡献. \n\n对于左端点为L\\[i\\],右端点为i+1到R\\[i\\]-1的区间也有p2的贡献. \n\n并且\\[i - 1, i\\]也有p1的贡献（开始没想到这一点，然后死活过不了样例） \n\n然后我们就可以把询问离线，用扫描线+线段树去做了（剩下的都是套路。。。）\n\n### Code\n```cpp\n#include <bits/stdc++.h>\n#define LL long long\n\nusing namespace std;\n\nconst int Maxn = 200000 + 100;\n\nint N, M, p1, p2;\nint A[Maxn];\nint L[Maxn], R[Maxn];\n\nstruct Pair\n{\n\tint x, y;\n};\n\nstruct Triple\n{\n\tint x, y, z;\n};\n\nvector <Pair> vec_query1[Maxn];\nvector <Pair> vec_query2[Maxn];\nvector <Triple> vec_modify[Maxn];\n\nLL Ans[Maxn], Sum[Maxn];\n\nstruct tree\n{\n\tLL sum, tag;\n}Tree[Maxn << 2];\n\ninline void push_up (int x)\n{\n\tTree[x].sum = Tree[x << 1].sum + Tree[x << 1 | 1].sum;\n}\n\ninline void push_down (int x, int l, int r)\n{\n\tif (!Tree[x].tag) return ;\n\tTree[x << 1].tag += Tree[x].tag;\n\tTree[x << 1 | 1].tag += Tree[x].tag;\n\tLL mid = (l + r) >> 1;\n\tTree[x << 1].sum += Tree[x].tag * (mid - l + 1);\n\tTree[x << 1 | 1].sum += Tree[x].tag * (r - mid);\n\tTree[x].tag = 0ll;\n}\n\ninline void Update (int root, int l, int r, int x, int y, int z)\n{\n\tif (y < l || x > r) return ;\n\tif (x <= l && r <= y)\n\t{\n\t\tTree[root].sum += 1ll * (r - l + 1) * z;\n\t\tTree[root].tag += 1ll * z;\n\t\treturn ;\n\t}\n\tpush_down(root, l, r);\n\tLL mid = (l + r) >> 1;\n\tif (x <= mid) Update(root << 1, l, mid, x, y, z);\n\tif (y > mid) Update(root << 1 | 1, mid + 1, r, x, y, z);\n\tpush_up(root);\n}\n\ninline LL Query (int root, int l, int r, int x, int y)\n{\n\tif (y < l || x > r) return 0ll;\n\tif (x <= l && r <= y) return Tree[root].sum;\n\tpush_down(root, l, r);\n\tLL mid = (l + r) >> 1;\n\tLL ans = 0ll;\n\tif (x <= mid) ans += Query(root << 1, l, mid, x, y);\n\tif (y > mid) ans += Query(root << 1 | 1, mid + 1, r, x, y);\n\treturn ans;\n}\n\nint main()\n{\n#ifdef hk_cnyali\n\tfreopen(\"A.in\", \"r\", stdin);\n\tfreopen(\"A.out\", \"w\", stdout);\n#endif\n\n\tscanf(\"%d%d%d%d\", &N, &M, &p1, &p2);\n\tfor (int i = 1; i <= N; ++i)\n\t\tscanf(\"%d\", &A[i]);\n\n\tA[0] = A[N + 1] = 0x3f3f3f3f;\n\tfor (int i = 2; i <= N; ++i)\n\t{\n\t\tint now = i - 1;\n\t\twhile (A[now] < A[i])\n\t\t\tnow = L[now];\n\t\tL[i] = now;\n\t}\n\n\tR[N] = N + 1;\n\tfor (int i = N - 1; i >= 1; --i)\n\t{\n\t\tint now = i  + 1;\n\t\twhile (A[now] < A[i])\n\t\t\tnow = R[now];\n\t\tR[i] = now;\n\t}\n\n\t/*\n\tfor (LL i = 1; i <= N; ++i) cout<<L[i]<<\" \";\n\tcout<<endl;\n\tfor (LL i = 1; i <= N; ++i) cout<<R[i]<<\" \";\n\tcout<<endl;\n\t*/\n\n/*\n   R[i]  + L[i] -> p1\n   L[i]  + (i + 1 ... R[i] - 1) -> p2\n   R[i]  + (L[i] + 1 ... i - 1) -> p2\n */\n\n\tfor (int i = 1; i <= N; ++i)\n\t{\n\t\tvec_modify[R[i]].push_back((Triple){L[i], L[i], p1});\n\t\t//vec_modify[R[i]].push_back((Triple){R[i], R[i], p1});\n\t\tvec_modify[i].push_back((Triple){i - 1, i - 1, p1});\n\t\tvec_modify[L[i]].push_back((Triple){i + 1, R[i] - 1, p2});\n\t\tvec_modify[R[i]].push_back((Triple){L[i] + 1, i - 1, p2});\n\t}\n\n\tint x, y;\n\tfor (int i = 1; i <= M; ++i)\n\t{\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tvec_query1[x].push_back((Pair){y, i});\n\t\tvec_query2[y].push_back((Pair){x, i});\n\t}\n\n\tfor (int i = 0; i <= N; ++i)\n\t{\n\t\tfor (int j = 0; j < vec_modify[i].size(); ++j)\n\t\t\t//cout<<vec_modify[i][j].x<<\" \"<<vec_modify[i][j].y<<\" \"<<vec_modify[i][j].z<<endl,\n\t\t\tUpdate(1, 1, N, vec_modify[i][j].x, vec_modify[i][j].y, vec_modify[i][j].z);\n\t\tfor (int j = 0; j < vec_query1[i + 1].size(); ++j)\n\t\t\t//cout<<vec_query1[i + 1][j].y<<\" \",\n\t\t\tAns[vec_query1[i + 1][j].y] = Query(1, 1, N, i + 1, vec_query1[i + 1][j].x);\n\t\tfor (int j = 0; j < vec_query2[i].size(); ++j)\n\t\t\t//cout<<vec_query2[i][j].y<<\" \",\n\t\t\tAns[vec_query2[i][j].y] = Query(1, 1, N, vec_query2[i][j].x, i) - Ans[vec_query2[i][j].y];\n\t}\n\t//cout<<endl;\n\n\tfor (int i = 1; i <= M; ++i)\n\t\tprintf(\"%lld\\n\", Ans[i]);\n\treturn 0;\n}\n```","categories":["Problem"],"tags":["线段树","数据结构","扫描线","省选"]},{"title":"「Luogu3415」祭坛 - 扫描线 + 树状数组","url":"/2018/02/11/Luogu-P3415-%E7%A5%AD%E5%9D%9B-%E6%89%AB%E6%8F%8F%E7%BA%BF-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/","content":"\n题目链接：[传送门](https://www.luogu.org/problemnew/show/P3415 \"传送门\")\n\n### Description\n\n懒得放，太长了 大概意思就是让你在平面内找一点，使得它的四个正方向上的点的数量的最小值最大\n<!--more-->\n\n### Hint\n\nN(点数) <= 1e6 0 <= x, y <= N\n\n### Sample Input\n\n> 26 0 5 1 1 1 5 1 9 3 5 3 10 4 0 4 1 4 2 4 4 4 6 4 9 4 11 5 0 5 2 5 4 5 8 5 9 5 10 5 11 6 5 7 5 8 5 9 10 10 2 10 5\n\n### Sample Ouput\n\n> 3 2\n\n### Solution\n\n这道题的做法比较巧妙 \n首先二分一个答案，然后用扫描线的思想维护两个数组up\\[i\\], down\\[i\\]表示第i列的上方有多少点，下方有多少点，\n那么满足题意的点一定满足up\\[i\\] >= t, down\\[i\\] >= t(t为二分的答案)，这是竖列的要求。 \n然后对于横行的要求的话，我们找到可行的左端点和右端点，\n在这个区间内用树状数组维护一下满足数列要求的点，查询一个区间和即可 (我知道没讲清，反正自己懂就好了。。。)\n\n### Code\n```cpp\n    #include <bits/stdc++.h>\n    #define lowbit(x) x & (-x)\n    \n    using namespace std;\n    \n    const int Maxn = 100000 + 100;\n    \n    int N, M;\n    int Cnt[Maxn];\n    int up[Maxn], down[Maxn];\n    int Sum[Maxn * 2];\n    int l[Maxn], r[Maxn];\n    int a[Maxn], b[Maxn];\n    int Val[Maxn];\n    \n    vector <int> vec[Maxn];\n    \n    inline void add (int x, int v)\n    {\n        while (x <= N)\n        {\n            Sum[x] += v;\n            x += lowbit(x);\n        }\n    }\n    \n    inline int Query (int x)\n    {\n        int Ans = 0;\n        while (x)\n        {\n            Ans += Sum[x];\n            x -= lowbit(x);\n        }\n        return Ans;\n    }\n    \n    inline void Update(int x, int y)\n    {\n        if (Val[x] == y) return ;\n        if (y == 1) add(x, 1);\n        else add(x, -1);\n        Val[x] = y;\n    }\n    \n    \n    inline int Check (int t)\n    {\n        memset(a, 0, sizeof(a));\n        memset(b, 0, sizeof(b));\n        memset(Sum, 0, sizeof(Sum));\n        memset(Val, 0, sizeof(Val));\n        for (int i = 1; i <= N; ++i) up[i] = 0, down[i] = Cnt[i];\n        for (int i = 1; i <= N; ++i)\n            if (vec[i].size() >= 2 * t)\n                l[i] = vec[i][t - 1] + 1, r[i] = vec[i][vec[i].size() - t] - 1;\n            else l[i] = N + 1, r[i] = 0;\n        int sum = 0;\n        for (int i = 1; i <= N; ++i)\n        {\n            vector <int> Vis;\n            for (int j = 0; j < vec[i - 1].size(); ++j)\n            {\n                int y = vec[i - 1][j];\n                Vis.push_back(y);\n                up[y] ++;\n                if (up[y] >= t) a[y] = 1; else a[y] = 0;\n            }\n    \n            for (int j = 0; j < vec[i].size(); ++j)\n            {\n                int y = vec[i][j];\n                Vis.push_back(y);\n                down[y] --;\n                if (down[y] >= t) b[y] = 1; else b[y] = 0;\n            }\n    \n            for (int j = 0; j < Vis.size(); ++j)\n            {\n                int y = Vis[j];\n                Update(y, a[y] + b[y] == 2);\n            }\n    \n            if (l[i] <= r[i])\n                sum += Query(r[i]) - Query(l[i] - 1);\n        }\n        return sum;\n    }\n    \n    int main()\n    {\n    #ifdef hk_cnyali\n        freopen(\"A.in\", \"r\", stdin);\n        freopen(\"A.out\", \"w\", stdout);\n    #endif\n    \n        scanf(\"%d\", &M);\n        N = M + 1;\n        for (int i = 1; i <= M; ++i)\n        {\n            int x, y;\n            scanf(\"%d%d\", &x, &y);\n            ++x, ++y;\n            vec[x].push_back(y);\n            Cnt[y] ++;\n        }\n    \n        for (int i = 1; i <= N; ++i) sort(vec[i].begin(), vec[i].end());\n    \n        int l = 0, r = M, Ans = -1;\n        while (l <= r)\n        {\n            int mid = (l + r) >> 1;\n            if (Check(mid)) l = mid + 1, Ans = mid;\n            else r = mid - 1;\n        }\n    \n        cout<<Ans<<endl<<Check(Ans)<<endl;\n        return 0;\n    }\n```\n","categories":["Problem"],"tags":["数据结构","树状数组","扫描线"]},{"title":"「SDOI2010」粟粟的书架 - 主席树 + 二分答案","url":"/2018/02/11/Luogu-P2468-SDOI2010-%E7%B2%9F%E7%B2%9F%E7%9A%84%E4%B9%A6%E6%9E%B6-%E4%B8%BB%E5%B8%AD%E6%A0%91-%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/","content":"\n题目链接：[传送门](https://www.luogu.org/problemnew/show/P2468 \"传送门\")\n\n### Description\n\n幸福幼儿园B29班的粟粟是一个聪明机灵、乖巧可爱的小朋友，她的爱好是画画和读书，尤其喜欢Thomas H. Cormen的文章。\n粟粟家中有一个R行C列的巨型书架，书架的每一个位置都摆有一本书，上数第i行、左数第j列摆放的书有Pi,j页厚。\n粟粟每天除了读书之外，还有一件必不可少的工作就是摘苹果，她每天必须摘取一个指定的苹果。\n粟粟家果树上的苹果有的高、有的低，但无论如何凭粟粟自己的个头都难以摘到。\n不过她发现，如果在脚下放上几本书，就可以够着苹果；她同时注意到，对于第i天指定的那个苹果，只要她脚下放置书的总页数之和不低于Hi，就一定能够摘到。 \n由于书架内的书过多，父母担心粟粟一天内就把所有书看完而耽误了上幼儿园，于是每天只允许粟粟在一个特定区域内拿书。\n这个区域是一个矩形，第i天给定区域的左上角是上数第x1i行的左数第y1i本书，右下角是上数第x2i行的左数第y2i本书。换句话说，粟粟在这一天，只能在这﹙x2i－x1i＋1﹚×﹙y2i－y1i＋1﹚本书中挑选若干本垫在脚下，摘取苹果。 \n粟粟每次取书时都能及时放回原位，并且她的书架不会再撤下书目或换上新书，摘苹果的任务会一直持续M天。\n给出每本书籍的页数和每天的区域限制及采摘要求，请你告诉粟粟，她每天至少拿取多少本书，就可以摘到当天指定的苹果。\n<!--more-->\n\n### Hint\n\n对于50%的数据，满足R, C≤200，M≤200000； 另有50%的数据，满足R＝1，C≤500000，M≤20000 对于100%的数据，满足1≤Pi,j≤1000，1≤Hi≤2000000000\n\n### Sample Input\n\n> 5 5 7 14 15 9 26 53 58 9 7 9 32 38 46 26 43 38 32 7 9 50 28 8 41 9 7 17 1 2 5 3 139 3 1 5 5 399 3 3 4 5 91 4 1 4 1 33 1 3 5 4 185 3 3 4 3 23 3 1 3 3 108\n\n### Sample Output\n\n> 6 15 2 Poor QLW 9 1 3\n\n### Solution\n\n这是一道二合一的题 \n前50%中R,C<=200，我们可以设val\\[i\\]\\[j\\]\\[k\\]表示(1,1)到(i,j)这个矩阵中大于等于k的值的总和,num\\[i\\]\\[j\\]\\[k\\]表示(1,1)到(i,j)这个矩阵中大于等于k的值的个数。 \n然后用这个前缀和+二分答案即可 \n后50%中，R=1，也就是变成了数列上的问题。\n然后我们用主席树维护区间前k大数的和，然后也用二分答案去做即可\n\n### Summary\n\n这道题打得非常快，但是调了好久。。。 数组各种原因开炸，一开始数组开小了结果WA掉了，检查好久代码没发现问题把数组开大点就全RE，最后仔细算了一下要开的数组的大小，修改之后就A了。。。\n\n### Code\n```cpp\n    #include <bits/stdc++.h>\n    #define x1 hk\n    #define x2 is\n    #define y1 so\n    #define y2 clever\n    \n    using namespace std;\n    \n    const int Maxn = 200 + 10, Maxm = 500000 + 100;\n    \n    int N, M, Q;\n    int val[Maxn][Maxn][1000 + 10];\n    int num[Maxn][Maxn][1000 + 10];\n    \n    inline int calc_val (int x1, int y1, int x2, int y2, int x)\n    {\n        return val[x2][y2][x] - val[x2][y1 - 1][x] - val[x1 - 1][y2][x] + val[x1 - 1][y1 - 1][x];\n    }\n    \n    inline int calc_num (int x1, int y1, int x2, int y2, int x)\n    {\n        return num[x2][y2][x] - num[x2][y1 - 1][x] - num[x1 - 1][y2][x] + num[x1 - 1][y1 - 1][x];\n    }\n    \n    inline void Subtask1()\n    {\n        int A[Maxn][Maxn];\n        memset(A, 0, sizeof(A));\n        for (int i = 1; i <= N; ++i)\n            for (int j = 1; j <= M; ++j)\n                scanf(\"%d\", &A[i][j]);\n    \n        for (int i = 1; i <= N; ++i)\n            for (int j = 1; j <= M; ++j)\n                for (int k = 0; k <= 1000; ++k)\n                    val[i][j][k] = val[i][j - 1][k] + val[i - 1][j][k] - val[i - 1][j - 1][k] + (A[i][j] >= k ? A[i][j] : 0),\n                    num[i][j][k] = num[i][j - 1][k] + num[i - 1][j][k] - num[i - 1][j - 1][k] + (A[i][j] >= k);\n    \n        int x1, y1, x2, y2, x;\n        while (Q--)\n        {\n            scanf(\"%d%d%d%d%d\", &x1, &y1, &x2, &y2, &x);\n            //cout<<calc_val(x1, y1, x2, y2, 0)<<endl;\n            if (calc_val(x1, y1, x2, y2, 0) < x){puts(\"Poor QLW\"); continue;}\n            int l = 0, r = 1000, pos = -1;\n            while (l <= r)\n            {\n                int mid = (l + r) >> 1;\n                if (calc_val(x1, y1, x2, y2, mid) >= x) l = mid + 1, pos = mid;\n                else r = mid - 1;\n            }\n            printf(\"%d\\n\", calc_num(x1, y1, x2, y2, pos) - (calc_val(x1, y1, x2, y2, pos) - x) / pos);\n        }\n    }\n    \n    int Root[Maxm], Cnt;\n    \n    struct tree\n    {\n        int lson, rson, val, sum;\n    }Tree[Maxm * 20];\n    \n    inline void push_up (int root)\n    {\n        Tree[root].val = Tree[Tree[root].lson].val + Tree[Tree[root].rson].val;\n        Tree[root].sum = Tree[Tree[root].lson].sum + Tree[Tree[root].rson].sum;\n    }\n    \n    inline void build(int &root, int l, int r)\n    {\n        root = ++ Cnt;\n        if (l == r)\n            return ;\n        int mid = (l + r) >> 1;\n        build (Tree[root].lson, l, mid);\n        build (Tree[root].rson, mid + 1, r);\n    }\n    \n    inline void Insert (int pre, int &now, int l, int r, int x)\n    {\n        now = ++ Cnt;\n        Tree[now].lson = Tree[pre].lson;\n        Tree[now].rson = Tree[pre].rson;\n        Tree[now].val = Tree[pre].val;\n        Tree[now].sum = Tree[pre].sum;\n        if (l == r)\n        {\n            Tree[now].val ++;\n            Tree[now].sum += x;\n            return ;\n        }\n        int mid = (l + r) >> 1;\n        if (x <= mid) Insert(Tree[pre].lson, Tree[now].lson, l, mid, x);\n        else Insert(Tree[pre].rson, Tree[now].rson, mid + 1, r, x);\n        push_up(now);\n    }\n    \n    inline int Query (int pre, int now, int l, int r, int x)\n    {\n        //cout<<pre<<\" \"<<Tree[pre].sum<<\" \"<<now<<\" \"<<Tree[now].sum<<endl;\n        if (l == r)\n            return !(Tree[now].val - Tree[pre].val) ? (Tree[now].sum - Tree[pre].sum) : (Tree[now].sum - Tree[pre].sum) / (Tree[now].val - Tree[pre].val) * x;\n        int mid = (l + r) >> 1;\n        int right = Tree[Tree[now].rson].val - Tree[Tree[pre].rson].val;\n        if (right >=  x)\n            return Query(Tree[pre].rson, Tree[now].rson, mid + 1, r, x);\n        else return Tree[Tree[now].rson].sum - Tree[Tree[pre].rson].sum + Query(Tree[pre].lson, Tree[now].lson, l, mid, x - right);\n    }\n    \n    int Sum[Maxm];\n    int A[Maxm];\n    inline void Subtask2()\n    {\n        N = M;\n        build(Root[0], 1, 1000);\n        for (int i = 1; i <= N; ++i)\n        {\n            scanf(\"%d\", &A[i]);\n            Sum[i] = Sum[i - 1] + A[i];\n            Insert(Root[i - 1], Root[i], 1, 1000, A[i]);\n        }\n        int x, y, h;\n        while (Q--)\n        {\n            scanf(\"%*d%d%*d%d%d\", &x, &y, &h);\n            if (Sum[y] - Sum[x - 1] < h)\n            {\n                puts(\"Poor QLW\");\n                continue;\n            }\n            int l = 0, r = N, pos = -1;\n            while (l <= r)\n            {\n                int mid = (l + r) >> 1;\n                if (Query(Root[x - 1], Root[y], 1, 1000, mid) >= h) r = mid - 1, pos = mid;\n                else l = mid + 1;\n            }\n            printf(\"%d\\n\", pos);\n        }\n    }\n    \n    int main()\n    {\n    #ifdef hk_cnyali\n        freopen(\"A.in\", \"r\", stdin);\n        freopen(\"A.out\", \"w\", stdout);\n    #endif\n        scanf(\"%d%d%d\", &N, &M, &Q);\n        if (N != 1)\n            Subtask1();\n        else Subtask2();\n        return 0;\n    }\n```\n","categories":["Problem"],"tags":["二分答案","线段树","数据结构","主席树","前缀和","可持久化"]},{"title":"「CQOI2015」任务查询系统 - 主席树","url":"/2018/02/11/Luogu-P3168-CQOI2015-%E4%BB%BB%E5%8A%A1%E6%9F%A5%E8%AF%A2%E7%B3%BB%E7%BB%9F-%E4%B8%BB%E5%B8%AD%E6%A0%91/","content":"\n题目链接：[传送门](https://www.luogu.org/problemnew/show/P3168 \"传送门\")\n\n### Description\n\n最近实验室正在为其管理的超级计算机编制一套任务管理系统，而你被安排完成其中的查询部分。超级计算机中的任务用三元组(Si,Ei,Pi)描述，(Si,Ei,Pi)表示任务从第Si秒开始，在第Ei秒后结束（第Si秒和Ei秒任务也在运行），其优先级为Pi。同一时间可能有多个任务同时执行，它们的优先级可能相同，也可能不同。调度系统会经常向查询系统询问，第Xi秒正在运行的任务中，优先级最小的Ki个任务（即将任务按照优先级从小到大排序后取前Ki个）的优先级之和是多少。特别的，如果Ki大于第Xi秒正在运行的任务总数，则直接回答第Xi秒正在运行的任务优先级之和。上述所有参数均为整数，时间的范围在1到n之间（包含1和n）。\n<!--more-->\n\n\n### Hint\n\n1<=m,n,Si,Ei,Ci<=100000，0<=Ai,Bi<=100000，1<=Pi<=10000000，Xi为1到n的一个排列\n\n### Sample Input\n\n> 4 3 1 2 6 2 3 3 1 3 2 3 3 4 3 1 3 2 1 1 3 4 2 2 4 3\n\n### Sample Output\n\n> 2 8 11\n\n### Solution\n\n不是在线的话可以直接差分扫描线+线段树 \n强制在线的话用可持久化数据结构搞一下就可以了 \n算是再加强一下代码能力把 \n有一个细节需要注意：查询的时候到最底层的时候要特判一下，因为第k个位置上的值有多个的话显然不能全都加上\n\n### Code\n```cpp\n    #include <bits/stdc++.h>\n    #define LL long long\n    \n    using namespace std;\n    \n    const int Maxn = 100000;\n    \n    int N, M;\n    int Root[Maxn + 100], Cnt;\n    \n    vector <int> vec[Maxn + 100];\n    \n    struct tree\n    {\n        int lson, rson;\n        LL val, sum;\n    }Tree[Maxn * 64 + 100];\n    \n    inline void build (int &root, int l, int r)\n    {\n        root = ++ Cnt;\n        if (l == r)\n            return ;\n        int mid = (l + r) >> 1;\n        build (Tree[root].lson, l, mid);\n        build (Tree[root].rson, mid + 1, r);\n    }\n    \n    inline void push_up (int root)\n    {\n        Tree[root].val = 1ll * (Tree[Tree[root].lson].val + Tree[Tree[root].rson].val);\n        Tree[root].sum = 1ll * (Tree[Tree[root].lson].sum + Tree[Tree[root].rson].sum);\n    }\n    \n    inline void Insert (int pre, int &now, int l, int r, int x, int d)\n    {\n        now = ++Cnt;\n        Tree[now].lson = Tree[pre].lson;\n        Tree[now].rson = Tree[pre].rson;\n        Tree[now].val = Tree[pre].val;\n        Tree[now].sum = Tree[pre].sum;\n        if (l == r)\n        {\n            Tree[now].val += (d > 0) ? 1ll : -1ll;\n            Tree[now].sum += 1ll * d;\n            return ;\n        }\n        int mid = (l + r) >> 1;\n        if (x <= mid) Insert(Tree[pre].lson, Tree[now].lson, l, mid, x, d);\n        else Insert(Tree[pre].rson, Tree[now].rson, mid + 1, r, x, d);\n        push_up(now);\n    }\n    \n    inline int Query (int root, int l, int r, LL k)\n    {\n        //cout<<root<<\" \"<<l<<\" \"<<r<<\" *\"<<Tree[Tree[root].lson].val<<\" \"<<Tree[Tree[root].lson].sum<<endl;\n        if (l == r)\n            return !Tree[root].val ? Tree[root].sum : Tree[root].sum / Tree[root].val * 1ll * k;\n        int mid = (l + r) >> 1;\n        if (Tree[Tree[root].lson].val >= k)\n            return Query(Tree[root].lson, l, mid, k);\n        else return Tree[Tree[root].lson].sum + Query(Tree[root].rson, mid + 1, r, k - Tree[Tree[root].lson].val);\n    }\n    \n    struct node\n    {\n        int x, y, z, val;\n    }A[Maxn + 100];\n    \n    int B[Maxn + 100];\n    \n    int main()\n    {\n    #ifdef hk_cnyali\n        freopen(\"A.in\", \"r\", stdin);\n        freopen(\"A.out\", \"w\", stdout);\n    #endif\n    \n        scanf(\"%d%d\", &M, &N);\n        for (int i = 1; i <= M; ++i)\n            scanf(\"%d%d%d\", &A[i].x, &A[i].y, &A[i].z), B[i] = A[i].z, A[i].val = A[i].z;\n    \n        sort(B + 1, B + M + 1);\n        int sz = unique(B + 1, B + M + 1) - B - 1;\n        for (int i = 1; i <= M; ++i)\n        {\n            A[i].z = lower_bound(B + 1, B + sz + 1, A[i].z) - B;\n            //cout<<A[i].x<<\" \"<<A[i].y<<\" \"<<A[i].z<<endl;\n            vec[A[i].x].push_back(i);\n            vec[A[i].y + 1].push_back(-i);\n        }\n    \n        build(Root[0], 1, Maxn);\n    \n        for (int i = 1; i <= N; ++i)\n        {\n            for (int j = 0; j < vec[i].size(); ++j)\n            {\n                //cout<<vec[i][j]<<\" \";\n                if (vec[i][j] > 0) Insert(!Root[i] ? Root[i - 1] : Root[i], Root[i], 1, Maxn, A[vec[i][j]].z, A[vec[i][j]].val);\n                else Insert(!Root[i] ? Root[i - 1] : Root[i], Root[i], 1, Maxn, A[-vec[i][j]].z, -A[-vec[i][j]].val);\n            }\n            //cout<<endl;\n    \n            if (!vec[i].size()) Root[i] = Root[i - 1];\n        }\n    \n        LL Ans = 1;\n        int x, a, b, c;\n        for (int i = 1; i <= N; ++i)\n        {\n            scanf(\"%d%d%d%d\", &x, &a, &b, &c);\n            Ans = Query(Root[x], 1, Maxn, 1 + ((a * Ans) + b) % c);\n            printf(\"%lld\\n\", Ans);\n        }\n    \n        return 0;\n    }\n```\n","categories":["Problem"],"tags":["线段树","数据结构","主席树","树","可持久化"]},{"title":"「SDOI2014」旅行 - 树链剖分","url":"/2018/02/10/Luogu-P3313-SDOI2014-%E6%97%85%E8%A1%8C-%E6%A0%91%E5%89%96/","content":"\n题目链接：[传送门](https://www.luogu.org/problemnew/show/P3313 \"传送门\")\n\n### Description\n\nS国有N个城市，编号从1到N。城市间用N-1条双向道路连接，满足从一个城市出发可以到达其它所有城市。每个城市信仰不同的宗教，如飞天面条神教、隐形独角兽教、绝地教都是常见的信仰。 为了方便，我们用不同的正整数代表各种宗教， S国的居民常常旅行。旅行时他们总会走最短路，并且为了避免麻烦，只在信仰和他们相同的城市留宿。当然旅程的终点也是信仰与他相同的城市。S国政府为每个城市标定了不同的旅行评级，旅行者们常会记下途中（包括起点和终点）留宿过的城市的评级总和或最大值。 在S国的历史上常会发生以下几种事件： “CC x c“：城市x的居民全体改信了c教； “CW x w“：城市x的评级调整为w; “QS x y“：一位旅行者从城市x出发，到城市y，并记下了途中留宿过的城市的评级总和； “QM x y“：一位旅行者从城市x出发，到城市y，并记下了途中留宿过的城市的评级最大值。 由于年代久远，旅行者记下的数字已经遗失了，但记录开始之前每座城市的信仰与评级，还有事件记录本身是完好的。请根据这些信息，还原旅行者记下的数字。 为了方便，我们认为事件之间的间隔足够长，以致在任意一次旅行中，所有城市的评级和信仰保持不变。\n<!--more-->\n\n### Hint\n\nN，Q < =10^5 ， C < =10^5\n\n### Sample Input\n\n> 5 6 3 1 2 3 1 2 3 3 5 1 1 2 1 3 3 4 3 5 QS 1 5 CC 3 1 QS 1 5 CW 3 3 QS 1 5 QM 2 4\n\n### Sample Output\n\n> 8 9 11 3\n\n### Solution\n\n先树链剖分一下，然后对于每一种教建一颗线段树维护Sum和Max即可\n\n### Code\n```cpp\n    #include <bits/stdc++.h>\n    \n    using namespace std;\n    \n    const int Maxn = 100000 + 100;\n    \n    int Begin[Maxn * 2], To[Maxn * 2], Next[Maxn * 2], e;\n    int dep[Maxn], fa[Maxn], top[Maxn], son[Maxn], size[Maxn];\n    int W[Maxn], C[Maxn];\n    int dfn[Maxn], idfn[Maxn], Index;\n    int N, M;\n    \n    inline void add_edge (int x, int y)\n    {\n        To[++e] = y;\n        Next[e] = Begin[x];\n        Begin[x] = e;\n    }\n    \n    inline void dfs (int x)\n    {\n        size[x] = 1;\n        for (int i = Begin[x]; i; i = Next[i])\n        {\n            int y = To[i];\n            if (fa[x] == y) continue;\n            fa[y] = x;\n            dep[y] = dep[x] + 1;\n            dfs(y);\n            size[x] += size[y];\n            if (size[y] > size[son[x]]) son[x] = y;\n        }\n    }\n    \n    inline void dfs (int x, int now)\n    {\n        dfn[x] = ++Index;\n        idfn[Index] = x;\n        top[x] = now;\n        if (son[x]) dfs(son[x], now);\n        for (int i = Begin[x]; i; i = Next[i])\n        {\n            int y = To[i];\n            if (fa[x] == y || son[x] == y) continue;\n            dfs(y, y);\n        }\n    }\n    \n    int Root[Maxn], Cnt;\n    struct tree\n    {\n        int lson, rson, Max, sum;\n    }Tree[Maxn * 20];\n    \n    inline void push_up (int &root)\n    {\n        Tree[root].Max = max(Tree[Tree[root].lson].Max, Tree[Tree[root].rson].Max);\n        Tree[root].sum = Tree[Tree[root].lson].sum + Tree[Tree[root].rson].sum;\n        if (!Tree[root].lson && !Tree[root].rson)\n            Tree[root].Max = Tree[root].sum = 0, root = 0;\n    }\n    \n    inline void Insert (int &root, int l, int r, int x, int d)\n    {\n        if (!root) root = ++ Cnt;\n        if (l == r)\n        {\n            Tree[root].Max = Tree[root].sum = d;\n            return ;\n        }\n        int mid = (l + r) >> 1;\n        if (x <= mid) Insert(Tree[root].lson, l, mid, x, d);\n        else Insert(Tree[root].rson, mid + 1, r, x, d);\n        push_up(root);\n    }\n    \n    inline void Delete (int &root, int l, int r, int x)\n    {\n        if (l == r)\n        {\n            Tree[root].lson = Tree[root].rson = Tree[root].Max = Tree[root].sum = 0;\n            root = 0;\n            return ;\n        }\n        int mid = (l + r) >> 1;\n        if (x <= mid) Delete(Tree[root].lson, l, mid, x);\n        else Delete(Tree[root].rson, mid + 1, r, x);\n        push_up(root);\n    }\n    \n    inline void Modify1 (int x, int y)\n    {\n        Delete(Root[C[x]], 1, N, dfn[x]);\n        C[x] = y;\n        Insert(Root[C[x]], 1, N, dfn[x], W[x]);\n    }\n    \n    inline void Modify2 (int x, int y)\n    {\n        W[x] = y;\n        Insert(Root[C[x]], 1, N, dfn[x], W[x]);\n    }\n    \n    inline int query_sum (int root, int l, int r, int x, int y)\n    {\n        if (y < l || x > r) return 0;\n        if (x <= l && r <= y) return Tree[root].sum;\n        int Ans = 0;\n        int mid = (l + r) >> 1;\n        if (x <= mid) Ans += query_sum(Tree[root].lson, l, mid, x, y);\n        if (y > mid) Ans += query_sum(Tree[root].rson, mid + 1, r, x, y);\n        return Ans;\n    }\n    \n    inline int Query1 (int x, int y)\n    {\n        int t1 = top[x], t2 = top[y];\n        int tmp = C[x];\n        int Sum = 0;\n        while (t1 != t2)\n        {\n            if (dep[t1] < dep[t2]) swap(x, y), swap(t1, t2);\n            Sum += query_sum(Root[tmp], 1, N, dfn[t1], dfn[x]);\n            x = fa[t1];\n            t1 = top[x];\n        }\n        if (dep[x] < dep[y]) Sum += query_sum(Root[tmp], 1, N, dfn[x], dfn[y]);\n        else Sum += query_sum(Root[tmp], 1, N, dfn[y], dfn[x]);\n        return Sum;\n    }\n    \n    inline int query_max (int root, int l, int r, int x, int y)\n    {\n        if (y < l || x > r) return 0;\n        if (x <= l && r <= y) return Tree[root].Max;\n        int mid = (l + r) >> 1;\n        int Max = -0x3f3f3f3f;\n        if (x <= mid) Max = max(Max, query_max(Tree[root].lson, l, mid, x, y));\n        if (y > mid) Max = max(Max, query_max(Tree[root].rson, mid + 1, r, x, y));\n        return Max;\n    }\n    \n    inline int Query2 (int x, int y)\n    {\n        int t1 = top[x], t2 = top[y];\n        int tmp = C[x];\n        int Max = -0x3f3f3f3f;\n        while (t1 != t2)\n        {\n            if (dep[t1] < dep[t2]) swap(x, y), swap(t1, t2);\n            Max = max(Max, query_max(Root[tmp], 1, N, dfn[t1], dfn[x]));\n            x = fa[t1];\n            t1 = top[x];\n        }\n        if (dep[x] < dep[y]) Max = max(Max, query_max(Root[tmp], 1, N, dfn[x], dfn[y]));\n        else Max = max(Max, query_max(Root[tmp], 1, N, dfn[y], dfn[x]));\n        return Max;\n    }\n    \n    int main()\n    {\n    #ifdef hk_cnyali\n        freopen(\"A.in\", \"r\", stdin);\n        freopen(\"A.out\", \"w\", stdout);\n    #endif\n        scanf(\"%d%d\", &N, &M);\n        for (int i = 1; i <= N; ++i) scanf(\"%d%d\", &W[i], &C[i]);\n    \n        int x, y;\n        for (int i = 1; i < N; ++i)\n        {\n            scanf(\"%d%d\", &x, &y);\n            add_edge(x, y);\n            add_edge(y, x);\n        }\n    \n        dep[1] = 1;\n        dfs(1);\n        dfs(1, 1);\n    \n        for (int i = 1; i <= N; ++i)\n            Insert(Root[C[i]], 1, N, dfn[i], W[i]);\n    \n        char s[3];\n        for (int i = 1; i <= M; ++i)\n        {\n            scanf(\"%s%d%d\", s, &x, &y);\n            if (s[1] == 'S') printf(\"%d\\n\", Query1(x, y));\n            else if (s[1] == 'M') printf(\"%d\\n\", Query2(x, y));\n            else if (s[1] == 'C') Modify1(x, y);\n            else Modify2(x, y);\n        }\n        return 0;\n    }\n```\n","categories":["Problem"],"tags":["线段树","数据结构","树","树链剖分"]},{"title":"「LuoguT21778」 过年 - 权值线段树 + 扫描线","url":"/2018/02/09/Luogu-T21778-%E8%BF%87%E5%B9%B4-%E6%9D%83%E5%80%BC%E7%BA%BF%E6%AE%B5%E6%A0%91-%E6%89%AB%E6%8F%8F%E7%BA%BF%E6%80%9D%E6%83%B3/","content":"\n题目链接：[传送门](https://www.luogu.org/problemnew/show/T21778 \"传送门\")\n\n### Description\n\n有 n$(1 \\leq n \\leq 10^5)$个小朋友，过年了，要发放 $m(1 \\leq m \\leq 10^5)$次礼物。 每次发放，会给出三个参数 l,r,k$(1 \\leq l \\leq r \\leq n, 1 \\leq k \\leq 10^5)$，表示给区间\\[l,r\\] 内的小朋友都发一个礼物k。 所有礼物发放完成后，对于每一个小朋友，回答他接受的礼物中，出现次数最多的礼物是什么。如果有多个，输出编号最小的那个；如果不存在，输出 -1。\n<!--more-->\n\n### Sample Input\n\n> 6 3 1 5 1 2 3 2 3 4 2\n\n### Sample Output\n\n> 1 1 2 1 1 -1\n\n### Solution\n\n先用扫描线和差分的思想，把修改都拆成在l处+k,在r+1处-k，然后用权值线段树维护权值出现的次数以及最大值即可\n\n### Summary\n\n这道题一开始就是想的权值线段树，但是对权值线段树的认识还停留在只能查第k大上，不知道怎么求最大值。。。现在看来自己就是个傻x然后就不知道该怎么做。\n\n### Code\n```cpp\n    #include <bits/stdc++.h>\n    using namespace std;\n    const int Maxn = 100000 + 100;\n    int N, M, Cnt;\n    struct Tree\n    {\n        int val, id;\n    }Tree[Maxn * 4];\n    \n    vector <int> q[Maxn];\n    \n    inline void push_up (int x)\n    {\n        if (Tree[x << 1].val == Tree[x << 1 | 1].val)\n            Tree[x].val = Tree[x << 1].val, Tree[x].id = min(Tree[x << 1].id, Tree[x << 1 | 1].id);\n        else if (Tree[x << 1].val > Tree[x << 1 | 1].val)\n            Tree[x].val = Tree[x << 1].val, Tree[x].id = Tree[x << 1].id;\n        else Tree[x].val = Tree[x << 1 | 1].val, Tree[x].id = Tree[x << 1 | 1].id;\n    }\n    \n    inline void build (int root, int l, int r)\n    {\n        if (l == r)\n        {\n            Tree[root].id = l;\n            Tree[root].val = 0;\n            return ;\n        }\n        int mid = (l + r) >> 1;\n        build(root << 1, l, mid);\n        build(root << 1 | 1, mid + 1, r);\n        push_up(root);\n    }\n    \n    inline void update (int root, int l, int r, int x, int z)\n    {\n        if (l == r)\n        {\n            Tree[root].val += z;\n            return ;\n        }\n        int mid = (l + r) >> 1;\n        if (x <= mid)\n            update(root << 1, l, mid, x, z);\n        else update(root << 1 | 1, mid + 1, r, x, z);\n        push_up(root);\n    }\n    \n    int main()\n    {\n    #ifdef hk_cnyali\n        freopen(\"A.in\", \"r\", stdin);\n        freopen(\"A.out\", \"w\", stdout);\n    #endif\n        scanf(\"%d%d\", &N, &M);\n        for (int i = 1; i <= M; ++i)\n        {\n            int x, y, z;\n            scanf(\"%d%d%d\", &x, &y, &z);\n            q[x].push_back(z);\n            q[y + 1].push_back(-z);\n        }\n        build(1, 1, 100000);\n        for (int i = 1; i <= N; ++i)\n        {\n            for (int j = 0; j < q[i].size(); ++j)\n            {\n                if (q[i][j] > 0)\n                    update(1, 1, 100000, q[i][j], 1);\n                else update(1, 1, 100000, -q[i][j], -1);\n            }\n            printf(\"%d\\n\", !Tree[1].val ? -1 : Tree[1].id);\n        }\n        return 0;\n    }\n```\n","categories":["Problem"],"tags":["线段树","数据结构","差分","树","扫描线","权值线段树"]},{"title":"「Luogu2633」Count on a tree - 主席树","url":"/2018/02/09/Luogu-P2633-Count-on-a-tree%EF%BC%88%E4%B8%BB%E5%B8%AD%E6%A0%91%EF%BC%89/","content":"\n题目链接：[传送门](https://www.luogu.org/problemnew/show/P2633 \"传送门\")\n\n### Description\n\n给定一棵N个节点的树，每个点有一个权值，对于M个询问(u,v,k)，你需要回答u xor lastans和v这两个节点间第K小的点权。其中lastans是上一个询问的答案，初始为0，即第一个询问的u是明文。\n<!--more-->\n\n### Sample Input\n\n> 8 5 105 2 9 3 8 5 7 7 1 2 1 3 1 4 3 5 3 6 3 7 4 8 2 5 1 0 5 2 10 5 3 11 5 4 110 8 2\n\n### Sample Output\n\n> 2 8 9 105 7\n\n### Solution\n\n主席树裸题，今天刚学的主席树。开始一直RE，后来把根的深度设为1就A掉了。。。\n\n### Code\n```cpp\n    #include <bits/stdc++.h>\n    \n    using namespace std;\n    \n    const int Maxn = 100000 + 100;\n    int N, M;\n    int Root[Maxn], fa[Maxn], lastans, Cnt;\n    int Begin[Maxn * 2], To[Maxn * 2], Next[Maxn * 2], e;\n    int dep[Maxn], anc[Maxn][30], Rank[Maxn];\n    \n    int A[Maxn], Re[Maxn], B[Maxn];\n    \n    struct tree\n    {\n        int lson, rson, val;\n    }Tree[Maxn * 64];\n    \n    inline void add_edge (int x, int y)\n    {\n        To[++e] = y;\n        Next[e] = Begin[x];\n        Begin[x] = e;\n    }\n    \n    inline void build (int &root, int l, int r)\n    {\n        root = ++ Cnt;\n        if (l == r) return ;\n        int mid = (l + r) >> 1;\n        build(Tree[root].lson, l, mid);\n        build(Tree[root].rson, mid + 1, r);\n    }\n    \n    inline void Insert (int pre, int &now, int l, int r, int x)\n    {\n        now = ++ Cnt;\n        Tree[now].lson = Tree[pre].lson;\n        Tree[now].rson = Tree[pre].rson;\n        Tree[now].val = Tree[pre].val + 1;\n        if (l == r) return ;\n        int mid = (l + r) >> 1;\n        if (x <= mid) Insert(Tree[pre].lson, Tree[now].lson, l, mid, x);\n        else Insert(Tree[pre].rson, Tree[now].rson, mid + 1, r, x);\n    }\n    \n    inline void dfs (int x)\n    {\n        Insert(Root[fa[x]], Root[x], 1, N, A[x]);\n        for (int i = 1; i <= 20; ++i)\n            anc[x][i] = anc[anc[x][i - 1]][i - 1];\n        for (int i = Begin[x]; i; i = Next[i])\n        {\n            int y = To[i];\n            if (fa[x] == y) continue;\n            dep[y] = dep[x] + 1;\n            fa[y] = x;\n            anc[y][0] = x;\n            dfs(y);\n        }\n    }\n    \n    inline int lca (int x, int y)\n    {\n        if (dep[x] < dep[y]) swap(x, y);\n        for (int i = 20; i >= 0; --i)\n            if (dep[anc[x][i]] >= dep[y])\n                x = anc[x][i];\n        if (x == y) return x;\n        for (int i = 20; i >= 0; --i)\n            if (anc[x][i] != anc[y][i])\n                x = anc[x][i], y = anc[y][i];\n        return fa[x];\n    }\n    \n    inline int Query (int x, int y, int Lca, int Lca_fa, int l, int r, int d)\n    {\n        if (l == r)\n            return l;\n        int mid = (l + r) >> 1;\n        int left = Tree[Tree[x].lson].val + Tree[Tree[y].lson].val - Tree[Tree[Lca].lson].val - Tree[Tree[Lca_fa].lson].val;\n        if (left >= d)\n            return Query(Tree[x].lson, Tree[y].lson, Tree[Lca].lson, Tree[Lca_fa].lson, l, mid, d);\n        else \n            return Query(Tree[x].rson, Tree[y].rson, Tree[Lca].rson, Tree[Lca_fa].rson, mid + 1, r, d - left);\n    }\n    \n    int main()\n    {\n    #ifdef hk_cnyali\n        freopen(\"A.in\", \"r\", stdin);\n        freopen(\"A.out\", \"w\", stdout);\n    #endif\n        scanf(\"%d%d\", &N, &M);\n        for (int i = 1; i <= N; ++i) scanf(\"%d\", &A[i]), B[i] = A[i];\n        sort(B + 1, B + N + 1);\n        int sz = unique(B + 1, B + N + 1) - B - 1;\n        int tmp;\n        for (int i = 1; i <= N; ++i)tmp = lower_bound(B + 1, B + sz + 1, A[i]) - B, Re[tmp] = A[i], A[i] = tmp;\n        for (int i = 1; i < N; ++i)\n        {\n            int x, y;\n            scanf(\"%d%d\", &x, &y);\n            add_edge(x, y);\n            add_edge(y, x);\n        }\n        build(Root[0], 1, N);\n        dep[1] = 1;\n        dfs(1);\n        for (int i = 1; i <= M; ++i)\n        {\n            int x, y, k;\n            scanf(\"%d%d%d\", &x, &y, &k);\n            x ^= lastans;\n            //v[x] + v[y] - v[Lca] - v[fa[Lca]]\n            int Lca = lca(x, y);\n            lastans = Re[Query(Root[x], Root[y], Root[Lca], Root[fa[Lca]], 1, N, k)];\n            printf(\"%d\\n\", lastans);\n        }\n        return 0;\n    }\n```\n","categories":["Problem"],"tags":["线段树","数据结构","主席树","树","LCA","可持久化"]},{"title":"「AGC007C」Pushing Balls - 概率期望","url":"/2018/02/07/AGC007-C-Pushing-Balls/","content":"\n题目链接：[传送门](https://beta.atcoder.jp/contests/agc007/tasks/agc007_c \"传送门\")\n\n### Description\n\n在一条直线上有 $n$ 个球和 $n + 1$ 个坑共$ 2n + 1$ 个“物品”，$i$ 个球在第$ i$ 和第$i + 1 $个坑之间。 \n\n球与坑之间是有距离的，这些距离组成了首项为 $a$，公差为 $x $的等差数列。\n\n即第i个物品和第 $i + 1$ 个物品之间的距离是 $a + (i − 1)x$。 \n\n小 A 会进行$ n$ 轮操作，每轮操作中，先从剩下的球中等概率地选择一个，然后等概率地选择一个方向，这个球将会朝这个方向滚，直到遇到一个里面没有球的坑并落进去留在里面。\n\n然后这一轮的收益为球滚的距离。 \n\n请求出期望收益。\n<!--more-->\n\n### Hint\n\n1 <= N <= 200000 1 <= a, x <= 100\n\n### Sample Input\n\n> 1 3 3\n\n### Sample Output\n\n> 2 1 0\n\n### Solution\n\n首先把“操作”换一种表述：等概率选择相邻的两个物品，并拿走他们，收益为两物品之间的距离，这样就不必区分球和坑了。\n\n我们会发现，每次操作后的“期望局面”仍然是一个等差数列\n\n记$m$为现在剩下的区间数，一开始$m=2n$，计算得到\n$$\na'=\\frac{(m+2)a+5x}{m}\n$$\n\n\n$$\nx'=\\frac{m+4}{m}x\n$$\n\n\n然后每次$Ans+=\\frac{2a+(m-1)x}{2}​$\n\n这样就能$O(n)$计算了\n\n### Summary\n\n$a'$和$x'$还有$Ans$如何计算开始一直不知道怎么推的，后来自己静下心来画了个图暴力算了下发现居然推出来了。所以以后做题还是不能太浮躁，像这种题要在草稿纸上多验算一下，不能只是在脑海中想一下大概的方法。\n\n### Code\n```cpp\n    #include <bits/stdc++.h>\n    using namespace std;\n    double N;\n    double a, x;\n    int main()\n    {\n    #ifdef hk_cnyali\n        freopen(\"C.in\", \"r\", stdin);\n        freopen(\"C.out\", \"w\", stdout);\n    #endif\n        scanf(\"%lf%lf%lf\", &N, &a, &x);\n        double Ans = 0;\n        double M = 2 * N;\n        while (M)\n        {\n            Ans += (2 * a + (M - 1) * x) / 2;\n            a = ((M + 2) * a + 5 * x ) / M;\n            x = (M + 4) * x / M;\n            M -= 2;\n        }\n        printf(\"%.20lf\\n\", Ans);\n        return 0;\n    }\n```\n","categories":["Problem"],"tags":["数学","概率和期望","agc","Atcoder"]},{"title":"「AGC009C」Division into Two - Dp","url":"/2018/02/06/AGC009-C-Division-into-Two/","content":"\n题目链接：[传送门](https://beta.atcoder.jp/contests/agc009/tasks/agc009_c \"传送门\")\n\n### Description\n\n给你一个长度为N的排好序的数列S和两个数A、B，你需要将这个数列分成两组，第一组中任意两个数的差要大于等于A，第二组中任意两个数的差要大于等于B，求方案数(Mod 1e9 + 7)\n<!--more-->\n\n### Hint\n\n1 <= N <= 1e5 1 <= A, B, Si <= 1e18\n\n### Sample Input\n\n> 5 3 7 1 3 6 9 12\n\n### Sample Output\n\n> 5\n\n### Solution\n\n很容易想到一个Dp，设Dp1\\[i\\]\\[j\\]表示第i个数被分到第1组中，另外一组最后一个数的位置为j时的方案数,Dp2\\[i\\]\\[j\\]的定义类似。\n那么有$Dp1\\\\[i+1\\]\\[j\\]+=Dp1\\[i\\]\\[j\\]\\(S\\[i+1\\]-S\\[i\\]>=A)$，$Dp2\\[i+1\\]\\[i\\]+=Dp1\\[i\\]\\[j\\](S\\[i+1\\]-S\\[j\\]>=B)$\n但是这是N^2的Dp。\n我们可以用树状数组优化，只是要注意清空的时候不能用memset，会超时。\n由于每次加入树状数组中的元素不多，直接把修改过的元素记录下来直接赋0即可\n\n### Summary\n\n这道题调了一下午，最后是写了个暴力写到一半才发现的错误。代码能力要提高，然后memset不能乱用\n\n### Code\n```cpp\n    #include <bits/stdc++.h>\n    #define LL long long\n    using namespace std;\n    const int Maxn = 100000 + 100, Mod = 1e9 + 7;\n    int N;\n    LL A, B;\n    LL S[Maxn];\n    int Sum1[Maxn], Sum2[Maxn];\n    int Cnt1, Cnt2, Vis1[Maxn * 10], Vis2[Maxn * 10];\n    \n    inline int lowbit (int x) {return x & (-x);}\n    \n    inline void Update1 (int x, LL d)\n    {\n        ++x;\n        while (x <= (N + 1))\n        {\n            (Sum1[x] += d) %= Mod;\n            Vis1[++Cnt1] = x;\n            x += lowbit(x);\n        }\n    }\n    \n    inline void Update2 (int x, int d)\n    {\n        ++x;\n        while (x <= (N + 1))\n        {\n            (Sum2[x] += d) %= Mod;\n            Vis2[++Cnt2] = x;\n            x += lowbit(x);\n        }\n    }\n    \n    inline int Query1 (int x)\n    {\n        int Ans = 0;\n        ++x;\n        while (x)\n        {\n            (Ans += Sum1[x]) %= Mod;\n            x -= lowbit(x);\n        }\n        return Ans;\n    }\n    \n    inline int Query2 (int x)\n    {\n        int Ans = 0;\n        ++x;\n        while (x)\n        {\n            (Ans += Sum2[x]) %= Mod;\n            x -= lowbit(x);\n        }\n        return Ans;\n    }\n    \n    int main()\n    {\n    #ifdef hk_cnyali\n        freopen(\"C.in\", \"r\", stdin);\n        freopen(\"C.out\", \"w\", stdout);\n    #endif\n        scanf(\"%d%lld%lld\", &N, &A, &B);\n        for (int i = 1; i <= N; ++i) scanf(\"%lld\", &S[i]);\n        S[0] = -0x3f3f3f3f3f3f3f3f;\n        Update1(0, 1);\n        Update2(0, 1);\n        for (int i = 1; i < N; ++i)\n        {\n            int l = 0, r = i, Ans1 = 0, Ans2 = 0;\n            while (l <= r)\n            {\n                int mid = (l + r) >> 1;\n                if (S[mid] <= S[i + 1] - B) l = mid + 1, Ans1 = mid;\n                else r = mid - 1;\n            }\n            l = 0, r = i;\n            while (l <= r)\n            {\n                int mid = (l + r) >> 1;\n                if (S[mid] <= S[i + 1] - A) l = mid + 1, Ans2 = mid;\n                else r = mid - 1;\n            }\n            //cout<<i + 1<<\" \"<<Ans1<<\" \"<<Ans2<<endl;\n            int SUM1 = Query1(Ans1);\n            int SUM2 = Query2(Ans2);\n            if (S[i + 1] - S[i] < A)\n                while (Cnt1)\n                    Sum1[Vis1[Cnt1--]] = 0;\n                //memset(Sum1, 0, sizeof(Sum1));\n            if (S[i + 1] - S[i] < B)\n                while (Cnt2)\n                    Sum2[Vis2[Cnt2--]] = 0;\n                //memset(Sum2, 0, sizeof(Sum2));\n            Update2(i, SUM1);\n            Update1(i, SUM2);\n            //Ans += Query1(i + 1) + Query2(i + 1);\n        }\n        printf(\"%d\\n\", (Query1(N) + Query2(N)) % Mod);\n        return 0;\n    }\n```\n","categories":["Problem"],"tags":["动态规划","agc","Atcoder"]},{"title":"「AGC006C」Rabbit Exercise - 概率期望","url":"/2018/02/05/AGC006-C-Rabbit-Exercise/","content":"\n题目链接：[传送门](https://beta.atcoder.jp/contests/agc006/tasks/agc006_c \"传送门\")\n\n### Description\n\n数轴上有n只兔子，第i只兔子的坐标为xi。 有一组操作，这组操作的第i个操作是要让第ai只兔子等概率的跳到自己关于第ai+1或第ai-1只兔子的对称点。 进行K组操作，求每只兔子最后坐标的期望值。\n\n<!--more-->\n\n### Hint\n\nN, M <= 1e5, K <= 1e18\n\n### Sample Input\n\n> 3 -1 0 2 1 1 2\n\n### Sample Output\n\n> -1.0 1.0 2.0\n\n### Solution\n\n我们可以把每个点直接跳到进行一次操作后期望到达的点（利用了期望的线性），\n\n那么 $a_x = \\frac{1}{2} (2a_{x - 1} - a_x) + \\frac{1}{2} (2a_{x + 1} - a_x) = a_{x + 1} + a_{x - 1} - a_x$ \n\n如果我们把原序列做一个差分的话 \n\n$a_{x - 1}, a_x, a_{x + 1}$---------------------------> $a_{x - 1} - a_{x - 2}, a_x - a_{x - 1}, a_{x + 1} - a_x$ \n\n$a_{x - 1}, a_{x + 1} + a_{x - 1} - a_x, a_{x + 1}$ ---> $a_{x - 1} - a_{x - 2}, a_{x + 1} - a_x, a_x - a_{x - 1}$ \n\n就能发现实际上就是把$x$和$x + 1$交换了位置 \n\n然后我们用一个数组记录一下位置即可 \n\n对于$K\\le10^{18}$，我们可以用一个类似快速幂的东西（或者说是倍增）去做\n\n里面有个小细节就是每次更新数组的时候要先用`Tmp`数组存一下，然后再复制到原数组上，否则有可能跳来跳去\n\n出问题 \n\n还有就是要开`long long`，`int`会炸\n\n### Summary\n\n这道题早就听说过了特别难，今天自己做的话显然是看了题解的。自己做的时候就完全没有一点头绪，开始想到了对于每次操作可以直接跳到期望的那个点，但是不知道怎么处理那么大的K。这道题也算是积累一个方法吧。\n\n### Code\n```cpp\n    #include <bits/stdc++.h>\n    #define LL long long\n    using namespace std;\n    const LL Maxn = 100000 + 100;\n    LL A[Maxn], d[Maxn], P[Maxn];\n    LL Tmp[Maxn], Ans[Maxn];\n    LL N, M;\n    LL K;\n    inline void Pow()\n    {\n        LL b = K;\n        for (LL i = 1; i <= N; ++i) Ans[i] = i;\n        while (b)\n        {\n            if (b & 1)\n            {\n                for (LL i = 1; i <= N; ++i) Tmp[i] = Ans[P[i]];\n                for (LL i = 1; i <= N; ++i) Ans[i] = Tmp[i];\n            }\n            for (LL i = 1; i <= N; ++i) Tmp[i] = P[P[i]];\n            for (LL i = 1; i <= N; ++i) P[i] = Tmp[i];\n            b >>= 1;\n        }\n        for (LL i = 1; i <= N; ++i) Tmp[i] = d[Ans[i]];\n        for (LL i = 1; i <= N; ++i) d[i] = Tmp[i];\n    }\n    int main()\n    {\n    #ifdef hk_cnyali\n        freopen(\"C.in\", \"r\", stdin);\n        freopen(\"C.out\", \"w\", stdout);\n    #endif\n        scanf(\"%lld\", &N);\n        for (LL i = 1; i <= N; ++i)\n            scanf(\"%lld\", &A[i]), d[i] = A[i] - A[i - 1];\n        scanf(\"%lld %lld\", &M, &K);\n        for (LL i = 1; i <= N; ++i) P[i] = i;\n        for (LL i = 1; i <= M; ++i)\n        {\n            LL x; scanf(\"%lld\", &x);\n            swap(P[x], P[x + 1]);\n        }\n        Pow();\n        LL Sum = 0;\n        for (LL i = 1; i <= N; ++i)\n        {\n            Sum += d[i];\n            cout<<Sum<<endl;\n        }\n        return 0;\n    }\n```\n","categories":["Problem"],"tags":["概率和期望","agc","Atcoder"]},{"title":"「AGC006B」Median Pyramid Easy - 构造","url":"/2018/02/05/AGC006-B-Median-Pyramid-Easy/","content":"\n题目链接：[传送门](https://beta.atcoder.jp/contests/agc006/tasks/agc006_b \"传送门\")\n\n### Description\n\nWe have a pyramid with N steps, built with blocks. The steps are numbered 1 through N from top to bottom. For each 1≤i≤N, step i consists of 2i−1 blocks aligned horizontally. The pyramid is built so that the blocks at the centers of the steps are aligned vertically. Snuke wrote a permutation of (1, 2, …, 2N−1) into the blocks of step N. Then, he wrote integers into all remaining blocks, under the following rule: The integer written into a block b must be equal to the median of the three integers written into the three blocks directly under b, or to the lower left or lower right of b. ![](https://atcoder.jp/img/agc006/a940f1d8303f255e1f91d17a5696633f.png) Writing integers into the blocks Afterwards, he erased all integers written into the blocks. Now, he only remembers that the integer written into the block of step 1 was x. Construct a permutation of (1, 2, …, 2N−1) that could have been written into the blocks of step N, or declare that Snuke's memory is incorrect and such a permutation does not exist.\n\n<!--more-->\n### Hint\n\n2 <= N <= 1e5 1 <= x <= 2 * N - 1\n\n### Sample Input\n\n> 4 4\n\n### Sample Output\n\n> Yes 1 6 3 7 4 5 2\n\n### Solution\n\n这题懒得翻译了，就是从下往上填格子，每个格子取它下面三个格子的中位数 显然当$x==1$或$x==2N - 1$ 时无解 然后如果$x!=2$ 并且 $x!= 2N - 2$的话我们可以把x放在正中间，然后把与它差的绝对值不超过2的数分列它的两侧，即x+2 x-1 x x+1 x-2这样放置。那么这样便在上一层可以产生三个相同的x，依次推上去的话一定是x 当$x==2$或$x==2N-2$时，用类似的方法能在上一层构造出两个x，这样也能使最顶端为x\n\n### Summary\n\n太难得能不看题解做出来一道构造题了。做这道题的时候开始思路还不是很清晰，然后尝试模拟了几组数据之后就发现了规律。以后还是要忍着不能看题解\n\n### Code\n```cpp\n    #include <bits/stdc++.h>\n    using namespace std;\n    int N, x;\n    int P[1000000 + 100];\n    int main()\n    {\n    #ifdef hk_cnyali\n        freopen(\"B.in\", \"r\", stdin);\n        freopen(\"B.out\", \"w\", stdout);\n    #endif\n        scanf(\"%d%d\", &N, &x);\n        if (x >= 2 * N - 1 || x <= 1)\n        {\n            cout<<\"No\"<<endl;\n            return 0;\n        }\n        int l = x - 2, r = x + 2, flag = 0; \n        if (x == 2)\n        {\n            l = 1, r = 5;\n            flag = 1;\n            if (2 * N - 1 < 5)\n            {\n                if (x == 2)\n                {\n                    cout<<\"Yes\"<<endl;\n                    printf(\"1\\n2\\n3\\n\");\n                }\n                else\n                    cout<<\"No\"<<endl;\n                return 0;\n            }\n        }\n        if (x == 2 * N - 2)\n        {\n            l = 2 * N - 5, r = 2 * N - 1;\n            flag = 2;\n            if (l < 1)\n            {\n                if (x == 2)\n                {\n                    cout<<\"Yes\"<<endl;\n                    printf(\"1\\n2\\n3\\n\");\n                }\n                else\n                    cout<<\"No\"<<endl;\n    \n                return 0;\n            }\n        }\n        cout<<\"Yes\"<<endl;\n        for (int i = 1, Cnt = 1; i <= 2 * N - 1, Cnt <= (N - 3); ++i)\n            if (i >= l && i <= r) continue;\n            else cout<<i<<endl, P[i] = 1, ++Cnt;\n        if (flag == 1)\n            printf(\"5\\n1\\n2\\n3\\n4\\n\");\n        else if (flag == 2)\n        {\n            int m = 2 * N - 1;\n            printf(\"%d\\n%d\\n%d\\n%d\\n%d\\n\", m - 3, m, m - 1, m - 2, m - 4);\n        }\n        else \n            cout<<x + 2<<endl<<x - 1<<endl<<x<<endl<<x + 1<<endl<<x - 2<<endl;\n        //cout<<r<<endl<<l + 1<<endl<<l + 2<<endl<<r - 1<<endl<<l<<endl;\n        for (int i = 1, Cnt = 1; i <= 2 * N - 1, Cnt <= (N - 3); ++i)\n            if ((i >= l && i <= r) || P[i]) continue;\n            else cout<<i<<endl, ++Cnt;\n        return 0;\n    }\n```\n","categories":["Problem"],"tags":["构造","agc","Atcoder"]},{"title":"「AGC005B」Minimum Sum","url":"/2018/02/05/AGC005-B-Minimum-Sum/","content":"\n题目链接：[传送门](https://beta.atcoder.jp/contests/agc005/tasks/agc005_b \"传送门\")\n\n### Description\n\n给你一个N的排列，求![](http://hk-cnyali.com/wp-content/uploads/2018/02/520049e1a049bb9810b398b35d7dcb7f-300x75.png) \n<!--more-->\n\n### Hint\n\n1<=N<=2e5\n\n### Sample Input\n\n> 3 2 1 3\n\n### Sample Output\n\n> 9\n\n### Solution\n\n我的做法好像和网上的不一样。。。 通过找规律观察可以发现每一个数的贡献为这个数的值*前面第一个比它小的数到它的距离*后面第一个比它小的数到它的距离 然后就是要预处理出它前面/后面第一个比它小的数的位置 这个东西我是直接暴力往前跳的，感性理解好像复杂度有保证，但是还不会证明。。。\n\n### Summary\n\n这道B题想了我一个上午，看来还是太弱了 一开始思路很乱，感觉想不出，不过幸好没看题解，不然又错过了一次锻炼思维的机会 虽然花了这么久才做出来，但是至少没看题解，所以还是有收获的\n\n### Code\n```cpp\n    #include <bits/stdc++.h>\n    #define LL long long\n    using namespace std;\n    const int Maxn = 200000 + 100;\n    int N;\n    int A[Maxn], Next[Maxn], Pre[Maxn];\n    int main()\n    {\n    #ifdef hk_cnyali\n        freopen(\"B.in\", \"r\", stdin);\n        freopen(\"B.out\", \"w\", stdout);\n    #endif\n        scanf(\"%d\", &N);\n        for (int i = 1; i <= N; ++i) scanf(\"%d\", &A[i]);\n        for (int i = 2; i <= N; ++i)\n        {\n            if (A[i - 1] < A[i])\n            {\n                Pre[i] = i - 1;\n                continue;\n            }\n            else \n            {\n                int now = i - 1;\n                while (now && A[now] > A[i])\n                    now = Pre[now];\n                Pre[i] = now;\n            }\n        }\n        Next[N] = N + 1;\n        for (int i = N - 1; i >= 1; --i)\n        {\n            if (A[i + 1] < A[i])\n            {\n                Next[i] = i + 1;\n                continue;\n            }\n            else \n            {\n                int now = i + 1;\n                while (now && A[now] > A[i])\n                    now = Next[now];\n                Next[i] = now;\n            }\n        }\n        LL Ans = 0;\n        for (int i = 1; i <= N; ++i)\n            Ans += (LL)(1ll * A[i] * (i - Pre[i]) * (Next[i] - i));\n        cout<<Ans<<endl;\n        return 0;\n    }\n```\t\n","categories":["Problem"],"tags":["agc","Atcoder"]},{"title":"「AGC004C」AND Grid - 构造","url":"/2018/02/04/AGC004-C-AND-Grid-%E6%9E%84%E9%80%A0/","content":"\n### Description\n\n有两张n * m的图，一张上有一个红色四连通块，另一张上有一个蓝色四连通块，两张重叠在一起生成新图，规则是若某格既有红色又有蓝色便染成紫色，否则不染色。保证最边缘的一圈没有紫色格。现在给出新图，问红蓝染色的一种可行方案。\n\n<!--more-->\n\n### Hint\n\nH, W <= 500\n\n### Sample Input\n\n> 5 5 ..... .#.#. ..... .#.#. .....\n\n### Sample Output\n\n> ..... ##### #.... ##### ..... .###. .#.#. .#.#. .#.#. .....\n\n### Solution\n\n我们把除了第一行和最后一行的位置用红色和蓝色交替涂，列为奇数的涂红色，偶数的涂蓝色，然后在第一行全涂红色，最后一行全涂蓝色即可\n\n### Summary\n\n构造题还是太弱了，开始思考的时候一直在想一种颜色横着搞，另一种颜色竖着搞，发现根本不能满足要求，然后一直在死磕怎么把已经涂过的路线绕开。。。 以后做这种构造题的时候思路还要更加开阔，不能只按照题目的要求去模拟，往往要跳出那个思维定势才能想到正确的做法\n\n### Code\n```cpp\n    #include <bits/stdc++.h>\n    using namespace std;\n    const int Maxn = 500 + 100;\n    int A[Maxn][Maxn];\n    int N, M;\n    char safe_getchar()\n    {\n        char ch = getchar();\n        while (ch != '#' && ch != '.') ch = getchar();\n        return ch;\n    }\n    int main()\n    {\n    #ifdef hk_cnyali\n        freopen(\"C.in\", \"r\", stdin);\n        freopen(\"C.out\", \"w\", stdout);\n    #endif\n        scanf(\"%d%d\", &N, &M);\n        for (int i = 1; i <= N; ++i)\n            for (int j = 1; j <= M; ++j)\n            {\n                char c = safe_getchar();\n                if (c == '#') A[i][j] = 1;\n            }\n        for (int i = 1; i <= N; ++i)\n        {\n            for (int j = 1; j <= M; ++j)\n                if ((i == 1 || (j & 1) || A[i][j] == 1) && i != N)\n                    cout<<\"#\";\n                else cout<<\".\";\n            cout<<endl;\n        }\n        cout<<endl;\n        for (int i = 1; i <= N; ++i)\n        {\n            for (int j = 1; j <= M; ++j)\n                if ((i == N || !(j & 1) || A[i][j] == 1) && i != 1)\n                    cout<<\"#\";\n                else cout<<\".\";\n            cout<<endl;\n        }\n        return 0;\n    }\n```\n","categories":["Problem"],"tags":["构造","agc","Atcoder"]},{"title":"「AGC004B」Colorful Slimes","url":"/2018/02/03/AGC004-B-Colorful-Slimes/","content":"\n题目链接：[传送门](https://beta.atcoder.jp/contests/agc004/tasks/agc004_b \"传送门\")\n\n### Description\n\n给你一个长为n的序列要填满，已知填上第i个数花费的代价为ai，把当前序列循环右移一位花费的代价为x，求最小代价。\n\n<!--more-->\n\n### Hint\n\nN <= 2000, ai <= 10^9, x <= 10^9\n\n### Input\n\nN x a1 a2 ... aN\n\n### Output\n\nFind the minimum time that Snuke needs to have slimes in all N colors.\n\n### Sample Input\n\n> 2 10 1 100\n\n### Sample Output\n\n> 12\n\n### Solution\n\n这道题想了很久没想出来，看了题解，发现自己完全想错了。。。 我们可以枚举最多循环向后移动i次，那么对于每一个j来说，它一定是从它前面i个数中最小的那一个转移过来，预处理一个区间最小值即可\n\n### Summary\n\n这种题的套路还是不是很熟悉\n\n###### 听sxy说这种N^2的题的套路一般都是先O（N）枚举一个东西，然后再O（N）去计算答案。然后一些数据范围更大的题就是O（1）或者log去计算答案。这道题就当做是一个积累，以后做题的时候要往这方面想\n\n### Code\n```cpp\n    #include <bits/stdc++.h>\n    #define LL long long\n    using namespace std;\n    const int Maxn = 2000 + 100;\n    int N;\n    LL M;\n    LL A[Maxn], Min[Maxn][Maxn];\n    int main()\n    {\n    #ifdef hk_cnyali\n        freopen(\"B.in\", \"r\", stdin);\n        freopen(\"B.out\", \"w\", stdout);\n    #endif\n        scanf(\"%d%lld\", &N, &M);\n        for (int i = 1; i <= N; ++i) scanf(\"%lld\", &A[i]);\n        for (int i = 1; i <= N; ++i) Min[i][i] = A[i];\n        for (int i = 1; i <= N; ++i)\n            for (int j = i + 1; j <= N; ++j)\n                Min[i][j] = min(Min[i][j - 1], A[j]);\n        LL Ans = 0x3f3f3f3f3f3f3f3f;\n        for (int i = 0; i < N; ++i)\n        {\n            LL Sum = i * M;\n            for (int j = 1; j <= N; ++j)\n                if (j > i) Sum += Min[j - i][j];\n                else Sum += min(Min[1][j], Min[j - i + N][N]);\n            Ans = min(Ans, Sum);\n        }\n        cout<<Ans<<endl;\n        return 0;\n    }\n```\n","categories":["Problem"],"tags":["agc","Atcoder"]},{"title":"「AGC002C」Knot Puzzle","url":"/2018/02/02/AGC-002-C-Knot-Puzzle/","content":"\n题目链接：[传送门](https://beta.atcoder.jp/contests/agc002/tasks/agc002_c \"传送门\")\n\n### Description\n\nWe have N pieces of ropes, numbered 1 through N. The length of piece i is ai. At first, for each i(1≤i≤N−1), piece i and piece i+1 are tied at the ends, forming one long rope with N−1 knots. Snuke will try to untie all of the knots by performing the following operation repeatedly: Choose a (connected) rope with a total length of at least L, then untie one of its knots. Is it possible to untie all of the N−1 knots by properly applying this operation? If the answer is positive, find one possible order to untie the knots.\n<!--more-->\n\n### Hint\n\n2≤N≤105 1≤L≤109 1≤ai≤109 All input values are integers.\n\n### Input\n\nN L a1 a2 ... an\n\n### Output\n\nIf it is not possible to untie all of the N−1 knots, print Impossible. If it is possible to untie all of the knots, print Possible, then print another N−1 lines that describe a possible order to untie the knots. The j-th of those N−1 lines should contain the index of the knot that is untied in the j-th operation. Here, the index of the knot connecting piece i and piece i+1 is i. If there is more than one solution, output any.\n\n### Sample Input\n\n> 3 50 30 20 10\n\n### Sample Output\n\n> Possible 2 1\n\n### Solution\n\n看了正解，发现自己是个傻x 一个类似于暴力的算法，然后加了一些玄学的暴力 直接放代码算了\n\n### Code\n```cpp\n    #include <bits/stdc++.h>\n    #define LL long long\n    using namespace std;\n    const LL Maxn = 1000000 + 100;\n    LL N, M;\n    LL Ans[Maxn];\n    struct node\n    {\n        LL id, val;\n    }A[Maxn];\n    int main()\n    {\n    #ifdef hk_cnyali\n        freopen(\"C.in\", \"r\", stdin);\n        freopen(\"C.out\", \"w\", stdout);\n    #endif\n        scanf(\"%lld%lld\", &N, &M);\n        LL k = 0ll;\n        for (LL i = 1ll; i <= N; ++i)\n        {\n            scanf(\"%lld\", &A[i].val), A[i].id = i;\n            if (A[i].val > A[k].val) k = i;\n        }\n        LL Cnt = N, sum = 0ll;\n        while (Cnt > 1ll)\n        {\n            LL fl = 0ll;\n            if (k <= Cnt / 2)\n            {\n                k = 0ll;\n                for (LL i = 1ll; i < Cnt; ++i)\n                {\n                    if (A[i].val + A[i + 1ll].val >= M)\n                    {\n                        Ans[++sum] = A[i + 1].id - 1;\n                        fl = 1ll;\n                        A[i + 1ll].val += A[i].val;\n                        A[i].val = 0ll;\n                        //A[i + 1ll].id = A[i].id;\n                    }\n                }\n            }\n            else \n            {\n                k = 0ll;\n                for (LL i = Cnt; i > 1ll; --i)\n                {\n                    if (A[i].val + A[i - 1ll].val >= M)\n                    {\n                        Ans[++sum] = A[i - 1].id;\n                        fl = 1ll;\n                        A[i - 1ll].val += A[i].val;\n                        A[i].val = 0ll;\n                        //A[i - 1ll].id = A[i].id;\n                        //A[i + 1ll].id = A[i].id;\n                    }\n                }\n            }\n            if (!fl)\n            {\n                cout<<\"Impossible\"<<endl;\n                return 0;\n            }\n            LL tmp = Cnt;\n            Cnt = 0ll;\n            for (LL i = 1ll; i <= tmp; ++i)\n                if (A[i].val) A[++Cnt].val = A[i].val, A[Cnt].id = A[i].id;\n            for (LL i = 1ll; i <= Cnt; ++i)\n                if (A[i].val > A[k].val) k = i;\n        }\n        cout<<\"Possible\"<<endl;\n        for (LL i = sum; i >= 1ll; --i)\n            cout<<Ans[i]<<endl;\n        return 0;\n    }\n```\n","categories":["Problem"],"tags":["agc","Atcoder"]},{"title":"「AGC001C」Shorten Diameter","url":"/2018/02/02/AGC001-C-Shorten-Diameter/","content":"\n题目链接： [传送门](https://beta.atcoder.jp/contests/agc001/tasks/agc001_c \"传送门\")\n\n### Description\n\nGiven an undirected tree, let the distance between vertices u and v be the number of edges on the simple path from u to v. The diameter of a tree is the maximum among the distances between any two vertices. We will call a tree good if and only if its diameter is at most K. You are given an undirected tree with N vertices numbered 1 through N. For each i(1≦i≦N−1), there is an edge connecting vertices Ai and Bi. You want to remove zero or more vertices from the tree, so that the resulting tree is good. When a vertex is removed, all incident edges will also be removed. The resulting graph must be connected. Find the minimum number of vertices that you need to remove in order to produce a good tree.\n\n<!--more-->\n### Hint\n\n2≦N≦2000 1≦K≦N−1 1≦Ai≦N,1≦Bi≦N The graph defined by Ai and Bi is a tree.\n\n### Input\n\nN K A1 B1 A2 B2 : AN−1 BN−1\n\n### Output\n\nPrint the minimum number of vertices that you need to remove in order to produce a good tree.\n\n### Sample Input\n\n> 6 2 1 2 3 2 4 2 1 6 5 6\n\n### Sample Output\n\n> 2\n\n### Translation\n\n给你一棵树，问你至少要删掉多少个点才能使得树的直径小于等于K（剩下的点必须连通）\n\n### Solution\n\n我们考虑最后形成的树，如果这棵树的直径(设为D)为偶数，那么一定存在一个点使得这个点到其他任意点的距离小于等于D/2；如果D为奇数，那么一定存在一条边使得这条边到其他点的距离小于等于(D-1)/2 然后我们枚举这个点或者这条边即可\n\n### Summary\n\n一开始做这道题的时候D为奇数时搞错了，拍了6万多组数据才拍出错。。。 感觉做题的时候思路还不是很清晰，没有完全想清楚就开始打程序，导致D为奇数时处理错了，以后应该多分析再动手。\n\n### Code\n```cpp\n    #include <bits/stdc++.h>\n    using namespace std;\n    const int Maxn = 4000 + 100;\n    int Begin[Maxn], To[Maxn], Next[Maxn], e;\n    int Sum[Maxn], Dep[Maxn];\n    int N, K, Maxdep;\n    \n    inline void add_edge(int x, int y)\n    {\n        To[++e] = y;\n        Next[e] = Begin[x];\n        Begin[x] = e;\n    }\n    \n    inline void dfs (int x, int fa)\n    {\n        Maxdep = max(Maxdep, Dep[x]);\n        Sum[Dep[x]] ++;\n        for (int i = Begin[x]; i; i = Next[i])\n        {\n            int y = To[i];\n            if (y == fa) continue;\n            Dep[y] = Dep[x] + 1;\n            dfs(y, x);\n        }\n    }\n    \n    int main()\n    {\n    #ifdef hk_cnyali\n        freopen(\"C.in\", \"r\", stdin);\n        freopen(\"C.out\", \"w\", stdout);\n    #endif\n        scanf(\"%d%d\", &N, &K);\n        for (int i = 1; i < N; ++i)\n        {\n            int x, y;\n            scanf(\"%d%d\", &x, &y);\n            add_edge(x, y);\n            add_edge(y, x);\n        }\n        int Ans = 0x3f3f3f3f;\n        for (int i = 1; i <= N; ++i)\n        {\n            memset(Sum, 0, sizeof(Sum));\n            memset(Dep, 0, sizeof(Dep));\n            Maxdep = 0;\n            dfs(i, 0);\n            int Cnt = 0;\n            for (int j = K / 2 + 1; j <= Maxdep; ++j)\n                Cnt += Sum[j];\n            int Maxsize = 0;\n            if (!(K & 1))Ans = min(Ans, Cnt);\n            else \n            {\n                for (int j = Begin[i]; j; j = Next[j])\n                {\n                    int y = To[j];\n                    int tmp = 0;\n                    memset(Sum, 0, sizeof(Sum));\n                    memset(Dep, 0, sizeof(Dep));\n                    Maxdep = 0;\n                    dfs(i, y);\n                    for (int k = K / 2 + 1; k <= Maxdep; ++k)\n                        tmp += Sum[k];\n                    memset(Sum, 0, sizeof(Sum));\n                    memset(Dep, 0, sizeof(Dep));\n                    Maxdep = 0;\n                    dfs(y, i);\n                    for (int k = K / 2 + 1; k <= Maxdep; ++k)\n                        tmp += Sum[k];\n                    Ans = min(Ans, tmp);\n                }\n            }\n        }\n        cout<<Ans<<endl;\n        return 0;\n    }\n```\n","categories":["Problem"],"tags":["树","agc","Atcoder"]},{"title":"「AGC008B」Contiguous Repainting - 前缀和","url":"/2018/01/29/AGC008-B-Contiguous-Repainting/","content":"\n题目链接：[传送门](https://beta.atcoder.jp/contests/agc008/tasks/agc008_b \"传送门\")\n\n### Description\n\nThere are N squares aligned in a row. The i-th square from the left contains an integer ai. Initially, all the squares are white. Snuke will perform the following operation some number of times: Select K consecutive squares. Then, paint all of them white, or paint all of them black. Here, the colors of the squares are overwritten. After Snuke finishes performing the operation, the score will be calculated as the sum of the integers contained in the black squares. Find the maximum possible score.、\n<!--more-->\n\n### Input\n\nThe input is given from Standard Input in the following format:\n\n> N K a1 a2... aN\n\n### Output\n\nPrint the maximum possible score.\n\n### Sample Input\n\n> 10 5 5 -4 -5 -8 -4 7 2 -4 0 7\n\n### Sample Output\n\n> 17\n\n### Solution\n\n开始看错题了，以为是把颜色翻转，还感觉这道题特别难。。。\n我们可以发现如果将一段长度为K的相同颜色的区间看作中转站的话，那么其他的点一定都能够取到。\n然后枚举一下这些区间，维护一下所有数的前缀和和所有正数的前缀和，取个max即可\n\n### Code\n```cpp\n    #include <bits/stdc++.h>\n    #define LL long long\n    using namespace std;\n    const int Maxn = 100000 + 100;\n    LL A[Maxn], Sum1[Maxn], Sum2[Maxn];\n    LL N, K;\n    int main()\n    {\n    #ifdef hk_cnyali\n        freopen(\"B.in\", \"r\", stdin);\n        freopen(\"B.out\", \"w\", stdout);\n    #endif\n        scanf(\"%lld%lld\", &N, &K);\n        for (LL i = 1; i <= N; ++i)\n        {\n            scanf(\"%lld\", &A[i]);\n            Sum1[i] = Sum1[i - 1] + A[i];\n            if (A[i] > 0) Sum2[i] = Sum2[i - 1] + A[i];\n            else Sum2[i] = Sum2[i - 1];\n        }\n        LL Ans = 0ll;\n        for (LL i = 1; i + K - 1 <= N; ++i)\n        {\n            LL Sum = Sum2[N] - (Sum2[i + K - 1] - Sum2[i - 1]);\n            if (Sum1[i + K - 1] - Sum1[i - 1] > 0) Sum += Sum1[i + K - 1] - Sum1[i - 1];\n            Ans = max(Ans, Sum);\n        }\n        cout<<Ans<<endl;\n        return 0;\n    }\n```\n","categories":["Problem"],"tags":["前缀和","agc","Atcoder"]},{"title":"「POJ2398」Toy Storage - 叉积 + 二分","url":"/2018/01/28/POJ2398-Toy-Storage-%E5%8F%89%E7%A7%AF-%E4%BA%8C%E5%88%86/","content":"\n题目链接：[传送门](http://poj.org/problem?id=2398 \"传送门\")\n\n### Description\n\nMom and dad have a problem: their child, Reza, never puts his toys away when he is finished playing with them. They gave Reza a rectangular box to put his toys in. Unfortunately, Reza is rebellious and obeys his parents by simply throwing his toys into the box. All the toys get mixed up, and it is impossible for Reza to find his favorite toys anymore. Reza's parents came up with the following idea. They put cardboard partitions into the box. Even if Reza keeps throwing his toys into the box, at least toys that get thrown into different partitions stay separate. The box looks like this from the top: We want for each positive integer t, such that there exists a partition with t toys, determine how many partitions have t, toys.\n<!--more-->\n\n### Input\n\nThe input consists of a number of cases. The first line consists of six integers n, m, x1, y1, x2, y2. The number of cardboards to form the partitions is n (0 < n <= 1000) and the number of toys is given in m (0 < m <= 1000). The coordinates of the upper-left corner and the lower-right corner of the box are (x1, y1) and (x2, y2), respectively. The following n lines each consists of two integers Ui Li, indicating that the ends of the ith cardboard is at the coordinates (Ui, y1) and (Li, y2). You may assume that the cardboards do not intersect with each other. The next m lines each consists of two integers Xi Yi specifying where the ith toy has landed in the box. You may assume that no toy will land on a cardboard. A line consisting of a single 0 terminates the input.\n\n### Output\n\nFor each box, first provide a header stating \"Box\" on a line of its own. After that, there will be one line of output per count (t > 0) of toys in a partition. The value t will be followed by a colon and a space, followed the number of partitions containing t toys. Output will be sorted in ascending order of t for each box.\n\n### Sample Input\n\n> 4 10 0 10 100 0 20 20 80 80 60 60 40 40 5 10 15 10 95 10 25 10 65 10 75 10 35 10 45 10 55 10 85 10 5 6 0 10 60 0 4 3 15 30 3 1 6 8 10 10 2 1 2 8 1 5 5 5 40 10 7 9 0\n\n### Sample Output\n\n> Box 2: 5 Box 1: 4 2: 1\n\n### Translation\n\n大意就是给定一个盒子，其中有n个隔板分成n+1个格子，给出m个点，问每个格子内的点的个数\n\n### Solution\n\n一道比较简单的题目。我们只要将隔板排序后，二分地去找每个点所在位置，用叉积的正负判断位置关系即可\n\n### Code\n```cpp\n    #include <iostream>\n    #include <cstdio>\n    #include <cstring>\n    #include <cmath>\n    #include <algorithm>\n    #define x1 X1\n    #define x2 X2\n    #define y1 Y1\n    #define y2 Y2\n    using namespace std;\n    const int Maxn = 1000 + 10;\n    int N, M, x1, x2, y1, y2;\n    struct Point\n    {\n        int x, y;\n    };\n    struct Line\n    {\n        Point a, b;\n    }A[Maxn];\n    \n    inline int cmp (Line u, Line v)\n    {\n        return u.a.x < v.a.x;\n    }\n    int Sum[Maxn], Ans[Maxn];\n    \n    inline int Check(int x, int y, int now)\n    {\n        Point AA, B;\n        AA.x = A[now].b.x - x;\n        AA.y = A[now].b.y - y;\n        B.x = - A[now].a.x + A[now].b.x;\n        B.y = - A[now].a.y + A[now].b.y;\n        if ((AA.x * B.y - B.x * AA.y) >= 0) return 1;\n        return 0;\n    }\n    \n    inline void Find(int x, int y)\n    {\n        int l = 1, r = N, pos = 0;\n        while (l <= r)\n        {\n            int mid = (l + r) >> 1;\n            if (Check(x, y, mid)) l = mid + 1, pos = mid;\n            else r = mid - 1;\n        }\n        Sum[pos] ++;\n    }\n    \n    int main()\n    {\n    #ifndef ONLINE_JUDGE\n        freopen(\"A.in\", \"r\", stdin);\n        freopen(\"A.out\", \"w\", stdout);\n    #endif\n        while (1)\n        {\n            scanf(\"%d\", &N);\n            if (!N) break;\n            scanf(\"%d%d%d%d%d\", &M, &x1, &y1, &x2, &y2);\n            memset(Sum, 0, sizeof(Sum));\n            memset(Ans, 0, sizeof(Ans));\n            for (int i = 1; i <= N; ++i)\n            {\n                int x, y;\n                scanf(\"%d%d\", &x, &y);\n                A[i].a.x = x; A[i].a.y = y1;\n                A[i].b.x = y; A[i].b.y = y2;\n            }\n            sort(A + 1, A + N + 1, cmp);\n            for (int i = 1; i <= M; ++i)\n            {\n                int x, y;\n                scanf(\"%d%d\", &x, &y);\n                Find(x, y);\n            }\n            cout<<\"Box\"<<endl;\n            for (int i = 0; i <= N; ++i)\n                Ans[Sum[i]] ++;\n            for (int i = 1; i <= M; ++i)\n                if (Ans[i]) cout<<i<<\": \"<<Ans[i]<<endl;\n        }\n        return 0;\n    }\n```\n","categories":["Problem"],"tags":["二分","计算几何"]},{"title":"「Luogu3796」【模板】AC自动机（加强版）","url":"/2018/01/28/Luogu-P3796-%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91AC%E8%87%AA%E5%8A%A8%E6%9C%BA%EF%BC%88%E5%8A%A0%E5%BC%BA%E7%89%88%EF%BC%89/","content":"\n题目链接：[传送门](https://www.luogu.org/problemnew/show/P3796 \"传送门\")\n\n### Description\n\n有N个由小写字母组成的模式串以及一个文本串T。每个模式串可能会在文本串中出现多次。你需要找出哪些模式串在文本串T中出现的次数最多。\n<!--more-->\n\n### Input\n\n输入含多组数据。 每组数据的第一行为一个正整数N，表示共有N个模式串,1≤N≤150。 接下去N行，每行一个长度小于等于70的模式串。下一行是一个长度小于等于10^6的文本串T。 输入结束标志为N=0。\n\n### Output\n\n对于每组数据，第一行输出模式串最多出现的次数，接下去若干行每行输出一个出现次数最多的模式串，按输入顺序排列\n\n### Sample Input\n\n> 2 aba bab ababababac 6 beta alpha haha delta dede tata dedeltalphahahahototatalpha 0\n\n### Sample Output\n\n> 4 aba 2 alpha haha\n\n### Solution\n\n模板题，终于会AC自动机了\n\n### Code\n```cpp\n    #include <bits/stdc++.h>\n    using namespace std;\n    const int Maxn = 1000000 + 100;\n    int N;\n    struct ans\n    {\n        char S[71];\n        int cnt, pos;\n    }Ans[160];\n    struct Array\n    {\n        int son[30], val, fail, last;\n    };\n    struct AC_automaton\n    {\n        Array A[Maxn];\n        int Cnt = 0;\n        void Init(int x)\n        {\n            memset(A[x].son, 0, sizeof(A[x].son));\n            A[x].fail = 0;\n            A[x].last = 0;\n            A[x].val =0;\n        }\n        void Insert(char *S, int num)\n        {\n            int len = strlen(S), now = 0;\n            for (int i = 0; i < len; ++i)\n            {\n                if (!A[now].son[S[i] - 'a']) A[now].son[S[i] - 'a'] = ++Cnt, Init(Cnt);\n                now = A[now].son[S[i] - 'a'];\n            }\n            A[now].val = num;\n        }\n        void Get_fail()\n        {\n            queue<int> Q;\n            for (int i = 0; i < 26; ++i) if (A[0].son[i]) Q.push(A[0].son[i]), A[A[0].son[i]].fail = 0;\n            while (!Q.empty())\n            {\n                int x = Q.front(); Q.pop();\n                for (int i = 0; i < 26; ++i)\n                    if (A[x].son[i])\n                    {\n                        A[A[x].son[i]].fail = A[A[x].fail].son[i];\n                        if (A[A[A[x].fail].son[i]].val) A[A[x].son[i]].last = A[A[x].fail].son[i];\n                        else A[A[x].son[i]].last = A[A[A[x].fail].son[i]].last;\n                        Q.push(A[x].son[i]);\n                    }\n                    else A[x].son[i] = A[A[x].fail].son[i];\n            }\n        }\n        void Calc(char *S)\n        {\n            int now = 0, len = strlen(S);\n            for (int i = 0; i < len; ++i)\n            {\n                now = A[now].son[S[i] - 'a'];\n                for (int x = now; x; x = A[x].last)\n                    Ans[A[x].val].cnt ++;\n            }\n        }\n    }AC;\n    \n    inline int cmp(ans a, ans b)\n    {\n        if (a.cnt == b.cnt) return a.pos < b.pos;\n        return a.cnt > b.cnt;\n    }\n    \n    char S[Maxn];\n    int main()\n    {\n    #ifndef ONLINE_JUDGE\n        freopen(\"A.in\", \"r\", stdin);\n        freopen(\"A.out\", \"w\", stdout);\n    #endif\n        while (1)\n        {\n            scanf(\"%d\", &N);\n            if (!N) break;\n            AC.Cnt = 0;\n            AC.Init(0);\n            for (int i = 1; i <= N; ++i)\n            {\n                scanf(\"%s\", Ans[i].S);\n                Ans[i].pos = i;\n                Ans[i].cnt = 0;\n                AC.Insert(Ans[i].S, i);\n            }\n            AC.Get_fail();\n            scanf(\"%s\", S);\n            AC.Calc(S);\n            sort(Ans + 1, Ans + N + 1, cmp);\n            cout<<Ans[1].cnt<<endl;\n            for (int i = 1; i <= N; ++i)\n                if (Ans[i].cnt == Ans[1].cnt)\n                    cout<<Ans[i].S<<endl;\n                else break;\n        }\n        return 0;\n    }\n```\n","categories":["Problem"],"tags":["字符串","AC自动机"]},{"title":"「ZJOI2008」杀蚂蚁 - 大模拟 + 计算几何","url":"/2018/01/24/Luogu-P2586-ZJOI2008-%E6%9D%80%E8%9A%82%E8%9A%81%EF%BC%88%E5%A4%A7%E6%A8%A1%E6%8B%9F-%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%EF%BC%89/","content":"\n题目链接：[传送门](https://www.luogu.org/problemnew/show/P2586 \"传送门\")\n\n### Description\n题目就不放了...\n<!--more-->\n\n### Input\n\n输入的第一行是2个用空格隔开的整数，n、m，分别表示了地图的长和宽。 第二行是3个用空格隔开的整数，s、d、r，依次表示炮塔的个数、单次攻击伤害以及攻击范围。 接下来s行，每行是2个用空格隔开的整数x、y，描述了一个炮塔的位置。当然，蚂蚁窝的洞口以及蛋糕所在的位置上一定没有炮塔。 最后一行是一个正整数t，表示我们模拟游戏的前t秒钟。\n\n### Output\n\n如果在第t秒或之前蚂蚁抢到了蛋糕，输出一行“Game over after x seconds”，其中x为游戏结束的时间，否则输出“The game is going on”。 如果游戏在t秒或之前结束，输出游戏结束时所有蚂蚁的信息，否则输出t秒后所有蚂蚁的信息。格式如下： 第一行是1个整数s，表示此时活着的蚂蚁的总数。 接下来s行，每行5个整数，依次表示一只蚂蚁的年龄（单位为秒）、等级、当前血量，以及在地图上的位置（a，b）。输出按蚂蚁的年龄递减排序。\n\n### Sample Input\n\n> 3 5 1 1 2 2 2 5\n\n### Sample Output\n\n> The game is going on 5 5 1 3 1 4 4 1 3 0 4 3 1 3 0 3 2 1 3 0 2 1 1 4 0 1\n\n### Solution\n\n从题目的长度来看就可以看出这道题有多么工业 \n这道题就是一个特别考验耐心的大模拟再加一点计算几何 \n6.22K，300行的代码再一次次刷新了我对工业的认识 \n几个需要注意的地方： \n1. 判断方向当信息素最多的点有多个时，是在这几个点中从向东开始顺时针找最靠前的，而不是在所有方向中去找能走的方向（我本来是这么理解的，后来感觉如果有多个信息素最多的点就直接在所有方向中找能走的，和信息素无关，后来调好久没调出来，改成原来的代码就A了。。。） \n2. (0,0)位置如果有蚂蚁就不能新出生 \n3. 存图的数组和存信息素的数组不能弄到一起 \n4. 计算几何的部分还不是特别理解，待会儿还要再仔细学一下\n\n### Code(第一个6K的代码)\n```cpp\n    #include <iostream>\n    #include <cstdio>\n    #include <cstring>\n    #include <cmath>\n    #include <algorithm>\n    \n    using namespace std;\n    const int Maxn = 22;\n    struct Antt\n    {\n        int x, y, alive, age, blood, level, target, blood_init;\n        int prex, prey;\n    }Ant[10];\n    \n    struct Tower\n    {\n        int x, y;\n    }Tower[Maxn];\n    \n    int N, M, S, D, R, T;\n    int Ant_sum;\n    int Map[10][10], dr[4][2] = { {0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    int Val[10][10];\n    int Cake;\n    /*    3\n          ^\n          |\n     2<---#---> 0\n          |\n          v\n          1\n    */\n    \n    struct point {int x, y; };\n    struct line {point a, b; } l;\n    point sub (point a, point b) {point t; t.x = a.x - b.x; t.y = a.y - b.y; return t; }\n    inline int cmul (point a, point b) {return a.x * b.y - a.y * b.x;}\n    inline int turn (point a, point b, point c) {return cmul(sub(b, a), sub(c, a)); }\n    inline int sqr (int x) { return x * x; }\n    double caldis (int x1, int y1, int x2, int y2) {return sqrt(sqr(x1 - x2) + sqr(y1 - y2)); }\n    inline int cdis (int x, int y) {return sqr(Tower[x].x - Ant[y].x) + sqr(Tower[x].y - Ant[y].y);}\n    double getdis (int x, int y) {return sqrt(cdis(x, y)); }\n    \n    double Pow (double a, int b)\n    {\n        double Ans = 1.0;\n        for (int i = 1; i <= b; ++i)\n            Ans *= a;\n        return Ans;\n    }\n    \n    inline void Born()\n    {\n        if (Map[0][0] == 1) return ;\n        for (int i = 1; i <= 6; ++i)\n            if (!Ant[i].alive)\n            {\n                Ant[i].alive = 1;\n                Ant[i].x = 0, Ant[i].y = 0;\n                Map[Ant[i].x][Ant[i].y] = 1;\n                Ant[i].prex = 0, Ant[i].prey = 0;\n                Ant_sum++;\n                Ant[i].level = (Ant_sum - 1) / 6 + 1;\n                Ant[i].age = 0;\n                Ant[i].blood = (int)(4.0 * Pow(1.1, Ant[i].level));\n                Ant[i].blood_init = Ant[i].blood;\n                Ant[i].target = 0;\n                return ;\n            }\n    }\n    \n    inline void Mark()\n    {\n        for (int i = 1; i <= 6; ++i)\n        {\n            if (!Ant[i].alive) continue;\n            if (!Ant[i].target) Val[Ant[i].x][Ant[i].y] += 2;\n            else Val[Ant[i].x][Ant[i].y] += 5;\n        }\n    }\n    \n    inline int cmp (Antt a, Antt b)\n    {\n        return a.age > b.age;\n    }\n    \n    inline int pre (int x)\n    {\n        if (!x) return 3;\n        return x - 1;\n    }\n    \n    inline void Move()\n    {\n        sort(Ant + 1, Ant + 7, cmp);\n        for (int i = 1; i <= 6; ++i)\n        {\n            if (!Ant[i].alive) continue;\n            int dir = 100;\n            for (int d = 0; d < 4; ++d)\n            {\n                int dx = Ant[i].x + dr[d][0];\n                int dy = Ant[i].y + dr[d][1];\n                if (dx < 0 || dx > N || dy < 0 || dy > M) continue;\n                if (Map[dx][dy] != 0 || (dx == Ant[i].prex && dy == Ant[i].prey)) continue;\n                if (dir == 100) {dir = d; continue;}\n                if (Val[Ant[i].x + dr[dir][0]][Ant[i].y + dr[dir][1]] >= Val[dx][dy]) continue;\n                dir = d;\n            }\n            if (dir == 100)\n            {\n                Ant[i].prex = Ant[i].x;\n                Ant[i].prey = Ant[i].y;\n                continue;\n            }\n            /*\n            if (fl)\n                {\n                    dir = 3;\n                    int flag = 0;\n                    while (1)\n                    {\n                        dir = (dir + 1) % 4;\n                        int dx = Ant[i].x + dr[dir][0];\n                        int dy = Ant[i].y + dr[dir][1];\n                        if (dx < 0 || dx > N || dy < 0 || dy > M) continue;\n                        if (Map[dx][dy] != 0 || (dx == Ant[i].prex && dy == Ant[i].prey)) continue;\n                        break;\n                    }\n                }\n            */\n    \n            /*\n            if (dir == 100)\n            {\n                Ant[i].prex = Ant[i].x;\n                Ant[i].prey = Ant[i].y;\n                continue;\n            }\n            */\n            if (!((Ant[i].age + 1) % 5))\n            {\n                while (1)\n                {\n                    dir = pre(dir);\n                    int dx = Ant[i].x + dr[dir][0];\n                    int dy = Ant[i].y + dr[dir][1];\n                    if (dx < 0 || dx > N || dy < 0 || dy > M) continue;\n                    if (Map[dx][dy] != 0 || (dx == Ant[i].prex && dy == Ant[i].prey)) continue;\n                    break;\n                }\n            }\n            Ant[i].prex = Ant[i].x;\n            Ant[i].prey = Ant[i].y;\n            Map[Ant[i].prex][Ant[i].prey] = 0;\n            Ant[i].x += dr[dir][0];\n            Ant[i].y += dr[dir][1];\n            Map[Ant[i].x][Ant[i].y] = 1;\n        }\n    }\n    \n    inline void Check_before()\n    {\n        for (int i = 1; i <= 6; ++i)\n        {\n            if (!Ant[i].alive) continue;\n            if (Ant[i].x == N && Ant[i].y == M && !Cake)\n            {\n                Cake = 1;\n                Ant[i].target = 1;\n                Ant[i].blood = min(Ant[i].blood + (int)(Ant[i].blood_init / 2), Ant[i].blood_init);\n            }\n        }\n    }\n    \n    inline int cross(int x,int y)\n    {\n        double d = caldis(l.a.x, l.a.y, l.b.x, l.b.y);\n        if(x == l.a.x && y == l.a.y || x == l.b.x && y == l.b.y) return 1;\n        int x1 = min(l.a.x, l.b.x), x2 = max(l.a.x, l.b.x);\n        int y1 = min(l.a.y, l.b.y), y2 = max(l.a.y, l.b.y);\n        if(x < x1 || x > x2 | y < y1 || y > y2)return 0;\n        point p;\n        p.x = x;p.y = y;\n        if(fabs(turn(l.a, l.b, p)) / d <= 0.5)return 1;\n        return 0;\n    }\n    \n    inline void Attack(int now)\n    {\n        sort(Ant + 1, Ant + 7, cmp);\n        int pos = 0, Dis = 0x3f3f3f3f;\n        for (int i = 1; i <= 6; ++i)\n        {\n            if (!Ant[i].alive) continue;\n            int dis = cdis(now, i);\n            if (dis <= R * R)\n            {\n                if (Ant[i].target) pos = i;\n                else if (!Ant[pos].target && dis < Dis)\n                    Dis = dis, pos = i;\n            }\n        }\n        if (!pos) return ;\n        l.a.x = Tower[now].x; l.a.y = Tower[now].y;\n        l.b.x = Ant[pos].x; l.b.y = Ant[pos].y;\n        for (int i = 1; i <= 6; ++i)\n        {\n            if (!Ant[i].alive) continue;\n            if (cross(Ant[i].x, Ant[i].y))\n                Ant[i].blood -= D;\n        }\n    }\n    \n    inline void Check_after()\n    {\n        for (int i = 1; i <= 6; ++i)\n        {\n            if (!Ant[i].alive) continue;\n            if (Ant[i].blood < 0)\n            {\n                if (Ant[i].target) Ant[i].target = 0, Cake = 0;\n                Map[Ant[i].x][Ant[i].y] = 0;\n                Ant[i].x = 0, Ant[i].y = 0, Ant[i].alive = 0, Ant[i].blood = 0, Ant[i].age = 0, Ant[i].level = 0;\n                Ant[i].prex = 0, Ant[i].prey = 0, Ant[i].blood_init = 0;\n            }\n        }\n    }\n    \n    inline void Print()\n    {\n        sort(Ant + 1, Ant + 7, cmp);\n        int Cnt = 0;\n        for (int i = 1; i <= 6; ++i)\n            if (Ant[i].alive) ++Cnt;\n        cout<<Cnt<<endl;\n        for (int i = 1; i <= 6; ++i)\n        {\n            if (!Ant[i].alive) continue;\n            printf(\"%d %d %d %d %d\\n\", Ant[i].age, Ant[i].level, Ant[i].blood, Ant[i].x, Ant[i].y);\n        }\n    }\n    \n    inline void Check(int x)\n    {\n        for (int i = 1; i <= 6; ++i)\n        {\n            if (!Ant[i].alive) continue;\n            if (Ant[i].target && !Ant[i].x && !Ant[i].y)\n            {\n                printf(\"Game over after %d seconds\\n\", x);\n                Print();\n                exit(0);\n            }\n        }\n    }\n    \n    inline void Last()\n    {\n        for (int i = 0; i <= 8; ++i)\n            for (int j = 0; j <= 8; ++j)\n                if (Val[i][j] > 0) Val[i][j] --;\n        for (int i = 1; i <= 6; ++i)\n            if (Ant[i].alive)\n                Ant[i].age++;\n    }\n    \n    int main()\n    {\n    #ifndef ONLINE_JUDGE\n        freopen(\"A.in\", \"r\", stdin);\n        freopen(\"A.out\", \"w\", stdout);\n    #endif\n        scanf(\"%d%d%d%d%d\", &N, &M, &S, &D, &R);\n        for (int i = 1; i <= S; ++i)\n            scanf(\"%d %d\", &Tower[i].x, &Tower[i].y), Map[Tower[i].x][Tower[i].y] = -1;\n        scanf(\"%d\", &T);\n        for (int i = 1; i <= T; ++i)\n        {\n            Born();\n            Mark();\n            Move();\n            Check_before();\n            for (int k = 1; k <= S; ++k) Attack(k);\n            Check_after();\n            Check(i);\n            Last();\n        }\n        /*\n        for (int i = 0; i <= N; ++i)\n        {\n            for (int j = 0 ; j <= M; ++j)\n                printf(\"%5d\", Map[i][j]);\n            cout<<endl;\n        }\n        */\n        puts(\"The game is going on\");\n        Print();\n        return 0;\n    }\n```\n","categories":["Problem"],"tags":["计算几何","模拟","省选"]},{"title":"「CF914D」Bash and a Tough Math Puzzle - 线段树","url":"/2018/01/22/D-Bash-and-a-Tough-Math-Puzzle-%E7%BA%BF%E6%AE%B5%E6%A0%91-Codeforces-Round-458/","content":"\n题目链接：[传送门](http://codeforces.com/contest/914/problem/D \"传送门\")\n\n### Description\n\nBash likes playing with arrays. He has an array a1, a2, ... an of n integers. He likes to guess the greatest common divisor (gcd) of different segments of the array. Of course, sometimes the guess is not correct. However, Bash will be satisfied if his guess is almost correct. Suppose he guesses that the gcd of the elements in the range \\[l, r\\] of a is x. He considers the guess to be almost correct if he can change at most one element in the segment such that the gcd of the segment is x after making the change. Note that when he guesses, he doesn't actually change the array — he just wonders if the gcd of the segment can be made x. Apart from this, he also sometimes makes changes to the array itself. Since he can't figure it out himself, Bash wants you to tell him which of his guesses are almost correct. Formally, you have to process q queries of one of the following forms:\n<!--more-->\n\n*   1 l r x — Bash guesses that the gcd of the range \\[l, r\\] is x. Report if this guess is almost correct.\n*   2 i y — Bash sets ai to y. Note: The array is 1-indexed.\n\n### Input\n\nThe first line contains an integer n (1 ≤ n ≤ 5·10^5) — the size of the array. The second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ 10^9) — the elements of the array. The third line contains an integer q (1 ≤ q ≤ 4·10^5) — the number of queries. The next q lines describe the queries and may have one of the following forms:\n\n*   1 l r x (1 ≤ l ≤ r ≤ n, 1 ≤ x ≤ 10^9).\n*   2 i y (1 ≤ i ≤ n, 1 ≤ y ≤ 10^9). Guaranteed, that there is at least one query of first type.\n\n### Output\n\nFor each query of first type, output \"YES\" (without quotes) if Bash's guess is almost correct and \"NO\" (without quotes) otherwise.\n\n### Sample Input\n\n> 3 2 6 3 4 1 1 2 2 1 1 3 3 2 1 9 1 1 3 2\n\n### Sample Output\n\n> YES YES NO\n\n### Solution\n\n题意：n个数的数列，对它有下面两种操作 \n* 猜 l ~ r 这部分数的最大公因数为x，如果x不是最大公因数，但只改变l ~ r中的一个数就能让x是最大公因数，那么可以认为是猜中了 \n* 把某一个数 i 的值变为 y 用线段树维护一下Gcd， 更新直接单点修改，查询的时候求出区间内不是x的倍数的数量，如果大于1则输出No，否则输出YES \n\n只是查询时要加一个剪枝，如果ans大于1则不需要向下递归，直接return\n\n### Code\n```cpp\n    #include <bits/stdc++.h>\n    using namespace std;\n    const int Maxn = 500000 + 100;\n    int Tree[Maxn * 4];\n    int N, M;\n    \n    inline int Gcd (int a, int b)\n    {\n        return b ? Gcd(b, a % b) : a;\n    }\n    \n    inline void Push_up(int root)\n    {\n        Tree[root] = Gcd(Tree[root << 1], Tree[root << 1 | 1]);\n    }\n    \n    inline void build (int root, int l, int r)\n    {\n        if (l == r)\n        {\n            scanf(\"%d\", &Tree[root]);\n            return ;\n        }\n        int mid = (l + r) >> 1;\n        build(root << 1, l, mid);\n        build(root << 1 | 1, mid + 1, r);\n        Push_up(root);\n    }\n    \n    inline void Update(int root, int l, int r, int x, int y)\n    {\n        if (l == r)\n        {\n            Tree[root] = y;\n            return ;\n        }\n        int mid = (l + r) >> 1;\n        if (x <= mid) Update(root << 1, l, mid, x, y);\n        else Update(root << 1 | 1, mid + 1, r, x, y);\n        Push_up(root);\n    }\n    \n    inline int Query(int root, int l, int r, int x, int y, int z)\n    {\n        if (l == r) return 1;\n        int mid = (l + r) >> 1, Ans = 0;\n        if (x <= mid && Tree[root << 1] % z)\n            Ans += Query(root << 1, l, mid, x, y, z);\n        if (y > mid && Tree[root << 1 | 1] % z && Ans <= 1)\n            Ans += Query(root << 1 | 1, mid + 1, r, x, y, z);\n        return Ans;\n    }\n    \n    int main()\n    {\n    #ifndef ONLINE_JUDGE\n        freopen(\"D.in\", \"r\", stdin);\n        freopen(\"D.out\", \"w\", stdout);\n    #endif\n        scanf(\"%d\", &N);\n        build(1, 1, N);\n        scanf(\"%d\", &M);\n        for (int i = 1; i <= M; ++i)\n        {\n            int type, x, y, z;\n            scanf(\"%d\", &type);\n            if (type == 1)\n            {\n                scanf(\"%d%d%d\", &x, &y, &z);\n                if (Query(1, 1, N, x, y, z) <= 1) cout<<\"YES\"<<endl;\n                else cout<<\"NO\"<<endl;\n            }\n            else \n            {\n                scanf(\"%d%d\", &x, &y);\n                Update(1, 1, N, x, y);\n            }\n        }\n        return 0;\n    }\n```\n","categories":["Problem"],"tags":["Codeforces","线段树","树"]},{"title":"迟来的NOIp2017 Summary","url":"/2018/01/18/%E8%BF%9F%E6%9D%A5%E7%9A%84NOIp2017-Summary/","content":"\n去年联赛总结一直拖着没写，是时候补一发了\n\n<!--more-->\n### Day 0\n\n霉霉发新专了！好高兴！整个一天都沉迷在**Reputation**中无法自拔 好像感觉都没复习什么，就只是看了看数论的板子\n然后晚上怕第二天早上起不来，8点多就上床了，结果躺床上一直睡不着（心里一直在想要是没考好怎么办，然后莫名其妙的想一些乱七八糟的事情，**心态\\- -**）\n最后好像是晚上12点多才睡着。。。\n\n### Day 1\n\n进考场之前紧张的要死，还在心里默默地奶了一口只要把T1的模拟打出来，T2T3打个暴力就能稳一等了（flag++）\n拿到题之后先看T1，文件名math？？？逗我？？？心态直接爆炸，数学题本来自己就做不出，这回还放在T1的位置，粗略的理解了一下题意之后**整个人就慌了**，只好赶快去看T2.\n看完T2之后特别高兴，不就是一道很水的模拟题吗（flag+++），还以为今年T1，T2放反了位置，T3看都没看就直接去敲T2，**心想所有的希望都寄托在T2上了，要是T2没打出来就彻底完了** \n30min后：卧槽还要判语法错误 \n1h后：卧槽大样例怎么死活调不过 \n1h30min后：卧槽我的模拟好像整个都是错的 \n2h后：。。。 **心态完全爆炸**，已经对联赛不报任何希望了，一想到别人能A掉前两题，自己好像一道题都没分就越着急，越着急就越调不出来 \n2h30min后：算了T2彻底放弃了，30分的暴力也不想写了，去看T3能不能打个暴力 \n大概又花了20min左右把T3所谓的10分的暴力写完（事实上10分也没有），然后回过头去盯着T1，面如死灰 \n最后30min，写了T130分暴力之后，拿着样例玩来玩去（内心已经毫无波澜，只是看着数据那么大，看看能不能猜得出规律） \n然后最后20min的时候突然发现了规律：答案好像就是a×b-a-b！！！\n管他的，就敲这个了，要是规律错了也只能听天由命了 \n出考场后差点哭了，不过听到T1规律好像是对的，同年级的其他同学T2好像也没调出来的消息之后心里还稍微缓和了一点 \n下午还去考了一下普及组，5min切题的感觉还比较爽（后来T3莫名其妙爆0也不知道是为什么，也没去管它了） \nDay 1期望得分：$100 + 0 + 10 = 110$\n\n### Day 2\n\n总结了Day1翻车的原因（其实最主要的还是心态问题），还算是比较轻松地进了考场 \n看了一眼T1，好像比较常规，看T2的时候心里有点急，大概看了一下题面好像能打暴力，T3也就只会暴力（当时还不会Splay），心想今天的题目画风好像还比较正常，然后开开心心去码T1\n大概花了30min码T1（写的dfs），很快的速度过了大样例之后**想着N^2的算法应该没问题就没造极限数据测了**（flag+++++++++++）\n然后大部分时间都花在T2上\n先是写了40分的暴力，然后发现70分的也是暴力，然后70分的调了蛮久，大概1h才调出来\n想T2的时候脑袋里闪过了状压，但是**觉得去年考了状压今年应该不会考吧就没往那方面去想**（too young too simple）\nT3打了个稳稳的暴力，就去思考后面的部分分\n考场上应该是写了一个线段树之类的东西，写完之后发现有问题然后又删了。。。 \n最后30min的时候检查每道题的细节，突然觉得T1有点不放心就写了个gen造一组极限数据，一测发现根！本！跑！不！过！！！\n最大的点要跑3s多！！！然后各种卡常卡常卡常，最后卡到1s内，结果大样例Wa了。。。 \n最后5min，抉择了一下，最后还是交了没卡常的版本 而且后来听说T1最大的数据会爆long long，要开unsigned long long，果然没戏了 \nDay 2期望得分 $40 + 70 + 30 = 140$ \n两天期望总分250 显然一等没戏了，回去老老实实搞文化 然后用各种民间数据测了一下，洛谷数据有300分，雅礼长郡的数据都是290左右，学军数据只有240 别人都说学军的数据最接近官方数据，之后就不抱有任何的希望了。。。\n\n### Day ？？\n\n出分那天CCF还放了鸽子，每个课间就跑去信息老师那里查分，结果等了两天还没出分 \n最后出分的时候我还不相信，居然有300？？？D1T2居然样例都没过还能有20分？？？D2T1数据水成这样？？？（事实上这道题最后20分我是wa了，现在还不知道是怎么wa的。。。） \n太感谢CCF这么水的数据了，又给了我一点希望 不过显然同年级的其他大佬都比我考得好（**CXR420太爷了%%%**） \n翻了下湖南省的排名，似乎刚好压线 每天晚上都默默祈祷能压线有个一等\n\n### Day ？？？\n\n终于出最后的一等奖名单了，幸好还有个压线一等可以不用回去搞文化了\n\n### Summary\n\n这回的压线一等运气的成分很大，主要还是有一下几个问题： \n1. **心态**太不稳定了。\n前一天晚上就紧张的睡不着觉，而且考试的时候也没有把注意力全部放在题目上，而是过多地在意结果,这样是非常不好的。\n所以以后的每一次模拟赛都要当做是正式的比赛，这样才能锻炼自己的心态 \n2. **代码能力和调试能力**太差。\nD1T2模拟没调出来有很大一部分原因就是平时这种比较工业的模拟题练少了，细节考虑不全，而且平时做题总是对着数据调程序，这样很难锻炼调试能力 \n3. 显而易见的**水平**还是不够啊。\nD2T2算是比较简单的状压Dp都没能想出来，而且D2T3的后面的部分分用一些数据结构应该也是比较容易拿到的。\n所以以后做题的时候还是要多锻炼独立思考的能力，不能养成题目一做不出来就去看题解的习惯，这样的话水平才能有所提高。\n差不多就这样了，接下来的新的一年里继续迎接新的挑战吧\n","categories":["Summary"],"tags":["Summary","OI历程","NOIp"]},{"title":"「Luogu2073」送花 - Splay","url":"/2018/01/17/Luogu-P2073-%E9%80%81%E8%8A%B1-Splay/","content":"\n题目链接：[传送门](https://www.luogu.org/problemnew/show/2073 \"传送门\")\n\n### Description\n\n这些花都很漂亮，每朵花有一个美丽值W，价格为C。 小明一开始有一个空的花束，他不断地向里面添加花。他有以下几种操作： 1 W C 添加一朵美丽值为W，价格为C的花。 3 小明觉得当前花束中最便宜的一朵花太廉价，不适合送给小红，所以删除最便宜的一朵花。 2 小明觉得当前花束中最贵的一朵花太贵，他心疼自己的钱，所以删除最贵的一朵花。 -1 完成添加与删除，开始包装花束 若删除操作时没有花，则跳过删除操作。 如果加入的花朵价格已经与花束中已有花朵价格重复，则这一朵花不能加入花束。 请你帮小明写一个程序，计算出开始包装花束时，花束中所有花的美丽值的总和，以及小明需要为花束付出的总价格\n\n<!--more-->\n### Input\n\n若干行，每行一个操作，以-1结束。\n\n### Output\n\n一行，两个空格隔开的正整数表示开始包装花束时，花束中所有花的美丽值的总和。以及小明需要为花束付出的总价格。\n\n### Sample Input\n\n> 1 1 1 1 2 5 2 1 3 3 3 1 5 2 -1\n\n### Sample Output\n\n> 8 5\n\n### Solution\n\n再练习一道Splay的板子题，除了开始看反了价格和美丽值之外算是一遍A的吧:joy:\n\n### Code\n```cpp\n    #include <bits/stdc++.h>\n    using namespace std;\n    const int Maxn = 100000 + 100;\n    int N, root;\n    struct node\n    {\n        int ch[2], size, fa, val, sum;\n    }Tree[Maxn];\n    \n    inline int judge_dir (int x) { return Tree[Tree[x].fa].ch[1] == x; }\n    \n    inline void Push_up (int x) { Tree[x].size = Tree[Tree[x].ch[0]].size + Tree[Tree[x].ch[1]].size + 1; }\n    \n    inline void Connect(int x, int y, int dir) { Tree[x].fa = y; Tree[y].ch[dir] = x; }\n    \n    inline void Rotate (int x)\n    {\n        int f = Tree[x].fa, anc = Tree[f].fa, dirx = judge_dir(x), dirf = judge_dir(f);\n        Connect(Tree[x].ch[dirx ^ 1], f, dirx);\n        Connect(x, anc, dirf);\n        Connect(f, x, dirx ^ 1);\n        Push_up(f); Push_up(x);\n    }\n    \n    inline void Splay (int x, int y)\n    {\n        while (Tree[x].fa != y)\n        {\n            int f = Tree[x].fa, dirx = judge_dir(x), dirf = judge_dir(f);\n            if (Tree[f].fa == y) Rotate(x);\n            else if (dirx == dirf) Rotate(f), Rotate(x);\n            else Rotate(x), Rotate(x);\n        }\n        if (!y) root = x;\n    }\n    \n    inline void Create(int x, int v)\n    {\n        if (!root)\n        {\n            Tree[++N].val = x; Tree[N].sum = v;\n            Tree[N].size = 1; Tree[N].fa = 0;\n            root = N;\n            return ;\n        }\n        int now = root;\n        while (1)\n        {\n            if (Tree[now].val == x)\n                return ;\n            now = Tree[now].ch[x > Tree[now].val];\n            if (!now) break;\n        }\n        now = root;\n        while (1)\n        {\n            Tree[now].size ++;\n            int dir = x > Tree[now].val;\n            if (!Tree[now].ch[dir])\n            {\n                Tree[++N].fa = now;\n                Tree[N].size = 1;\n                Tree[now].ch[dir] = N;\n                Tree[N].val = x, Tree[N].sum = v;\n                Splay(N, 0);\n                return ;\n            }\n            now = Tree[now].ch[dir];\n        }\n    }\n    \n    inline void Delete(int type)\n    {\n        if (!root) return ;\n        int now = root;\n        while (Tree[now].ch[type]) now = Tree[now].ch[type];\n        Splay(now, 0);\n        Tree[Tree[now].ch[type ^ 1]].fa = 0;\n        root = Tree[now].ch[type ^ 1];\n    }\n    \n    int Ans1 = 0, Ans2 = 0;\n    \n    inline void Calc (int x)\n    {\n        Ans1 += Tree[x].val;\n        Ans2 += Tree[x].sum;\n        if (Tree[x].ch[0]) Calc(Tree[x].ch[0]);\n        if (Tree[x].ch[1]) Calc(Tree[x].ch[1]);\n    }\n    \n    int main()\n    {\n    #ifndef ONLINE_JUDGE\n        freopen(\"A.in\", \"r\", stdin);\n        freopen(\"A.out\", \"w\", stdout);\n    #endif\n        int type;\n        while (1)\n        {\n            scanf(\"%d\", &type);\n            if (type == - 1) break;\n            int x, y;\n            if (type == 1)\n            {\n                scanf(\"%d%d\", &x, &y);\n                Create(y, x);\n            }\n            else if (type == 2) Delete(1);\n            else Delete(0);\n        }\n        if (!root){cout<<0<<\" \"<<0<<endl; return 0;}\n        Calc(root);\n        cout<<Ans2<<\" \"<<Ans1<<endl;\n        return 0;\n    }\n```\n","categories":["Problem"],"tags":["平衡树","Splay"]},{"title":"「HNOI2004」敲砖块 - Dp","url":"/2018/01/15/Luogu-P1437-HNOI2004-%E6%95%B2%E7%A0%96%E5%9D%97-Dp/","content":"\n题目链接：[传送门](https://www.luogu.org/problemnew/show/1437 \"传送门\")\n\n### Description\n\n在一个凹槽中放置了 n 层砖块、最上面的一层有n 块砖，从上到下每层依次减少一块砖。每块砖 都有一个分值，敲掉这块砖就能得到相应的分值，如下图所示。\n\n> 14 15 4 3 23 33 33 76 2 2 13 11 22 23 31\n\n如果你想敲掉第 i 层的第j 块砖的话，若i=1，你可以直接敲掉它；若i>1，则你必须先敲掉第i-1 层的第j 和第j+1 块砖。 你现在可以敲掉最多 m 块砖，求得分最多能有多少。\n\n<!--more-->\n### Input\n\n输入文件的第一行为两个正整数 n 和m；接下来n 行，描述这n 层砖块上的分值$a\\[i\\]\\[j\\]$,满足0 ≤ a\\[i\\]\\[j\\] ≤ 100 对于 100%的数据，满足1≤n≤50，1 ≤ m ≤ n * (n+1)/2；\n\n### Output\n\n输出文件仅一行为一个正整数，表示被敲掉砖块的最大价值总和。\n\n### Sample Input\n\n> 4 5 2 2 3 4 8 2 7 2 3 49\n\n### Sample Output\n\n> 19\n\n### Solution\n\n一道Dp题。如果顺着考虑的话，我们会发现因为第i列的答案和i + 1有关，因此会有后效性 \n但是如果我们倒着考虑的话就不会有这个问题 \n设$Dp\\[i\\]\\[j\\]\\[k\\]$表示第i列从上往下连续选j个，从i列到第N列总共选了k个的答案，\n那么有 $Dp\\[i\\]\\[j\\]\\[k\\] = max(Dp\\[i + 1\\]\\[x\\]\\[k - j\\]) + \\\\\\sum_{y=1}^{j} A\\[y\\]\\[i\\]$ \nmax后面的东西用前缀和预处理出即可\n\n### Code\n```cpp\n    #include <bits/stdc++.h>\n    using namespace std;\n    const int Maxn = 1300;\n    int A[55][55], Dp[55][55][Maxn];\n    int Sum[55][55];\n    int N, M;\n    int main()\n    {\n    #ifdef hk_cnyali\n        freopen(\"A.in\", \"r\", stdin);\n        freopen(\"A.out\", \"w\", stdout);\n    #endif\n        scanf(\"%d%d\", &N, &M);\n        for (int i = 1; i <= N; ++i)\n            for (int j = 1; j <= N - i + 1; ++j)\n                scanf(\"%d\", &A[i][j]);\n        for (int i = 1; i <= N; ++i)\n            for (int j = 1; j <= N - i + 1; ++j)\n                Sum[i][j] = Sum[i - 1][j] + A[i][j];\n        Dp[N][1][1] = A[1][N];\n        int Ans = 0;\n        for (int i = N - 1; i >= 1; --i)\n        {\n            for (int j = 0; j <= N - i + 1; ++j)\n            {\n                for (int k = (2 * j - 1); k <= M; ++k)\n                {\n                    for (int x = j - 1; x <= N; ++x)\n                        Dp[i][j][k] = max(Dp[i][j][k], Dp[i + 1][x][k - j]);\n                    Dp[i][j][k] += Sum[j][i];\n                    Ans = max(Ans, Dp[i][j][k]);\n                }\n            }\n        }\n        cout<<Ans<<endl;\n        return 0;\n    }\n\t```\n","categories":["Problem"],"tags":["动态规划","省选"]},{"title":"「ZJOI2006」书架 - Splay","url":"/2018/01/12/Luogu-P2596-ZJOI2006-%E4%B9%A6%E6%9E%B6-Splay/","content":"\n题目链接：[传送门](https://www.luogu.org/problemnew/show/2596 \"传送门\")\n\n### Description\n\n小T有一个很大的书柜。这个书柜的构造有些独特，即书柜里的书是从上至下堆放成一列。她用1到n的正整数给每本书都编了号。 小T在看书的时候，每次取出一本书，看完后放回书柜然后再拿下一本。由于这些书太有吸引力了，所以她看完后常常会忘记原来是放在书柜的什么位置。不过小T的记忆力是非常好的，所以每次放书的时候至少能够将那本书放在拿出来时的位置附近，比如说她拿的时候这本书上面有X本书，那么放回去时这本书上面就只可能有X-1、X或X+1本书。 当然也有特殊情况，比如在看书的时候突然电话响了或者有朋友来访。这时候粗心的小T会随手把书放在书柜里所有书的最上面或者最下面，然后转身离开。 久而久之，小T的书柜里的书的顺序就会越来越乱，找到特定的编号的书就变得越来越困难。于是她想请你帮她编写一个图书管理程序，处理她看书时的一些操作，以及回答她的两个提问：(1)编号为X的书在书柜的什么位置；(2)从上到下第i本书的编号是多少。\n\n<!--more-->\n\n### Input\n\n第一行有两个数n，m，分别表示书的个数以及命令的条数；第二行为n个正整数：第i个数表示初始时从上至下第i个位置放置的书的编号；第三行到m+2行，每行一条命令。命令有5种形式： 1． Top S——表示把编号为S的书房在最上面。 2． Bottom S——表示把编号为S的书房在最下面。 3． Insert S T——T∈{-1，0，1}，若编号为S的书上面有X本书，则这条命令表示把这本书放回去后它的上面有X+T本书； 4． Ask S——询问编号为S的书的上面目前有多少本书。 5． Query S——询问从上面数起的第S本书的编号。\n\n### Output\n\n对于每一条Ask或Query语句你应该输出一行，一个数，代表询问的答案。\n\n### Sample Input\n\n> 10 10 1 3 2 7 5 8 10 4 9 6 Query 3 Top 5 Ask 6 Bottom 3 Ask 3 Top 6 Insert 4 -1 Query 5 Query 2 Ask 2\n\n### Sample Output\n\n> 2 9 9 7 5 3\n\n### Solution\n\n又是一道平衡树的题 然而一道模板题我调了一天。。。 代码能力太弱了。。。\n\n### Code\n```cpp\n    #include <bits/stdc++.h>\n    \n    using namespace std;\n    const int Maxn = 80000 + 100;\n    \n    int N, M, cnt, root;\n    struct node\n    {\n        int ch[2], size, fa, val, val2;\n    }Tree[Maxn];\n    \n    int Pos[Maxn];\n    inline void Insert(int x, int f)\n    {\n        Tree[++cnt].val = x;\n        Pos[x] = cnt;\n        Tree[cnt].fa = f;\n        Tree[cnt].size = 1;\n        return ;\n    }\n    \n    inline int judge_dir (int x)\n    {\n        return Tree[Tree[x].fa].ch[1] == x;\n    }\n    \n    inline void Connect(int x, int f, int dir)\n    {\n        Tree[x].fa = f;\n        Tree[f].ch[dir] = x;\n        return ;\n    }\n    \n    inline void Push_up(int x)\n    {\n        Tree[x].size = Tree[Tree[x].ch[0]].size + Tree[Tree[x].ch[1]].size + 1;\n        Pos[Tree[Tree[x].ch[0]].val] = Tree[x].ch[0];\n        Pos[Tree[x].val] = x;\n        Pos[Tree[Tree[x].ch[1]].val] = Tree[x].ch[1];\n        return ;\n    }\n    \n    inline void rotate(int x)\n    {\n        int dirx = judge_dir(x), f = Tree[x].fa, anc = Tree[f].fa, dirf = judge_dir(f);\n        Connect(Tree[x].ch[dirx ^ 1], f, dirx);\n        Connect(x, anc, dirf);\n        Connect(f, x, dirx ^ 1);\n        Push_up(f);\n        Push_up(x);\n    }\n    \n    inline void Splay(int x, int y)\n    {\n        while (Tree[x].fa != y)\n        {\n            int dirx = judge_dir(x), f = Tree[x].fa, dirf = judge_dir(f);\n            if (Tree[f].fa == y) rotate(x);\n            else if (dirx == dirf) rotate(f), rotate(x);\n            else rotate(x), rotate(x);\n        }\n        Pos[Tree[x].val] = x;\n        if (!y) root = x;\n    }\n    \n    inline void Create(int x)\n    {\n        if (!root)\n        {\n            root = 1;\n            Tree[root].val2 = 1;\n            Insert(x, 0);\n            return ;\n        }\n        /*\n        ++cnt;\n        Tree[cnt - 1].ch[1] = cnt;\n        Tree[cnt].val = x;\n        Tree[cnt].fa = cnt - 1;\n        Splay(cnt, 0);\n        */\n        int now = root;\n        while (1)\n        {\n            Tree[now].size ++;\n            int dir = x > Tree[now].val2;\n            if (!Tree[now].ch[dir])\n            {\n                Insert(x, now);\n                Tree[now].ch[dir] = cnt;\n                Tree[now].val2 = cnt;\n                Splay(cnt, 0);\n                return ;\n            }\n            now = Tree[now].ch[dir];\n        }\n    }\n    \n    char s[10];\n    \n    inline int Find(int x)\n    {\n        return Pos[x];\n    }\n    \n    inline void Put_top(int x)\n    {\n        x = Find(x);\n    //  cout<<\"*\"<<x<<endl;\n        Splay(x, 0);\n        if (!Tree[x].ch[0]) return ;\n        if (!Tree[x].ch[1])\n        {\n            Tree[x].ch[1] = Tree[x].ch[0];\n            Tree[x].ch[0] = 0;\n            Push_up(x);\n            return ;\n        }\n        int now = Tree[x].ch[1];\n        while (Tree[now].ch[0]) now = Tree[now].ch[0];\n        Splay(now, x);\n        Connect(Tree[x].ch[0], now, 0);\n        Tree[x].ch[0] = 0;\n        Push_up(now);\n        Push_up(x);\n    }\n    \n    inline void Put_bottom(int x)\n    {\n        x = Find(x);\n    //  cout<<\"#\"<<x<<endl;\n        Splay(x, 0);\n        if (!Tree[x].ch[1]) return ;\n        if (!Tree[x].ch[0])\n        {\n            Tree[x].ch[0] = Tree[x].ch[1];\n            Tree[x].ch[1] = 0;\n            Push_up(x);\n            return ;\n        }\n        int now = Tree[x].ch[0];\n        while (Tree[now].ch[1]) now = Tree[now].ch[1];\n        Splay(now, x);\n        Connect(Tree[x].ch[1], now, 1);\n        Tree[x].ch[1] = 0;\n        Push_up(now);\n        Push_up(x);\n    }\n    \n    inline void Change(int x, int y)\n    {\n        if (!y) return ;\n        x = Find(x);\n        Splay(x, 0);\n        int dir = (y == 1);\n        if (!Tree[x].ch[dir]) return ;\n        int now = Tree[root].ch[dir];\n    //  cout<<Tree[root].ch[0]<<\" \"<<Tree[root].ch[1]<<endl;\n    //  cout<<Tree[10].ch[0]<<\" \"<<Tree[10].ch[1]<<endl;\n        while (Tree[now].ch[dir ^ 1]) now = Tree[now].ch[dir ^ 1];\n    //  cout<<Tree[now].val;cout<<endl;\n    //  cout<<Tree[x].val<<\" \"<<Tree[now].val<<endl;\n        swap(Tree[x].val, Tree[now].val);\n        Pos[Tree[x].val] = x;\n        Pos[Tree[now].val] = now;\n    //  cout<<Tree[2].val<<endl;\n    }\n    \n    inline int Rank(int x)\n    {\n        x = Find(x);\n        Splay(x, 0);\n        return Tree[Tree[x].ch[0]].size;\n    }\n    \n    inline int Rerank(int x)\n    {\n        int now = root;\n        while (1)\n        {\n            int Sum = Tree[Tree[now].ch[0]].size + 1;\n            if (Sum == x) return Tree[now].val;\n            if (x <= (Sum - 1)) now = Tree[now].ch[0];\n            else x -= (Tree[Tree[now].ch[0]].size + 1), now = Tree[now].ch[1];\n        }\n    }\n    \n    inline void Print(int x)\n    {\n        if (Tree[x].ch[0]) Print(Tree[x].ch[0]);\n        cout<<Tree[x].val<<\" \";\n        if (Tree[x].ch[1]) Print(Tree[x].ch[1]);\n    }\n    int main()\n    {\n    #ifdef hk_cnyali\n        freopen(\"A.in\", \"r\", stdin);\n        freopen(\"A.out\", \"w\", stdout);\n    #endif\n        scanf(\"%d%d\", &N, &M);\n        int x, y;\n        for (int i = 1; i <= N; ++i)\n        {\n            scanf(\"%d\", &x);\n            Create(x);\n        }\n        while (M--)\n        {\n            scanf(\"%s\", s);\n            scanf(\"%d\", &x);\n            if (s[0] == 'T') Put_top(x);\n            if (s[0] == 'B') Put_bottom(x);\n            if (s[0] == 'I') scanf(\"%d\", &y), Change(x, y);\n            if (s[0] == 'A') cout<<Rank(x)<<endl;\n            if (s[0] == 'Q') cout<<Rerank(x)<<endl;\n        }\n        return 0;\n    }\n```\n","categories":["Problem"],"tags":["数据结构","平衡树","Splay","树"]},{"title":"「Luogu3391」【模板】文艺平衡树 - Splay","url":"/2018/01/11/Luogu-P3391-%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E6%96%87%E8%89%BA%E5%B9%B3%E8%A1%A1%E6%A0%91%EF%BC%88Splay%EF%BC%89/","content":"\n题目链接：[传送门](https://www.luogu.org/problemnew/show/P3391 \"传送门\")\n\n### Description\n\n您需要写一种数据结构（可参考题目标题），来维护一个有序数列，其中需要提供以下操作：翻转一个区间，例如原有序序列是5 4 3 2 1，翻转区间是\\[2,4\\]的话，结果是5 2 3 4 1\n<!--more-->\n\n### Input\n\n第一行为n,m n表示初始序列有n个数，这个序列依次是 $(1,2, \\\\\\cdots n-1,n)$m表示翻转操作次数 接下来m行每行两个数 $\\[l,r\\]$ 数据保证 $1 \\\\\\leq l \\\\\\leq r \\\\\\leq n $\n\n### Output\n\n输出一行n个数字，表示原始序列经过m次变换后的结果\n\n### Sample Input\n\n> 5 3 1 3 1 3 1 4\n\n### Sample Output\n\n> 4 3 2 1 5\n\n### Solution\n\n再写一道Splay的板子题 \n只是这里作为查找（或者说排序）的关键字不再是权值，而是编号 \n那么我们可以知道最终的结果一定是这棵二叉树的中序遍历 \n并且对于在原序列中的第k个数，就相当于是Splay中的第k小的数（即左子树中有k-1个数比它小) \n然后在最开始插入的时候我们需要1加到n+2，1和n+2相当于是在两侧的哨兵 \n那么我们对于一个所需要翻转的区间(l,r)，只需要先找到l和r+2在平衡树中的位置，\n将l Splay至根处，将r+2 Splay到l的右儿子处，\n那么所需要翻转的区间就全在r+2的左子树中 \n直接加个标记，维护、下传即可\n\n### Code\n```cpp\n    #include <iostream>\n    #include <cstdio>\n    #include <cstring>\n    #include <cmath>\n    #include <algorithm>\n    \n    using namespace std;\n    const int Maxn = 100000 + 1000;\n    int N, M, root, cnt;\n    \n    struct node\n    {\n        int ch[2], fa, val, mark, size;\n    }Tree[Maxn];\n    \n    inline void Insert(int x, int f)\n    {\n        Tree[++cnt].val = x;\n        Tree[cnt].fa = f;\n        Tree[cnt].size = 1;\n    }\n    \n    inline int judge_dir(int x)\n    {\n        return (Tree[Tree[x].fa].ch[1] == x);\n    }\n    \n    inline void Push_up(int x)\n    {\n        Tree[x].size = Tree[Tree[x].ch[0]].size + Tree[Tree[x].ch[1]].size + 1;\n    }\n    \n    inline void Connect(int x, int f, int dir)\n    {\n        Tree[x].fa = f;\n        Tree[f].ch[dir] = x;\n    }\n    \n    inline void Push_down(int x)\n    {\n        if (!Tree[x].mark) return ;\n        swap(Tree[x].ch[0], Tree[x].ch[1]);\n        Tree[Tree[x].ch[0]].mark ^= 1;\n        Tree[Tree[x].ch[1]].mark ^= 1;\n        Tree[x].mark = 0;\n    }\n    \n    inline void rotate(int x)\n    {\n        int dirx = judge_dir(x), f = Tree[x].fa, dirf = judge_dir(f), anc = Tree[f].fa;\n        Connect(Tree[x].ch[dirx ^ 1], f, dirx);\n        Connect(f, x, dirx ^ 1);\n        Connect(x, anc, dirf);\n        Push_up(f);\n        Push_up(x);\n    }\n    \n    inline void Splay(int x, int y)\n    {\n        while (Tree[x].fa != y)\n        {\n        //  cout<<x<<\" \"<<Tree[x].fa<<endl;\n            int f = Tree[x].fa;\n            int dirx = judge_dir(x);\n            int dirf = judge_dir(f);\n            if (Tree[f].fa == y) rotate(x);\n            else if (dirx == dirf) rotate(f), rotate(x);\n            else rotate(x), rotate(x);\n        }\n        if (!y) root = x;\n    }\n    \n    inline void Create(int x)\n    {\n        if (!cnt)\n        {\n            root = 1;\n            Insert(x, 0);\n            return ;\n        }\n        int now = root;\n        while (1)\n        {\n            Tree[now].size ++;\n            int dir = (x > Tree[now].val);\n            if (!Tree[now].ch[dir])\n            {\n                Insert(x, now);\n                Tree[now].ch[dir] = cnt;\n                Splay(cnt, 0);\n                return ;\n            }\n            now = Tree[now].ch[dir];\n        }\n    }\n    \n    inline int Find (int x)\n    {\n        int now = root;\n        while (1)\n        {\n            Push_down(now);\n            if (Tree[Tree[now].ch[0]].size + 1 == x) return now;\n            if (Tree[Tree[now].ch[0]].size + 1 < x)\n                x -= (Tree[Tree[now].ch[0]].size + 1), now = Tree[now].ch[1];\n            else now = Tree[now].ch[0];\n        }\n    }\n    \n    inline void Modify(int l, int r)\n    {\n        int x = Find(l), y = Find(r);\n        Splay(x, 0);\n        Splay(y, x);\n        Tree[Tree[Tree[root].ch[1]].ch[0]].mark ^= 1;\n    }\n    \n    inline void Print(int x)\n    {\n        Push_down(x);\n        if (Tree[x].ch[0]) Print(Tree[x].ch[0]);\n        if (Tree[x].val > 1 && Tree[x].val < N + 2) printf(\"%d \", Tree[x].val - 1);\n        if (Tree[x].ch[1]) Print(Tree[x].ch[1]);\n    }\n    \n    int main()\n    {\n    #ifndef ONLINE_JUDGE\n        freopen(\"A.in\", \"r\", stdin);\n        freopen(\"A.out\", \"w\", stdout);\n    #endif\n        scanf(\"%d%d\", &N, &M);\n        for (int i = 1; i <= N + 2; ++i)\n            Create(i);\n        while (M--)\n        {\n            int x, y;\n            scanf(\"%d%d\", &x, &y);\n            Modify(x, y + 2);\n        }\n        Print(root);\n        return 0;\n    }\n```\n","categories":["Algorithm"],"tags":["数据结构","平衡树","Splay","树"]},{"title":"「Luogu3369」【模板】普通平衡树 - Splay","url":"/2018/01/10/Luogu-P3369%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E6%99%AE%E9%80%9A%E5%B9%B3%E8%A1%A1%E6%A0%91%EF%BC%88Splay%E6%9D%BF%E5%AD%90%EF%BC%89/","content":"\n题目链接：[传送门](https://www.luogu.org/problemnew/show/P3369 \"传送门\")\n\n### Description\n\n您需要写一种数据结构（可参考题目标题），来维护一些数，其中需要提供以下操作：\n\n1.  插入x数\n    \n2.  删除x数(若有多个相同的数，因只删除一个)\n    \n3.  查询x数的排名(排名定义为比当前数小的数的个数+1。若有多个相同的数，因输出最小的排名)\n    \n4.  查询排名为x的数\n    \n5.  求x的前驱(前驱定义为小于x，且最大的数)\n    \n6.  求x的后继(后继定义为大于x，且最小的数)\n    \n<!--more-->\n\n### Input\n\n第一行为n，表示操作的个数,下面n行每行有两个数opt和x，opt表示操作的序号( $1\\\\\\leq opt \\\\\\leq 6$)\n\n### Output\n\n对于操作3,4,5,6每行输出一个数，表示对应答案\n\n### Sample Input\n\n> 10 1 106465 4 1 1 317721 1 460929 1 644985 1 84185 1 89851 6 81968 1 492737 5 493598\n\n### Sample Output\n\n> 106465 84185 492737\n\n### Solution\n\n才学Splay，一道Splay的模板题 第一次写200+行的代码，打了2h，调了一天才A掉 看来我还是太弱了。。。 就把板子放这里算了\n\n### Code\n```cpp\n    #include <iostream>\n    #include <cstdio>\n    #include <cstring>\n    #include <cmath>\n    #include <algorithm>\n    \n    #define root Tree[0].ch[1]\n    const int Maxn = 100000 + 100;\n    using namespace std;\n    \n    struct node\n    {\n        int val, ch[2], size, cnt, fa;\n    }Tree[Maxn];\n    int M, N;\n    int points;\n    \n    inline void update(int x)\n    {\n        Tree[x].size = Tree[Tree[x].ch[0]].size + Tree[Tree[x].ch[1]].size + Tree[x].cnt;\n        return ;\n    }\n    \n    inline int judge_dir(int x)\n    {\n        return Tree[Tree[x].fa].ch[1] == x;\n    }\n    \n    inline void Connect(int x, int f, int dir)\n    {\n        Tree[x].fa = f;\n        Tree[f].ch[dir] = x;\n        return ;\n    }\n    \n    inline void Rotate(int x)\n    {\n        int f = Tree[x].fa; \n        int dirx = judge_dir(x);\n        int anc = Tree[f].fa;\n        int dirf = judge_dir(f);\n        Connect(Tree[x].ch[dirx ^ 1], f, dirx);\n        Connect(f, x, (dirx ^ 1));\n        Connect(x, anc, dirf);\n        update(f); update(x);\n        return ;\n    }\n    \n    inline void Splay (int x, int y)\n    {\n        while (Tree[x].fa != y)\n        {\n            int f = Tree[x].fa;\n            int dirx = judge_dir(x), dirf = judge_dir(f);\n            if (Tree[f].fa == y) Rotate(x);\n            else if (dirx == dirf) Rotate(f), Rotate(x);\n            else Rotate(x), Rotate(x);\n        }\n        return ;\n    }\n    \n    inline int Insert (int x, int f)\n    {\n        Tree[++N].val = x;\n        Tree[N].size = Tree[N].cnt = 1;\n        Tree[N].fa = f;\n        return N;\n    }\n    \n    inline void Clear(int x)\n    {\n        Tree[x].val = 0, Tree[x].fa = 0;\n        Tree[x].size = 0, Tree[x].cnt = 0;\n        Tree[x].ch[0] = 0, Tree[x].ch[1] = 0;\n        return ;\n    }\n    \n    inline int Find (int x)\n    {\n        int now = root;\n        while (1)\n        {\n            if (Tree[now].val == x)\n            {\n                Splay(now, 0);\n                return now;\n            }\n            int dir = (x > Tree[now].val);\n            if (!Tree[now].ch[dir]) return 0;\n            now = Tree[now].ch[dir];\n        }\n        return 0;\n    }\n    inline void Create (int x)\n    {\n        points++;\n        if (!N)\n        {\n            root = 1;\n            Insert(x, 0);\n            return ;\n        }\n        int now = root;\n        while (1)\n        {\n            Tree[now].size ++;\n            if (Tree[now].val == x)\n            {\n                Tree[now].cnt ++;\n                Splay(now, 0);\n                return ;\n            }\n            int dir = (x > Tree[now].val);\n            if (!Tree[now].ch[dir])\n            {\n                Insert(x, now);\n                Tree[now].ch[dir] = N;\n                Splay(N, 0);\n                return ;\n            }\n            now = Tree[now].ch[dir];\n        }\n        return ;\n    }\n    \n    inline void Delete(int v)\n    {\n        int x = Find(v);\n        if (!x) return ;\n        points--;\n        if (Tree[x].cnt > 1)\n        {\n            Tree[x].cnt --;\n            Tree[x].size --;\n            return ;\n        }\n        if (!Tree[x].ch[0])\n        {\n            root = Tree[x].ch[1];\n            Tree[root].fa = 0;\n            Clear(x);\n    //      cout<<\"*\"<<root<<endl;\n            return ;\n        }\n        int now = Tree[x].ch[0];\n        while (Tree[now].ch[1]) now = Tree[now].ch[1];\n        Splay(now, x);\n        Connect(Tree[x].ch[1], now, 1);\n        Connect(now, 0, 1);\n    //  root = now;\n        update(now);\n        Clear(x);\n        return ;\n    }\n    \n    inline int Rank(int v)\n    {\n        int now = root;\n        int Ans = 0;\n        while (1)\n        {\n        //  cout<<\"*\"<<now<<endl;\n            if (Tree[now].val == v) return Ans + Tree[Tree[now].ch[0]].size + 1;\n            if (now == 0) break;\n            if (Tree[now].val > v)\n                now = Tree[now].ch[0];\n            else Ans += (Tree[Tree[now].ch[0]].size + Tree[now].cnt), now = Tree[now].ch[1];\n        }\n        return Ans;\n    }\n    \n    inline int Rerank(int x)\n    {\n        if (x > points) return -(0x3f3f3f3f);\n        int now = root;\n        while (1)\n        {\n            int Sum = Tree[now].size - Tree[Tree[now].ch[1]].size;\n            if (Tree[Tree[now].ch[0]].size < x && x <= Sum)\n                break;\n            if (x < Sum)\n                now = Tree[now].ch[0];\n            else x -= Sum, now = Tree[now].ch[1];\n        }\n        Splay(now, 0);\n        return Tree[now].val;\n    }\n    \n    inline int Pre(int v)\n    {\n        int Sum = -(0x3f3f3f3f);\n        int now = root;\n        while (1)\n        {\n            if (!now) break;\n            if (Tree[now].val < v && Tree[now].val > Sum) Sum = Tree[now].val;\n            if (Tree[now].val < v) now = Tree[now].ch[1];\n            else now = Tree[now].ch[0];\n        }\n        return Sum;\n    }\n    \n    inline int Next(int v)\n    {\n        int Sum = 0x3f3f3f3f;\n        int now = root;\n        while (1)\n        {\n            if (!now) break;\n            if (Tree[now].val > v && Tree[now].val < Sum) Sum = Tree[now].val;\n            if (Tree[now].val > v) now = Tree[now].ch[0];\n            else now = Tree[now].ch[1];\n        }\n        return Sum;\n    }\n    \n    int main()\n    {\n    #ifndef ONLINE_JUDGE\n        freopen(\"A.in\", \"r\", stdin);\n        freopen(\"A.out\", \"w\", stdout);\n    #endif\n        scanf(\"%d\", &M);\n        int tot = 0;\n        while (M --)\n        {\n            int op, x;\n            scanf(\"%d%d\", &op, &x);\n            if (op == 1) Create(x);\n            if (op == 2) Delete(x);\n            if (op == 3) printf(\"%d\\n\", Rank(x));\n            if (op == 4) printf(\"%d\\n\", Rerank(x));\n            if (op == 5) printf(\"%d\\n\", Pre(x));\n            if (op == 6) printf(\"%d\\n\", Next(x));\n        }\n        return 0;\n    }\n```\n","categories":["Problem"],"tags":["数据结构","平衡树","Splay","树"]},{"title":"「ZJOI2013」K大数查询 - 树套树","url":"/2018/01/07/Luogu-P3332-ZJOI2013-K%E5%A4%A7%E6%95%B0%E6%9F%A5%E8%AF%A2/","content":"\n题目链接：[传送门](https://www.luogu.org/problemnew/show/3332 \"传送门\")\n\n### Description\n\n有N个位置，M个操作。操作有两种，每次操作如果是1 a b c的形式表示在第a个位置到第b个位置，每个位置加入一个数c如果是2 a b c形式，表示询问从第a个位置到第b个位置，第C大的数是多少。\n<!--more-->\n\n### Input\n\n第一行N，M接下来M行，每行形如1 a b c或2 a b c\n\n### Output\n\n输出每个询问的结果\n\n### Sample Input\n\n> 2 5 1 1 2 1 1 1 2 2 2 1 1 2 2 1 1 1 2 1 2 3\n\n### Sample Output\n\n> 1 2 1\n\n### Solution\n\n这道题调了好久，最后发现(mid - l + 1)打成(l - mid + 1)了。。。\n又是一道树套树的题 外层是权值线段树，内层是区间线段树维护标记 \n对权值建一颗权值线段树 \n其中的某个点表示权值在某个范围的数的个数 \n然后每个点上建一颗区间线段树 \n表示该点表示的权值范围内位于原数组的某个区间的数的个数\n\n### Code\n```cpp\n    #include <iostream>\n    #include <cstdio>\n    #include <cstring>\n    #include <cmath>\n    #include <algorithm>\n    #define LL long long\n    using namespace std;\n    const int Maxn = 50000 + 100;\n    struct node\n    {\n        int lson, rson;\n        LL mark, Sum;\n    }Tree[Maxn * 400];\n    int root[Maxn * 8];\n    int Cnt;\n    int N, M;\n    inline void push_down(int x, int l, int r)\n    {\n        if (!Tree[x].mark) return ;\n        int mid = (l + r) >> 1;\n        if (!Tree[x].lson) Tree[x].lson = ++Cnt;\n        if (!Tree[x].rson) Tree[x].rson = ++Cnt;\n        Tree[Tree[x].lson].mark += Tree[x].mark;\n        Tree[Tree[x].rson].mark += Tree[x].mark;\n        Tree[Tree[x].lson].Sum += Tree[x].mark * (LL)(mid - l + 1);\n        Tree[Tree[x].rson].Sum += Tree[x].mark * (LL)(r - mid);\n        Tree[x].mark = 0;\n    }\n    inline void push_up(int x)\n    {\n        Tree[x].Sum = Tree[Tree[x].lson].Sum + Tree[Tree[x].rson].Sum;\n    }\n    inline void add2(int &R, int l, int r, int x, int y)\n    {\n        if (!R) R = ++Cnt;\n        if (x == l && y == r)\n        {\n            Tree[R].Sum += (y - x + 1);\n            Tree[R].mark ++;\n            return ;\n        }\n        push_down(R, l, r);\n        int mid = (l + r) >> 1;\n        if (y <= mid) add2(Tree[R].lson, l, mid, x, y);\n        else if ( x > mid) add2(Tree[R].rson, mid + 1, r, x, y);\n        else add2(Tree[R].lson, l, mid, x, mid), add2(Tree[R].rson, mid + 1, r, mid + 1, y);\n        push_up(R);\n    }\n    inline void add1 (int R, int l, int r, int x, int y, int z)\n    {\n        add2(root[R], 1, N, x, y);\n        if (l == r) return ;\n        int mid = (l + r) >> 1;\n        if (z <= mid) add1(R << 1, l, mid, x, y, z);\n        else add1(R << 1 | 1, mid + 1, r, x, y, z);\n    }\n    inline LL query2(int R, int l, int r, int x, int y)\n    {\n        if (!R) return 0;\n        if (l == x && r == y)\n            return Tree[R].Sum;\n        push_down(R, l, r);\n        int mid = (l + r) >> 1;\n        if (y <= mid) return query2(Tree[R].lson, l, mid, x, y);\n        else if (x > mid) return query2(Tree[R].rson, mid + 1, r, x, y);\n        else return query2(Tree[R].lson, l, mid, x, mid) + query2(Tree[R].rson, mid + 1, r, mid + 1, y);\n    }\n    inline int query1(int R, int l, int r, int x, int y, LL z)\n    {\n        if (l == r)\n            return l;\n        int mid = (l + r) >> 1;\n        LL t = query2(root[R << 1 | 1], 1, N, x, y);\n        if (z <= t) return query1(R << 1 | 1, mid + 1, r, x, y, z);\n        else return query1(R << 1, l, mid, x, y, z - t);\n    }\n    int main()\n    {\n    #ifndef ONLINE_JUDGE\n        freopen(\"A.in\", \"r\", stdin);\n        freopen(\"A.out\", \"w\", stdout);\n    #endif\n        scanf(\"%d%d\", &N, &M);\n        for (int i = 1; i <= M; ++i)\n        {\n            int type, x, y, z;\n            scanf(\"%d%d%d%d\", &type, &x, &y, &z);\n            LL z1 = (LL)z;\n            if (type == 1)\n                add1(1, 1, N, x, y, z);\n            else printf(\"%d\\n\", query1(1, 1, N, x, y, z1));\n        }\n        return 0;\n    }\n```\n","categories":["Algorithm"],"tags":["线段树","数据结构","省选","树套树"]},{"title":"「CQOI2011」动态逆序对 - 树套树","url":"/2018/01/07/Luogu-P3157-CQOI2011-%E5%8A%A8%E6%80%81%E9%80%86%E5%BA%8F%E5%AF%B9/","content":"\n题目链接：[传送门](https://www.luogu.org/problemnew/show/3157 \"传送门\")\n\n### Description\n\n对于序列A，它的逆序对数定义为满足i < j，且Ai > Aj的数对(i,j)的个数。给1到n的一个排列，按照某种顺序依次删除m个元素，你的任务是在每次删除一个元素之前统计整个序列的逆序对数。\n\n<!--more-->\n\n### Input\n\n输入第一行包含两个整数n和m，即初始元素的个数和删除的元素个数。以下n行每行包含一个1到n之间的正整数，即初始排列。以下m行每行一个正整数，依次为每次删除的元素。\n\n### Output\n\n输出包含m行，依次为删除每个元素之前，逆序对的个数。\n\n### Sample Input\n\n> 5 4 1 5 3 4 2 5 1 4 2\n\n### Sample Output\n\n> 5 2 2 1\n\n### Solution\n\n人生第一道树套树的题 \n这一题如果不带修改的话很明显可以用权值线段树做 \n因为对于一个点而言，它对答案产生的贡献就是它前面的数中比它大的数的个数加上它后面的数中比它小的数的个数 \n但是如果需要修改，我们还直接上线段树的话每一次修改的时间复杂度就会是$O(N log N)$的，显然承受不了。\n因此我们可以考虑套一层树状数组，每个树状数组上的点上开一颗线段树，\n那么这样的话修改就变成$O(log^2 N)$的了，\n只是需要注意线段树要动态开点，不然会MLE \n然后愉快地上树状数组套权值线段树就可以了\n\n### Code\n```cpp\n    #include <iostream>\n    #include <cstdio>\n    #include <cstring>\n    #include <cmath>\n    #include <algorithm>\n    #define LL long long\n    #define lowbit(x) (x & (-x))\n    using namespace std;\n    const int Maxn = 100000 + 100, Maxm = 50000 + 100, Maxt = 10000000 + 10;\n    int N, M;\n    int A[Maxn], Pos[Maxn], lson[Maxt], rson[Maxt], Tree[Maxt], Cnt;\n    inline void push_up(int x)\n    {\n        Tree[x] = Tree[lson[x]] + Tree[rson[x]];\n    }\n    inline int query_seg(int root, int l, int r, int x, int y)\n    {\n        if (!root) return 0;\n    //  if (x <= l && r <= y)\n    //      return Tree[root];\n        if (x == l && r == y)\n            return Tree[root];\n        int mid = (l + r) >> 1;\n        int Sum = 0;\n        //if (x <= mid) Sum += query_seg(lson[root], l, mid, x, y);\n        //if (y > mid) Sum += query_seg(rson[root], mid + 1, r, x, y);\n    //  push_up(root);\n        if (y <= mid) return query_seg(lson[root], l, mid, x, y);\n        else if (x > mid) return query_seg(rson[root], mid + 1, r, x, y);\n        return query_seg(lson[root], l, mid, x, mid) + query_seg(rson[root], mid + 1, r, mid + 1, y);\n    //  return Sum;\n    }\n    inline void add_seg(int &root, int l, int r, int x, int v)\n    {\n        if (!root) root = ++Cnt;\n        if (l == r)\n        {\n            Tree[root] += v;\n            return ;\n        }\n        int mid = (l + r) >> 1;\n        if (x <= mid)\n            add_seg(lson[root], l, mid, x, v);\n        else \n            add_seg(rson[root], mid + 1, r, x, v);\n        push_up(root);\n    }\n    inline int query_bit(int x, int l, int r)\n    {\n        int Sum = 0;\n        int fl = 0;\n        while (x)\n        {\n            Sum += query_seg(x, 1, N, l, r);\n            x -= lowbit(x);\n        }\n        return Sum;\n    }\n    inline void add_bit(int x, int y, int v)\n    {\n        while (x <= N)\n        {\n            add_seg(x, 1, N, y, v);\n            x += lowbit(x);\n        }\n    }\n    int main()\n    {\n    #ifndef ONLINE_JUDGE\n        freopen(\"A.in\", \"r\", stdin);\n        freopen(\"A.out\", \"w\", stdout);\n    #endif\n        scanf(\"%d%d\", &N, &M);\n        Cnt = N;\n        LL Ans = 0;\n        for (int i = 1; i <= N; ++i)\n        {\n            scanf(\"%d\", &A[i]), Pos[A[i]] = i;\n            Ans += (LL)query_bit(i - 1, A[i] + 1, N);\n            add_bit(i, A[i], 1);\n        }\n        int x;\n        for (int i = 1; i <= M; ++i)\n        {\n            printf(\"%lld\\n\", Ans);\n            scanf(\"%d\", &x);\n            Ans -= (LL)query_bit(Pos[x] - 1, x + 1, N);\n            Ans -= (LL)query_bit(N, 1, x - 1);\n            Ans += (LL)query_bit(Pos[x] - 1, 1, x - 1);\n            add_bit(Pos[x], x, -1);\n        }\n        return 0;\n    }\n```\n","categories":["Problem"],"tags":["线段树","数据结构","树状数组","省选","树套树"]},{"title":"中国剩余定理（CRT）","url":"/2018/01/05/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86%EF%BC%88CRT%EF%BC%89/","content":"\n### 大致思想\n\n设$(m_1, m_2,\\cdots ,m_k) = 1$，且$M=m_1\\*m_2\\*\\cdots \\*m_k$ 有同余方程 $x \\equiv a_1(mod\\ m_1)$ $x \\equiv a_2(mod\\ m_2)$ $\\ \\ \\ \\ ...$ $x \\equiv a_k(mod\\ m_k)$ 的解为 $x = (\\sum_{i=1}^{k} a_i \\* {\\frac {M}{m_i}} \\*(\\frac {M} {m_i})^{-1}) mod \\ M$\n<!--more-->\n","categories":["Algorithm"],"tags":["数学","CRT"]},{"title":"线性筛欧拉函数","url":"/2018/01/04/%E7%BA%BF%E6%80%A7%E7%AD%9B%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/","content":"\n### 大致内容\n\n线性筛欧拉函数和线性筛素数其实差不多 只是需要用到一些性质： （以下所有p都为素数）\n\n<!--more-->\n\n**性质1. $\\varphi (p) = p-1$**\n\n这个比较显然，因为素数p除了1之外的因数只有p，因此1到p的整数只有p和p自己不互质\n\n \n\n**性质2. 若 $p|i​$，那么$\\varphi (i * p) = p * \\varphi(i)​$**\n\n证明：\n\n设$b = gcd(n, i)$ 因为n、i不互质，所以$n=k_1b, i=k_2b$ 所以$n +i=(k_1+k_2)b$，即$n+i$与$i$不互质\n\n因为$[1,i]$中与$i$不互质的整数n共有$i-\\varphi (i)$个，且$n+i$与$i$不互质\n\n所以$(i,2i]$中与$i$不互质的整数也是$i-\\varphi (i)$个 \n\n所以$[1, i*p]$中与$i$不互质的整数有$p(i - \\varphi(i)) = p*i - p*\\varphi(i)$ 个\n\n即$\\varphi(i*p)=p*i-(p*i-p*\\varphi(i))$ \n\n因此$\\varphi (i * p) = p * \\varphi(i)$\n\n> 2018.12.16 Update\n>\n> 今天再看这个性质2居然看不太懂了。。。\n>\n> 另外一个比较好理解的证明方法：\n>\n> 由于$\\varphi$的另外一种计算方法$\\varphi(x)=x*\\prod_{i}(1-\\frac{1}{p_i})$ 其中$p_i$为$x$的质因子\n>\n> 且此时$i|p$，即$i$已经包含了$i * p$的所有质因子\n>\n> 那么$\\varphi(i * p)=i * p * \\prod_i(1-\\frac{1}{p_i}) = p * \\varphi(i)$\n\n\n\n**性质3\\. 若 $p\\nmid i$，那么$\\varphi(i * p)=\\varphi(i) * (p - 1)$**\n\n由性质1及phi函数为积性函数可知\n\n### Code(hdu2824)\n```cpp\n    #include <iostream>\n    #include <cstdio>\n    #include <cmath>\n    #include <cstring>\n    #include <algorithm>\n    #define LL long long\n    using namespace std;\n    const int Maxn = 3000000 + 100;\n    int Prime[Maxn], phi[Maxn], NotPrime[Maxn], Cnt;\n    int N, a, b;\n    inline void Get_phi()\n    {\n        for (int i = 2; i <= Maxn; ++i)\n        {\n            if (!NotPrime[i])\n            {\n                Prime[++Cnt] = i;\n                phi[i] = i - 1;\n            }\n            for (int j = 1; j <= Cnt && i * Prime[j] <= Maxn; ++j)\n            {\n                NotPrime[i * Prime[j]] = 1;\n                if (!(i % Prime[j]))\n                {\n                    phi[i * Prime[j]] = phi[i] * Prime[j];\n                    break;\n                }\n                else phi[i * Prime[j]] = phi[i] * (Prime[j] - 1);\n            }\n        }\n    }\n    int main()\n    {\n    #ifndef ONLINE_JUDGE\n        freopen(\"A.in\", \"r\", stdin);\n        freopen(\"A.out\", \"w\", stdout);\n    #endif\n        Get_phi();\n        while (scanf(\"%d%d\", &a, &b) != EOF)\n        {\n            LL Ans = 0;\n            for (int i = a; i <= b; ++i) Ans += phi[i];\n            cout<<Ans<<endl;\n        }\n        return 0;\n    }\n```\n","categories":["Algorithm"],"tags":["数学","欧拉函数","线性筛"]},{"title":"「JSOI2004」平衡点 - 模拟退火","url":"/2018/01/03/Luogu-P1337-JSOI-%E5%B9%B3%E8%A1%A1%E7%82%B9%EF%BC%88%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB%EF%BC%89/","content":"\n题目链接：[传送门](https://www.luogu.org/problemnew/show/P1337 \"传送门\")\n\n### Description\n\n如图：有n个重物，每个重物系在一条足够长的绳子上。每条绳子自上而下穿过桌面上的洞，然后系在一起。图中X处就是公共的绳结。假设绳子是完全弹性的（不会造成能量损失），桌子足够高（因而重物不会垂到地上），且忽略所有的摩擦。 问绳结X最终平衡于何处。 注意：桌面上的洞都比绳结X小得多，所以即使某个重物特别重，绳结X也不可能穿过桌面上的洞掉下来，最多是卡在某个洞口处。\n<!--more-->\n\n### Input\n\n文件的第一行为一个正整数n（1≤n≤1000），表示重物和洞的数目。接下来的n行，每行是3个整数：Xi.Yi.Wi，分别表示第i个洞的坐标以及第 i个重物的重量。(-10000≤x,y≤10000, 0 < w≤1000 )\n\n### Output\n\n你的程序必须输出两个浮点数（保留小数点后三位），分别表示处于最终平衡状态时绳结X的横坐标和纵坐标。两个数以一个空格隔开。\n\n### Sample Input\n\n> 3 0 0 1 0 2 1 1 1 1\n\n### Sample Output\n\n> 0.577 1.000\n\n### Solution\n\n~~人生第一道计算几何/模拟退火题 ~~\n~~虽然好像有点水。。。 ~~\n~~我们首先确定一个原点，然后在这个原点上进行正交分解，~~\n~~最终我们可以得到一个合力，而真正的平衡点一定在合力所指的方向~~\n~~接着把平衡点向合力方向调整一个尺度k，k是自定的一个常数，且随着调整次数的增多而不断减小 ~~\n~~于是这样就可以求得近似解~~\n\n19.2.28 UPD\n\n假的假的，什么鬼模拟退火，就是个爬山。。。\n\n找时间写一篇真的模拟退火。。。\n\n### Code\n```cpp\n    #include <iostream>\n    #include <cstdio>\n    #include <cstring>\n    #include <cmath>\n    #include <algorithm>\n    using namespace std;\n    const int Maxn = 1000 + 100;\n    const double eps = 1e-5;\n    int N;\n    struct node\n    {\n        double x, y, f;\n    }Object[Maxn];\n    double Move = 5000;\n    double x, y;\n    inline double sqr(double x)\n    {\n        return x * x;\n    }\n    int Dx = 1, Dy = 1;\n    inline void Work()\n    {\n        double Fx = 0, Fy = 0, Dis = 0;\n        for (int i = 1; i <= N; ++i)\n        {\n            Dis = sqrt(sqr(x - Object[i].x) + sqr(y - Object[i].y));\n            if (Dis == 0.0)\n                continue;\n            Fx += Object[i].f * (Object[i].x - x) / Dis;\n            Fy += Object[i].f * (Object[i].y - y) / Dis;\n        }\n        double F = sqrt(sqr(Fx) + sqr(Fy));\n        x += Move * Fx / F;\n        y += Move * Fy / F;\n    }\n    int main()\n    {\n    #ifndef ONLINE_JUDGE\n        freopen(\"A.in\", \"r\", stdin);\n        freopen(\"A.out\", \"w\", stdout);\n    #endif\n        scanf(\"%d\", &N);\n        for (int i = 1; i <= N; ++i) scanf(\"%lf%lf%lf\", &Object[i].x, &Object[i].y, &Object[i].f);\n        while (1)\n        {\n            double sx = x;\n            double sy = y;\n            Work();\n            if (abs(sx - x) <= eps && abs(sy - y) <= eps) break;\n            if (Dx != (x > sx) || Dy != (y > sy))\n            {\n                Dx = !(x > sx);\n                Dy = !(y > sy);\n                Move *= 0.9;\n            }\n        }\n        printf(\"%.3lf %.3lf\\n\", x, y);\n        return 0;\n    }\n```\n","categories":["Problem"],"tags":["计算几何","省选","模拟退火"]},{"title":"Baby-Step-Gaint-Step(BSGS)算法","url":"/2018/01/03/Baby-Step-Gaint-Step-BSGS-%E7%AE%97%E6%B3%95/","content":"\n模板题：[POJ2417](http://poj.org/problem?id=2417 \"POJ2417\") 调这道题调了我一下午，第二天实在查不出错把#ifndef去掉就A了。。。。。\n\n### 大致思想\n\nBSGS这个算法主要是用来解决这个问题： $A^x\\equiv B ( mod \\ C)$已知ABC， 求x \n\n而最普通的BSGS求解的是C为质数（其实就是相当与AC互质）的情况 \n\n对于这个问题，如果直接暴力枚举x的值的话，根据Fermat小定理可以知道$A^{\\phi p} \\equiv 1(mod\\ p)$ \n\n那么我们只要再往下枚举的话必定会产生循环 \n\n因此枚举的范围就是$0$~$\\phi C$，但是如果C特别大的话显然会超时，于是便有了BSGS算法\n<!--more-->\n\n### 算法流程\n\n我们设$m = \\lceil \\sqrt C \\rceil$（可以证明出只需要取到该值）, \n\n令$x = i * m + j $ 那么有$A^{im + j} \\equiv B(mod\\ C)$ \n\n因此$A^{im} \\times A^j\\equiv B(mod \\ C)$ \n\n我们枚举i的话，就能得到$A^{im}$的值\n\n令$D=A^{im}$，则 $D \\times A^j \\equiv (mod \\ C)$ \n\n显然我们能用扩欧将$A^j$求出，然后可以先预处理出所有$A^j$的值，存在hash中\n\n直接在hash中查找其所对应的j值即可（用map当然可以，只是会T。。。）\n\n### Code\n```cpp\n    #include <iostream>\n    #include <cstdio>\n    #include <cstring>\n    #include <cmath>\n    #include <algorithm>\n    #include <map>\n    #define LL long long \n    #define ll long long \n    using namespace std;\n    LL A, B, C;\n    struct hash\n    {\n        static const LL Mod = 100007;\n        LL a[Mod + 100], v[Mod + 100];\n        LL Find(LL x)\n        {\n            int y = x % Mod;\n            while (a[y] != x && a[y] != -1) (y += 1) %= Mod;\n            return y;\n        }\n        void Insert(LL x, LL y)\n        {\n            LL z = Find(x);\n            if (a[z] == -1)\n            {\n                a[z] = x;\n                v[z] = y;\n            }\n        }\n        LL Get(LL x)\n        {\n            LL y = Find(x);\n            return a[y] == x ? v[y] : -1;\n        }\n        void Clear()\n        {\n            memset(a, 0xff, sizeof(a));\n        }\n    } S;\n    inline LL Pow(LL a, LL b)\n    {\n        LL Ans = 1;\n        while (b)\n        {\n            if (b & 1) (Ans *= a) %= C;\n            (a *= a) %= C;\n            b >>= 1;\n        }\n        return Ans;\n    }\n    inline LL Ex_gcd(LL a, LL b, LL &x, LL &y)\n    {\n        if (!b)\n        {\n            x = 1; y = 0;\n            return a;\n        }\n        LL Gcd = Ex_gcd(b, a % b, x, y);\n        LL Tmp = x;\n        x = y;\n        y = (Tmp - (a / b) * y);\n        return Gcd;\n    }\n    \n    inline int BSGS()\n    {\n        S.Clear();\n        LL M = ceil(sqrt((double)C));\n        LL Base = 1;\n        for (LL i = 0; i < M; ++i)\n        {\n            S.Insert(Base, i);\n            Base = Base * A % C;\n        }\n        LL D = 1;\n        for (LL i = 0; i < M; ++i)\n        {\n            LL x, y;\n            Ex_gcd(D, C, x, y);\n            x = ((x * B) % C + C) % C;\n            LL k = S.Get(x);\n            if (k != -1)\n                return i * M + k;\n            (D *= Base) %= C;\n        }\n        return -1;\n    }\n    int main()\n    {\n    /*#ifndef ONLINE_JDUGE\n        freopen(\"A.in\", \"r\", stdin);\n        freopen(\"A.out\", \"w\", stdout);\n    #endif\n    */\n        while (scanf(\"%lld%lld%lld\", &C, &A, &B)!= EOF)\n        {\n        //  cout<<C<<\" \"<<A<<\" \"<<B<<endl;\n            LL Ans = BSGS();\n            if (Ans == -1) puts(\"no solution\");\n            else printf(\"%lld\\n\", Ans);\n        }\n        return 0;\n    }\n```\n\n### 扩展\n\n如果A和C不互质怎么办？ \n\n设$d = \\gcd(A, C)$，则$A=a * d, B = b * d, C = c* d$(如果B不是d的倍数且B!=1的话显然无解)\n\n也就是说$(a * d)^x \\equiv (b*d) (mod \\ c*d)$ \n\n因此$a * (a * d)^{x - 1} \\equiv b(mod\\ c)$ \n\n我们把之前的$D*= a$，那么前半部分就只剩下$(a * d)^{x - 1} $了\n\n所以我们不断求$d = gcd(A, C)$,然后不断将$B /= d, C /= d, D *= A/d$，++cnt, 直到d==1为止 \n\n最后方程就变成这种形式了： \n\n$D * A^{x - cnt} \\equiv B(mod\\ C)$ \n\n我们像之前一样令$x = i * m + j + cnt$，和之前一样处理即可 \n\n只是这样求出来的$x \\ge cnt$，我们需要首先枚举一下$0\\sim cnt-1$的情况就能解决了\n\n","categories":["Algorithm"],"tags":["数学","BSGS","ex_BSGS","费马小定理"]},{"title":"Pollard Rho大数质因数分解","url":"/2018/01/01/Pollard-Rho%E5%A4%A7%E6%95%B0%E8%B4%A8%E5%9B%A0%E6%95%B0%E5%88%86%E8%A7%A3/","content":"\n### 大致思想\n\nPollard Rho是一个神奇的玄学算法 我们知道质因数分解用朴素的试除法的话时间复杂度是$O(\\\\sqrt N)$的 Pollard Rho大致思路其实就是利用各种玄学的随机算法去优化暴力。。。\n\n<!--more-->\n\n### 算法流程\n\n我们先用Miller-Rabin判断当前的数是否是素数，\n如果是则直接返回，否则找出这个数的一个因子（不一定是质因子），然后递归地分解这个因子和约掉这个因子的另一个因子。\n然而在找出这个数的因子时，Pollard Rho算法利用了一个神奇的随机化算法：\n我们通过随机选取一个整数a，然后b=a×a+c(c为任意整数)得到两个整数a和b，\n设待分解的整数为n，那么循环计算$p=gcd(abs (a-b),n)$,\n若p不为1或a和b出现循环则跳出，\n否则需要将b的值赋给a，再次利用b=a×a+c计算新的b值。\n若ab出现循环时，我们需要更换c值再次重新循环计算；\n而若$1 < p < n$时则找到了一个因子p 然后还有一个小小的优化，就是利用Floyd判环的原理，让A和B按照B的速度是A的速度的两倍从同一起点开始往前走\n当B第一次赶上A时，我们便知道B已经走了至少一圈。\n利用这个优化可以快很多 模板题：[POJ1811](http://poj.org/problem?id=1811 \"POJ1811\")\n\n### Code\n```cpp\n    #include <iostream>\n    #include <cstdio>\n    #include <cstring>\n    #include <cmath>\n    #include <algorithm>\n    #define LL long long\n    using namespace std;\n    const int Maxn = 1000000 + 100;\n    LL N;\n    LL Fac[Maxn], Num[Maxn], Cnt;\n    inline LL gcd(LL a, LL b)\n    {\n        return b ? gcd(b, a % b) : a;\n    }\n    inline LL Mult(LL a, LL b, LL x)\n    {\n        LL Ans = 0;\n        while (b)\n        {\n            if (b & 1) Ans = (Ans + a) % x;\n            (a += a) %= x;\n            b >>= 1;\n        }\n        return Ans;\n    }\n    inline LL Pow(LL a, LL b, LL x)\n    {\n        LL Ans = 1;\n        while (b)\n        {\n            if (b & 1) Ans = Mult(Ans, a, x);\n            a = Mult(a, a, x);\n            b >>= 1;\n        }\n        return Ans;\n    }\n    inline int Miller_Rabin(LL x)\n    {\n        if (x == 2 || x == 3 || x == 5 || x == 7)return 1;\n        if (x < 2 || !(x % 2) || !(x % 3) || !(x % 5) || !(x % 7)) return 0;\n        LL u = x - 1, k = 0;\n        while (!(u & 1))u >>= 1, ++k;\n        for (int i = 1; i <= 1000; ++i)\n        {\n            LL a = rand()%(x - 2) + 2;\n            a = Pow(a, u, x);\n            LL b = a;\n            for (int j = 0; j < k; ++j)\n            {\n                a = Mult(a, a, x);\n                if (a == 1 && b != 1 && b != (x - 1)) return 0;\n                b = a;\n            }\n            if (a != 1) return 0;\n        }\n        return 1;\n    }\n    inline LL Pollard_Rho(LL x, LL k)\n    {\n        LL u = 2, cnt = 1;\n        LL a = rand()%(x - 1) + 1;\n        LL b = a;\n        while (1)\n        {\n            a = (Mult(a, a, x) + k) % x;\n            ++ cnt;\n            LL d = gcd((b - a + x) % x, x);\n            if (1 < d && d <= x)\n                return d;\n            if (cnt == u)\n            {\n                b = a;\n                u <<= 1;\n            }\n        }\n    }\n    inline void Find(LL x, LL c)\n    {\n        if (Miller_Rabin(x))\n        {\n            Fac[++Cnt] = x;\n            return ;\n        }\n        LL k = c;\n        LL p = x;\n        while (p == x) p = Pollard_Rho(x, --k);\n        Find(p, k);\n        Find(x / p, k);\n    }\n    LL Ans[Maxn];\n    int main()\n    {\n    #ifndef ONLINE_JUDGE\n        freopen(\"A.in\", \"r\", stdin);\n        freopen(\"A.out\", \"w\", stdout);\n    #endif\n        scanf(\"%lld\", &N);\n        srand(time(0));\n        if (Miller_Rabin(N))\n        {\n            cout<<N<<endl;\n            return 0;\n        }\n        Find(N, 19260817);\n        sort(Fac + 1, Fac + Cnt + 1);\n        LL Sum = Cnt;\n        Cnt = 1;\n        Ans[Cnt] = Fac[1];\n        Num[1] = 1;\n        for (int i = 2; i <= Sum; ++i)\n        {\n            if (Fac[i] == Fac[i - 1])\n                Num[Cnt] ++;\n            else Ans[++Cnt] = Fac[i], Num[Cnt] = 1;\n        }\n        if (Num[1]== 1)\n            printf(\"%lld \", Ans[1]);\n        else printf(\"%lld^%lld \", Ans[1], Num[1]);\n        for (int i = 2; i <= Cnt; ++i)\n        {\n            if (Num[i] != 1) printf(\"* %lld^%lld \", Ans[i], Num[i]);\n            else printf(\"* %lld \", Ans[i]);\n        }\n        cout<<endl;\n        return 0;\n    }\n```\n","categories":["Algorithm"],"tags":["数学","Pollard Rho","Miller-Rabin"]},{"title":"「JSOI2008」星球大战 - 并查集","url":"/2017/12/31/Luogu-P1197-JSOI2008-%E6%98%9F%E7%90%83%E5%A4%A7%E6%88%98-%E5%B9%B6%E6%9F%A5%E9%9B%86/","content":"\n题目链接：[传送门](https://www.luogu.org/problemnew/show/1197 \"传送门\")\n\n### Description\n\n很久以前，在一个遥远的星系，一个黑暗的帝国靠着它的超级武器统治者整个星系。某一天，凭着一个偶然的机遇，一支反抗军摧毁了帝国的超级武器，并攻下了星系中几乎所有的星球。这些星球通过特殊的以太隧道互相直接或间接地连接。 但好景不长，很快帝国又重新造出了他的超级武器。凭借这超级武器的力量，帝国开始有计划地摧毁反抗军占领的星球。由于星球的不断被摧毁，两个星球之间的通讯通道也开始不可靠起来。现在，反抗军首领交给你一个任务：给出原来两个星球之间的以太隧道连通情况以及帝国打击的星球顺序，以尽量快的速度求出每一次打击之后反抗军占据的星球的连通快的个数。（如果两个星球可以通过现存的以太通道直接或间接地连通，则这两个星球在同一个连通块中）。\n\n<!--more-->\n### Input\n\n输入文件第一行包含两个整数，N (1 <= N <= 2M) 和M (1 <= M <= 200,000)，分别表示星球的数目和以太隧道的数目。星球用0~N-1的整数编号。 接下来的M行，每行包括两个整数X, Y，其中（0<=X <> Y < N），表示星球X和星球Y之间有以太隧道。注意所有的以太隧道都是双向的。 接下来一行是一个整数K，表示帝国计划打击的星球个数。 接下来的K行每行一个整数X，满足0<=X < N，表示帝国计划打击的星球编号。帝国总是按输入的顺序依次摧毁星球的。\n\n### Output\n\n输出文件的第一行是开始时星球的连通块个数。 接下来的K行，每行一个整数，表示经过该次打击后现存星球的连通块个数。\n\n### Sample Input\n\n8 13 0 1 1 6 6 5 5 0 0 6 1 2 2 3 3 4 4 5 7 1 7 2 7 6 3 6 5 1 6 3 5 7\n\n### Sample Output\n\n1 1 1 2 3 3\n\n### Solution\n\n这道题套路见到过，做法显然是并查集，但是既然不能删边的话只要倒着加边即可 \n然后就是存边的时候要花点心思(不会用Vector的我想好久要怎么处理) 然而在码这道题的时候各种低级错误调了好久。。。\n\n### Code\n```cpp\n    #include <iostream>\n    #include <cstdio>\n    #include <cstring>\n    #include <cmath>\n    #include <algorithm>\n    using namespace std;\n    const int Maxn = 2000 + 100;\n    int e, Begin[Maxn], To[Maxn], Next[Maxn];\n    int N, M;\n    int Vis[Maxn], Match[Maxn];\n    inline void add(int x, int y)\n    {\n        To[++e] = y;\n        Next[e] = Begin[x];\n        Begin[x] = e;\n    }\n    inline int Dfs(int x)\n    {\n        for (int i = Begin[x]; i; i = Next[i])\n        {\n            int y = To[i];\n            if (Vis[y]) continue;\n            Vis[y] = 1;\n            if (!Match[y] || Dfs(Match[y]))\n            {\n                Match[y] = x;\n                return 1;\n            }\n        }\n        return 0;\n    }\n    int ANS[Maxn];\n    int main()\n    {\n    #ifndef ONLINE_JUDGE\n        freopen(\"A.in\", \"r\", stdin);\n        freopen(\"A.out\", \"w\", stdout);\n    #endif\n        scanf(\"%d%d\", &N, &M);\n        int x, y;\n        for (int i = 1; i <= M; ++i)\n        {\n            scanf(\"%d%d\", &x, &y);\n            ++x, ++y;\n            add(i, x);\n            add(i, y);\n        }\n        int Ans = 0;\n        for (int i = 1; i <= N; ++i)\n        {\n            memset(Vis, 0, sizeof(Vis));\n            if (!Dfs(i)) break;\n            else ++Ans;\n        }\n        cout<<Ans<<endl;\n        for (int i = 1; i <= N; ++i)\n            ANS[Match[i]] = i;\n        for (int i = 1; i <= Ans; ++i)\n            cout<<ANS[i] - 1<<endl;\n        return 0;\n    }\n```\n","categories":["Problem"],"tags":["并查集","省选"]},{"title":"「HNOI2006」超级英雄 & 「SCOI2010」连续攻击游戏 - 二分图","url":"/2017/12/31/Luogu-P2319-HNOI2006-%E8%B6%85%E7%BA%A7%E8%8B%B1%E9%9B%84-P1640-SCOI2010-%E8%BF%9E%E7%BB%AD%E6%94%BB%E5%87%BB%E6%B8%B8%E6%88%8F/","content":"\n两道二分图最大匹配的题，题目可以说是几乎一模一样，这里就只放一道吧 传送门：[Luogu P2319 \\[HNOI2006\\]超级英雄](https://www.luogu.org/problemnew/show/2319 \"Luogu P2319 [HNOI2006]超级英雄\") [Luogu P1640 \\[SCOI2010\\]连续攻击游戏](https://www.luogu.org/problemnew/show/1640 \"Luogu P1640 [SCOI2010]连续攻击游戏\")\n<!--more-->\n\n### Description\n\n现在电视台有一种节目叫做超级英雄，大概的流程就是每位选手到台上回答主持人的几个问题，然后根据回答问题的多少获得不同数目的奖品或奖金。主持人问题准备了若干道题目，只有当选手正确回答一道题后，才能进入下一题，否则就被淘汰。为了增加节目的趣味性并适当降低难度，主持人总提供给选手几个“锦囊妙计”，比如求助现场观众，或者去掉若干个错误答案（选择题）等等。 这里，我们把规则稍微改变一下。假设主持人总共有m道题，选手有n种不同的“锦囊妙计”。主持人规定，每道题都可以从两种“锦囊妙计”中选择一种，而每种“锦囊妙计”只能用一次。我们又假设一道题使用了它允许的锦囊妙计后，就一定能正确回答，顺利进入下一题。现在我来到了节目现场，可是我实在是太笨了，以至于一道题也不会做，每道题只好借助使用“锦囊妙计”来通过。如果我事先就知道了每道题能够使用哪两种“锦囊妙计”，那么你能告诉我怎样选择才能通过最多的题数吗？\n\n### Input\n\n输入的第一行是两个正整数 nn 和 mm (0 < n < 1001, 0 < m < 10010 < n < 1001,0 < m< 1001)表示总共有 n 种“锦囊妙计”，编号为 0 \\\\sim n-10∼n−1，总共有 mm 个问题。 以下的m行，每行两个数，分别表示第 mm 个问题可以使用的“锦囊妙计”的编号。 注意，每种编号的“锦囊妙计”只能使用一次，同一个问题的两个“锦囊妙计”可能一样。\n\n### Output\n\n输出的第一行为最多能通过的题数 pp，接下来 pp 行，每行为一个整数，第 ii 行表示第 ii 题使用的“锦囊妙计的编号”。 如果有多种答案，那么任意输出一种，本题使用 Special Judge 评判答案。\n\n### Sample Input\n\n5 6 3 2 2 0 0 3 0 4 3 2 3 2\n\n### Sample Output\n\n4 3 2 0 4\n\n### Solution\n\n几乎是裸的二分图匹配 \n直接按照题意连边 \n只是要注意只要找不到匹配就直接退出 \n剩下就是匈牙利了\n\n### Code\n```cpp\n    #include <iostream>\n    #include <cstdio>\n    #include <cstring>\n    #include <cmath>\n    #include <algorithm>\n    using namespace std;\n    const int Maxn = 2000 + 100;\n    int e, Begin[Maxn], To[Maxn], Next[Maxn];\n    int N, M;\n    int Vis[Maxn], Match[Maxn];\n    inline void add(int x, int y)\n    {\n        To[++e] = y;\n        Next[e] = Begin[x];\n        Begin[x] = e;\n    }\n    inline int Dfs(int x)\n    {\n        for (int i = Begin[x]; i; i = Next[i])\n        {\n            int y = To[i];\n            if (Vis[y]) continue;\n            Vis[y] = 1;\n            if (!Match[y] || Dfs(Match[y]))\n            {\n                Match[y] = x;\n                return 1;\n            }\n        }\n        return 0;\n    }\n    int ANS[Maxn];\n    int main()\n    {\n    #ifndef ONLINE_JUDGE\n        freopen(\"A.in\", \"r\", stdin);\n        freopen(\"A.out\", \"w\", stdout);\n    #endif\n        scanf(\"%d%d\", &N, &M);\n        int x, y;\n        for (int i = 1; i <= M; ++i)\n        {\n            scanf(\"%d%d\", &x, &y);\n            ++x, ++y;\n            add(i, x);\n            add(i, y);\n        }\n        int Ans = 0;\n        for (int i = 1; i <= N; ++i)\n        {\n            memset(Vis, 0, sizeof(Vis));\n            if (!Dfs(i)) break;\n            else ++Ans;\n        }\n        cout<<Ans<<endl;\n        for (int i = 1; i <= N; ++i)\n            ANS[Match[i]] = i;\n        for (int i = 1; i <= Ans; ++i)\n            cout<<ANS[i] - 1<<endl;\n        return 0;\n    }\n```\n","categories":["Problem"],"tags":["二分图匹配","省选","匈牙利算法"]},{"title":"Miller-Rabin素数测试","url":"/2017/12/31/Miller-Rabin%E7%B4%A0%E6%95%B0%E6%B5%8B%E8%AF%95/","content":"\n### 基本算法\n\nMiller-Rabin素数测试其实是基于Fermat小定理的一种素数测试方法，其大致思想如下：\n**Fermat小定理：**对于素数p和任意正整数a，有$a^{p-1} \\equiv 1(mod\\ p)$，反过来，如果满足$a^{p-1} \\equiv 1(mod\\ p)$，p就有很大概率是素数 \n**Miller-Rabin：**于是，我们不断选取基数b， 计算是否每次都有$b^{n - 1} \\equiv 1(mod\\ p)$，\n若每次都成立则n是素数，若不成立则为合数 \n**二次探测定理：**如果p为奇素数，则$x^2 \\equiv 1(mod\\ p)$的解为$x = 1$或$x = p - 1$ \n我们可以利用二次探测定理优化，那么算法就变成了：\n尽可能提取因子2，把n-1表示成$d * 2^n$，如果n是一个素数，那么或者$a ^ d \\equiv 1(mod\\ n)$，或者存在某个i使得$a^{d+2^{r - i}} \\equiv n-1(mod\\ n) (0\\le i\\le r-1)$\n<!--more-->\n\n### Code\n```cpp\n    #include <iostream>\n    #include <cstdio>\n    #include <cstring>\n    #include <cmath>\n    #include <algorithm>\n    #define LL long long\n    using namespace std;\n    LL N;\n    inline LL Mult(LL a, LL b)\n    {\n        LL Ans = 0;\n        while (b)\n        {\n            if (b & 1) (Ans += a) %= N;\n            (a += a) %= N;\n            b >>= 1;\n        }\n        return Ans;\n    }\n    inline LL Pow(LL a, LL b)\n    {\n        LL Ans = 1;\n        while (b)\n        {\n            if (b & 1) Ans = Mult(Ans, a);\n            a = Mult(a, a);\n            b >>= 1;\n        }\n        return Ans;\n    }\n    inline int Miller_Rabin()\n    {\n        if (N == 2 || N == 3 || N == 5 || N == 7 || N == 11) return 1;\n        if (N == 1 || !(N % 2) || !(N % 3)|| !(N % 5) || !(N % 7) || !(N % 11)) return 0;\n        LL u = N - 1, k = 0;\n        while (!(u & 1)) ++k, u >>= 1;\n        for (int i = 1; i <= 1000; ++i)\n        {\n            LL x = rand()% (N - 2) + 2;\n            x = Pow(x, u);\n            LL pre = x;\n            for (int j = 0; j < k; ++j)\n            {\n                x = Mult(x, x);\n                if (x == 1 && pre != 1 && pre != (N - 1)) return 0;\n                pre = x;\n            }\n            if (x != 1) return 0;\n        }\n        return 1;\n    }\n    int main()\n    {\n    #ifndef ONLINE_JUDGE\n        freopen(\"A.in\", \"r\", stdin);\n        freopen(\"A.out\", \"w\", stdout);\n    #endif\n        scanf(\"%lld\", &N);\n        srand(time(0));\n        if (Miller_Rabin())\n            cout<<\"Yes\"<<endl;\n        else cout<<\"No\"<<endl;\n        return 0;\n    }\n```\n","categories":["Algorithm"],"tags":["数学","费马小定理","Miller-Rabin"]},{"title":"「ZJOI2009」假期的宿舍 - 二分图","url":"/2017/12/28/Luogu-P2055-ZJOI2009-%E5%81%87%E6%9C%9F%E7%9A%84%E5%AE%BF%E8%88%8D/","content":"\n### Description\n\n学校放假了 · · · · · · 有些同学回家了，而有些同学则有以前的好朋友来探访，那么住宿就是一个问题。比如 A 和 B 都是学校的学生，A 要回家，而 C 来看B，C 与 A 不认识。我们假设每个人只能睡和自己直接认识的人的床。那么一个解决方案就是 B 睡 A 的床而 C 睡 B 的床。而实际情况可能非常复杂，有的人可能认识好多在校学生，在校学生之间也不一定都互相认识。我们已知一共有 n 个人，并且知道其中每个人是不是本校学生，也知道每个本校学生是否回家。问是否存在一个方案使得所有不回家的本校学生和来看他们的其他人都有地方住。\n\n<!--more-->\n### Input\n\n第一行一个数 T 表示数据组数。接下来 T 组数据，每组数据第一行一个数n 表示涉及到的总人数。接下来一行 n 个数，第 i 个数表示第 i 个人是否是在校学生 (0 表示不是，1 表示是)。再接下来一行 n 个数，第 i 个数表示第 i 个人是否回家 (0 表示不会家，1 表示回家，注意如果第 i 个人不是在校学生，那么这个位置上的数是一个随机的数，你应该在读入以后忽略它)。接下来 n 行每行 n 个数，第 i 行第 j 个数表示 i 和 j 是否认识 (1 表示认识，0 表示不认识，第 i 行 i 个的值为 0，但是显然自己还是可以睡自己的床)，认识的关系是相互的。\n\n### Output\n\n对于每组数据，如果存在一个方案则输出 “ ˆ_ˆ ”(不含引号) 否则输出“T_T”(不含引号)。(注意输出的都是半角字符，即三个符号的 ASCII 码分别为94,84,95)\n\n### Sample Input\n\n1 3 1 1 0 0 1 0 0 1 1 1 0 0 1 0 0\n\n### Sample Output\n\n^_^\n\n### Solution\n\n典型的二分图匹配 \n只是需要注意如何连边 \n将所有不在校的和在校不走的和他们认识的在校的人连边 \n然后因为是多组数据，所以要记得存的图要清空\n\n### Code\n```cpp\n    #include <iostream>\n    #include <cstdio>\n    #include <cstring>\n    #include <cmath>\n    #include <algorithm>\n    using namespace std;\n    const int Maxn = 200 + 100;\n    int Link[Maxn], Map[Maxn][Maxn], Vis[Maxn];\n    int Type[Maxn];\n    // 1: 在校不走 2: 在校回家 0: 不在校\n    int N;\n    inline int dfs(int x)\n    {\n        for (int i = 1; i <= N; ++i)\n        {\n            if (!Vis[i] && Map[x][i])\n            {\n                Vis[i] = 1;\n                if (!Link[i] || dfs(Link[i]))\n                {\n                    Link[i] = x;\n                    return 1;\n                }\n            }\n        }\n        return 0;\n    }\n    int main()\n    {\n    #ifndef ONLINE_JUDGE\n        freopen(\"A.in\", \"r\", stdin);\n        freopen(\"A.out\", \"w\", stdout);\n    #endif\n        int T;\n        scanf(\"%d\", &T);\n        while (T--)\n        {\n            memset(Link, 0, sizeof(Link));\n            scanf(\"%d\", &N);\n            int Sum = 0;\n            for (int i = 1; i <= N; ++i)\n                scanf(\"%d\", &Type[i]), Sum += !(Type[i]);\n            for (int i = 1; i <= N; ++i)\n            {\n                int x;\n                scanf(\"%d\", &x);\n                if (Type[i]) Type[i] += x;\n                if (Type[i] == 1) Sum++; \n            }\n            for (int i = 1; i <= N; ++i)\n                for (int j = 1; j <= N; ++j)\n                {\n                    int x;\n                    Map[i][j] = 0;\n                    scanf(\"%d\", &x);\n                    if (x && Type[i] <= 1 && Type[j] >= 1)\n                        Map[i][j] = 1;\n                    if (Type[i] == 1 && i == j)\n                        Map[i][j] = 1;\n                }\n            int Ans = 0;\n            for (int i = 1; i <= N; ++i)\n            {\n                memset(Vis, 0, sizeof(Vis));\n                if ((!Type[i] || Type[i] == 1)&& dfs(i)) Ans ++;\n            }\n            if (Ans == Sum)\n                cout<<\"^_^\"<<endl;\n            else cout<<\"T_T\"<<endl; \n        }\n        return 0;\n    }\n```\n","categories":["Problem"],"tags":["二分图匹配","省选","匈牙利算法"]},{"title":"「ZJOI2007」矩阵游戏 - 二分图","url":"/2017/12/28/Luogu-P1129-ZJOI2007-%E7%9F%A9%E9%98%B5%E6%B8%B8%E6%88%8F/","content":"\n题目链接:[传送门](https://www.luogu.org/problemnew/show/P1129 \"传送门\")\n\n### Description\n\n小Q是一个非常聪明的孩子，除了国际象棋，他还很喜欢玩一个电脑益智游戏――矩阵游戏。矩阵游戏在一个N*N黑白方阵进行（如同国际象棋一般，只是颜色是随意的）。每次可以对该矩阵进行两种操作： 行交换操作：选择矩阵的任意两行，交换这两行（即交换对应格子的颜色） 列交换操作：选择矩阵的任意两列，交换这两列（即交换对应格子的颜色） 游戏的目标，即通过若干次操作，使得方阵的主对角线(左上角到右下角的连线)上的格子均为黑色。 对于某些关卡，小Q百思不得其解，以致他开始怀疑这些关卡是不是根本就是无解的！！于是小Q决定写一个程序来判断这些关卡是否有解。\n<!--more-->\n\n### Input\n\n第一行包含一个整数T，表示数据的组数。 接下来包含T组数据，每组数据第一行为一个整数N，表示方阵的大小；接下来N行为一个N*N的01矩阵（0表示白色，1表示黑色）。\n\n### Output\n\n包含T行。对于每一组数据，如果该关卡有解，输出一行Yes；否则输出一行No。\n\n### Sample Input\n\n2 2 0 0 0 1 3 0 0 1 0 1 0 1 0 0\n\n### Samplle Output\n\nNo Yes\n\n### Solution\n\n其实题意可转化为让每一个$(i, i)$的位置都要为1，\n因此我们可以将题目转化为二分图的问题:\n若$(i,j)$为1，则将i向j连边（因为i行需要移至j行才能保证(j,j)有解）\n然后直接跑一边匈牙利即可\n\n### Code\n```cpp\n    #include <iostream>\n    #include <cstdio>\n    #include <cstring>\n    #include <cmath>\n    #include <algorithm>\n    using namespace std;\n    const int Maxn = 300;\n    int Map[Maxn][Maxn];\n    int Link[Maxn], Vis[Maxn];\n    int N;\n    inline int dfs(int x)\n    {\n        for (int i = 1; i <= N; ++i)\n        {\n            if (!Vis[i] && Map[x][i])\n            {\n                Vis[i] = 1;\n                if (!Link[i] || dfs(Link[i]))\n                {\n                    Link[i] = x;\n                    return 1;\n                }\n            }\n        }\n        return 0;\n    }\n    int main()\n    {\n    #ifndef ONLINE_JUDGE\n        freopen(\"A.in\", \"r\", stdin);\n        freopen(\"A.out\", \"w\", stdout);\n    #endif\n        int T;\n        scanf(\"%d\", &T);\n        while (T--)\n        {\n            memset(Link, 0, sizeof(Link));\n            scanf(\"%d\", &N);\n            int x;\n            for (int i = 1; i <= N; ++i)\n                for (int j = 1; j <= N; ++j)\n                    scanf(\"%d\", &Map[i][j]);\n            int Ans = 0;\n            for (int i = 1; i <= N; ++i)\n            {\n                memset(Vis, 0, sizeof(Vis));\n                if (dfs(i)) Ans ++;\n            }\n            if (Ans == N)\n                cout<<\"Yes\"<<endl;\n            else cout<<\"No\"<<endl;\n        }\n        return 0;\n    }\n```\n","categories":["Problem"],"tags":["二分图匹配","省选","匈牙利算法"]},{"title":"【Day -4】11-6模拟赛 Summary","url":"/2017/11/06/%E3%80%90Day-4%E3%80%9111-6%E6%A8%A1%E6%8B%9F%E8%B5%9B-Summary/","content":"","categories":["Summary"]},{"title":"【Day -5】11-5模拟赛 Summary","url":"/2017/11/05/%E3%80%90Day-5%E3%80%9111-5%E6%A8%A1%E6%8B%9F%E8%B5%9B-Summary/","content":"","categories":["Summary"]},{"title":"「ZJOI2007」棋盘制作 - DP + 悬线法","url":"/2017/11/04/ZJOI2007-%E6%A3%8B%E7%9B%98%E5%88%B6%E4%BD%9C-DP%EF%BC%8C%E6%82%AC%E7%BA%BF%E6%B3%95%E6%B1%82%E6%9C%80%E5%A4%A7%E5%AD%90%E7%9F%A9%E5%BD%A2/","content":"\n题目链接：[传送门](https://www.luogu.org/problemnew/show/1169 \"传送门\")\n\n### Description\n\n小Q找到了一张由N*M个正方形的格子组成的矩形纸片，每个格子被涂有黑白两种颜色之一。小Q想在这种纸中裁减一部分作为新棋盘，当然，他希望这个棋盘尽可能的大。 不过小Q还没有决定是找一个正方形的棋盘还是一个矩形的棋盘（当然，不管哪种，棋盘必须都黑白相间，即相邻的格子不同色），所以他希望可以找到最大的正方形棋盘面积和最大的矩形棋盘面积，从而决定哪个更好一些。 于是小Q找到了即将参加全国信息学竞赛的你，你能帮助他么？\n\n### Input\n\n包含两个整数N和M，分别表示矩形纸片的长和宽。接下来的N行包含一个N * M的01矩阵，表示这张矩形纸片的颜色（0表示白色，1表示黑色）。\n\n### Output\n\n包含两行，每行包含一个整数。第一行为可以找到的最大正方形棋盘的面积，第二行为可以找到的最大矩形棋盘的面积（注意正方形和矩形是可以相交或者包含的）。\n\n### Solution\n\n我们可以先将横纵坐标合为偶数的点取反，这样这道题就变成了求最大子正方形最大子矩形的问题 \n\n第一问非常简单，设$Dp[i][j]$表示到（i,j）的最大子正方形的边长，\n\n如果$A[i][j] =A[i - 1][j] = A[i][j - 1] = A[i - 1][j - 1]$，\n\n则$Dp[i][j] = min(Dp[i - 1][j], Dp[i][j - 1], Dp[i - 1][j - 1]) + 1$ \n\n答案一边算一边取最大值即可 \n\n第二问的话自己想没想出来，看了题解之后发现是一种新的算法：\n\n悬线法（又是一个听起来特别高端的名字） ，特别详细的做法和证明等百度上都有 \n\n主要思路是先预处理出$up[i][j]$表示（i，j）向上扩展最多能扩展几行，$down[i][j]$表示（i，j）向下扩展最多能扩展几行\n\n然后我们首先枚举每一行，每一列，在第i行中，记max_lenth表示枚举到第j列时最多横向能扩展的列数，max_up和max_down分别表示能向上、向下扩展多少行 \n\n这样的话,max_up和max_down就分别等于在这max_lenth列中$up[i][j]$和$down[i][j]$的最小值\n\n 然后答案一边枚举一边更新即可 \n\n复杂度是$O(NM)$的 又学到了一种新的算法\n","categories":["Problem"],"tags":["动态规划"]},{"title":"「Luogu1196」银河英雄传说 - 带权并查集","url":"/2017/11/04/%E6%B4%9B%E8%B0%B7P1196-%E9%93%B6%E6%B2%B3%E8%8B%B1%E9%9B%84%E4%BC%A0%E8%AF%B4-%E5%B8%A6%E6%9D%83%E5%B9%B6%E6%9F%A5%E9%9B%86/","content":"\n### Description\n太长了懒得放\n<!--more-->\n\n### Input\n\n输入文件galaxy.in的第一行有一个整数T（1<=T<=500,000），表示总共有T条指令。 以下有T行，每行有一条指令。指令有两种格式： M i j ：i和j是两个整数（1<=i , j<=30000），表示指令涉及的战舰编号。该指令是莱因哈特窃听到的杨威利发布的舰队调动指令，并且保证第i号战舰与第j号战舰不在同一列。 C i j ：i和j是两个整数（1<=i , j<=30000），表示指令涉及的战舰编号。该指令是莱因哈特发布的询问指令。\n\n### Output\n\n输出文件为galaxy.out。你的程序应当依次对输入的每一条指令进行分析和处理： 如果是杨威利发布的舰队调动指令，则表示舰队排列发生了变化，你的程序要注意到这一点，但是不要输出任何信息； 如果是莱因哈特发布的询问指令，你的程序要输出一行，仅包含一个整数，表示在同一列上，第i 号战舰与第j 号战舰之间布置的战舰数目。如果第i 号战舰与第j号战舰当前不在同一列上，则输出-1。\n\n### Solution\n\n感觉自己带权并查集还不熟，于是做了一下这道很老的题。。。 我们除了记$fa\\[x\\]$表示x的祖先之外，还需要记$Dis\\[x\\] Sum\\[x\\]$分别表示x到祖先的距离和x这个并查集的大小，然后直接维护即可\n\n### Code\n```cpp\n    #include <bits/stdc++.h>\n    using namespace std;\n    const int Maxn = 30000 + 100;\n    int fa[Maxn], Sum[Maxn], Dis[Maxn];\n    int N;\n    inline char safe_read()\n    {\n        char ch = getchar();\n        while (ch != 'M' && ch != 'C')ch = getchar();\n        return ch;\n    }\n    inline int find (int x)\n    {\n        if (fa[x] != x)\n        {\n            int k = fa[x];\n            fa[x] = find(fa[x]);\n            Dis[x] += Dis[k];\n            Sum[x] = Sum[fa[x]];\n        }\n        return fa[x];\n    }\n    int main()\n    {\n    #ifndef ONLINE_JUDGE\n        freopen(\"A.in\", \"r\", stdin);\n        freopen(\"A.out\", \"w\", stdout);\n    #endif\n        scanf(\"%d\", &N);\n        for (int i = 1; i <= Maxn; ++i)\n            fa[i] = i, Sum[i] = 1;\n        while (N --)\n        {\n            char type;\n            int x, y;\n            type = safe_read();\n            scanf(\"%d%d\", &x, &y);\n            if (type == 'M')\n            {\n                int fx = find(x), fy = find(y);\n                fa[fx] = fy;\n                Dis[fx] = Dis[fy] + Sum[fy];\n                Sum[fy] += Sum[fx];\n                Sum[fx] = Sum[fy];\n            }\n            else \n            {\n                int fx = find(x), fy = find(y);\n                if (fx != fy)\n                    puts(\"-1\");\n                else \n                {\n                    printf(\"%d\\n\", abs(Dis[x] - Dis[y]) - 1);\n                }\n            }\n        }\n        return 0;\n    }\n```\n","categories":["Problem"],"tags":["并查集","带权并查集"]},{"title":"【Day -8】11-2模拟赛 Summary","url":"/2017/11/02/%E3%80%90Day-8%E3%80%9111-2%E6%A8%A1%E6%8B%9F%E8%B5%9B-Summary/","content":"","categories":["Summary"]},{"title":"【Day -9】11-1模拟赛 Summary","url":"/2017/11/01/%E3%80%90Day-9%E3%80%9111-1%E6%A8%A1%E6%8B%9F%E8%B5%9B-Summary/","content":"","categories":["Summary"]},{"title":"【Day -11】10-30模拟赛 Summary","url":"/2017/10/30/%E3%80%90Day-11%E3%80%9110-30%E6%A8%A1%E6%8B%9F%E8%B5%9B-Summary/","content":"","categories":["Summary"]},{"title":"【Day -15】10-26模拟赛 Summary","url":"/2017/10/26/%E3%80%90Day-15%E3%80%9110-26%E6%A8%A1%E6%8B%9F%E8%B5%9B-Summary/","content":"","categories":["Summary"]},{"title":"【Day -17】10-24模拟赛 Summary","url":"/2017/10/24/%E3%80%90Day-17%E3%80%9110-24%E6%A8%A1%E6%8B%9F%E8%B5%9B-Summary/","content":"","categories":["Summary"]},{"title":"【Day -18】10-23模拟赛 Summary","url":"/2017/10/24/%E3%80%90Day-18%E3%80%9110-23%E6%A8%A1%E6%8B%9F%E8%B5%9B-Summary/","content":"","categories":["Summary"]},{"title":"【Day -19】10-22模拟赛 Summary","url":"/2017/10/22/%E3%80%90Day-19%E3%80%9110-22%E6%A8%A1%E6%8B%9F%E8%B5%9B-Summary/","content":"","categories":["Summary"]},{"title":"【Day -21】10-20模拟赛 Summary","url":"/2017/10/20/%E3%80%90Day-21%E3%80%9110-20%E6%A8%A1%E6%8B%9F%E8%B5%9B-Summary/","content":"","categories":["Summary"]},{"title":"【Day -22】10-19模拟赛 Summary","url":"/2017/10/19/%E3%80%90Day-22%E3%80%9110-19%E6%A8%A1%E6%8B%9F%E8%B5%9B-Summary/","content":"","categories":["Summary"]},{"title":"【Day -24】10-17模拟赛 Summary","url":"/2017/10/17/%E3%80%90Day-24%E3%80%9110-17%E6%A8%A1%E6%8B%9F%E8%B5%9B-Summary/","content":"","categories":["Summary"]},{"title":"【Day -25】10-16模拟赛 Summary","url":"/2017/10/16/%E3%80%90Day-25%E3%80%9110-16%E6%A8%A1%E6%8B%9F%E8%B5%9B-Summary/","content":"","categories":["Summary"]},{"title":"「Luogu1113」杂务","url":"/2017/09/21/Luogu-1113%E6%9D%82%E5%8A%A1/","content":"\n这段时间都在搞文化，好久没自己刷过题了，来道水题练练手 题目链接:[传送门](https://www.luogu.org/problem/show?pid=1113 \"传送门\")\n<!--more-->\n\n### Description\n\nJohn的农场在给奶牛挤奶前有很多杂务要完成，每一项杂务都需要一定的时间来完成它。比如：他们要将奶牛集合起来，将他们赶进牛棚，为奶牛清洗乳房以及一些其它工作。尽早将所有杂务完成是必要的，因为这样才有更多时间挤出更多的牛奶。当然，有些杂务必须在另一些杂务完成的情况下才能进行。比如：只有将奶牛赶进牛棚才能开始为它清洗乳房，还有在未给奶牛清洗乳房之前不能挤奶。我们把这些工作称为完成本项工作的准备工作。至少有一项杂务不要求有准备工作，这个可以最早着手完成的工作，标记为杂务1。John有需要完成的n个杂务的清单，并且这份清单是有一定顺序的，杂务k(k>1)的准备工作只可能在杂务1..k-1中。 写一个程序从1到n读入每个杂务的工作说明。计算出所有杂务都被完成的最短时间。当然互相没有关系的杂务可以同时工作，并且，你可以假定John的农场有足够多的工人来同时完成任意多项任务。\n\n### Input\n\n第1行：一个整数n，必须完成的杂务的数目(3<=n<=10,000)； 第2 ~ n+1行： 共有n行，每行有一些用1个空格隔开的整数，分别表示： 工作序号(1..n,在输入文件中是有序的)； 完成工作所需要的时间len（1<=len<=100）； 一些必须完成的准备工作，总数不超过100个，由一个数字0结束。有些杂务没有需要准备的工作只描述一个单独的0，整个输入文件中不会出现多余的空格。\n\n### Output\n\n一个整数，表示完成所有杂务所需的最短时间。\n\n### Input_Sample\n\n7 1 5 0 2 2 1 0 3 3 2 0 4 6 1 0 5 1 2 4 0 6 8 2 4 0 7 4 3 5 6 0\n\n### Output_Sample\n\n23\n\n### Solution\n\n可以注意到题中已经将拓扑排序排好了 \n**杂务k(k>1)的准备工作只可能在杂务1..k-1中** \n于是就变成了一道递推的水题 \n用F\\[i\\]表示完成第i件任务最早时间 \n那么对于第i件事，从它的前提中找到一个最晚完成的，这就是这件事的最早起始时间\n\n### Code\n```cpp\n    #include <iostream>\n    #include <cstdio>\n    #include <cstring>\n    #include <cmath>\n    #include <algorithm>\n    using namespace std;\n    int N;\n    int F[10000 + 10];\n    int main()\n    {\n    #ifndef ONLINE_JUDGE\n        freopen(\"a.in\", \"r\", stdin);\n        freopen(\"a.out\", \"w\", stdout);\n    #endif\n        scanf(\"%d\", &N);\n        int Ans = 0;\n        for (int i = 1; i <= N; ++ i)\n        {\n            int T, Pre, Max = 0;\n            scanf(\"%*d%d%d\", &T, &Pre);\n            Max = F[Pre];\n            while (Pre)\n            {\n                scanf(\"%d\", &Pre);\n                Max = max (F[Pre], Max);\n            }\n            F[i] = Max + T;\n            Ans = max (Ans, F[i]);\n        }\n        cout<<Ans<<endl;\n        return 0;\n    }\n```\n","categories":["Problem"],"tags":["递推"]},{"title":"(板子)线性筛素数 LuoguP3383","url":"/2017/08/22/%E6%9D%BF%E5%AD%90-%E7%BA%BF%E6%80%A7%E7%AD%9B%E7%B4%A0%E6%95%B0-LuoguP3383/","content":"\n### Code\n```cpp\n    #include <iostream>\n    #include <cstdio>\n    #include <cstring>\n    #include <cmath>\n    #include <algorithm>\n    using namespace std;\n    const int Maxn = 10000000+100;\n    int IsNotPrime[Maxn], Prime[Maxn];\n    int N, M, Prime_Num;\n    inline void work ()\n    {\n        for (int i = 2; i <= N; ++ i)\n        {\n            if (!IsNotPrime[i])Prime[++Prime_Num] = i;\n            for (int j = 1; j <= Prime_Num && (i * Prime[j] <= N); ++ j)\n            {\n                IsNotPrime[i * Prime[j]] = 1;\n                if (!(i % Prime[j])) break;\n            }\n        }\n    }\n    int main()\n    {\n    #ifndef ONLINE_JUDGE\n        freopen(\"Prime.in\", \"r\", stdin);\n        freopen(\"Prime.out\", \"w\", stdout);\n    #endif\n        scanf(\"%d %d\", &N, &M);\n        IsNotPrime[0] = 1;\n        IsNotPrime[1] = 1;\n        work();\n        int x;\n        for (int i = 1; i <= M; ++ i)\n        {\n            scanf(\"%d\", &x);\n            if(!IsNotPrime[x]) puts(\"Yes\");\n            else puts(\"No\");\n        }\n        return 0;\n    }\n```\n","categories":["Algorithm"],"tags":["数学","线性筛"]},{"title":"扩展欧几里得算法","url":"/2017/08/21/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/","content":"\n### 基本算法\n\n对于不完全为 0 的非负整数 a，b 必然存在整数对 x，y ，使得 ax + by = gcd(a, b);\n\n<!--more-->\n\n### 证明\n\n*  当b = 0 时：gcd(a, b) = a 此时易知x = 1,y = 0 \n\n*  当b ≠ 0 时： 设$ax_0 + by_0 = \\gcd(a,b)$ \n\n由于$\\gcd(a, b) = \\gcd(b, a\\% b)$\n\n我们如果设$bx_1 + (a \\% b)y_1 = \\gcd(b, a\\%b)$ \n\n那么$ax_0 + by_0 = bx_1 + (a \\% b)y_1$ \n\n即$ax_0 + by_0 = bx_1 + (a - \\lfloor {\\frac{a}{b}}\\rfloor b)y_1​$ \n\n展开移项得:$ax_0 + by_0 = ay_1 + b(x_1 - \\lfloor {\\frac{a}{b}}\\rfloor y_1)$ \n\n所以我们有： $ x_0 = y_1 $ $ y_0 = x_1 - \\lfloor {\\frac{a}{b}}\\rfloor y_1$ \n\n于是我们在递归求gcd时回溯求$x_0$和$y_0$即可\n\n### Code\n```cpp\n    #include <iostream>\n    #include <cstdio>\n    #include <cstring>\n    #include <cmath>\n    #include <algorithm>\n    #define LL long long\n    using namespace std;\n    LL A, B;\n    inline LL Ex_gcd (LL A, LL B, LL &x, LL &y)\n    {\n        if (!B)\n        {\n            x = 1;\n            y = 0;\n            return A;\n        }\n        LL Ans = Ex_gcd (B, A % B, x, y);\n        LL tmp = x;\n        x = y;\n        y = tmp - (A / B)* y;\n        return Ans;\n    }\n    int main()\n    {\n    #ifndef ONLINE_JUDGE\n        freopen(\"Ex_gcd.in\", \"r\", stdin);\n        freopen(\"Ex_gcd.out\", \"w\", stdout);\n    #endif\n        scanf(\"%lld%lld\", &A, &B);\n        LL x, y;\n        Ex_gcd(A, B, x, y);\n        printf(\"%lld\\n\", (x + B) % B);\n        return 0;\n    }\n```\n","categories":["Algorithm"],"tags":["数学","gcd","ex_gcd"]},{"title":"费马小定理","url":"/2017/08/21/%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86/","content":"\n### 定理内容\n\n若p是质数，且$gcd(a, p) = 1$，那么 $ a^{p-1}\\equiv 1$(mod p)\n\n<!--more-->\n### 证明\n\n我们考虑从1至p的所有整数{1,2，……,p-1,p} \n\n将其中每一项乘上一个与p互质的数x，得到{x,2x,……,(p-1)x,px}\n\n由于p和x互质，那么这些数同余于{1,2，……,p-1,p} \n\n令$A = 1\\times 2\\times \\cdots\\times(p-1)\\times p$,$B = x\\times 2x\\times \\cdots\\times(p-1)x\\times px$ \n\n那么易知$B\\equiv A$(mod p) \n\n又因为$A = (p-1)! $,$B = x^{p-1}\\times (p-1)!$ \n\n两边同时约去$(p-1)!$\n\n得到$x^{p-1}\\equiv 1$(mod p)","categories":["Algorithm"],"tags":["数学","费马小定理"]},{"title":"同余运算及基本性质","url":"/2017/08/21/%E5%90%8C%E4%BD%99%E8%BF%90%E7%AE%97%E5%8F%8A%E5%9F%BA%E6%9C%AC%E6%80%A7%E8%B4%A8/","content":"\n### 运算\n\n如果两个数a和b之差能被m整除，那么我们就说a和b对模数m同余（关于m同余）。\n比如，100-60除以8正好除尽，我们就说100和60对于模数8同余。它的另一层含义就是说，100和60除以8的余数相同。\na和b对m同余，我们记作a≡b(mod m)。比如，刚才的例子可以写成100≡60(mod 8)。\n你会发现这种记号到处都在用，比如和数论相关的书中就经常把a mod 3 = 1写作a≡1(mod 3)。 \n之所以把同余当作一种运算，是因为同余满足运算的诸多性质。比如，同余满足等价关系。\n具体地说，它满足自反性（一个数永远和自己同余）、对称性（a和b同余，b和a也就同余）和传递性（a和b同余，b和c同余可以推出a和c同余）。这三个性质都是显然的。\n\n<!--more-->\n### 性质\n\n1、 如果a≡b(mod m)，x≡y(mod m)，则a+x≡b+y(mod m)。 \n证明：条件告诉我们，可以找到p和q使得a-mp = b-mq，也存在r和s使得x-mr = y-ms。\n于是a-mp + x-mr = b-mq + y-ms，即a+x-m(p+r) = b+y-m(q+s)，\n这就告诉我们a+x和b+y除以m的余数相同。 \n2、如果a≡b(mod m)，x≡y(mod m)，则ax≡by(mod m)。 \n证明：条件告诉我们，a-mp = b-mq，x-mr = y-ms。\n于是(a-mp)(x-mr) = (b-mq)(y-ms)，\n等式两边分别展开后必然是ax-m(…) = by-m(…)的形式，\n这就说明ax≡by(mod m)。 \n3、如果ac≡bc(mod m)，且c和m互质，则a≡b(mod m) （就是说同余式两边可以同时除以一个和模数互质的数）。 \n证明：条件告诉我们，ac-mp = bc-mq，移项可得ac-bc = mp-mq，也就是说(a-b)c = m(p-q)。\n这表明，(a-b)c里需要含有因子m，但c和m互质，因此只有可能是a-b被m整除，也即a≡b(mod m)。\n","categories":["Algorithm"],"tags":["数学"]},{"title":"「Luogu1692」斐波那契数列 - 矩阵快速幂","url":"/2017/08/20/%E6%B4%9B%E8%B0%B7P1692-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97-%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/","content":"\n题目链接：[传送门](https://www.luogu.org/problem/show?pid=1962 \"传送门\")\n\n### Description\n\n求出斐波那契第N项(N<=$2^{64}$Mod 1000000007的值\n<!--more-->\n### Solution\n\n我们可以用矩阵快速幂优化递推 首先我们易得： $\\begin{pmatrix}F[N+1]& F[N] \\\\ F[N] & F[N-1] \\end{pmatrix} = \\begin{pmatrix}1&1\\\\ 1& 0\\end{pmatrix} \\times \\begin{pmatrix}F[N]& F[N-1] \\\\ F[N-1] & F[N-2] \\end{pmatrix}$ 所以我们就有： $\\begin{pmatrix}F[N+1]& F[N] \\\\ F[N] & F[N-1] \\end{pmatrix} = \\begin{pmatrix}1&1\\\\ 1& 0\\end{pmatrix} ^N$ 然后我们用矩阵快速幂处理即可\n\n### Code\n```cpp\n    #include <iostream>\n    #include <cstdio>\n    #include <cstring>\n    #include <cmath>\n    #include <algorithm>\n    #define LL long long\n    using namespace std;\n    const int Mod = 1000000007; \n    LL N, M;\n    LL bas[5][5], ans[5][5], tmp[5][5];\n    inline LL read()\n    {\n        char ch = getchar();\n        while (ch < '0' || ch > '9')ch = getchar();\n        LL sum = ch - '0';\n        ch = getchar();\n        while (ch >= '0' && ch <= '9') {sum = sum * 10 + ch - '0'; ch = getchar();}\n        return sum;\n    }\n    inline void Matrix_mult (int fl)\n    {\n        if (fl)\n        {\n            for (int i = 1; i <= 2; ++ i)\n                for (int j = 1; j <= 2; ++j)\n                    tmp[i][j] = ans[i][j],ans[i][j]=0;  \n            for (int i = 1; i <= 2; ++ i)\n                for (int j = 1; j <= 2; ++ j)\n                    for (int k = 1; k <= 2; ++ k)\n                        (ans[i][j] += (tmp[i][k] * bas[k][j]) % Mod) %= Mod;\n        }\n        else\n        {\n            for (int i = 1; i <= 2; ++ i)\n                for (int j =1; j <= 2; ++j)\n                    tmp[i][j] = bas[i][j],bas[i][j]=0;\n            for (int i = 1; i <= 2; ++ i)\n                for (int j = 1; j <= 2; ++ j)\n                    for (int k = 1; k <= 2; ++ k)\n                        (bas[i][j] += (tmp[i][k] * tmp[k][j]) % Mod) %= Mod;\n        }\n    \n    }\n    inline void Matrix_pow ()\n    {\n        while (N)\n        {\n            if (N & 1) Matrix_mult(1);\n            Matrix_mult(0);\n            N >>= 1;\n        }\n    }\n    int main()\n    {\n    #ifndef ONLINE_JUDGE\n        freopen(\"a.in\", \"r\", stdin);\n        freopen(\"a.out\", \"w\", stdout);\n    #endif\n        N = read();\n        bas[1][1] = 1;bas[1][2] = 1;bas[2][1] = 1;\n        ans[1][1] = 1;ans[1][2] = 1;ans[2][1] = 1;ans[2][2] = 1;\n        N--;\n        Matrix_pow();\n        printf(\"%lld\\n\", ans[1][2]);\n        return 0;\n    }\n```\n","categories":["Problem"],"tags":["矩阵快速幂","矩阵","快速幂"]},{"title":"「Luogu1273」有线电视网 - 树形背包","url":"/2017/08/19/%E6%B4%9B%E8%B0%B7P1273-%E6%9C%89%E7%BA%BF%E7%94%B5%E8%A7%86%E7%BD%91%EF%BC%88%E6%A0%91%E5%BD%A2%E8%83%8C%E5%8C%85%EF%BC%89/","content":"\n题目链接:[传送门](https://www.luogu.org/problem/show?pid=1273 \"传送门\")\n\n### Description\n\n某收费有线电视网计划转播一场重要的足球比赛。他们的转播网和用户终端构成一棵树状结构，这棵树的根结点位于足球比赛的现场，树叶为各个用户终端，其他中转站为该树的内部节点。 从转播站到转播站以及从转播站到所有用户终端的信号传输费用都是已知的，一场转播的总费用等于传输信号的费用总和。 现在每个用户都准备了一笔费用想观看这场精彩的足球比赛，有线电视网有权决定给哪些用户提供信号而不给哪些用户提供信号。 写一个程序找出一个方案使得有线电视网在不亏本的情况下使观看转播的用户尽可能多。\n<!--more-->\n\n### Solution\n\n又是一道树形DP题 \n设$F\\[x\\]\\[j\\]$表示以第x个节点为根的子树中选j个用户所能获得的最大收益 \n于是我们有： $F\\[x\\]\\[j\\]=\\\\\\max(F\\[x\\]\\[j\\],f\\[x\\]\\[j-k\\]+f\\[to\\[i\\]\\]\\[k\\]-w\\[i\\])$ to\\[i\\]为x的儿子 \nw\\[i\\]为i到x的边权 \n然后我们枚举j和k即可 要注意j和k枚举的范围（详见代码）\n\n### Code\n```cpp\n    #include<iostream>\n    #include<cstdio>\n    #include<cstring>\n    #include<cmath>\n    #include<algorithm>\n    #define begin Begin\n    #define next Next\n    using namespace std;\n    const int maxn=3000+10;\n    int e,begin[maxn],to[maxn*2],next[maxn*2],w[maxn*2];\n    int money[maxn];\n    inline void add(int x,int y,int z){\n        to[++e]=y;\n        next[e]=begin[x];\n        begin[x]=e;\n        w[e]=z;\n    }\n    int n,m,f[maxn][maxn];\n    inline int dfs(int x){\n        if(x>n-m){\n            f[x][1]=money[x];\n            return 1;\n        }\n        int son=0;\n        for(int i=begin[x];i;i=next[i]){\n            int y=dfs(to[i]);son+=y;\n            for(int j=son;j>=1;j--)\n                for(int k=1;k<=y;k++)\n                    f[x][j]=max(f[x][j],f[x][j-k]+f[to[i]][k]-w[i]);\n        }\n        return son;\n    }\n    int main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"a.in\",\"r\",stdin);\n        freopen(\"a.out\",\"w\",stdout);\n    #endif\n        scanf(\"%d%d\",&n,&m);\n        for(int i=1;i<=(n-m);i++){\n            int k,x,y;\n            scanf(\"%d\",&k);\n            for(int j=1;j<=k;j++){\n                scanf(\"%d%d\",&x,&y);    \n                add(i,x,y);\n            }\n        }\n        for(int i=(n-m+1);i<=n;i++)scanf(\"%d\",&money[i]);\n        memset(f,-60,sizeof(f));\n        for(int i=1;i<=n;i++)f[i][0]=0;\n        dfs(1);\n        for(;m;m--)if(f[1][m]>=0)break;\n        cout<<m<<endl;\n        return 0;\n    }\n```\n","categories":["Problem"],"tags":["动态规划"]},{"title":"矩阵快速幂","url":"/2017/08/19/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/","content":"\n模板题：[传送门](https://www.luogu.org/problem/show?pid=3390 \"传送门\")\n\n### 矩阵乘法\n\n#### 基本运算\n\n![](http://hk-cnyali.com/wp-content/uploads/2017/08/1-300x103.png) 结果矩阵第m行与第n列交叉位置的那个值，等于第一个矩阵第m行与第二个矩阵第n列，对应位置的每个值的乘积之和 比如： ![](http://hk-cnyali.com/wp-content/uploads/2017/08/adaf2edda3cc7cd955ae9be73e01213fb80e9109-300x29.png) \n<!--more-->\n\n#### 基本性质\n\n1.  乘法结合律： (AB)C=A(BC)\n2.  乘法左分配律：(A+B)C=AC+BC\n3.  乘法右分配律：C(A+B)=CA+CB\n4.  矩阵乘法一般不满足交换律\n\n### 矩阵快速幂\n\n矩阵快速幂实际上就是将快速幂的数字的运算换成了矩阵，利用二分的思想快速求解\n\n### 模板\n```cpp\n    #include<bits/stdc++.h>\n    #define LL long long\n    using namespace std;\n    const int maxn=100+10,Mod=1000000007;\n    LL a[maxn][maxn];\n    LL ans[maxn][maxn];\n    LL bas[maxn][maxn];\n    LL tmp[maxn][maxn];\n    int n;\n    LL m;\n    inline void Mult(int flag){\n        if(flag){\n            for(int i=1;i<=n;i++)\n                for(int j=1;j<=n;j++)\n                    tmp[i][j]=ans[i][j],ans[i][j]=0;\n            for(int i=1;i<=n;i++)\n                for(int j=1;j<=n;j++)\n                    for(int k=1;k<=n;k++)\n                        (ans[i][j]+=(bas[i][k]*tmp[k][j])%Mod)%=Mod;\n        }\n        else {\n            for(int i=1;i<=n;i++)\n                for(int j=1;j<=n;j++)\n                    tmp[i][j]=0;\n            for(int i=1;i<=n;i++)\n                for(int j=1;j<=n;j++)\n                    for(int k=1;k<=n;k++)\n                        (tmp[i][j]+=(bas[i][k]*bas[k][j])%Mod)%=Mod;\n            for(int i=1;i<=n;i++)\n                for(int j=1;j<=n;j++)\n                    bas[i][j]=tmp[i][j];\n        }\n    }\n    inline void pow(LL m){\n        while(m){\n            if(m&1)Mult(1);\n            Mult(0);\n            m>>=1;\n        }\n    }\n    int main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"a.in\",\"r\",stdin);\n        freopen(\"a.out\",\"w\",stdout);\n    #endif\n        scanf(\"%d%lld\",&n,&m);\n        for(int i=1;i<=n;i++)\n            for(int j=1;j<=n;j++)\n                scanf(\"%d\",&bas[i][j]),ans[i][j]=bas[i][j];\n        pow(m-1);\n        for(int i=1;i<=n;i++){\n            for(int j=1;j<=n;j++)\n                printf(\"%d \",ans[i][j]);\n            puts(\"\");\n        }\n        return 0;\n    }\n```\n","categories":["Algorithm"],"tags":["矩阵快速幂","矩阵","快速幂"]},{"title":"「NOIP2016」换教室 - 期望DP","url":"/2017/08/17/NOIp2016-%E6%8D%A2%E6%95%99%E5%AE%A4-%E6%9C%9F%E6%9C%9BDP/","content":"\n题目链接：[传送门](https://www.luogu.org/problem/show?pid=1850 \"传送门\")\n\n### Description\n\n有n个时间段，第i个时间段可以选择在ci教室上课，也可以选择申请换课，有ki概率申请通过，在di上课，另外1−ki的概率留在ci教室。 总共有v个教室，e条路径双向联通教室xi和yi，路径有权值wi。在课间时（相邻两个时间段的间隔中），你要从上一个教室走最短路径到下一个教室。 现在你有m次申请机会，只能提前申请一堆换课（也就是你不能在知道某一次申请结果后再去申请下一个换课）。求总距离的最小期望。 1≤n≤2000,0≤m≤2000,1≤v≤300,0≤e≤90000,1≤wi≤100,0≤ki≤1\n<!--more-->\n\n### Solution\n\n记得之前听这题的讲解的时候还是mengbier，现在再加深了一下对概率和期望的理解之后，发现这题其实还是比较好理解的 \n我们先跑一遍floyd 然后可以设$F[i][j][0/1]$表示到第i个时间段，总共换了j次教室，当前这一次是换(1)或是不换(0)的概率的最小值（似乎听起来比较绕）\n我们可以发现 $F[i][j][0]$可以从$F[i-1][j][0]$推得,或由$F[i-1][j][1]$推得(此时有两种情况) \n而对于$F[i][j][1]$，我们可以从$F[i-1][j-1][0]$推得，或由$F[i-1][j-1][1]$推得（这里最复杂，有四种情况） \n两个状态转移方程实在是太长了，根本显示不下，具体见代码吧 \n这两个方程其实都很好想（只是码起来太工业了） 大概思路就是这样\n\n### Code\n```cpp\n    #include<iostream>\n    #include<cstdio>\n    #include<cstring>\n    #include<cmath>\n    #include<algorithm>\n    using namespace std;\n    const int maxn=2000+10,maxm=300+10;\n    int dis[maxm][maxm];\n    double p[maxn],f[maxn][maxn][2];\n    int c[maxn],d[maxn];\n    int n,m,v,e;\n    int main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"classroom.in\",\"r\",stdin);\n        freopen(\"classroom.out\",\"w\",stdout);\n    #endif\n        scanf(\"%d%d%d%d\",&n,&m,&v,&e);\n        for(int i=1;i<=n;i++)scanf(\"%d\",&c[i]);\n        for(int i=1;i<=n;i++)scanf(\"%d\",&d[i]);\n        for(int i=1;i<=n;i++)scanf(\"%lf\",&p[i]);\n        for(int i=0;i<=v;i++)\n            for(int j=0;j<=v;j++)\n                if(i==j)dis[i][j]=0;\n                else dis[i][j]=0x3f3f3f3f;\n        for(int i=0;i<=n;i++)\n            for(int j=0;j<=n;j++)\n                f[i][j][0]=f[i][j][1]=0x3f3f3f3f;\n        for(int i=1;i<=e;i++){\n            int x,y,z;\n            scanf(\"%d%d%d\",&x,&y,&z);\n            if(x==y)continue;\n            dis[x][y]=min(dis[x][y],z);\n            dis[y][x]=dis[x][y];\n        }\n        for(int k=1;k<=v;k++)\n            for(int i=1;i<=v;i++)\n                for(int j=1;j<=v;j++)\n                    if(dis[i][j]>dis[i][k]+dis[k][j])\n                        dis[i][j]=dis[i][k]+dis[k][j];\n        f[1][0][0]=0;\n        f[1][1][1]=0;\n        for(int i=2;i<=n;i++){\n            f[i][0][0]=f[i-1][0][0]+dis[c[i-1]][c[i]];\n            for(int j=1;j<=min(i,m);j++){\n                double a1,a2,b1,b2;\n                a1=f[i-1][j][0]+dis[c[i-1]][c[i]];\n                a2=f[i-1][j][1]+dis[d[i-1]][c[i]]*p[i-1]+dis[c[i-1]][c[i]]*(1.0-p[i-1]);    \n                f[i][j][0]=min(a1,a2);\n                b1=(f[i-1][j-1][0]+dis[c[i-1]][d[i]]*p[i]+dis[c[i-1]][c[i]]*(1.0-p[i]));\n                b2=(f[i-1][j-1][1]+dis[d[i-1]][d[i]]*p[i-1]*p[i]+dis[d[i-1]][c[i]]*p[i-1]*(1.0-p[i])+dis[c[i-1]][d[i]]*(1-p[i-1])*p[i]+dis[c[i-1]][c[i]]*(1.0-p[i-1])*(1.0-p[i]));\n                f[i][j][1]=min(b1,b2);\n            }\n        }\n        double ans=f[n][0][0];\n        for(int i=1;i<=m;i++)ans=min(ans,min(f[n][i][0],f[n][i][1]));\n        printf(\"%.2lf\\n\",ans);\n        return 0;\n    }\n```\n","categories":["Problem"],"tags":["动态规划","概率和期望","NOIp"]},{"title":"「Luogu2015」 二叉苹果树 - 树形DP","url":"/2017/08/17/%E6%B4%9B%E8%B0%B7P2015-%E4%BA%8C%E5%8F%89%E8%8B%B9%E6%9E%9C%E6%A0%91%EF%BC%88%E6%A0%91%E5%BD%A2DP%EF%BC%89/","content":"\n题目链接:[传送门](https://www.luogu.org/problem/show?pid=2015 \"传送门\")\n\n### Description\n\n有一棵苹果树，如果树枝有分叉，一定是分2叉（就是说没有只有1个儿子的结点） 这棵树共有N个结点（叶子点或者树枝分叉点），编号为1-N,树根编号一定是1。 我们用一根树枝两端连接的结点的编号来描述一根树枝的位置。下面是一颗有4个树枝的树 2 5 \\ / 3 4 \\ / 1 现在这颗树枝条太多了，需要剪枝。但是一些树枝上长有苹果。 给定需要保留的树枝数量，求出最多能留住多少苹果。\n<!--more-->\n\n### Solution\n\n这又是一道树形DP的经典题目。 \n我们设$F\\[x\\]\\[j\\]$表示以x为节点的根保留j条树枝的最大值，k表示枚举y子树保留k根树枝，那么有： \n$F\\[x\\]\\[j\\]=\\\\max(F\\[x\\]\\[j\\],F\\[x\\]\\[j-k\\]+F\\[y\\]\\[k-1\\]+w\\[x\\]\\[y\\])$ \n我们只需要dfs一遍，枚举j和k即可\n\n### Code\n```cpp\n    #include<iostream>\n    #include<cstdio>\n    #include<cstring>\n    #include<cmath>\n    #include<algorithm>\n    #define begin Begin\n    #define next Next\n    using namespace std;\n    const int maxn=100+10;\n    int n,m,e;\n    int begin[maxn],to[maxn*2],next[maxn*2],w[maxn*2];\n    inline void add(int x,int y,int z){\n        to[++e]=y;\n        next[e]=begin[x];\n        begin[x]=e;\n        w[e]=z;\n    }\n    int p[maxn],f[maxn][maxn];\n    inline int dfs(int x){\n        int son=0;\n        for(int i=begin[x];i;i=next[i]){\n            int y=to[i];\n            if(p[y])continue;\n            p[y]=1;\n            son+=dfs(y)+1;\n            for(int j=min(son,m);j>=1;j--)\n                for(int k=min(m,j);k>=1;k--)\n                    f[x][j]=max(f[x][j],f[x][j-k]+f[y][k-1]+w[i]);\n        }\n        return son;\n    }\n    int main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"a.in\",\"r\",stdin);\n        freopen(\"a.out\",\"w\",stdout);\n    #endif\n        scanf(\"%d%d\",&n,&m);\n        for(int i=1;i<n;i++){\n            int x,y,z;\n            scanf(\"%d%d%d\",&x,&y,&z);\n            add(x,y,z);\n            add(y,x,z);\n        }\n        p[1]=1;\n        dfs(1);\n        printf(\"%d\\n\",f[1][m]);\n        return 0;\n    }\n```\n","categories":["Problem"],"tags":["动态规划"]},{"title":"「POJ2342」Anniversary party - 树形DP","url":"/2017/08/16/POJ2342-%E6%A0%91%E5%BD%A2DP%E5%85%A5%E9%97%A8/","content":"\n题目链接:[传送门](http://poj.org/problem?id=2342 \"传送门\")\n\n### Description\n\n某公司要举办一次晚会，但是为了使得晚会的气氛更加活跃，每个参加晚会的人都不希望在晚会中见到他的直接上司，现在已知每个人的活跃指数和上司关系（当然不可能存在环），求邀请哪些人（多少人）来能使得晚会的总活跃指数最大。\n\n<!--more-->\n\n### Solution\n\n这是一道树形DP入门的水题 \n我们设$dp[i][0]$表示不选i时的最大活跃值，dp[i][1]表示选i时的最大活跃值，那么有：\n(j为i的儿子) $dp[i][0]+=\\max(dp[j][0],dp[j][1])$ $dp[i][1]+=dp[j][0]$ \n这样只要dfs一遍就能将答案$\\max(dp[root][0],dp[root][1])$求出了\n\n### Code\n```cpp\n    #include<iostream>\n    #include<cstdio>\n    #include<cstring>\n    #include<cmath>\n    #include<algorithm>\n    #define begin Begin\n    #define next Next\n    using namespace std;\n    const int maxn=6000+10;\n    int p[maxn];\n    int dp[maxn][2];\n    int n;\n    int fa[maxn];\n    inline void dfs(int x){\n        for(int i=1;i<=n;i++)\n            if(fa[i]==x && !p[i]){\n                p[i]=1;\n                dfs(i);\n                dp[x][0]+=max(dp[i][0],dp[i][1]);\n                dp[x][1]+=dp[i][0];\n            }\n    }\n    int main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"POJ2342.in\",\"r\",stdin);\n        freopen(\"POJ2342.out\",\"w\",stdout);\n    #endif\n        while(scanf(\"%d\",&n)!=EOF){\n            memset(fa,0,sizeof(fa));\n            memset(p,0,sizeof(p));\n            memset(dp,0,sizeof(dp));\n            for(int i=1;i<=n;i++)scanf(\"%d\",&dp[i][1]);\n            int root=0;\n            int x,y;\n            while(scanf(\"%d%d\",&x,&y),x||y){\n                root=y;\n                fa[x]=y;\n            }\n            while(fa[root])root=fa[root];//求树的根\n            p[root]=1;\n            dfs(root);\n            printf(\"%d\\n\",max(dp[root][0],dp[root][1]));\n        }\n        return 0;\n    }\n```\n","categories":["Problem"],"tags":["动态规划"]},{"title":"「Luogu1108」 低价购买 - Dp","url":"/2017/08/15/%E6%B4%9B%E8%B0%B7P1108-%E4%BD%8E%E4%BB%B7%E8%B4%AD%E4%B9%B0-%E6%9C%80%E9%95%BF%E4%B8%8B%E9%99%8D%E5%AD%90%E5%BA%8F%E5%88%97%E5%8F%8A%E8%AE%A1%E6%95%B0/","content":"\n题目链接：[传送门](https://www.luogu.org/problem/show?pid=1108 \"传送门\")\n\n### Description\n\n给定一个长为n(n<=5000)序列A，求最长下降子序列及方案数 ps：当二种方案“看起来一样”时（就是说它们构成的序列一样的时候）,这2种方案被认为是相同的。如:2,1,1,1,1中方案数为1\n<!--more-->\n\n### Solution\n\n对于第一问，我们直接跑一遍$n^2$的LIS即可\n对于第二问，我们记$cnt\\[i\\]$表示到第i位，长度为$f\\[i\\]$的LIS的个数，\n那么有$cnt\\[i\\] = \\\\sum{d\\[j\\] | (f\\[j\\]==f\\[i\\]-1)}$ \n对于判重，如果$f\\[i\\]=f\\[j\\]$&&$a\\[i\\]=a\\[j\\]$就说明这两种情况完全一样，所以对i位以前的j位进行清零。这样就能将cnt求出来了\n\n### Code\n```cpp\n    #include<bits/stdc++.h>\n    using namespace std;\n    const int maxn=5000+10;\n    int n;\n    int a[maxn],f[maxn],cnt[maxn];\n    int main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"a.in\",\"r\",stdin);\n        freopen(\"a.out\",\"w\",stdout);\n    #endif\n        scanf(\"%d\",&n);\n        for(int i=1;i<=n;i++)\n            scanf(\"%d\",&a[i]);\n        int ans=0;\n        for(int i=1;i<=n;i++){\n            f[i]=1;\n            for(int j=1;j<i;j++)\n                if(a[j]>a[i])\n                    f[i]=max(f[i],f[j]+1);\n            ans=max(ans,f[i]);\n        }\n        printf(\"%d \",ans);\n        for(int i=1;i<=n;i++){\n            for(int j=1;j<i;j++){\n                if(a[j]>a[i] && f[i]==f[j]+1)\n                    cnt[i]+=cnt[j];\n                if(a[j]==a[i] && f[i]==f[j])\n                    cnt[j]=0;\n            }\n            if(f[i]==1)cnt[i]=1;\n        }\n        int ans2=0;\n        for(int i=1;i<=n;i++)\n            if(ans==f[i])ans2+=cnt[i];\n        cout<<ans2<<endl;\n        return 0;\n    }\n```\n","categories":["Problem"],"tags":["动态规划"]},{"title":"「Luogu1120」小木棍 - 搜索","url":"/2017/08/14/%E6%B4%9B%E8%B0%B7P1120-%E5%B0%8F%E6%9C%A8%E6%A3%8D-%E6%90%9C%E7%B4%A2/","content":"\n题目链接:[传送门](https://www.luogu.org/problem/show?pid=1120 \"传送门\")\n\n### Description\n\n乔治有一些同样长的小木棍，他把这些木棍随意砍成几段，直到每段的长都不超过50。 现在，他想把小木棍拼接成原来的样子，但是却忘记了自己开始时有多少根木棍和它们的长度。 给出每段小木棍的长度，编程帮他找出原始木棍的最小可能长度。\n<!--more-->\n\n### Input\n\n输入文件共有二行。 第一行为一个单独的整数N表示砍过以后的小木棍的总数，其中N≤65 （管理员注：要把超过50的长度自觉过滤掉，坑了很多人了！） 第二行为N个用空个隔开的正整数，表示N根小木棍的长度。\n\n### Output\n\n输出文件仅一行，表示要求的原始木棍的最小可能长度\n\n### Solution\n\n这题其实就是dfs+剪枝。\ndfs(now,len,x,deep,times)表示当前要拼的木棍剩余now，总长为len，用到第x根木棍，之前已经拼成了deep跟木棍，总共要拼times根木棍，直接爆搜即可 \n剪枝： \n1、先将所有棍子按照长度从大到小排序，方便剪枝 \n2、如果使用当前木棍之后无法拼好，且该木棍正好能补全要当前要拼成的木棍，剪枝 \n3、如果now=len，也就是说now是新一组木棍的开始，但用了剩下木棍中最大的木棍都拼不了，剪枝 \n4、若当前长度的木棍拼不成，那么和它一样长的木棍也会拼不成，剪枝 大概就是这么几个剪枝，然后就可以A了\n\n### Code\n```cpp\n    #include<bits/stdc++.h>\n    using namespace std;\n    const int maxn=70;\n    int n;\n    int a[maxn],p[maxn];\n    inline int cmp(int x,int y){\n        return x>y;\n    }\n    inline int dfs(int now,int len,int x,int deep,int times){\n        if(times==deep){\n            return 1;\n        }\n        if(now==0){if(dfs(len,len,1,deep+1,times))return 1;}\n        for(int i=x;i<=n;i++){\n            if(!p[i] && a[i]<=now){\n                p[i]=1; \n                if(dfs(now-a[i],len,x+1,deep,times))return 1;\n                p[i]=0;\n                if(a[i]==now || now==len)break;\n                while(a[i+1]==a[i])i++;\n            }\n        }\n        return 0;\n    }\n    int main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"a.in\",\"r\",stdin);\n        freopen(\"a.out\",\"w\",stdout);\n    #endif\n        scanf(\"%d\",&n);\n        int sum=0;\n        for(int i=1;i<=n;i++){\n            scanf(\"%d\",&a[i]);\n            if(a[i]>50)i--,n--;\n            else sum+=a[i];\n        }\n        sort(a+1,a+n+1,cmp);\n        int ans;\n        for(int i=a[1];i<=sum;i++)\n            if(!(sum%i)){\n                int tot=sum/i;\n                if(dfs(i,i,1,0,tot)){ans=i;break;}\n            }\n        cout<<ans<<endl;\n        return 0;\n    }\n```\n","categories":["Problem"],"tags":["搜索"]},{"title":"「HAOI2016」食物链 - 记忆化搜索","url":"/2017/08/14/HAOI-2016-%E9%A3%9F%E7%89%A9%E9%93%BE-%E6%B4%9B%E8%B0%B7P3183-%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/","content":"\n题目链接:[传送门](https://www.luogu.org/problem/show?pid=3183 \"传送门\")\n\n### Description\n\n现在给你n个物种和m条能量流动关系，求其中的食物链条数。物种的名称为从1到n编号M条能量流动关系形如a1 b1a2 b2a3 b3......am-1 bm-1am bm其中ai bi表示能量从物种ai流向物种bi,注意单独的一种孤立生物不算一条食物链\n\n<!--more-->\n\n### Input\n\n第一行两个整数n和m,接下来m行每行两个整数ai bi描述m条能量流动关系。（数据保证输入数据符号生物学特点，且不会有重复的能量流动关系出现）1<=N<=100000 0<=m<=200000题目保证答案不会爆 int\n\n### Output\n\n一个整数即食物网中的食物链条数\n\n### Solution\n\n这是一道记搜的模板题。我们从入度为0的点开始搜，到出度为0的点结束，设f\\[x\\]表示x的答案，然后记搜即可\n\n### Code\n```cpp\n    #include<bits/stdc++.h>\n    #define begin Begin\n    #define next Next\n    #define in In\n    #define out Out\n    using namespace std;\n    const int maxn=200000+100;\n    int n,m,e;\n    int begin[maxn],to[maxn*2],next[maxn*2];\n    int in[maxn],out[maxn];\n    inline void add(int x,int y){\n        to[++e]=y;\n        next[e]=begin[x];\n        begin[x]=e;\n    }\n    int f[maxn];\n    inline int dfs(int x){\n        if(f[x])return f[x];\n        int ans=0;\n        if(!out[x] && in[x])ans++;\n        for(int i=begin[x];i;i=next[i])\n            ans+=dfs(to[i]);\n        f[x]=ans;\n        return ans;\n    }\n    int main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"a.in\",\"r\",stdin);\n        freopen(\"a.out\",\"w\",stdout);\n    #endif\n        scanf(\"%d%d\",&n,&m);\n        int x,y;\n        for(int i=1;i<=m;i++){\n            scanf(\"%d%d\",&x,&y);\n            add(x,y);\n            in[y]++;\n            out[x]++;\n        }\n        int ans=0;\n        for(int i=1;i<=n;i++)\n            if(!in[i])\n                ans+=dfs(i);\n        printf(\"%d\\n\",ans);\n        return 0;\n    }\n```\n","categories":["Problem"],"tags":["搜索","记忆化搜索"]},{"title":"「NOIp2003」 加分二叉树 - 区间DP","url":"/2017/08/11/NOIp2003-%E5%8A%A0%E5%88%86%E4%BA%8C%E5%8F%89%E6%A0%91-%E6%B4%9B%E8%B0%B7P1040-%E5%8C%BA%E9%97%B4DP/","content":"\n题目链接：[传送门](https://www.luogu.org/problem/show?pid=1040 \"传送门\")\n\n### Description\n\n设一个n个节点的二叉树tree的中序遍历为（1,2,3,…,n），其中数字1,2,3,…,n为节点编号。每个节点都有一个分数（均为正整数），记第i个节点的分数为di，tree及它的每个子树都有一个加分，任一棵子树subtree（也包含tree本身）的加分计算方法如下： subtree的左子树的加分× subtree的右子树的加分＋subtree的根的分数。 若某个子树为空，规定其加分为1，叶子的加分就是叶节点本身的分数。不考虑它的空子树。 试求一棵符合中序遍历为（1,2,3,…,n）且加分最高的二叉树tree。要求输出； （1）tree的最高加分 （2）tree的前序遍历\n<!--more-->\n\n### Input\n\n第1行：一个整数n（n＜30），为节点个数。 第2行：n个用空格隔开的整数，为每个节点的分数（分数＜100）。\n\n### Output\n\n第1行：一个整数，为最高加分（结果不会超过4,000,000,000）。 第2行：n个用空格隔开的整数，为该树的前序遍历。\n\n### Solution\n\n因为题目给出了中序遍历，且一棵子树在中序遍历中一定是一段连续的区间，因此对子树的计算便可转化为对区间的计算。\n\n因此这道题就可以转化为区间DP \n\n我们设$F[i][j]$表示在区间[i,j]中的最大加分，也就是从i到j组成的子树的最大加分，\n\n那么便有区间DP的套路: $F[i][j]=\\max(F[i][j],F[i][k-1] * F[k+1][j]+F[k][k])$ \n\n当然当k==i || k==j时我们要特殊处理下 \n\n至于输出前序遍历的话，我们可以开一个root[][]数组表示i到j的根，输出时递归处理即可\n\n### Code\n```cpp\n    #include<bits/stdc++.h>\n    using namespace std;\n    int n;\n    int a[35],f[50][50],root[50][50];\n    inline void print(int l,int r){\n        if(l==r){\n            printf(\"%d \",l);\n            return ;\n        }   \n        if(r-l==1){\n            if(root[l][r]==l)printf(\"%d %d \",l,r);\n            else printf(\"%d \",r,l);\n            return ;\n        }\n        printf(\"%d \",root[l][r]);\n        print(l,root[l][r]-1);\n        print(root[l][r]+1,r);\n    }\n    int main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"a.in\",\"r\",stdin);\n        freopen(\"a.out\",\"w\",stdout);\n    #endif\n        scanf(\"%d\",&n);\n        for(int i=1;i<=n;i++)scanf(\"%d\",&a[i]),f[i][i]=a[i];\n        for(int l=1;l<n;l++)\n            for(int i=1;i<=n-l;i++){\n                int j=i+l;\n                for(int k=i;k<=j;k++){\n                    int a1=f[i+1][j]+f[i][i],a2=f[i][j-1]+f[j][j],a3=f[i][k-1]*f[k+1][j]+f[k][k];\n                    if(k==i && a1>f[i][j])\n                        f[i][j]=a1,root[i][j]=i;\n                    else if(k==j && a2>f[i][j])\n                        f[i][j]=a2,root[i][j]=j;\n                    else if(a3>f[i][j])\n                        f[i][j]=a3,root[i][j]=k;\n                }\n                //cout<<i<<\" \"<<j<<\" \"<<f[i][j]<<endl;\n            }\n        cout<<f[1][n]<<endl;\n        print(1,n);\n        return 0;\n    }\n```\n","categories":["Problem"],"tags":["动态规划","NOIp","区间DP"]},{"title":"「NOIp2008」传纸条 - Dp","url":"/2017/08/09/NOIp2008-%E4%BC%A0%E7%BA%B8%E6%9D%A1-%E6%B4%9B%E8%B0%B7P1006-%E5%8F%8C%E7%BA%BF%E7%A8%8B%E5%8A%A8%E8%A7%84/","content":"\n题目链接：[传送门](https://www.luogu.org/problem/show?pid=1006 \"传送门\")\n\n### Description\n\n小渊和小轩是好朋友也是同班同学，他们在一起总有谈不完的话题。一次素质拓展活动中，班上同学安排做成一个m行n列的矩阵，而小渊和小轩被安排在矩阵对角线的两端，因此，他们就无法直接交谈了。幸运的是，他们可以通过传纸条来进行交流。纸条要经由许多同学传到对方手里，小渊坐在矩阵的左上角，坐标(1,1)，小轩坐在矩阵的右下角，坐标(m,n)。从小渊传到小轩的纸条只可以向下或者向右传递，从小轩传给小渊的纸条只可以向上或者向左传递。 在活动进行中，小渊希望给小轩传递一张纸条，同时希望小轩给他回复。班里每个同学都可以帮他们传递，但只会帮他们一次，也就是说如果此人在小渊递给小轩纸条的时候帮忙，那么在小轩递给小渊的时候就不会再帮忙。反之亦然。 还有一件事情需要注意，全班每个同学愿意帮忙的好感度有高有低（注意：小渊和小轩的好心程度没有定义，输入时用0表示），可以用一个0-100的自然数来表示，数越大表示越好心。小渊和小轩希望尽可能找好心程度高的同学来帮忙传纸条，即找到来回两条传递路径，使得这两条路径上同学的好心程度只和最大。现在，请你帮助小渊和小轩找到这样的两条路径。\n<!--more-->\n\n### Input\n\n输入文件message.in的第一行有2个用空格隔开的整数m和n，表示班里有m行n列（1<=m,n<=50）。 接下来的m行是一个m*n的矩阵，矩阵中第i行j列的整数表示坐在第i行j列的学生的好心程度。每行的n个整数之间用空格隔开。\n\n### Output\n\n输出文件message.out共一行，包含一个整数，表示来回两条路上参与传递纸条的学生的好心程度之和的最大值。\n\n### Solotion\n\n这是一道双线程动规的水题。\n题目要求找两条来回的路径，事实上就是要从(1,1)出发找两条不同的路径，使得它们的和最大。 \n设[i][j]和[x][y]表示两条不同的路径的话，我们可以考虑设dp[i][j][x][y]表示到(i,j)和(x,y)为止的最大和，\n那么有状态转移方程: $dp[i][j][x][y]=max(dp[i-1][j][x-1][y],dp[i-1][j][x][y-1],dp[i][j-1][x-1][y],dp[i][j-1][x][y-1])+((x==i \\&\\& y==j)?(a[x][y]):(a[i][j]+a[x][y]))$\n\n#### Code\n```cpp\n    #include<bits/stdc++.h>\n    using namespace std;\n    int n,m;\n    int a[55][55];\n    int dp[55][55][55][55];\n    inline int maxi(int a,int b,int c,int d){\n        return max(max(a,b),max(c,d));  \n    }\n    int main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"a.in\",\"r\",stdin);\n        freopen(\"a.out\",\"w\",stdout);\n    #endif\n        scanf(\"%d%d\",&n,&m);\n        for(int i=1;i<=n;i++)\n            for(int j=1;j<=m;j++)\n                scanf(\"%d\",&a[i][j]);\n        for(int i=1;i<=n;i++)\n            for(int j=1;j<=m;j++)\n                for(int x=1;x<=n;x++)\n                    for(int y=1;y<=m;y++){\n                        dp[i][j][x][y]=maxi(dp[i-1][j][x-1][y],dp[i-1][j][x][y-1],dp[i][j-1][x-1][y],dp[i][j-1][x][y-1])+((x==i && y==j)?(a[x][y]):(a[i][j]+a[x][y]));\n                    }\n        printf(\"%d\\n\",dp[n][m][n][m]);\n        return 0;\n    }\n```\n","categories":["Problem"],"tags":["动态规划","NOIp"]},{"title":"LCA总结","url":"/2017/08/08/LCA%E6%80%BB%E7%BB%93/","content":"\n这段时间一直在学习LCA的各种算法，下面就对LCA的各种算法进行一次总结：\n<!--more-->\n\n### 问题概述\n\nLCA（最近公共祖先）指的是在一棵树上两个节点的最近的公共祖先（这句话好像跟没说差不多），也就是深度最深的公共祖先。\nLCA的适用范围非常广，在许多较难的与树有关的题中都会需要用到。\n因此，掌握求LCA的方法是非常重要的。\n\n### 在线算法\n\n#### 树链剖分\n\n在[上一篇博客](http://hk-cnyali.com/2017/08/08/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/ \"上一篇博客\")中，我已经将树链剖分进行了详细解释。\n事实上，在用树链剖分求LCA时，只需要做两遍dfs即可，这样一来，编程复杂度就大大降低了。 \n预处理的方法和上一篇博客的方法是完全一样的。\n在询问LCA时，我们只需要沿着轻/重链向上跳，直到两节点的top相等，最后返回深度较小的节点即可\n```cpp\n    #include<bits/stdc++.h>\n    #define begin Begin\n    #define next Next\n    #define size Size\n    #define deep dep\n    using namespace std;\n    const int maxn=500000+100;\n    int begin[maxn],next[maxn*2],to[maxn*2];\n    int deep[maxn],son[maxn];\n    int size[maxn],top[maxn],fa[maxn];\n    int n,m,s,e;\n    inline void add(int x,int y){\n        to[++e]=y;\n        next[e]=begin[x];\n        begin[x]=e;\n    }\n    inline void dfs1(int x){\n        size[x]=1;\n        for(int i=begin[x];i;i=next[i]){\n            int y=to[i];\n            if(fa[x]==y)continue;\n            fa[y]=x;\n            deep[y]=deep[x]+1;\n            dfs1(y);\n            if(size[y]>=size[son[x]])son[x]=y;\n            size[x]+=size[y];\n        }\n    }\n    inline void dfs2(int x,int now){\n        top[x]=now;\n        if(son[x])dfs2(son[x],now);\n        for(int i=begin[x];i;i=next[i]){\n            int y=to[i];\n            if(fa[x]==y || son[x]==y)continue;\n            dfs2(y,y);\n        }\n    }\n    inline int LCA(int x,int y){\n        int t1=top[x],t2=top[y];\n        while(t1!=t2){\n            if(deep[t1]<deep[t2])swap(t1,t2),swap(x,y);\n            x=fa[t1];\n            t1=top[x];\n        }\n        if(deep[x]>deep[y])swap(x,y);\n        return x;\n    }\n    int main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"a.in\",\"r\",stdin);\n        freopen(\"a.out\",\"w\",stdout);\n    #endif\n        scanf(\"%d%d%d\",&n,&m,&s);\n        for(int i=1;i<n;i++){\n            int x,y;\n            scanf(\"%d%d\",&x,&y);\n            add(x,y);\n            add(y,x);\n        }\n        deep[s]=1;\n        dfs1(s);\n        dfs2(s,s);\n        for(int i=1;i<=m;i++){\n            int x,y;\n            scanf(\"%d%d\",&x,&y);\n            printf(\"%d\\n\",LCA(x,y));\n        }\n        return 0;\n    }\n```\n\n时间复杂度:$O(N+M\\log N)$（在树的形态为链时最快，为完全二叉树时最慢）\n\n#### 倍增\n\n首先，我们先dfs预处理出每个节点向上跳$2^i$次所到达的节点。\n\n询问时，先根据两个节点的的深度，将深度大的节点向上跳，使得两个节点在同一层上，\n如果正好是祖先就结束，否则将两个节点同时向上跳，直到他们父亲相同为止，此时他们的父亲即为LCA。\n\n具体实现见代码\n\n```cpp\n    #include<bits/stdc++.h>\n    #define begin Bgein\n    #define next Mext\n    using namespace std;\n    const int maxn=500000+10;\n    int n,m,s;\n    int begin[maxn*2],next[2*maxn],to[maxn*2],e;\n    int anc[maxn][30],deep[maxn],fa[maxn];\n    inline void add(int x,int y){\n        to[++e]=y;  \n        next[e]=begin[x];\n        begin[x]=e;\n    }\n    inline void dfs(int x){\n        for(int i=1;i<=22;i++)anc[x][i]=anc[anc[x][i-1]][i-1];\n        for(int i=begin[x];i;i=next[i]){\n            int y=to[i];\n            if(anc[x][0]==y)continue;\n            anc[y][0]=x;\n            deep[y]=deep[x]+1;\n            dfs(y);\n        }\n    }\n    inline int LCA(int x,int y){\n        if(deep[x]<deep[y])swap(x,y);\n        for(int i=22;i>=0;i--)\n            if(deep[anc[x][i]]>=deep[y])x=anc[x][i];\n        if(x==y)return x;\n        for(int i=22;i>=0;i--)\n            if(anc[x][i]!=anc[y][i])x=anc[x][i],y=anc[y][i];\n        return anc[x][0];\n    }\n    int main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"LCA.in\",\"r\",stdin);\n        freopen(\"LCA.out\",\"w\",stdout);\n    #endif\n        scanf(\"%d%d%d\",&n,&m,&s);\n        for(int i=1;i<n;i++){\n            int a,b;\n            scanf(\"%d%d\",&a,&b);\n            add(a,b);add(b,a);\n        }\n        deep[s]=1;\n        dfs(s);\n        for(int i=1;i<=m;i++){\n            int a,b;\n            scanf(\"%d%d\",&a,&b);\n            printf(\"%d\\n\",LCA(a,b));\n        }\n        return 0;\n    }\n    \n```\n时间复杂度$O(N\\log N + M \\log N)$（在树的形态为链时最慢，随机生成的数较快）\n\n#### ST表\n\n这种算法事实上就是把LCA转化为RMQ，在dfs序中查找区间最小值。\n\n但是这种方法我还没写过，所以先不放代码了 \n\n时间复杂度$O(N\\log N + M + N)$ (在树的形态为完全二叉树时最快)\n\n### 离线算法\n\n#### tarjan\n\ntarjan算法其实是dfs+并查集。\n\n我们将给定的树和询问操作分别建图，然后进行dfs。\n\n每搜索到一个点u时，先遍历它的所有子节点v，\n\n如果v还有子节点，则继续便利下去，否则将v并到u上，\n\n然后寻找所有与u有询问关系的点x，\n\n若x已经被访问过，则LCA(u,x)=fa[x] 大致的思路就是这样，具体见代码\n\n```cpp\n    #include<bits/stdc++.h>\n    #define begin Begin\n    #define next Next\n    using namespace std;\n    const int maxn=500000+100;\n    int e1,e2;\n    int begin[maxn],next[maxn*2],to[maxn*2];\n    int qbegin[maxn],qnext[maxn*2],qto[maxn*2];\n    int num[maxn*2];\n    inline void add(int x,int y){\n        to[++e1]=y;\n        next[e1]=begin[x];\n        begin[x]=e1;\n    }\n    inline void add1(int x,int y,int z){\n        qto[++e2]=y;\n        qnext[e2]=qbegin[x];\n        qbegin[x]=e2;\n        num[e2]=z;\n    }\n    int n,m,s;\n    int p[maxn],ans[maxn],f[maxn];\n    inline int find(int x){\n        return f[x]==x?x:f[x]=find(f[x]);\n    }\n    inline void link(int x,int y){\n        int fx=find(x),fy=find(y);\n        if(fx==fy)return ;\n        f[fy]=fx;\n    }\n    inline void dfs(int x){\n        p[x]=1;\n        for(int i=begin[x];i;i=next[i]){\n            int y=to[i];\n            if(p[y])continue;\n            dfs(y);\n            link(x,y);\n        }\n        for(int i=qbegin[x];i;i=qnext[i]){\n            int y=qto[i];\n            if(!p[y])continue;\n            ans[num[i]]=find(y);\n        }\n    }\n    int main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"a.in\",\"r\",stdin);\n        freopen(\"a.out\",\"w\",stdout);\n    #endif\n        scanf(\"%d%d%d\",&n,&m,&s);\n        for(int i=1;i<=n;i++)f[i]=i;\n        for(int i=1;i<n;i++){\n            int x,y;\n            scanf(\"%d%d\",&x,&y);\n            add(x,y);\n            add(y,x);\n        }\n        for(int i=1;i<=m;i++){\n            int x,y;\n            scanf(\"%d%d\",&x,&y);\n            add1(x,y,i);\n            add1(y,x,i);\n        }\n        dfs(s);\n        for(int i=1;i<=m;i++)printf(\"%d\\n\",ans[i]);\n        puts(\"\");\n        return 0;\n    }\n```\n\n时间复杂度$O(N+M)$\n\n### 总结\n\n求LCA的方法大致就是这些。\n对于不同的题目，我们还是要根据数据范围来选择合适的算法求解。\n当然，当数据范围不是很大时，选择自己最熟悉的写就可以了。\n就像文章开头所说，这些求LCA的算法是非常实用的。\n","categories":["Algorithm"],"tags":["tarjan","倍增","树链剖分","ST表","LCA","RMQ"]},{"title":"树链剖分","url":"/2017/08/08/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/","content":"\n开始一直以为树剖是一个非常高大上的数据结构，怕学不会，学完之后发现树链剖分其实特别简单\n\n<!--more-->\n\n### 问题概述\n\n树链剖分（也叫轻重链剖分），是解决在树上进行区间修改、查询这一类问题的一个算法。\n事实上，树链剖分就是由两遍dfs预处理+其他数据结构（如线段树、树状数组等）构成的。以[洛谷P3384](https://www.luogu.org/problem/show?pid=3384 \"洛谷P3384\")为例，\n如果我们直接将每个节点按照dfs的顺序加入线段树中的话，每次修改或是查询都需要将u和v的路径之间所有的节点都处理一遍。\n但是如果我们现将这棵树进行特殊的编号，使得在查询和修改时能够保证某一段连续的区间尽可能长，这样就可以降低我们的时间复杂度了。\n事实上，将一棵树剖分为若干条链（每条链在线段树中是一段连续的区间），然后再利用线段树进行维护，这就是树链剖分。\n\n### 一些定义\n\n以节点u为例： \nsize\\[u\\]：以u为根结点的子树的节点个数 \n重儿子(son\\[u\\])：u的子节点中size最大的子节点编号 \n轻儿子：u节点的其他子节点 \n重边：节点u与节点son\\[u\\]的边 \n重链：全部由重边组成的路径 \n轻边：节点u与其他子节点的边 \ndeep\\[u\\]：节点u在树中的深度 \nfa\\[u\\]：节点u的父亲节点的编号 \ntop\\[u\\]：节点u所在重链中深度最小的节点编号,也就是u所在重链的顶端 \nid\\[u\\]：节点u在线段树中的编号(视题目而定，若题目给的是边的权值及修改，那么则表示u的前驱边在线段树中的编号) \nreal\\[u\\]:与id数组的映射(real\\[id\\[i\\]\\]=i)\n关于这个它有两个重要的性质： \n(1)轻边(u,v)中，size(v)<=size(u/2) \n(2)从根到某一点的路径上，轻边和重边的个数均不超过$logN$\n\n### 算法流程\n\n#### 预处理\n\n1、第一次dfs将每个节点的size、fa、deep、son都处理出来，找出每个节点的重儿子。这一部分比较简单，直接上代码：\n```cpp\n    inline void dfs1(int x){\n        size[x]=1;\n        for(int i=begin[x];i;i=next[i]){\n            int y=to[i];\n            if(fa[x]==y)continue;\n            fa[y]=x;\n            deep[y]=deep[x]+1;\n            dfs1(y);\n            if(size[y]>size[son[x]])son[x]=y;\n            size[x]+=size[y];\n        }\n    }\n```\n\n2、第二遍dfs求出每个节点的id、real、top。这里要强调的是，因为同一重链上的点必须在线段树中是连续的区间，那么如果对于节点u有重儿子(即不为叶子节点)的话，我们就必须先搜索他的重儿子。\n```cpp\n    int cnt=0;\n    inline void dfs2(int x,int now){\n        id[x]=++cnt;\n        real[id[x]]=x;\n        top[x]=now;\n        if(son[x])dfs2(son[x],now);\n        for(int i=begin[x];i;i=next[i]) {\n            int y=to[i];\n            if(fa[x]==y || son[x]==y)continue;\n            dfs2(y,y);\n        }\n    }\n```\n\n3、按照id数组建立线段树 预处理时间复杂度：$O(NlogN)$\n\n#### 查询及修改\n\n（一）求x到y路径节点值之和： 令t1=top\\[x\\],t2=top\\[y\\]，则 \n1、如果t1==t2，则说明x和y在同一条重链上，设deep\\[x\\] < deep\\[y\\],那么只需要在线段数上查询(id\\[x\\],id\\[y\\])即可 \n2、如果t1!=t2，设deep\\[x\\]>=deep\\[y\\]，我们先查询（id\\[t1\\],id\\[x\\]），然后x=fa\\[t1\\]，直到t1==t2为止 代码如下：\n```cpp\n    inline int find(int x,int y){\n        int sum=0,t1=top[x],t2=top[y];\n        while(t1!=t2){\n            if(deep[t1]<deep[t2]){swap(t1,t2);swap(x,y);}\n            sum+=query(1,1,n,id[t1],id[x]);\n            //cout<<x<<\" \"<<y<<\" \"<<sum<<endl;\n            sum%=Mod;\n            x=fa[t1];\n            t1=top[x];\n        }\n        if(deep[x]>deep[y])swap(x,y);\n        sum+=query(1,1,n,id[x],id[y]);\n        return sum%Mod;\n    }\n```\n\n修改的话，和查询的做法是一样的，只不过将query函数改为了update函数\n```cpp\n    inline void change(int x,int y,int z){\n        int t1=top[x],t2=top[y];\n        while(t1!=t2){\n            if(deep[t1]<deep[t2]){swap(t1,t2);swap(x,y);}\n            update(1,1,n,id[t1],id[x],z);\n            x=fa[t1];\n            t1=top[x];\n        }\n        if(deep[x]>deep[y])swap(x,y);\n        update(1,1,n,id[x],id[y],z);\n    }\n```\n\n（二）求以x为根节点的子树的节点值的和 \n因为我们是dfs进行的预处理，因此很容易发现x的子树的id一定是一段连续的区间，即$\\[id\\[x\\],id\\[x\\]+size\\[x\\]-1\\]$，修改同理 查询及修改复杂度$Mlog^2N$\n\n### 代码实现\n```cpp\n    #include<iostream>\n    #include<cstdio>\n    #include<cstring>\n    #include<cmath>\n    #include<algorithm>\n    #define begin Begin\n    #define next Next\n    #define size Size\n    #define find Find\n    #define deep Deep\n    #define change Change\n    using namespace std;\n    typedef long long LL;\n    const int maxn=5e5+5;\n    int begin[maxn],next[maxn],to[maxn],e;\n    int real[maxn],id[maxn];\n    int size[maxn],son[maxn],top[maxn],deep[maxn];\n    int fa[maxn];\n    int n,m,s;\n    LL Mod;\n    int a[maxn];\n    struct node{\n        int sum,mark;\n    }tree[maxn*4];\n    inline void add(int x,int y){\n        to[++e]=y;\n        next[e]=begin[x];\n        begin[x]=e;\n    }\n    inline void dfs1(int x){\n        size[x]=1;\n        for(int i=begin[x];i;i=next[i]){\n            int y=to[i];\n            if(fa[x]==y)continue;\n            fa[y]=x;\n            deep[y]=deep[x]+1;\n            dfs1(y);\n            if(size[y]>size[son[x]])son[x]=y;\n            size[x]+=size[y];\n        }\n    }\n    int cnt=0;\n    inline void dfs2(int x,int now){\n        id[x]=++cnt;\n        real[id[x]]=x;\n        top[x]=now;\n        if(son[x])dfs2(son[x],now);\n        for(int i=begin[x];i;i=next[i]) {\n            int y=to[i];\n            if(fa[x]==y || son[x]==y)continue;\n            dfs2(y,y);\n        }\n    }\n    inline void build(int root,int l,int r){\n        //cout<<root<<\" \"<<l<<\" \"<<r<<endl;\n        if(l==r){\n            tree[root].sum=a[real[l]];\n            return ;\n        }\n        int mid=(l+r)>>1;\n        build(root<<1,l,mid), build(root<<1|1,mid+1,r);\n        tree[root].sum=(tree[root<<1].sum+tree[root<<1|1].sum)%Mod;\n    }\n    inline void pushdown(int x,int l,int r,int mid){\n        if(tree[x].mark){\n            tree[x<<1].mark+=tree[x].mark;\n            tree[x<<1|1].mark+=tree[x].mark;\n            tree[x<<1].sum+=tree[x].mark*(mid-l+1);\n            tree[x<<1].sum%=Mod;\n            tree[x<<1|1].sum+=tree[x].mark*(r-mid);\n            tree[x<<1].sum%=Mod;\n            tree[x].mark=0;\n        }\n        return ;\n    }\n    inline void update(int root,int l,int r,int x,int y,int z){\n        int mid = (l + r) >> 1;\n        pushdown(root,l,r,mid);\n        if(x<=l && y>=r){\n            tree[root].mark+=z;\n            tree[root].sum+=(r-l+1)*z;\n            tree[root].sum%=Mod;\n            return ;\n        }\n        if(x<=mid)update(root<<1,l,mid,x,y,z);\n        if(y>mid)update(root<<1|1,mid+1,r,x,y,z);\n        tree[root].sum=(tree[root<<1].sum+tree[root<<1|1].sum)%Mod;\n    }\n    inline int query(int root,int l,int r,int x,int y){\n        int mid=(l+r)>>1;\n        pushdown(root,l,r,mid);\n        if(x<=l && y>=r)return tree[root].sum;\n        int ans=0;\n        if(x<=mid)ans+=query(root<<1,l,mid,x,y);\n        ans%=Mod;\n        if(y>mid)ans+=query(root<<1|1,mid+1,r,x,y);\n        return ans%Mod;\n    }\n    inline void change(int x,int y,int z){\n        int t1=top[x],t2=top[y];\n        while(t1!=t2){\n            if(deep[t1]<deep[t2]){swap(t1,t2);swap(x,y);}\n            update(1,1,n,id[t1],id[x],z);\n            x=fa[t1];\n            t1=top[x];\n        }\n        if(deep[x]>deep[y])swap(x,y);\n        update(1,1,n,id[x],id[y],z);\n    }\n    inline int find(int x,int y){\n        int sum=0,t1=top[x],t2=top[y];\n        while(t1!=t2){\n            if(deep[t1]<deep[t2]){swap(t1,t2);swap(x,y);}\n            sum+=query(1,1,n,id[t1],id[x]);\n            //cout<<x<<\" \"<<y<<\" \"<<sum<<endl;\n            sum%=Mod;\n            x=fa[t1];\n            t1=top[x];\n        }\n        if(deep[x]>deep[y])swap(x,y);\n        sum+=query(1,1,n,id[x],id[y]);\n        return sum%Mod;\n    }\n    int main(){ \n    #ifndef ONLINE_JUDGE\n        freopen(\"a.in\",\"r\",stdin);\n        freopen(\"a.out\",\"w\",stdout);\n    #endif\n        scanf(\"%d%d%d%lld\",&n,&m,&s,&Mod);\n        for(int i=1;i<=n;i++)scanf(\"%d\",&a[i]);\n        int x,y,z,pd;\n        for(int i=1;i<n;i++){\n            scanf(\"%d%d\",&x,&y);\n            add(x,y);add(y,x);\n        }\n        deep[s]=1;\n        dfs1(s);\n        top[s]=s;\n        dfs2(s,s);\n        build(1,1,n);\n        for(int i=1;i<=m;i++){\n            scanf(\"%d\",&pd);    \n            if(pd==1){\n                scanf(\"%d%d%d\",&x,&y,&z);\n                change(x,y,z);\n            }\n            else if(pd==2){\n                scanf(\"%d%d\",&x,&y);\n                printf(\"%d\\n\",find(x,y)%Mod);\n            }\n            else if(pd==3){\n                scanf(\"%d%d\",&x,&z);\n    //          cout<<id[x]<<\" \"<<id[x]+size[x]-1<<\" \"<<endl;\n                update(1,1,n,id[x],id[x]+size[x]-1,z);\n            }\n            else {\n                scanf(\"%d\",&x);\n                printf(\"%d\\n\",query(1,1,n,id[x],id[x]+size[x]-1));\n            }\n        }\n        return 0;\n    }\n```\n\n### 几道例题\n\nNOI2015 LuoguP2146 软件包管理器 [传送门](https://www.luogu.org/problem/show?pid=2146 \"传送门\") ZJOI2008 LuoguP2590 树的统计 [传送门](https://www.luogu.org/problem/show?pid=2590 \"传送门\")\n","categories":["Algorithm"],"tags":["树","树链剖分"]},{"title":"区间神器——莫队","url":"/2017/08/08/%E5%8C%BA%E9%97%B4%E7%A5%9E%E5%99%A8%E2%80%94%E2%80%94%E8%8E%AB%E9%98%9F/","content":"\n### 问题概述\n\n在处理区间问题时，如果一类题目满足已知区间$[L,R]$的答案后，我们可以$O(1)$处理出$[L+1,R],[L-1,R],[L,R+1],[L,R-1]$的答案，且可以离线处理的话，我们就可以用莫队算法在均摊时间复杂度为$O(N ^{1.5})$的复杂度内解决此类区间问题。 \n为什么说它是区间神器呢？那是因为它的常数非常小，大多数区间题目都能用莫队算法水过\n<!--more-->\n\n### 算法思想/流程\n\n_注：因为大多数题目的总区间长度与查询次数的范围相同，以下均将总区间长度与查询次数视为N_ \n以HH的项链（洛谷P1972）为例 我们先设p[i]表示i是否在当前所要查找的区间内 cnt[i]表示i出现的次数 cl表示左指针，cr表示右指针 那么有暴力算法:\n\n```cpp\n    #include<iostream>\n    #include<cstdio>\n    #include<cmath>\n    #include<cstring>\n    #include<algorithm>\n    using namespace std;\n    const int maxn=200000+100;\n    int n,m;\n    int N;\n    int a[maxn],p[maxn];\n    struct node{\n        int l,r,id;\n    }q[maxn];\n    int ans[maxn],cnt[maxn];\n    int sum=0;\n    inline void update(int x){\n        if(p[x]){\n            cnt[a[x]]--;\n            if(!cnt[a[x]])sum--;\n        }\n        else {\n            cnt[a[x]]++;\n            if(cnt[a[x]]==1)sum++;\n        }\n        p[x]=!p[x];\n    }\n    int main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"a.in\",\"r\",stdin);\n        freopen(\"a.out\",\"w\",stdout);\n    #endif\n        scanf(\"%d\",&n);\n        N=sqrt(n);\n        for(int i=1;i<=n;i++)scanf(\"%d\",&a[i]);\n        scanf(\"%d\",&m);\n        for(int i=1;i<=m;i++){\n            scanf(\"%d%d\",&q[i].l,&q[i].r);\n            q[i].id=i;\n        }\n        int cl=1,cr=0;\n        for(int i=1;i<=m;i++){\n            while(cr<q[i].r)update(++cr);\n            while(cr>q[i].r)update(cr--);\n            while(cl<q[i].l)update(cl++);\n            while(cl>q[i].l)update(--cl);\n            ans[q[i].id]=sum;\n        }\n        for(int i=1;i<=m;i++)printf(\"%d\\n\",ans[i]);\n        return 0;\n    }\n```\n\n这个算法理解其实很很简单，手玩几组数据就能搞懂了，但是要注意update()时++cr cr++ ++cl cl++的区别，\n也就是添加或者删除操作时包不包括当前区间的左/右指针。这个多推几组数据也能很容易理解。 \n但是，我们这样做时间复杂度显然非常大，我们发现，在查询操作时，左指针和右指针来来回回跑了很多次，做了很多次无用功。\n那么我们可以考虑将其分块处理，将查询的区间以左端点所在块为第一关键字，右端点为第二关键字进行排序，然后再使用上述暴力算法。 \n因为右端点最多移动n*S(S为块大小)次，而左端点最多移动$\\frac{N^2}{S}$ 次，\n所以总的时间复杂度为$O(\\frac{N^2}{S}+{NS})$用均值不等式易证出，\n当S取$\\sqrt(N)$时，时间复杂度最小，为$O(N^{1.5})$\n\n### 代码实现\n```cpp\n    #include<iostream>\n    #include<cstdio>\n    #include<cmath>\n    #include<cstring>\n    #include<algorithm>\n    using namespace std;\n    const int maxn=200000+100;\n    int n,m;\n    int N;\n    int a[maxn],p[maxn];\n    struct node{\n        int l,r,id;\n    }q[maxn];\n    inline int cmp(node x,node y){\n        if((x.l/N)==(y.l/N))return x.r<y.r;\n        return (x.l)<(y.l);\n    }\n    int ans[maxn],cnt[maxn];\n    int sum=0;\n    inline void update(int x){\n        if(p[x]){\n            cnt[a[x]]--;\n            if(!cnt[a[x]])sum--;\n        }\n        else {\n            cnt[a[x]]++;\n            if(cnt[a[x]]==1)sum++;\n        }\n        p[x]=!p[x];\n    }\n    int main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"a.in\",\"r\",stdin);\n        freopen(\"a.out\",\"w\",stdout);\n    #endif\n        scanf(\"%d\",&n);\n        N=sqrt(n);\n        for(int i=1;i<=n;i++)scanf(\"%d\",&a[i]);\n        scanf(\"%d\",&m);\n        for(int i=1;i<=m;i++){\n            scanf(\"%d%d\",&q[i].l,&q[i].r);\n            q[i].id=i;\n        }\n        sort(q+1,q+m+1,cmp);\n        int cl=1,cr=0;\n        for(int i=1;i<=m;i++){\n            while(cr<q[i].r)update(++cr);\n            while(cr>q[i].r)update(cr--);\n            while(cl<q[i].l)update(cl++);\n            while(cl>q[i].l)update(--cl);\n            ans[q[i].id]=sum;\n        }\n        for(int i=1;i<=m;i++)printf(\"%d\\n\",ans[i]);\n        return 0;\n    }\n```\n\n这就是不带修改的莫队算法 其实莫队也是可以带修改的 但是带修改的莫队我理解的还不是很透彻，这个坑先留着，到时候再填\n","categories":["Algorithm"],"tags":["莫队"]},{"title":"RMQ问题（ST表算法）","url":"/2017/08/08/RMQ%E9%97%AE%E9%A2%98%EF%BC%88ST%E8%A1%A8%E7%AE%97%E6%B3%95%EF%BC%89/","content":"\n### 问题概述\n\n　　RMQ (Range Minimum/Maximum Query)，即区间最值查询，是指对于一个长为n的序列A，回答m次询问区间$[l,r]$的最大值或最小值。这种问题我们如果暴力枚举，当查询次数较多且范围较大时复杂度是不能被接受的。下面就来介绍一下一种比较高效且容易写的算法：ST表\n\n<!--more-->\n\n### 算法思想及流程\n\n　　ST表（Sparse_Table）算法是一种可以求RMQ问题的在线算法。所谓在线算法，是指以较长时间做预处理，再以较少的时间回答每次询问。而ST表则可以用$O(N \\log N)$的时间预处理，$O(1)$时间询问RMQ问题的算法。\n\n#### 预处理\n\nST表算法的本质是动态规划\n\n以最大值为例，我们可以设$F[i][j]$表示从第i个数至向右连续数$2^j$个数的范围内的最大值，即区间$[i,i+2^j-1]$中的最大值。 　　\n\n例如：A数列为：1，6，2，7，4，2，8，3，7 \n\n此时，$F[1][0]$为区间$[1,1+2^0-1]$的最大值，即为1 同理，$F[2][0]=6,F[3][0]=2$，因此，我们可以很容易地看出$F[i][0]=A[i]$ 　　\n\n至此，动态规划的状态，边界（初始值）都已经有了，接下来就是状态转移方程 　　\n\n我们可以考虑将$F[i][j]$平均分成两段，从i至$i+2^{j-1}-1$为一段，$i+2^{j-1}$至$i+2^j$为一段。\n\n即区间$[i,i+2^{j-1}-1],[i+2^{j-1},i+2^j]​$并且这两个区间的长度都为$2^{j-1}​$，则$F[i][j]​$为这两个区间的最大值。\n\n于是我们有$F[i][j]=max(F[i][j-1],F[i+2^{j-1}][j-1])​$ 　　\n\n但在代码实现的时候需要注意，外层循环要枚举j，内层循环则枚举i，因为我们设的状态是从第i位向至后数长度为$2^j$的区间内的最大值，\n\n即先要求出长度为1的，然后推出长度为2的，再由长度为2的推出长度为4的，以此类推。\n\n如果将i放在外层循环，则无法向后推出，显然是错误的 　　\n\n时间复杂度$O(N \\log N)$\n\n#### 询问\n\n　　对于询问，因为所求为最大/最小值，则我们只要保证两个区间完全将所求区间覆盖，即只要保证不漏，不需要保证不重。\n　　\n因此，我们需要找到一个最大的k，使得$l+2^k<=r$ 求k的过程可以while循环来找，也可以使用自带的函数，即\n\n```cpp\nk=(int)(log((double)(r-l+1))/log(2.0));\n```\n\n　　找到了这个最大的k之后，只需对$F[l][k]$和$F[l-2^k+1][k]$取max即可 　　\n　　时间复杂度$O(1)$\n\n### 代码实现\n\n　　注：此代码求的是区间最小值\n```cpp\n    #include<bits/stdc++.h>\n    #define begin Begin\n    #define next Next\n    using namespace std;\n    const int maxn=500000+10;\n    int n,m,s;\n    int a[maxn],d[maxn][30];\n    inline void rmq_init(){\n        for(int i=1;i<=n;i++)d[i][0]=a[i];\n        for(int j=1;(1<<j)<=n;j++)\n            for(int i=1;(i+(1<<j)-1)<=n;i++)\n                d[i][j]=min(d[i][j-1],d[i+(1<<(j-1))][j-1]);\n    }\n    inline int rmq(int x,int y){\n        int k=(int)(log((double)(y-x+1))/log(2.0));\n        return min(d[x][k],d[y-(1<<k)+1][k]);\n    }\n    int main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"RMQ.in\",\"r\",stdin);\n        freopen(\"RMQ.out\",\"w\",stdout);\n    #endif\n        scanf(\"%d%d\",&n,&m);\n        for(int i=1;i<=n;i++)scanf(\"%d\",&a[i]);\n        rmq_init();\n        for(int i=1;i<=m;i++){\n            int x,y;\n            scanf(\"%d%d\",&x,&y);\n            cout<<rmq(x,y)<<\" \";\n        }\n        cout<<endl;\n        return 0;\n    }\n```\n","categories":["Algorithm"],"tags":["ST表","RMQ"]},{"title":"Hello World！","url":"/2017/08/08/Hello-World%EF%BC%81/","content":"\n经历了各种瞎折腾两三天之后，终于把这个博客建好了 希望今后能够继续坚持写博客，在OI这条道路上越走越远\n```cpp\n    #incldue<bits/stdc++.h>\n    using namespace std;\n    int main(){\n        puts(\"Hello World!\");\n        return 0;\n    }\n```\n","categories":["Summary"],"tags":["OI历程"]}]